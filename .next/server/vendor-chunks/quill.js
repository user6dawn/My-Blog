"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/quill";
exports.ids = ["vendor-chunks/quill"];
exports.modules = {

/***/ "(ssr)/./node_modules/quill/dist/quill.js":
/*!******************************************!*\
  !*** ./node_modules/quill/dist/quill.js ***!
  \******************************************/
/***/ ((module) => {

eval("\n/*!\n * Quill Editor v1.3.7\n * https://quilljs.com/\n * Copyright (c) 2014, Jason Chen\n * Copyright (c) 2013, salesforce.com\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(typeof self !== \"undefined\" ? self : void 0, function() {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_731__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_731__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_731__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_731__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_731__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_731__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_731__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_731__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_731__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_731__.p = \"\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_731__(__nested_webpack_require_731__.s = 109);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1, __nested_webpack_require_3420__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var container_1 = __nested_webpack_require_3420__(17);\n            var format_1 = __nested_webpack_require_3420__(18);\n            var leaf_1 = __nested_webpack_require_3420__(19);\n            var scroll_1 = __nested_webpack_require_3420__(45);\n            var inline_1 = __nested_webpack_require_3420__(46);\n            var block_1 = __nested_webpack_require_3420__(47);\n            var embed_1 = __nested_webpack_require_3420__(48);\n            var text_1 = __nested_webpack_require_3420__(49);\n            var attributor_1 = __nested_webpack_require_3420__(12);\n            var class_1 = __nested_webpack_require_3420__(32);\n            var style_1 = __nested_webpack_require_3420__(33);\n            var store_1 = __nested_webpack_require_3420__(31);\n            var Registry = __nested_webpack_require_3420__(1);\n            var Parchment = {\n                Scope: Registry.Scope,\n                create: Registry.create,\n                find: Registry.find,\n                query: Registry.query,\n                register: Registry.register,\n                Container: container_1.default,\n                Format: format_1.default,\n                Leaf: leaf_1.default,\n                Embed: embed_1.default,\n                Scroll: scroll_1.default,\n                Block: block_1.default,\n                Inline: inline_1.default,\n                Text: text_1.default,\n                Attributor: {\n                    Attribute: attributor_1.default,\n                    Class: class_1.default,\n                    Style: style_1.default,\n                    Store: store_1.default\n                }\n            };\n            exports1.default = Parchment;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var ParchmentError = /** @class */ function(_super) {\n                __extends(ParchmentError, _super);\n                function ParchmentError(message) {\n                    var _this = this;\n                    message = \"[Parchment] \" + message;\n                    _this = _super.call(this, message) || this;\n                    _this.message = message;\n                    _this.name = _this.constructor.name;\n                    return _this;\n                }\n                return ParchmentError;\n            }(Error);\n            exports1.ParchmentError = ParchmentError;\n            var attributes = {};\n            var classes = {};\n            var tags = {};\n            var types = {};\n            exports1.DATA_KEY = \"__blot\";\n            var Scope;\n            (function(Scope) {\n                Scope[Scope[\"TYPE\"] = 3] = \"TYPE\";\n                Scope[Scope[\"LEVEL\"] = 12] = \"LEVEL\";\n                Scope[Scope[\"ATTRIBUTE\"] = 13] = \"ATTRIBUTE\";\n                Scope[Scope[\"BLOT\"] = 14] = \"BLOT\";\n                Scope[Scope[\"INLINE\"] = 7] = \"INLINE\";\n                Scope[Scope[\"BLOCK\"] = 11] = \"BLOCK\";\n                Scope[Scope[\"BLOCK_BLOT\"] = 10] = \"BLOCK_BLOT\";\n                Scope[Scope[\"INLINE_BLOT\"] = 6] = \"INLINE_BLOT\";\n                Scope[Scope[\"BLOCK_ATTRIBUTE\"] = 9] = \"BLOCK_ATTRIBUTE\";\n                Scope[Scope[\"INLINE_ATTRIBUTE\"] = 5] = \"INLINE_ATTRIBUTE\";\n                Scope[Scope[\"ANY\"] = 15] = \"ANY\";\n            })(Scope = exports1.Scope || (exports1.Scope = {}));\n            function create(input, value) {\n                var match = query(input);\n                if (match == null) {\n                    throw new ParchmentError(\"Unable to create \" + input + \" blot\");\n                }\n                var BlotClass = match;\n                var node = // @ts-ignore\n                input instanceof Node || input[\"nodeType\"] === Node.TEXT_NODE ? input : BlotClass.create(value);\n                return new BlotClass(node, value);\n            }\n            exports1.create = create;\n            function find(node, bubble) {\n                if (bubble === void 0) {\n                    bubble = false;\n                }\n                if (node == null) return null;\n                // @ts-ignore\n                if (node[exports1.DATA_KEY] != null) return node[exports1.DATA_KEY].blot;\n                if (bubble) return find(node.parentNode, bubble);\n                return null;\n            }\n            exports1.find = find;\n            function query(query, scope) {\n                if (scope === void 0) {\n                    scope = Scope.ANY;\n                }\n                var match;\n                if (typeof query === \"string\") {\n                    match = types[query] || attributes[query];\n                // @ts-ignore\n                } else if (query instanceof Text || query[\"nodeType\"] === Node.TEXT_NODE) {\n                    match = types[\"text\"];\n                } else if (typeof query === \"number\") {\n                    if (query & Scope.LEVEL & Scope.BLOCK) {\n                        match = types[\"block\"];\n                    } else if (query & Scope.LEVEL & Scope.INLINE) {\n                        match = types[\"inline\"];\n                    }\n                } else if (query instanceof HTMLElement) {\n                    var names = (query.getAttribute(\"class\") || \"\").split(/\\s+/);\n                    for(var i in names){\n                        match = classes[names[i]];\n                        if (match) break;\n                    }\n                    match = match || tags[query.tagName];\n                }\n                if (match == null) return null;\n                // @ts-ignore\n                if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope) return match;\n                return null;\n            }\n            exports1.query = query;\n            function register() {\n                var Definitions = [];\n                for(var _i = 0; _i < arguments.length; _i++){\n                    Definitions[_i] = arguments[_i];\n                }\n                if (Definitions.length > 1) {\n                    return Definitions.map(function(d) {\n                        return register(d);\n                    });\n                }\n                var Definition = Definitions[0];\n                if (typeof Definition.blotName !== \"string\" && typeof Definition.attrName !== \"string\") {\n                    throw new ParchmentError(\"Invalid definition\");\n                } else if (Definition.blotName === \"abstract\") {\n                    throw new ParchmentError(\"Cannot register abstract class\");\n                }\n                types[Definition.blotName || Definition.attrName] = Definition;\n                if (typeof Definition.keyName === \"string\") {\n                    attributes[Definition.keyName] = Definition;\n                } else {\n                    if (Definition.className != null) {\n                        classes[Definition.className] = Definition;\n                    }\n                    if (Definition.tagName != null) {\n                        if (Array.isArray(Definition.tagName)) {\n                            Definition.tagName = Definition.tagName.map(function(tagName) {\n                                return tagName.toUpperCase();\n                            });\n                        } else {\n                            Definition.tagName = Definition.tagName.toUpperCase();\n                        }\n                        var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [\n                            Definition.tagName\n                        ];\n                        tagNames.forEach(function(tag) {\n                            if (tags[tag] == null || Definition.className == null) {\n                                tags[tag] = Definition;\n                            }\n                        });\n                    }\n                }\n                return Definition;\n            }\n            exports1.register = register;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1, __nested_webpack_require_12144__) {\n            var diff = __nested_webpack_require_12144__(51);\n            var equal = __nested_webpack_require_12144__(11);\n            var extend = __nested_webpack_require_12144__(3);\n            var op = __nested_webpack_require_12144__(20);\n            var NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\n            var Delta = function(ops) {\n                // Assume we are given a well formed ops\n                if (Array.isArray(ops)) {\n                    this.ops = ops;\n                } else if (ops != null && Array.isArray(ops.ops)) {\n                    this.ops = ops.ops;\n                } else {\n                    this.ops = [];\n                }\n            };\n            Delta.prototype.insert = function(text, attributes) {\n                var newOp = {};\n                if (text.length === 0) return this;\n                newOp.insert = text;\n                if (attributes != null && typeof attributes === \"object\" && Object.keys(attributes).length > 0) {\n                    newOp.attributes = attributes;\n                }\n                return this.push(newOp);\n            };\n            Delta.prototype[\"delete\"] = function(length) {\n                if (length <= 0) return this;\n                return this.push({\n                    \"delete\": length\n                });\n            };\n            Delta.prototype.retain = function(length, attributes) {\n                if (length <= 0) return this;\n                var newOp = {\n                    retain: length\n                };\n                if (attributes != null && typeof attributes === \"object\" && Object.keys(attributes).length > 0) {\n                    newOp.attributes = attributes;\n                }\n                return this.push(newOp);\n            };\n            Delta.prototype.push = function(newOp) {\n                var index = this.ops.length;\n                var lastOp = this.ops[index - 1];\n                newOp = extend(true, {}, newOp);\n                if (typeof lastOp === \"object\") {\n                    if (typeof newOp[\"delete\"] === \"number\" && typeof lastOp[\"delete\"] === \"number\") {\n                        this.ops[index - 1] = {\n                            \"delete\": lastOp[\"delete\"] + newOp[\"delete\"]\n                        };\n                        return this;\n                    }\n                    // Since it does not matter if we insert before or after deleting at the same index,\n                    // always prefer to insert first\n                    if (typeof lastOp[\"delete\"] === \"number\" && newOp.insert != null) {\n                        index -= 1;\n                        lastOp = this.ops[index - 1];\n                        if (typeof lastOp !== \"object\") {\n                            this.ops.unshift(newOp);\n                            return this;\n                        }\n                    }\n                    if (equal(newOp.attributes, lastOp.attributes)) {\n                        if (typeof newOp.insert === \"string\" && typeof lastOp.insert === \"string\") {\n                            this.ops[index - 1] = {\n                                insert: lastOp.insert + newOp.insert\n                            };\n                            if (typeof newOp.attributes === \"object\") this.ops[index - 1].attributes = newOp.attributes;\n                            return this;\n                        } else if (typeof newOp.retain === \"number\" && typeof lastOp.retain === \"number\") {\n                            this.ops[index - 1] = {\n                                retain: lastOp.retain + newOp.retain\n                            };\n                            if (typeof newOp.attributes === \"object\") this.ops[index - 1].attributes = newOp.attributes;\n                            return this;\n                        }\n                    }\n                }\n                if (index === this.ops.length) {\n                    this.ops.push(newOp);\n                } else {\n                    this.ops.splice(index, 0, newOp);\n                }\n                return this;\n            };\n            Delta.prototype.chop = function() {\n                var lastOp = this.ops[this.ops.length - 1];\n                if (lastOp && lastOp.retain && !lastOp.attributes) {\n                    this.ops.pop();\n                }\n                return this;\n            };\n            Delta.prototype.filter = function(predicate) {\n                return this.ops.filter(predicate);\n            };\n            Delta.prototype.forEach = function(predicate) {\n                this.ops.forEach(predicate);\n            };\n            Delta.prototype.map = function(predicate) {\n                return this.ops.map(predicate);\n            };\n            Delta.prototype.partition = function(predicate) {\n                var passed = [], failed = [];\n                this.forEach(function(op) {\n                    var target = predicate(op) ? passed : failed;\n                    target.push(op);\n                });\n                return [\n                    passed,\n                    failed\n                ];\n            };\n            Delta.prototype.reduce = function(predicate, initial) {\n                return this.ops.reduce(predicate, initial);\n            };\n            Delta.prototype.changeLength = function() {\n                return this.reduce(function(length, elem) {\n                    if (elem.insert) {\n                        return length + op.length(elem);\n                    } else if (elem.delete) {\n                        return length - elem.delete;\n                    }\n                    return length;\n                }, 0);\n            };\n            Delta.prototype.length = function() {\n                return this.reduce(function(length, elem) {\n                    return length + op.length(elem);\n                }, 0);\n            };\n            Delta.prototype.slice = function(start, end) {\n                start = start || 0;\n                if (typeof end !== \"number\") end = Infinity;\n                var ops = [];\n                var iter = op.iterator(this.ops);\n                var index = 0;\n                while(index < end && iter.hasNext()){\n                    var nextOp;\n                    if (index < start) {\n                        nextOp = iter.next(start - index);\n                    } else {\n                        nextOp = iter.next(end - index);\n                        ops.push(nextOp);\n                    }\n                    index += op.length(nextOp);\n                }\n                return new Delta(ops);\n            };\n            Delta.prototype.compose = function(other) {\n                var thisIter = op.iterator(this.ops);\n                var otherIter = op.iterator(other.ops);\n                var ops = [];\n                var firstOther = otherIter.peek();\n                if (firstOther != null && typeof firstOther.retain === \"number\" && firstOther.attributes == null) {\n                    var firstLeft = firstOther.retain;\n                    while(thisIter.peekType() === \"insert\" && thisIter.peekLength() <= firstLeft){\n                        firstLeft -= thisIter.peekLength();\n                        ops.push(thisIter.next());\n                    }\n                    if (firstOther.retain - firstLeft > 0) {\n                        otherIter.next(firstOther.retain - firstLeft);\n                    }\n                }\n                var delta = new Delta(ops);\n                while(thisIter.hasNext() || otherIter.hasNext()){\n                    if (otherIter.peekType() === \"insert\") {\n                        delta.push(otherIter.next());\n                    } else if (thisIter.peekType() === \"delete\") {\n                        delta.push(thisIter.next());\n                    } else {\n                        var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                        var thisOp = thisIter.next(length);\n                        var otherOp = otherIter.next(length);\n                        if (typeof otherOp.retain === \"number\") {\n                            var newOp = {};\n                            if (typeof thisOp.retain === \"number\") {\n                                newOp.retain = length;\n                            } else {\n                                newOp.insert = thisOp.insert;\n                            }\n                            // Preserve null when composing with a retain, otherwise remove it for inserts\n                            var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === \"number\");\n                            if (attributes) newOp.attributes = attributes;\n                            delta.push(newOp);\n                            // Optimization if rest of other is just retain\n                            if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {\n                                var rest = new Delta(thisIter.rest());\n                                return delta.concat(rest).chop();\n                            }\n                        // Other op should be delete, we could be an insert or retain\n                        // Insert + delete cancels out\n                        } else if (typeof otherOp[\"delete\"] === \"number\" && typeof thisOp.retain === \"number\") {\n                            delta.push(otherOp);\n                        }\n                    }\n                }\n                return delta.chop();\n            };\n            Delta.prototype.concat = function(other) {\n                var delta = new Delta(this.ops.slice());\n                if (other.ops.length > 0) {\n                    delta.push(other.ops[0]);\n                    delta.ops = delta.ops.concat(other.ops.slice(1));\n                }\n                return delta;\n            };\n            Delta.prototype.diff = function(other, index) {\n                if (this.ops === other.ops) {\n                    return new Delta();\n                }\n                var strings = [\n                    this,\n                    other\n                ].map(function(delta) {\n                    return delta.map(function(op) {\n                        if (op.insert != null) {\n                            return typeof op.insert === \"string\" ? op.insert : NULL_CHARACTER;\n                        }\n                        var prep = delta === other ? \"on\" : \"with\";\n                        throw new Error(\"diff() called \" + prep + \" non-document\");\n                    }).join(\"\");\n                });\n                var delta = new Delta();\n                var diffResult = diff(strings[0], strings[1], index);\n                var thisIter = op.iterator(this.ops);\n                var otherIter = op.iterator(other.ops);\n                diffResult.forEach(function(component) {\n                    var length = component[1].length;\n                    while(length > 0){\n                        var opLength = 0;\n                        switch(component[0]){\n                            case diff.INSERT:\n                                opLength = Math.min(otherIter.peekLength(), length);\n                                delta.push(otherIter.next(opLength));\n                                break;\n                            case diff.DELETE:\n                                opLength = Math.min(length, thisIter.peekLength());\n                                thisIter.next(opLength);\n                                delta[\"delete\"](opLength);\n                                break;\n                            case diff.EQUAL:\n                                opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n                                var thisOp = thisIter.next(opLength);\n                                var otherOp = otherIter.next(opLength);\n                                if (equal(thisOp.insert, otherOp.insert)) {\n                                    delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));\n                                } else {\n                                    delta.push(otherOp)[\"delete\"](opLength);\n                                }\n                                break;\n                        }\n                        length -= opLength;\n                    }\n                });\n                return delta.chop();\n            };\n            Delta.prototype.eachLine = function(predicate, newline) {\n                newline = newline || \"\\n\";\n                var iter = op.iterator(this.ops);\n                var line = new Delta();\n                var i = 0;\n                while(iter.hasNext()){\n                    if (iter.peekType() !== \"insert\") return;\n                    var thisOp = iter.peek();\n                    var start = op.length(thisOp) - iter.peekLength();\n                    var index = typeof thisOp.insert === \"string\" ? thisOp.insert.indexOf(newline, start) - start : -1;\n                    if (index < 0) {\n                        line.push(iter.next());\n                    } else if (index > 0) {\n                        line.push(iter.next(index));\n                    } else {\n                        if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n                            return;\n                        }\n                        i += 1;\n                        line = new Delta();\n                    }\n                }\n                if (line.length() > 0) {\n                    predicate(line, {}, i);\n                }\n            };\n            Delta.prototype.transform = function(other, priority) {\n                priority = !!priority;\n                if (typeof other === \"number\") {\n                    return this.transformPosition(other, priority);\n                }\n                var thisIter = op.iterator(this.ops);\n                var otherIter = op.iterator(other.ops);\n                var delta = new Delta();\n                while(thisIter.hasNext() || otherIter.hasNext()){\n                    if (thisIter.peekType() === \"insert\" && (priority || otherIter.peekType() !== \"insert\")) {\n                        delta.retain(op.length(thisIter.next()));\n                    } else if (otherIter.peekType() === \"insert\") {\n                        delta.push(otherIter.next());\n                    } else {\n                        var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                        var thisOp = thisIter.next(length);\n                        var otherOp = otherIter.next(length);\n                        if (thisOp[\"delete\"]) {\n                            continue;\n                        } else if (otherOp[\"delete\"]) {\n                            delta.push(otherOp);\n                        } else {\n                            // We retain either their retain or insert\n                            delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));\n                        }\n                    }\n                }\n                return delta.chop();\n            };\n            Delta.prototype.transformPosition = function(index, priority) {\n                priority = !!priority;\n                var thisIter = op.iterator(this.ops);\n                var offset = 0;\n                while(thisIter.hasNext() && offset <= index){\n                    var length = thisIter.peekLength();\n                    var nextType = thisIter.peekType();\n                    thisIter.next();\n                    if (nextType === \"delete\") {\n                        index -= Math.min(length, index - offset);\n                        continue;\n                    } else if (nextType === \"insert\" && (offset < index || !priority)) {\n                        index += length;\n                    }\n                    offset += length;\n                }\n                return index;\n            };\n            module1.exports = Delta;\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            var hasOwn = Object.prototype.hasOwnProperty;\n            var toStr = Object.prototype.toString;\n            var defineProperty = Object.defineProperty;\n            var gOPD = Object.getOwnPropertyDescriptor;\n            var isArray = function isArray(arr) {\n                if (typeof Array.isArray === \"function\") {\n                    return Array.isArray(arr);\n                }\n                return toStr.call(arr) === \"[object Array]\";\n            };\n            var isPlainObject = function isPlainObject(obj) {\n                if (!obj || toStr.call(obj) !== \"[object Object]\") {\n                    return false;\n                }\n                var hasOwnConstructor = hasOwn.call(obj, \"constructor\");\n                var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\");\n                // Not own constructor property must be Object\n                if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n                    return false;\n                }\n                // Own properties are enumerated firstly, so to speed up,\n                // if last one is own, then all properties are own.\n                var key;\n                for(key in obj){}\n                return typeof key === \"undefined\" || hasOwn.call(obj, key);\n            };\n            // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\n            var setProperty = function setProperty(target, options) {\n                if (defineProperty && options.name === \"__proto__\") {\n                    defineProperty(target, options.name, {\n                        enumerable: true,\n                        configurable: true,\n                        value: options.newValue,\n                        writable: true\n                    });\n                } else {\n                    target[options.name] = options.newValue;\n                }\n            };\n            // Return undefined instead of __proto__ if '__proto__' is not an own property\n            var getProperty = function getProperty(obj, name) {\n                if (name === \"__proto__\") {\n                    if (!hasOwn.call(obj, name)) {\n                        return void 0;\n                    } else if (gOPD) {\n                        // In early versions of node, obj['__proto__'] is buggy when obj has\n                        // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n                        return gOPD(obj, name).value;\n                    }\n                }\n                return obj[name];\n            };\n            module1.exports = function extend() {\n                var options, name, src, copy, copyIsArray, clone;\n                var target = arguments[0];\n                var i = 1;\n                var length = arguments.length;\n                var deep = false;\n                // Handle a deep copy situation\n                if (typeof target === \"boolean\") {\n                    deep = target;\n                    target = arguments[1] || {};\n                    // skip the boolean and the target\n                    i = 2;\n                }\n                if (target == null || typeof target !== \"object\" && typeof target !== \"function\") {\n                    target = {};\n                }\n                for(; i < length; ++i){\n                    options = arguments[i];\n                    // Only deal with non-null/undefined values\n                    if (options != null) {\n                        // Extend the base object\n                        for(name in options){\n                            src = getProperty(target, name);\n                            copy = getProperty(options, name);\n                            // Prevent never-ending loop\n                            if (target !== copy) {\n                                // Recurse if we're merging plain objects or arrays\n                                if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n                                    if (copyIsArray) {\n                                        copyIsArray = false;\n                                        clone = src && isArray(src) ? src : [];\n                                    } else {\n                                        clone = src && isPlainObject(src) ? src : {};\n                                    }\n                                    // Never move original objects, clone them\n                                    setProperty(target, {\n                                        name: name,\n                                        newValue: extend(deep, clone, copy)\n                                    });\n                                // Don't bring in undefined values\n                                } else if (typeof copy !== \"undefined\") {\n                                    setProperty(target, {\n                                        name: name,\n                                        newValue: copy\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n                // Return the modified object\n                return target;\n            };\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __nested_webpack_require_33535__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.BlockEmbed = exports1.bubbleFormats = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _extend = __nested_webpack_require_33535__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _quillDelta = __nested_webpack_require_33535__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _parchment = __nested_webpack_require_33535__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _break = __nested_webpack_require_33535__(16);\n            var _break2 = _interopRequireDefault(_break);\n            var _inline = __nested_webpack_require_33535__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            var _text = __nested_webpack_require_33535__(7);\n            var _text2 = _interopRequireDefault(_text);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var NEWLINE_LENGTH = 1;\n            var BlockEmbed = function(_Parchment$Embed) {\n                _inherits(BlockEmbed, _Parchment$Embed);\n                function BlockEmbed() {\n                    _classCallCheck(this, BlockEmbed);\n                    return _possibleConstructorReturn(this, (BlockEmbed.__proto__ || Object.getPrototypeOf(BlockEmbed)).apply(this, arguments));\n                }\n                _createClass(BlockEmbed, [\n                    {\n                        key: \"attach\",\n                        value: function attach() {\n                            _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), \"attach\", this).call(this);\n                            this.attributes = new _parchment2.default.Attributor.Store(this.domNode);\n                        }\n                    },\n                    {\n                        key: \"delta\",\n                        value: function delta() {\n                            return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);\n                            if (attribute != null) {\n                                this.attributes.attribute(attribute, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, name, value) {\n                            this.format(name, value);\n                        }\n                    },\n                    {\n                        key: \"insertAt\",\n                        value: function insertAt(index, value, def) {\n                            if (typeof value === \"string\" && value.endsWith(\"\\n\")) {\n                                var block = _parchment2.default.create(Block.blotName);\n                                this.parent.insertBefore(block, index === 0 ? this : this.next);\n                                block.insertAt(0, value.slice(0, -1));\n                            } else {\n                                _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), \"insertAt\", this).call(this, index, value, def);\n                            }\n                        }\n                    }\n                ]);\n                return BlockEmbed;\n            }(_parchment2.default.Embed);\n            BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;\n            // It is important for cursor behavior BlockEmbeds use tags that are block level elements\n            var Block = function(_Parchment$Block) {\n                _inherits(Block, _Parchment$Block);\n                function Block(domNode) {\n                    _classCallCheck(this, Block);\n                    var _this2 = _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).call(this, domNode));\n                    _this2.cache = {};\n                    return _this2;\n                }\n                _createClass(Block, [\n                    {\n                        key: \"delta\",\n                        value: function delta() {\n                            if (this.cache.delta == null) {\n                                this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function(delta, leaf) {\n                                    if (leaf.length() === 0) {\n                                        return delta;\n                                    } else {\n                                        return delta.insert(leaf.value(), bubbleFormats(leaf));\n                                    }\n                                }, new _quillDelta2.default()).insert(\"\\n\", bubbleFormats(this));\n                            }\n                            return this.cache.delta;\n                        }\n                    },\n                    {\n                        key: \"deleteAt\",\n                        value: function deleteAt(index, length) {\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"deleteAt\", this).call(this, index, length);\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, name, value) {\n                            if (length <= 0) return;\n                            if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {\n                                if (index + length === this.length()) {\n                                    this.format(name, value);\n                                }\n                            } else {\n                                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"formatAt\", this).call(this, index, Math.min(length, this.length() - index - 1), name, value);\n                            }\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"insertAt\",\n                        value: function insertAt(index, value, def) {\n                            if (def != null) return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"insertAt\", this).call(this, index, value, def);\n                            if (value.length === 0) return;\n                            var lines = value.split(\"\\n\");\n                            var text = lines.shift();\n                            if (text.length > 0) {\n                                if (index < this.length() - 1 || this.children.tail == null) {\n                                    _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"insertAt\", this).call(this, Math.min(index, this.length() - 1), text);\n                                } else {\n                                    this.children.tail.insertAt(this.children.tail.length(), text);\n                                }\n                                this.cache = {};\n                            }\n                            var block = this;\n                            lines.reduce(function(index, line) {\n                                block = block.split(index, true);\n                                block.insertAt(0, line);\n                                return line.length;\n                            }, index + text.length);\n                        }\n                    },\n                    {\n                        key: \"insertBefore\",\n                        value: function insertBefore(blot, ref) {\n                            var head = this.children.head;\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"insertBefore\", this).call(this, blot, ref);\n                            if (head instanceof _break2.default) {\n                                head.remove();\n                            }\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"length\",\n                        value: function length() {\n                            if (this.cache.length == null) {\n                                this.cache.length = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"length\", this).call(this) + NEWLINE_LENGTH;\n                            }\n                            return this.cache.length;\n                        }\n                    },\n                    {\n                        key: \"moveChildren\",\n                        value: function moveChildren(target, ref) {\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"moveChildren\", this).call(this, target, ref);\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"optimize\", this).call(this, context);\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"path\",\n                        value: function path(index) {\n                            return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"path\", this).call(this, index, true);\n                        }\n                    },\n                    {\n                        key: \"removeChild\",\n                        value: function removeChild(child) {\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"removeChild\", this).call(this, child);\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"split\",\n                        value: function split(index) {\n                            var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                            if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {\n                                var clone = this.clone();\n                                if (index === 0) {\n                                    this.parent.insertBefore(clone, this);\n                                    return this;\n                                } else {\n                                    this.parent.insertBefore(clone, this.next);\n                                    return clone;\n                                }\n                            } else {\n                                var next = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"split\", this).call(this, index, force);\n                                this.cache = {};\n                                return next;\n                            }\n                        }\n                    }\n                ]);\n                return Block;\n            }(_parchment2.default.Block);\n            Block.blotName = \"block\";\n            Block.tagName = \"P\";\n            Block.defaultChild = \"break\";\n            Block.allowedChildren = [\n                _inline2.default,\n                _parchment2.default.Embed,\n                _text2.default\n            ];\n            function bubbleFormats(blot) {\n                var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                if (blot == null) return formats;\n                if (typeof blot.formats === \"function\") {\n                    formats = (0, _extend2.default)(formats, blot.formats());\n                }\n                if (blot.parent == null || blot.parent.blotName == \"scroll\" || blot.parent.statics.scope !== blot.statics.scope) {\n                    return formats;\n                }\n                return bubbleFormats(blot.parent, formats);\n            }\n            exports1.bubbleFormats = bubbleFormats;\n            exports1.BlockEmbed = BlockEmbed;\n            exports1.default = Block;\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __nested_webpack_require_49266__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.overload = exports1.expandConfig = undefined;\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            __nested_webpack_require_49266__(50);\n            var _quillDelta = __nested_webpack_require_49266__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _editor = __nested_webpack_require_49266__(14);\n            var _editor2 = _interopRequireDefault(_editor);\n            var _emitter3 = __nested_webpack_require_49266__(8);\n            var _emitter4 = _interopRequireDefault(_emitter3);\n            var _module = __nested_webpack_require_49266__(9);\n            var _module2 = _interopRequireDefault(_module);\n            var _parchment = __nested_webpack_require_49266__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _selection = __nested_webpack_require_49266__(15);\n            var _selection2 = _interopRequireDefault(_selection);\n            var _extend = __nested_webpack_require_49266__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _logger = __nested_webpack_require_49266__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            var _theme = __nested_webpack_require_49266__(34);\n            var _theme2 = _interopRequireDefault(_theme);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var debug = (0, _logger2.default)(\"quill\");\n            var Quill = function() {\n                _createClass(Quill, null, [\n                    {\n                        key: \"debug\",\n                        value: function debug(limit) {\n                            if (limit === true) {\n                                limit = \"log\";\n                            }\n                            _logger2.default.level(limit);\n                        }\n                    },\n                    {\n                        key: \"find\",\n                        value: function find(node) {\n                            return node.__quill || _parchment2.default.find(node);\n                        }\n                    },\n                    {\n                        key: \"import\",\n                        value: function _import(name) {\n                            if (this.imports[name] == null) {\n                                debug.error(\"Cannot import \" + name + \". Are you sure it was registered?\");\n                            }\n                            return this.imports[name];\n                        }\n                    },\n                    {\n                        key: \"register\",\n                        value: function register(path, target) {\n                            var _this = this;\n                            var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                            if (typeof path !== \"string\") {\n                                var name = path.attrName || path.blotName;\n                                if (typeof name === \"string\") {\n                                    // register(Blot | Attributor, overwrite)\n                                    this.register(\"formats/\" + name, path, target);\n                                } else {\n                                    Object.keys(path).forEach(function(key) {\n                                        _this.register(key, path[key], target);\n                                    });\n                                }\n                            } else {\n                                if (this.imports[path] != null && !overwrite) {\n                                    debug.warn(\"Overwriting \" + path + \" with\", target);\n                                }\n                                this.imports[path] = target;\n                                if ((path.startsWith(\"blots/\") || path.startsWith(\"formats/\")) && target.blotName !== \"abstract\") {\n                                    _parchment2.default.register(target);\n                                } else if (path.startsWith(\"modules\") && typeof target.register === \"function\") {\n                                    target.register();\n                                }\n                            }\n                        }\n                    }\n                ]);\n                function Quill(container) {\n                    var _this2 = this;\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    _classCallCheck(this, Quill);\n                    this.options = expandConfig(container, options);\n                    this.container = this.options.container;\n                    if (this.container == null) {\n                        return debug.error(\"Invalid Quill container\", container);\n                    }\n                    if (this.options.debug) {\n                        Quill.debug(this.options.debug);\n                    }\n                    var html = this.container.innerHTML.trim();\n                    this.container.classList.add(\"ql-container\");\n                    this.container.innerHTML = \"\";\n                    this.container.__quill = this;\n                    this.root = this.addContainer(\"ql-editor\");\n                    this.root.classList.add(\"ql-blank\");\n                    this.root.setAttribute(\"data-gramm\", false);\n                    this.scrollingContainer = this.options.scrollingContainer || this.root;\n                    this.emitter = new _emitter4.default();\n                    this.scroll = _parchment2.default.create(this.root, {\n                        emitter: this.emitter,\n                        whitelist: this.options.formats\n                    });\n                    this.editor = new _editor2.default(this.scroll);\n                    this.selection = new _selection2.default(this.scroll, this.emitter);\n                    this.theme = new this.options.theme(this, this.options);\n                    this.keyboard = this.theme.addModule(\"keyboard\");\n                    this.clipboard = this.theme.addModule(\"clipboard\");\n                    this.history = this.theme.addModule(\"history\");\n                    this.theme.init();\n                    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type) {\n                        if (type === _emitter4.default.events.TEXT_CHANGE) {\n                            _this2.root.classList.toggle(\"ql-blank\", _this2.editor.isBlank());\n                        }\n                    });\n                    this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function(source, mutations) {\n                        var range = _this2.selection.lastRange;\n                        var index = range && range.length === 0 ? range.index : undefined;\n                        modify.call(_this2, function() {\n                            return _this2.editor.update(null, mutations, index);\n                        }, source);\n                    });\n                    var contents = this.clipboard.convert(\"<div class='ql-editor' style=\\\"white-space: normal;\\\">\" + html + \"<p><br></p></div>\");\n                    this.setContents(contents);\n                    this.history.clear();\n                    if (this.options.placeholder) {\n                        this.root.setAttribute(\"data-placeholder\", this.options.placeholder);\n                    }\n                    if (this.options.readOnly) {\n                        this.disable();\n                    }\n                }\n                _createClass(Quill, [\n                    {\n                        key: \"addContainer\",\n                        value: function addContainer(container) {\n                            var refNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n                            if (typeof container === \"string\") {\n                                var className = container;\n                                container = document.createElement(\"div\");\n                                container.classList.add(className);\n                            }\n                            this.container.insertBefore(container, refNode);\n                            return container;\n                        }\n                    },\n                    {\n                        key: \"blur\",\n                        value: function blur() {\n                            this.selection.setRange(null);\n                        }\n                    },\n                    {\n                        key: \"deleteText\",\n                        value: function deleteText(index, length, source) {\n                            var _this3 = this;\n                            var _overload = overload(index, length, source);\n                            var _overload2 = _slicedToArray(_overload, 4);\n                            index = _overload2[0];\n                            length = _overload2[1];\n                            source = _overload2[3];\n                            return modify.call(this, function() {\n                                return _this3.editor.deleteText(index, length);\n                            }, source, index, -1 * length);\n                        }\n                    },\n                    {\n                        key: \"disable\",\n                        value: function disable() {\n                            this.enable(false);\n                        }\n                    },\n                    {\n                        key: \"enable\",\n                        value: function enable() {\n                            var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                            this.scroll.enable(enabled);\n                            this.container.classList.toggle(\"ql-disabled\", !enabled);\n                        }\n                    },\n                    {\n                        key: \"focus\",\n                        value: function focus() {\n                            var scrollTop = this.scrollingContainer.scrollTop;\n                            this.selection.focus();\n                            this.scrollingContainer.scrollTop = scrollTop;\n                            this.scrollIntoView();\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            var _this4 = this;\n                            var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;\n                            return modify.call(this, function() {\n                                var range = _this4.getSelection(true);\n                                var change = new _quillDelta2.default();\n                                if (range == null) {\n                                    return change;\n                                } else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {\n                                    change = _this4.editor.formatLine(range.index, range.length, _defineProperty({}, name, value));\n                                } else if (range.length === 0) {\n                                    _this4.selection.format(name, value);\n                                    return change;\n                                } else {\n                                    change = _this4.editor.formatText(range.index, range.length, _defineProperty({}, name, value));\n                                }\n                                _this4.setSelection(range, _emitter4.default.sources.SILENT);\n                                return change;\n                            }, source);\n                        }\n                    },\n                    {\n                        key: \"formatLine\",\n                        value: function formatLine(index, length, name, value, source) {\n                            var _this5 = this;\n                            var formats = void 0;\n                            var _overload3 = overload(index, length, name, value, source);\n                            var _overload4 = _slicedToArray(_overload3, 4);\n                            index = _overload4[0];\n                            length = _overload4[1];\n                            formats = _overload4[2];\n                            source = _overload4[3];\n                            return modify.call(this, function() {\n                                return _this5.editor.formatLine(index, length, formats);\n                            }, source, index, 0);\n                        }\n                    },\n                    {\n                        key: \"formatText\",\n                        value: function formatText(index, length, name, value, source) {\n                            var _this6 = this;\n                            var formats = void 0;\n                            var _overload5 = overload(index, length, name, value, source);\n                            var _overload6 = _slicedToArray(_overload5, 4);\n                            index = _overload6[0];\n                            length = _overload6[1];\n                            formats = _overload6[2];\n                            source = _overload6[3];\n                            return modify.call(this, function() {\n                                return _this6.editor.formatText(index, length, formats);\n                            }, source, index, 0);\n                        }\n                    },\n                    {\n                        key: \"getBounds\",\n                        value: function getBounds(index) {\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                            var bounds = void 0;\n                            if (typeof index === \"number\") {\n                                bounds = this.selection.getBounds(index, length);\n                            } else {\n                                bounds = this.selection.getBounds(index.index, index.length);\n                            }\n                            var containerBounds = this.container.getBoundingClientRect();\n                            return {\n                                bottom: bounds.bottom - containerBounds.top,\n                                height: bounds.height,\n                                left: bounds.left - containerBounds.left,\n                                right: bounds.right - containerBounds.left,\n                                top: bounds.top - containerBounds.top,\n                                width: bounds.width\n                            };\n                        }\n                    },\n                    {\n                        key: \"getContents\",\n                        value: function getContents() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;\n                            var _overload7 = overload(index, length);\n                            var _overload8 = _slicedToArray(_overload7, 2);\n                            index = _overload8[0];\n                            length = _overload8[1];\n                            return this.editor.getContents(index, length);\n                        }\n                    },\n                    {\n                        key: \"getFormat\",\n                        value: function getFormat() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSelection(true);\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                            if (typeof index === \"number\") {\n                                return this.editor.getFormat(index, length);\n                            } else {\n                                return this.editor.getFormat(index.index, index.length);\n                            }\n                        }\n                    },\n                    {\n                        key: \"getIndex\",\n                        value: function getIndex(blot) {\n                            return blot.offset(this.scroll);\n                        }\n                    },\n                    {\n                        key: \"getLength\",\n                        value: function getLength() {\n                            return this.scroll.length();\n                        }\n                    },\n                    {\n                        key: \"getLeaf\",\n                        value: function getLeaf(index) {\n                            return this.scroll.leaf(index);\n                        }\n                    },\n                    {\n                        key: \"getLine\",\n                        value: function getLine(index) {\n                            return this.scroll.line(index);\n                        }\n                    },\n                    {\n                        key: \"getLines\",\n                        value: function getLines() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n                            if (typeof index !== \"number\") {\n                                return this.scroll.lines(index.index, index.length);\n                            } else {\n                                return this.scroll.lines(index, length);\n                            }\n                        }\n                    },\n                    {\n                        key: \"getModule\",\n                        value: function getModule(name) {\n                            return this.theme.modules[name];\n                        }\n                    },\n                    {\n                        key: \"getSelection\",\n                        value: function getSelection() {\n                            var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n                            if (focus) this.focus();\n                            this.update(); // Make sure we access getRange with editor in consistent state\n                            return this.selection.getRange()[0];\n                        }\n                    },\n                    {\n                        key: \"getText\",\n                        value: function getText() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;\n                            var _overload9 = overload(index, length);\n                            var _overload10 = _slicedToArray(_overload9, 2);\n                            index = _overload10[0];\n                            length = _overload10[1];\n                            return this.editor.getText(index, length);\n                        }\n                    },\n                    {\n                        key: \"hasFocus\",\n                        value: function hasFocus() {\n                            return this.selection.hasFocus();\n                        }\n                    },\n                    {\n                        key: \"insertEmbed\",\n                        value: function insertEmbed(index, embed, value) {\n                            var _this7 = this;\n                            var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Quill.sources.API;\n                            return modify.call(this, function() {\n                                return _this7.editor.insertEmbed(index, embed, value);\n                            }, source, index);\n                        }\n                    },\n                    {\n                        key: \"insertText\",\n                        value: function insertText(index, text, name, value, source) {\n                            var _this8 = this;\n                            var formats = void 0;\n                            var _overload11 = overload(index, 0, name, value, source);\n                            var _overload12 = _slicedToArray(_overload11, 4);\n                            index = _overload12[0];\n                            formats = _overload12[2];\n                            source = _overload12[3];\n                            return modify.call(this, function() {\n                                return _this8.editor.insertText(index, text, formats);\n                            }, source, index, text.length);\n                        }\n                    },\n                    {\n                        key: \"isEnabled\",\n                        value: function isEnabled() {\n                            return !this.container.classList.contains(\"ql-disabled\");\n                        }\n                    },\n                    {\n                        key: \"off\",\n                        value: function off() {\n                            return this.emitter.off.apply(this.emitter, arguments);\n                        }\n                    },\n                    {\n                        key: \"on\",\n                        value: function on() {\n                            return this.emitter.on.apply(this.emitter, arguments);\n                        }\n                    },\n                    {\n                        key: \"once\",\n                        value: function once() {\n                            return this.emitter.once.apply(this.emitter, arguments);\n                        }\n                    },\n                    {\n                        key: \"pasteHTML\",\n                        value: function pasteHTML(index, html, source) {\n                            this.clipboard.dangerouslyPasteHTML(index, html, source);\n                        }\n                    },\n                    {\n                        key: \"removeFormat\",\n                        value: function removeFormat(index, length, source) {\n                            var _this9 = this;\n                            var _overload13 = overload(index, length, source);\n                            var _overload14 = _slicedToArray(_overload13, 4);\n                            index = _overload14[0];\n                            length = _overload14[1];\n                            source = _overload14[3];\n                            return modify.call(this, function() {\n                                return _this9.editor.removeFormat(index, length);\n                            }, source, index);\n                        }\n                    },\n                    {\n                        key: \"scrollIntoView\",\n                        value: function scrollIntoView() {\n                            this.selection.scrollIntoView(this.scrollingContainer);\n                        }\n                    },\n                    {\n                        key: \"setContents\",\n                        value: function setContents(delta) {\n                            var _this10 = this;\n                            var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;\n                            return modify.call(this, function() {\n                                delta = new _quillDelta2.default(delta);\n                                var length = _this10.getLength();\n                                var deleted = _this10.editor.deleteText(0, length);\n                                var applied = _this10.editor.applyDelta(delta);\n                                var lastOp = applied.ops[applied.ops.length - 1];\n                                if (lastOp != null && typeof lastOp.insert === \"string\" && lastOp.insert[lastOp.insert.length - 1] === \"\\n\") {\n                                    _this10.editor.deleteText(_this10.getLength() - 1, 1);\n                                    applied.delete(1);\n                                }\n                                var ret = deleted.compose(applied);\n                                return ret;\n                            }, source);\n                        }\n                    },\n                    {\n                        key: \"setSelection\",\n                        value: function setSelection(index, length, source) {\n                            if (index == null) {\n                                this.selection.setRange(null, length || Quill.sources.API);\n                            } else {\n                                var _overload15 = overload(index, length, source);\n                                var _overload16 = _slicedToArray(_overload15, 4);\n                                index = _overload16[0];\n                                length = _overload16[1];\n                                source = _overload16[3];\n                                this.selection.setRange(new _selection.Range(index, length), source);\n                                if (source !== _emitter4.default.sources.SILENT) {\n                                    this.selection.scrollIntoView(this.scrollingContainer);\n                                }\n                            }\n                        }\n                    },\n                    {\n                        key: \"setText\",\n                        value: function setText(text) {\n                            var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;\n                            var delta = new _quillDelta2.default().insert(text);\n                            return this.setContents(delta, source);\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update() {\n                            var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;\n                            var change = this.scroll.update(source); // Will update selection before selection.update() does if text changes\n                            this.selection.update(source);\n                            return change;\n                        }\n                    },\n                    {\n                        key: \"updateContents\",\n                        value: function updateContents(delta) {\n                            var _this11 = this;\n                            var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;\n                            return modify.call(this, function() {\n                                delta = new _quillDelta2.default(delta);\n                                return _this11.editor.applyDelta(delta, source);\n                            }, source, true);\n                        }\n                    }\n                ]);\n                return Quill;\n            }();\n            Quill.DEFAULTS = {\n                bounds: null,\n                formats: null,\n                modules: {},\n                placeholder: \"\",\n                readOnly: false,\n                scrollingContainer: null,\n                strict: true,\n                theme: \"default\"\n            };\n            Quill.events = _emitter4.default.events;\n            Quill.sources = _emitter4.default.sources;\n            // eslint-disable-next-line no-undef\n            Quill.version =  false ? 0 : \"1.3.7\";\n            Quill.imports = {\n                \"delta\": _quillDelta2.default,\n                \"parchment\": _parchment2.default,\n                \"core/module\": _module2.default,\n                \"core/theme\": _theme2.default\n            };\n            function expandConfig(container, userConfig) {\n                userConfig = (0, _extend2.default)(true, {\n                    container: container,\n                    modules: {\n                        clipboard: true,\n                        keyboard: true,\n                        history: true\n                    }\n                }, userConfig);\n                if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {\n                    userConfig.theme = _theme2.default;\n                } else {\n                    userConfig.theme = Quill.import(\"themes/\" + userConfig.theme);\n                    if (userConfig.theme == null) {\n                        throw new Error(\"Invalid theme \" + userConfig.theme + \". Did you register it?\");\n                    }\n                }\n                var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);\n                [\n                    themeConfig,\n                    userConfig\n                ].forEach(function(config) {\n                    config.modules = config.modules || {};\n                    Object.keys(config.modules).forEach(function(module1) {\n                        if (config.modules[module1] === true) {\n                            config.modules[module1] = {};\n                        }\n                    });\n                });\n                var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));\n                var moduleConfig = moduleNames.reduce(function(config, name) {\n                    var moduleClass = Quill.import(\"modules/\" + name);\n                    if (moduleClass == null) {\n                        debug.error(\"Cannot load \" + name + \" module. Are you sure you registered it?\");\n                    } else {\n                        config[name] = moduleClass.DEFAULTS || {};\n                    }\n                    return config;\n                }, {});\n                // Special case toolbar shorthand\n                if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {\n                    userConfig.modules.toolbar = {\n                        container: userConfig.modules.toolbar\n                    };\n                }\n                userConfig = (0, _extend2.default)(true, {}, Quill.DEFAULTS, {\n                    modules: moduleConfig\n                }, themeConfig, userConfig);\n                [\n                    \"bounds\",\n                    \"container\",\n                    \"scrollingContainer\"\n                ].forEach(function(key) {\n                    if (typeof userConfig[key] === \"string\") {\n                        userConfig[key] = document.querySelector(userConfig[key]);\n                    }\n                });\n                userConfig.modules = Object.keys(userConfig.modules).reduce(function(config, name) {\n                    if (userConfig.modules[name]) {\n                        config[name] = userConfig.modules[name];\n                    }\n                    return config;\n                }, {});\n                return userConfig;\n            }\n            // Handle selection preservation and TEXT_CHANGE emission\n            // common to modification APIs\n            function modify(modifier, source, index, shift) {\n                if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {\n                    return new _quillDelta2.default();\n                }\n                var range = index == null ? null : this.getSelection();\n                var oldDelta = this.editor.delta;\n                var change = modifier();\n                if (range != null) {\n                    if (index === true) index = range.index;\n                    if (shift == null) {\n                        range = shiftRange(range, change, source);\n                    } else if (shift !== 0) {\n                        range = shiftRange(range, index, shift, source);\n                    }\n                    this.setSelection(range, _emitter4.default.sources.SILENT);\n                }\n                if (change.length() > 0) {\n                    var _emitter;\n                    var args = [\n                        _emitter4.default.events.TEXT_CHANGE,\n                        change,\n                        oldDelta,\n                        source\n                    ];\n                    (_emitter = this.emitter).emit.apply(_emitter, [\n                        _emitter4.default.events.EDITOR_CHANGE\n                    ].concat(args));\n                    if (source !== _emitter4.default.sources.SILENT) {\n                        var _emitter2;\n                        (_emitter2 = this.emitter).emit.apply(_emitter2, args);\n                    }\n                }\n                return change;\n            }\n            function overload(index, length, name, value, source) {\n                var formats = {};\n                if (typeof index.index === \"number\" && typeof index.length === \"number\") {\n                    // Allow for throwaway end (used by insertText/insertEmbed)\n                    if (typeof length !== \"number\") {\n                        source = value, value = name, name = length, length = index.length, index = index.index;\n                    } else {\n                        length = index.length, index = index.index;\n                    }\n                } else if (typeof length !== \"number\") {\n                    source = value, value = name, name = length, length = 0;\n                }\n                // Handle format being object, two format name/value strings or excluded\n                if ((typeof name === \"undefined\" ? \"undefined\" : _typeof(name)) === \"object\") {\n                    formats = name;\n                    source = value;\n                } else if (typeof name === \"string\") {\n                    if (value != null) {\n                        formats[name] = value;\n                    } else {\n                        source = name;\n                    }\n                }\n                // Handle optional source\n                source = source || _emitter4.default.sources.API;\n                return [\n                    index,\n                    length,\n                    formats,\n                    source\n                ];\n            }\n            function shiftRange(range, index, length, source) {\n                if (range == null) return null;\n                var start = void 0, end = void 0;\n                if (index instanceof _quillDelta2.default) {\n                    var _map = [\n                        range.index,\n                        range.index + range.length\n                    ].map(function(pos) {\n                        return index.transformPosition(pos, source !== _emitter4.default.sources.USER);\n                    });\n                    var _map2 = _slicedToArray(_map, 2);\n                    start = _map2[0];\n                    end = _map2[1];\n                } else {\n                    var _map3 = [\n                        range.index,\n                        range.index + range.length\n                    ].map(function(pos) {\n                        if (pos < index || pos === index && source === _emitter4.default.sources.USER) return pos;\n                        if (length >= 0) {\n                            return pos + length;\n                        } else {\n                            return Math.max(index, pos + length);\n                        }\n                    });\n                    var _map4 = _slicedToArray(_map3, 2);\n                    start = _map4[0];\n                    end = _map4[1];\n                }\n                return new _selection.Range(start, end - start);\n            }\n            exports1.expandConfig = expandConfig;\n            exports1.overload = overload;\n            exports1.default = Quill;\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __nested_webpack_require_88469__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _text = __nested_webpack_require_88469__(7);\n            var _text2 = _interopRequireDefault(_text);\n            var _parchment = __nested_webpack_require_88469__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Inline = function(_Parchment$Inline) {\n                _inherits(Inline, _Parchment$Inline);\n                function Inline() {\n                    _classCallCheck(this, Inline);\n                    return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));\n                }\n                _createClass(Inline, [\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, name, value) {\n                            if (Inline.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {\n                                var blot = this.isolate(index, length);\n                                if (value) {\n                                    blot.wrap(name, value);\n                                }\n                            } else {\n                                _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), \"formatAt\", this).call(this, index, length, name, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), \"optimize\", this).call(this, context);\n                            if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {\n                                var parent = this.parent.isolate(this.offset(), this.length());\n                                this.moveChildren(parent);\n                                parent.wrap(this);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"compare\",\n                        value: function compare(self1, other) {\n                            var selfIndex = Inline.order.indexOf(self1);\n                            var otherIndex = Inline.order.indexOf(other);\n                            if (selfIndex >= 0 || otherIndex >= 0) {\n                                return selfIndex - otherIndex;\n                            } else if (self1 === other) {\n                                return 0;\n                            } else if (self1 < other) {\n                                return -1;\n                            } else {\n                                return 1;\n                            }\n                        }\n                    }\n                ]);\n                return Inline;\n            }(_parchment2.default.Inline);\n            Inline.allowedChildren = [\n                Inline,\n                _parchment2.default.Embed,\n                _text2.default\n            ];\n            // Lower index means deeper in the DOM tree, since not found (-1) is for embeds\n            Inline.order = [\n                \"cursor\",\n                \"inline\",\n                \"underline\",\n                \"strike\",\n                \"italic\",\n                \"bold\",\n                \"script\",\n                \"link\",\n                \"code\" // Must be higher\n            ];\n            exports1.default = Inline;\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_95454__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _parchment = __nested_webpack_require_95454__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var TextBlot = function(_Parchment$Text) {\n                _inherits(TextBlot, _Parchment$Text);\n                function TextBlot() {\n                    _classCallCheck(this, TextBlot);\n                    return _possibleConstructorReturn(this, (TextBlot.__proto__ || Object.getPrototypeOf(TextBlot)).apply(this, arguments));\n                }\n                return TextBlot;\n            }(_parchment2.default.Text);\n            exports1.default = TextBlot;\n        /***/ },\n        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_97760__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _eventemitter = __nested_webpack_require_97760__(54);\n            var _eventemitter2 = _interopRequireDefault(_eventemitter);\n            var _logger = __nested_webpack_require_97760__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var debug = (0, _logger2.default)(\"quill:events\");\n            var EVENTS = [\n                \"selectionchange\",\n                \"mousedown\",\n                \"mouseup\",\n                \"click\"\n            ];\n            EVENTS.forEach(function(eventName) {\n                document.addEventListener(eventName, function() {\n                    for(var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    [].slice.call(document.querySelectorAll(\".ql-container\")).forEach(function(node) {\n                        // TODO use WeakMap\n                        if (node.__quill && node.__quill.emitter) {\n                            var _node$__quill$emitter;\n                            (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);\n                        }\n                    });\n                });\n            });\n            var Emitter = function(_EventEmitter) {\n                _inherits(Emitter, _EventEmitter);\n                function Emitter() {\n                    _classCallCheck(this, Emitter);\n                    var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));\n                    _this.listeners = {};\n                    _this.on(\"error\", debug.error);\n                    return _this;\n                }\n                _createClass(Emitter, [\n                    {\n                        key: \"emit\",\n                        value: function emit() {\n                            debug.log.apply(debug, arguments);\n                            _get(Emitter.prototype.__proto__ || Object.getPrototypeOf(Emitter.prototype), \"emit\", this).apply(this, arguments);\n                        }\n                    },\n                    {\n                        key: \"handleDOM\",\n                        value: function handleDOM(event) {\n                            for(var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                                args[_key2 - 1] = arguments[_key2];\n                            }\n                            (this.listeners[event.type] || []).forEach(function(_ref) {\n                                var node = _ref.node, handler = _ref.handler;\n                                if (event.target === node || node.contains(event.target)) {\n                                    handler.apply(undefined, [\n                                        event\n                                    ].concat(args));\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"listenDOM\",\n                        value: function listenDOM(eventName, node, handler) {\n                            if (!this.listeners[eventName]) {\n                                this.listeners[eventName] = [];\n                            }\n                            this.listeners[eventName].push({\n                                node: node,\n                                handler: handler\n                            });\n                        }\n                    }\n                ]);\n                return Emitter;\n            }(_eventemitter2.default);\n            Emitter.events = {\n                EDITOR_CHANGE: \"editor-change\",\n                SCROLL_BEFORE_UPDATE: \"scroll-before-update\",\n                SCROLL_OPTIMIZE: \"scroll-optimize\",\n                SCROLL_UPDATE: \"scroll-update\",\n                SELECTION_CHANGE: \"selection-change\",\n                TEXT_CHANGE: \"text-change\"\n            };\n            Emitter.sources = {\n                API: \"api\",\n                SILENT: \"silent\",\n                USER: \"user\"\n            };\n            exports1.default = Emitter;\n        /***/ },\n        /* 9 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var Module = function Module(quill) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                _classCallCheck(this, Module);\n                this.quill = quill;\n                this.options = options;\n            };\n            Module.DEFAULTS = {};\n            exports1.default = Module;\n        /***/ },\n        /* 10 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var levels = [\n                \"error\",\n                \"warn\",\n                \"log\",\n                \"info\"\n            ];\n            var level = \"warn\";\n            function debug(method) {\n                if (levels.indexOf(method) <= levels.indexOf(level)) {\n                    var _console;\n                    for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    (_console = console)[method].apply(_console, args); // eslint-disable-line no-console\n                }\n            }\n            function namespace(ns) {\n                return levels.reduce(function(logger, method) {\n                    logger[method] = debug.bind(console, method, ns);\n                    return logger;\n                }, {});\n            }\n            debug.level = namespace.level = function(newLevel) {\n                level = newLevel;\n            };\n            exports1.default = namespace;\n        /***/ },\n        /* 11 */ /***/ function(module1, exports1, __nested_webpack_require_107450__) {\n            var pSlice = Array.prototype.slice;\n            var objectKeys = __nested_webpack_require_107450__(52);\n            var isArguments = __nested_webpack_require_107450__(53);\n            var deepEqual = module1.exports = function(actual, expected, opts) {\n                if (!opts) opts = {};\n                // 7.1. All identical values are equivalent, as determined by ===.\n                if (actual === expected) {\n                    return true;\n                } else if (actual instanceof Date && expected instanceof Date) {\n                    return actual.getTime() === expected.getTime();\n                // 7.3. Other pairs that do not both pass typeof value == 'object',\n                // equivalence is determined by ==.\n                } else if (!actual || !expected || typeof actual != \"object\" && typeof expected != \"object\") {\n                    return opts.strict ? actual === expected : actual == expected;\n                // 7.4. For all other Object pairs, including Array objects, equivalence is\n                // determined by having the same number of owned properties (as verified\n                // with Object.prototype.hasOwnProperty.call), the same set of keys\n                // (although not necessarily the same order), equivalent values for every\n                // corresponding key, and an identical 'prototype' property. Note: this\n                // accounts for both named and indexed properties on Arrays.\n                } else {\n                    return objEquiv(actual, expected, opts);\n                }\n            };\n            function isUndefinedOrNull(value) {\n                return value === null || value === undefined;\n            }\n            function isBuffer(x) {\n                if (!x || typeof x !== \"object\" || typeof x.length !== \"number\") return false;\n                if (typeof x.copy !== \"function\" || typeof x.slice !== \"function\") {\n                    return false;\n                }\n                if (x.length > 0 && typeof x[0] !== \"number\") return false;\n                return true;\n            }\n            function objEquiv(a, b, opts) {\n                var i, key;\n                if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;\n                // an identical 'prototype' property.\n                if (a.prototype !== b.prototype) return false;\n                //~~~I've managed to break Object.keys through screwy arguments passing.\n                //   Converting to array solves the problem.\n                if (isArguments(a)) {\n                    if (!isArguments(b)) {\n                        return false;\n                    }\n                    a = pSlice.call(a);\n                    b = pSlice.call(b);\n                    return deepEqual(a, b, opts);\n                }\n                if (isBuffer(a)) {\n                    if (!isBuffer(b)) {\n                        return false;\n                    }\n                    if (a.length !== b.length) return false;\n                    for(i = 0; i < a.length; i++){\n                        if (a[i] !== b[i]) return false;\n                    }\n                    return true;\n                }\n                try {\n                    var ka = objectKeys(a), kb = objectKeys(b);\n                } catch (e) {\n                    return false;\n                }\n                // having the same number of owned properties (keys incorporates\n                // hasOwnProperty)\n                if (ka.length != kb.length) return false;\n                //the same set of keys (although not necessarily the same order),\n                ka.sort();\n                kb.sort();\n                //~~~cheap key test\n                for(i = ka.length - 1; i >= 0; i--){\n                    if (ka[i] != kb[i]) return false;\n                }\n                //equivalent values for every corresponding key, and\n                //~~~possibly expensive deep test\n                for(i = ka.length - 1; i >= 0; i--){\n                    key = ka[i];\n                    if (!deepEqual(a[key], b[key], opts)) return false;\n                }\n                return typeof a === typeof b;\n            }\n        /***/ },\n        /* 12 */ /***/ function(module1, exports1, __nested_webpack_require_111683__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var Registry = __nested_webpack_require_111683__(1);\n            var Attributor = /** @class */ function() {\n                function Attributor(attrName, keyName, options) {\n                    if (options === void 0) {\n                        options = {};\n                    }\n                    this.attrName = attrName;\n                    this.keyName = keyName;\n                    var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;\n                    if (options.scope != null) {\n                        // Ignore type bits, force attribute bit\n                        this.scope = options.scope & Registry.Scope.LEVEL | attributeBit;\n                    } else {\n                        this.scope = Registry.Scope.ATTRIBUTE;\n                    }\n                    if (options.whitelist != null) this.whitelist = options.whitelist;\n                }\n                Attributor.keys = function(node) {\n                    return [].map.call(node.attributes, function(item) {\n                        return item.name;\n                    });\n                };\n                Attributor.prototype.add = function(node, value) {\n                    if (!this.canAdd(node, value)) return false;\n                    node.setAttribute(this.keyName, value);\n                    return true;\n                };\n                Attributor.prototype.canAdd = function(node, value) {\n                    var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));\n                    if (match == null) return false;\n                    if (this.whitelist == null) return true;\n                    if (typeof value === \"string\") {\n                        return this.whitelist.indexOf(value.replace(/[\"']/g, \"\")) > -1;\n                    } else {\n                        return this.whitelist.indexOf(value) > -1;\n                    }\n                };\n                Attributor.prototype.remove = function(node) {\n                    node.removeAttribute(this.keyName);\n                };\n                Attributor.prototype.value = function(node) {\n                    var value = node.getAttribute(this.keyName);\n                    if (this.canAdd(node, value) && value) {\n                        return value;\n                    }\n                    return \"\";\n                };\n                return Attributor;\n            }();\n            exports1.default = Attributor;\n        /***/ },\n        /* 13 */ /***/ function(module1, exports1, __nested_webpack_require_114341__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.Code = undefined;\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _quillDelta = __nested_webpack_require_114341__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _parchment = __nested_webpack_require_114341__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _block = __nested_webpack_require_114341__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _inline = __nested_webpack_require_114341__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            var _text = __nested_webpack_require_114341__(7);\n            var _text2 = _interopRequireDefault(_text);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Code = function(_Inline) {\n                _inherits(Code, _Inline);\n                function Code() {\n                    _classCallCheck(this, Code);\n                    return _possibleConstructorReturn(this, (Code.__proto__ || Object.getPrototypeOf(Code)).apply(this, arguments));\n                }\n                return Code;\n            }(_inline2.default);\n            Code.blotName = \"code\";\n            Code.tagName = \"CODE\";\n            var CodeBlock = function(_Block) {\n                _inherits(CodeBlock, _Block);\n                function CodeBlock() {\n                    _classCallCheck(this, CodeBlock);\n                    return _possibleConstructorReturn(this, (CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock)).apply(this, arguments));\n                }\n                _createClass(CodeBlock, [\n                    {\n                        key: \"delta\",\n                        value: function delta() {\n                            var _this3 = this;\n                            var text = this.domNode.textContent;\n                            if (text.endsWith(\"\\n\")) {\n                                // Should always be true\n                                text = text.slice(0, -1);\n                            }\n                            return text.split(\"\\n\").reduce(function(delta, frag) {\n                                return delta.insert(frag).insert(\"\\n\", _this3.formats());\n                            }, new _quillDelta2.default());\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (name === this.statics.blotName && value) return;\n                            var _descendant = this.descendant(_text2.default, this.length() - 1), _descendant2 = _slicedToArray(_descendant, 1), text = _descendant2[0];\n                            if (text != null) {\n                                text.deleteAt(text.length() - 1, 1);\n                            }\n                            _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), \"format\", this).call(this, name, value);\n                        }\n                    },\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, name, value) {\n                            if (length === 0) return;\n                            if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {\n                                return;\n                            }\n                            var nextNewline = this.newlineIndex(index);\n                            if (nextNewline < 0 || nextNewline >= index + length) return;\n                            var prevNewline = this.newlineIndex(index, true) + 1;\n                            var isolateLength = nextNewline - prevNewline + 1;\n                            var blot = this.isolate(prevNewline, isolateLength);\n                            var next = blot.next;\n                            blot.format(name, value);\n                            if (next instanceof CodeBlock) {\n                                next.formatAt(0, index - prevNewline + length - isolateLength, name, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"insertAt\",\n                        value: function insertAt(index, value, def) {\n                            if (def != null) return;\n                            var _descendant3 = this.descendant(_text2.default, index), _descendant4 = _slicedToArray(_descendant3, 2), text = _descendant4[0], offset = _descendant4[1];\n                            text.insertAt(offset, value);\n                        }\n                    },\n                    {\n                        key: \"length\",\n                        value: function length() {\n                            var length = this.domNode.textContent.length;\n                            if (!this.domNode.textContent.endsWith(\"\\n\")) {\n                                return length + 1;\n                            }\n                            return length;\n                        }\n                    },\n                    {\n                        key: \"newlineIndex\",\n                        value: function newlineIndex(searchIndex) {\n                            var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                            if (!reverse) {\n                                var offset = this.domNode.textContent.slice(searchIndex).indexOf(\"\\n\");\n                                return offset > -1 ? searchIndex + offset : -1;\n                            } else {\n                                return this.domNode.textContent.slice(0, searchIndex).lastIndexOf(\"\\n\");\n                            }\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            if (!this.domNode.textContent.endsWith(\"\\n\")) {\n                                this.appendChild(_parchment2.default.create(\"text\", \"\\n\"));\n                            }\n                            _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), \"optimize\", this).call(this, context);\n                            var next = this.next;\n                            if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {\n                                next.optimize(context);\n                                next.moveChildren(this);\n                                next.remove();\n                            }\n                        }\n                    },\n                    {\n                        key: \"replace\",\n                        value: function replace(target) {\n                            _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), \"replace\", this).call(this, target);\n                            [].slice.call(this.domNode.querySelectorAll(\"*\")).forEach(function(node) {\n                                var blot = _parchment2.default.find(node);\n                                if (blot == null) {\n                                    node.parentNode.removeChild(node);\n                                } else if (blot instanceof _parchment2.default.Embed) {\n                                    blot.remove();\n                                } else {\n                                    blot.unwrap();\n                                }\n                            });\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var domNode = _get(CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock), \"create\", this).call(this, value);\n                            domNode.setAttribute(\"spellcheck\", false);\n                            return domNode;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats() {\n                            return true;\n                        }\n                    }\n                ]);\n                return CodeBlock;\n            }(_block2.default);\n            CodeBlock.blotName = \"code-block\";\n            CodeBlock.tagName = \"PRE\";\n            CodeBlock.TAB = \"  \";\n            exports1.Code = Code;\n            exports1.default = CodeBlock;\n        /***/ },\n        /* 14 */ /***/ function(module1, exports1, __nested_webpack_require_127655__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _quillDelta = __nested_webpack_require_127655__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _op = __nested_webpack_require_127655__(20);\n            var _op2 = _interopRequireDefault(_op);\n            var _parchment = __nested_webpack_require_127655__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _code = __nested_webpack_require_127655__(13);\n            var _code2 = _interopRequireDefault(_code);\n            var _cursor = __nested_webpack_require_127655__(24);\n            var _cursor2 = _interopRequireDefault(_cursor);\n            var _block = __nested_webpack_require_127655__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _break = __nested_webpack_require_127655__(16);\n            var _break2 = _interopRequireDefault(_break);\n            var _clone = __nested_webpack_require_127655__(21);\n            var _clone2 = _interopRequireDefault(_clone);\n            var _deepEqual = __nested_webpack_require_127655__(11);\n            var _deepEqual2 = _interopRequireDefault(_deepEqual);\n            var _extend = __nested_webpack_require_127655__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var ASCII = /^[ -~]*$/;\n            var Editor = function() {\n                function Editor(scroll) {\n                    _classCallCheck(this, Editor);\n                    this.scroll = scroll;\n                    this.delta = this.getDelta();\n                }\n                _createClass(Editor, [\n                    {\n                        key: \"applyDelta\",\n                        value: function applyDelta(delta) {\n                            var _this = this;\n                            var consumeNextNewline = false;\n                            this.scroll.update();\n                            var scrollLength = this.scroll.length();\n                            this.scroll.batchStart();\n                            delta = normalizeDelta(delta);\n                            delta.reduce(function(index, op) {\n                                var length = op.retain || op.delete || op.insert.length || 1;\n                                var attributes = op.attributes || {};\n                                if (op.insert != null) {\n                                    if (typeof op.insert === \"string\") {\n                                        var text = op.insert;\n                                        if (text.endsWith(\"\\n\") && consumeNextNewline) {\n                                            consumeNextNewline = false;\n                                            text = text.slice(0, -1);\n                                        }\n                                        if (index >= scrollLength && !text.endsWith(\"\\n\")) {\n                                            consumeNextNewline = true;\n                                        }\n                                        _this.scroll.insertAt(index, text);\n                                        var _scroll$line = _this.scroll.line(index), _scroll$line2 = _slicedToArray(_scroll$line, 2), line = _scroll$line2[0], offset = _scroll$line2[1];\n                                        var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));\n                                        if (line instanceof _block2.default) {\n                                            var _line$descendant = line.descendant(_parchment2.default.Leaf, offset), _line$descendant2 = _slicedToArray(_line$descendant, 1), leaf = _line$descendant2[0];\n                                            formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));\n                                        }\n                                        attributes = _op2.default.attributes.diff(formats, attributes) || {};\n                                    } else if (_typeof(op.insert) === \"object\") {\n                                        var key = Object.keys(op.insert)[0]; // There should only be one key\n                                        if (key == null) return index;\n                                        _this.scroll.insertAt(index, key, op.insert[key]);\n                                    }\n                                    scrollLength += length;\n                                }\n                                Object.keys(attributes).forEach(function(name) {\n                                    _this.scroll.formatAt(index, length, name, attributes[name]);\n                                });\n                                return index + length;\n                            }, 0);\n                            delta.reduce(function(index, op) {\n                                if (typeof op.delete === \"number\") {\n                                    _this.scroll.deleteAt(index, op.delete);\n                                    return index;\n                                }\n                                return index + (op.retain || op.insert.length || 1);\n                            }, 0);\n                            this.scroll.batchEnd();\n                            return this.update(delta);\n                        }\n                    },\n                    {\n                        key: \"deleteText\",\n                        value: function deleteText(index, length) {\n                            this.scroll.deleteAt(index, length);\n                            return this.update(new _quillDelta2.default().retain(index).delete(length));\n                        }\n                    },\n                    {\n                        key: \"formatLine\",\n                        value: function formatLine(index, length) {\n                            var _this2 = this;\n                            var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            this.scroll.update();\n                            Object.keys(formats).forEach(function(format) {\n                                if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format]) return;\n                                var lines = _this2.scroll.lines(index, Math.max(length, 1));\n                                var lengthRemaining = length;\n                                lines.forEach(function(line) {\n                                    var lineLength = line.length();\n                                    if (!(line instanceof _code2.default)) {\n                                        line.format(format, formats[format]);\n                                    } else {\n                                        var codeIndex = index - line.offset(_this2.scroll);\n                                        var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;\n                                        line.formatAt(codeIndex, codeLength, format, formats[format]);\n                                    }\n                                    lengthRemaining -= lineLength;\n                                });\n                            });\n                            this.scroll.optimize();\n                            return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));\n                        }\n                    },\n                    {\n                        key: \"formatText\",\n                        value: function formatText(index, length) {\n                            var _this3 = this;\n                            var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            Object.keys(formats).forEach(function(format) {\n                                _this3.scroll.formatAt(index, length, format, formats[format]);\n                            });\n                            return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));\n                        }\n                    },\n                    {\n                        key: \"getContents\",\n                        value: function getContents(index, length) {\n                            return this.delta.slice(index, index + length);\n                        }\n                    },\n                    {\n                        key: \"getDelta\",\n                        value: function getDelta() {\n                            return this.scroll.lines().reduce(function(delta, line) {\n                                return delta.concat(line.delta());\n                            }, new _quillDelta2.default());\n                        }\n                    },\n                    {\n                        key: \"getFormat\",\n                        value: function getFormat(index) {\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                            var lines = [], leaves = [];\n                            if (length === 0) {\n                                this.scroll.path(index).forEach(function(path) {\n                                    var _path = _slicedToArray(path, 1), blot = _path[0];\n                                    if (blot instanceof _block2.default) {\n                                        lines.push(blot);\n                                    } else if (blot instanceof _parchment2.default.Leaf) {\n                                        leaves.push(blot);\n                                    }\n                                });\n                            } else {\n                                lines = this.scroll.lines(index, length);\n                                leaves = this.scroll.descendants(_parchment2.default.Leaf, index, length);\n                            }\n                            var formatsArr = [\n                                lines,\n                                leaves\n                            ].map(function(blots) {\n                                if (blots.length === 0) return {};\n                                var formats = (0, _block.bubbleFormats)(blots.shift());\n                                while(Object.keys(formats).length > 0){\n                                    var blot = blots.shift();\n                                    if (blot == null) return formats;\n                                    formats = combineFormats((0, _block.bubbleFormats)(blot), formats);\n                                }\n                                return formats;\n                            });\n                            return _extend2.default.apply(_extend2.default, formatsArr);\n                        }\n                    },\n                    {\n                        key: \"getText\",\n                        value: function getText(index, length) {\n                            return this.getContents(index, length).filter(function(op) {\n                                return typeof op.insert === \"string\";\n                            }).map(function(op) {\n                                return op.insert;\n                            }).join(\"\");\n                        }\n                    },\n                    {\n                        key: \"insertEmbed\",\n                        value: function insertEmbed(index, embed, value) {\n                            this.scroll.insertAt(index, embed, value);\n                            return this.update(new _quillDelta2.default().retain(index).insert(_defineProperty({}, embed, value)));\n                        }\n                    },\n                    {\n                        key: \"insertText\",\n                        value: function insertText(index, text) {\n                            var _this4 = this;\n                            var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            text = text.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                            this.scroll.insertAt(index, text);\n                            Object.keys(formats).forEach(function(format) {\n                                _this4.scroll.formatAt(index, text.length, format, formats[format]);\n                            });\n                            return this.update(new _quillDelta2.default().retain(index).insert(text, (0, _clone2.default)(formats)));\n                        }\n                    },\n                    {\n                        key: \"isBlank\",\n                        value: function isBlank() {\n                            if (this.scroll.children.length == 0) return true;\n                            if (this.scroll.children.length > 1) return false;\n                            var block = this.scroll.children.head;\n                            if (block.statics.blotName !== _block2.default.blotName) return false;\n                            if (block.children.length > 1) return false;\n                            return block.children.head instanceof _break2.default;\n                        }\n                    },\n                    {\n                        key: \"removeFormat\",\n                        value: function removeFormat(index, length) {\n                            var text = this.getText(index, length);\n                            var _scroll$line3 = this.scroll.line(index + length), _scroll$line4 = _slicedToArray(_scroll$line3, 2), line = _scroll$line4[0], offset = _scroll$line4[1];\n                            var suffixLength = 0, suffix = new _quillDelta2.default();\n                            if (line != null) {\n                                if (!(line instanceof _code2.default)) {\n                                    suffixLength = line.length() - offset;\n                                } else {\n                                    suffixLength = line.newlineIndex(offset) - offset + 1;\n                                }\n                                suffix = line.delta().slice(offset, offset + suffixLength - 1).insert(\"\\n\");\n                            }\n                            var contents = this.getContents(index, length + suffixLength);\n                            var diff = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));\n                            var delta = new _quillDelta2.default().retain(index).concat(diff);\n                            return this.applyDelta(delta);\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(change) {\n                            var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n                            var cursorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n                            var oldDelta = this.delta;\n                            if (mutations.length === 1 && mutations[0].type === \"characterData\" && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {\n                                // Optimization for character changes\n                                var textBlot = _parchment2.default.find(mutations[0].target);\n                                var formats = (0, _block.bubbleFormats)(textBlot);\n                                var index = textBlot.offset(this.scroll);\n                                var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, \"\");\n                                var oldText = new _quillDelta2.default().insert(oldValue);\n                                var newText = new _quillDelta2.default().insert(textBlot.value());\n                                var diffDelta = new _quillDelta2.default().retain(index).concat(oldText.diff(newText, cursorIndex));\n                                change = diffDelta.reduce(function(delta, op) {\n                                    if (op.insert) {\n                                        return delta.insert(op.insert, formats);\n                                    } else {\n                                        return delta.push(op);\n                                    }\n                                }, new _quillDelta2.default());\n                                this.delta = oldDelta.compose(change);\n                            } else {\n                                this.delta = this.getDelta();\n                                if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {\n                                    change = oldDelta.diff(this.delta, cursorIndex);\n                                }\n                            }\n                            return change;\n                        }\n                    }\n                ]);\n                return Editor;\n            }();\n            function combineFormats(formats, combined) {\n                return Object.keys(combined).reduce(function(merged, name) {\n                    if (formats[name] == null) return merged;\n                    if (combined[name] === formats[name]) {\n                        merged[name] = combined[name];\n                    } else if (Array.isArray(combined[name])) {\n                        if (combined[name].indexOf(formats[name]) < 0) {\n                            merged[name] = combined[name].concat([\n                                formats[name]\n                            ]);\n                        }\n                    } else {\n                        merged[name] = [\n                            combined[name],\n                            formats[name]\n                        ];\n                    }\n                    return merged;\n                }, {});\n            }\n            function normalizeDelta(delta) {\n                return delta.reduce(function(delta, op) {\n                    if (op.insert === 1) {\n                        var attributes = (0, _clone2.default)(op.attributes);\n                        delete attributes[\"image\"];\n                        return delta.insert({\n                            image: op.attributes.image\n                        }, attributes);\n                    }\n                    if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {\n                        op = (0, _clone2.default)(op);\n                        if (op.attributes.list) {\n                            op.attributes.list = \"ordered\";\n                        } else {\n                            op.attributes.list = \"bullet\";\n                            delete op.attributes.bullet;\n                        }\n                    }\n                    if (typeof op.insert === \"string\") {\n                        var text = op.insert.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                        return delta.insert(text, op.attributes);\n                    }\n                    return delta.push(op);\n                }, new _quillDelta2.default());\n            }\n            exports1.default = Editor;\n        /***/ },\n        /* 15 */ /***/ function(module1, exports1, __nested_webpack_require_150086__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.Range = undefined;\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _parchment = __nested_webpack_require_150086__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _clone = __nested_webpack_require_150086__(21);\n            var _clone2 = _interopRequireDefault(_clone);\n            var _deepEqual = __nested_webpack_require_150086__(11);\n            var _deepEqual2 = _interopRequireDefault(_deepEqual);\n            var _emitter3 = __nested_webpack_require_150086__(8);\n            var _emitter4 = _interopRequireDefault(_emitter3);\n            var _logger = __nested_webpack_require_150086__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _toConsumableArray(arr) {\n                if (Array.isArray(arr)) {\n                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n                        arr2[i] = arr[i];\n                    }\n                    return arr2;\n                } else {\n                    return Array.from(arr);\n                }\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var debug = (0, _logger2.default)(\"quill:selection\");\n            var Range = function Range(index) {\n                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                _classCallCheck(this, Range);\n                this.index = index;\n                this.length = length;\n            };\n            var Selection = function() {\n                function Selection(scroll, emitter) {\n                    var _this = this;\n                    _classCallCheck(this, Selection);\n                    this.emitter = emitter;\n                    this.scroll = scroll;\n                    this.composing = false;\n                    this.mouseDown = false;\n                    this.root = this.scroll.domNode;\n                    this.cursor = _parchment2.default.create(\"cursor\", this);\n                    // savedRange is last non-null range\n                    this.lastRange = this.savedRange = new Range(0, 0);\n                    this.handleComposition();\n                    this.handleDragging();\n                    this.emitter.listenDOM(\"selectionchange\", document, function() {\n                        if (!_this.mouseDown) {\n                            setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);\n                        }\n                    });\n                    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type, delta) {\n                        if (type === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {\n                            _this.update(_emitter4.default.sources.SILENT);\n                        }\n                    });\n                    this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function() {\n                        if (!_this.hasFocus()) return;\n                        var native = _this.getNativeRange();\n                        if (native == null) return;\n                        if (native.start.node === _this.cursor.textNode) return; // cursor.restore() will handle\n                        // TODO unclear if this has negative side effects\n                        _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function() {\n                            try {\n                                _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);\n                            } catch (ignored) {}\n                        });\n                    });\n                    this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function(mutations, context) {\n                        if (context.range) {\n                            var _context$range = context.range, startNode = _context$range.startNode, startOffset = _context$range.startOffset, endNode = _context$range.endNode, endOffset = _context$range.endOffset;\n                            _this.setNativeRange(startNode, startOffset, endNode, endOffset);\n                        }\n                    });\n                    this.update(_emitter4.default.sources.SILENT);\n                }\n                _createClass(Selection, [\n                    {\n                        key: \"handleComposition\",\n                        value: function handleComposition() {\n                            var _this2 = this;\n                            this.root.addEventListener(\"compositionstart\", function() {\n                                _this2.composing = true;\n                            });\n                            this.root.addEventListener(\"compositionend\", function() {\n                                _this2.composing = false;\n                                if (_this2.cursor.parent) {\n                                    var range = _this2.cursor.restore();\n                                    if (!range) return;\n                                    setTimeout(function() {\n                                        _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);\n                                    }, 1);\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"handleDragging\",\n                        value: function handleDragging() {\n                            var _this3 = this;\n                            this.emitter.listenDOM(\"mousedown\", document.body, function() {\n                                _this3.mouseDown = true;\n                            });\n                            this.emitter.listenDOM(\"mouseup\", document.body, function() {\n                                _this3.mouseDown = false;\n                                _this3.update(_emitter4.default.sources.USER);\n                            });\n                        }\n                    },\n                    {\n                        key: \"focus\",\n                        value: function focus() {\n                            if (this.hasFocus()) return;\n                            this.root.focus();\n                            this.setRange(this.savedRange);\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(_format, value) {\n                            if (this.scroll.whitelist != null && !this.scroll.whitelist[_format]) return;\n                            this.scroll.update();\n                            var nativeRange = this.getNativeRange();\n                            if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK)) return;\n                            if (nativeRange.start.node !== this.cursor.textNode) {\n                                var blot = _parchment2.default.find(nativeRange.start.node, false);\n                                if (blot == null) return;\n                                // TODO Give blot ability to not split\n                                if (blot instanceof _parchment2.default.Leaf) {\n                                    var after = blot.split(nativeRange.start.offset);\n                                    blot.parent.insertBefore(this.cursor, after);\n                                } else {\n                                    blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen\n                                }\n                                this.cursor.attach();\n                            }\n                            this.cursor.format(_format, value);\n                            this.scroll.optimize();\n                            this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);\n                            this.update();\n                        }\n                    },\n                    {\n                        key: \"getBounds\",\n                        value: function getBounds(index) {\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                            var scrollLength = this.scroll.length();\n                            index = Math.min(index, scrollLength - 1);\n                            length = Math.min(index + length, scrollLength - 1) - index;\n                            var node = void 0, _scroll$leaf = this.scroll.leaf(index), _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2), leaf = _scroll$leaf2[0], offset = _scroll$leaf2[1];\n                            if (leaf == null) return null;\n                            var _leaf$position = leaf.position(offset, true);\n                            var _leaf$position2 = _slicedToArray(_leaf$position, 2);\n                            node = _leaf$position2[0];\n                            offset = _leaf$position2[1];\n                            var range = document.createRange();\n                            if (length > 0) {\n                                range.setStart(node, offset);\n                                var _scroll$leaf3 = this.scroll.leaf(index + length);\n                                var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);\n                                leaf = _scroll$leaf4[0];\n                                offset = _scroll$leaf4[1];\n                                if (leaf == null) return null;\n                                var _leaf$position3 = leaf.position(offset, true);\n                                var _leaf$position4 = _slicedToArray(_leaf$position3, 2);\n                                node = _leaf$position4[0];\n                                offset = _leaf$position4[1];\n                                range.setEnd(node, offset);\n                                return range.getBoundingClientRect();\n                            } else {\n                                var side = \"left\";\n                                var rect = void 0;\n                                if (node instanceof Text) {\n                                    if (offset < node.data.length) {\n                                        range.setStart(node, offset);\n                                        range.setEnd(node, offset + 1);\n                                    } else {\n                                        range.setStart(node, offset - 1);\n                                        range.setEnd(node, offset);\n                                        side = \"right\";\n                                    }\n                                    rect = range.getBoundingClientRect();\n                                } else {\n                                    rect = leaf.domNode.getBoundingClientRect();\n                                    if (offset > 0) side = \"right\";\n                                }\n                                return {\n                                    bottom: rect.top + rect.height,\n                                    height: rect.height,\n                                    left: rect[side],\n                                    right: rect[side],\n                                    top: rect.top,\n                                    width: 0\n                                };\n                            }\n                        }\n                    },\n                    {\n                        key: \"getNativeRange\",\n                        value: function getNativeRange() {\n                            var selection = document.getSelection();\n                            if (selection == null || selection.rangeCount <= 0) return null;\n                            var nativeRange = selection.getRangeAt(0);\n                            if (nativeRange == null) return null;\n                            var range = this.normalizeNative(nativeRange);\n                            debug.info(\"getNativeRange\", range);\n                            return range;\n                        }\n                    },\n                    {\n                        key: \"getRange\",\n                        value: function getRange() {\n                            var normalized = this.getNativeRange();\n                            if (normalized == null) return [\n                                null,\n                                null\n                            ];\n                            var range = this.normalizedToRange(normalized);\n                            return [\n                                range,\n                                normalized\n                            ];\n                        }\n                    },\n                    {\n                        key: \"hasFocus\",\n                        value: function hasFocus() {\n                            return document.activeElement === this.root;\n                        }\n                    },\n                    {\n                        key: \"normalizedToRange\",\n                        value: function normalizedToRange(range) {\n                            var _this4 = this;\n                            var positions = [\n                                [\n                                    range.start.node,\n                                    range.start.offset\n                                ]\n                            ];\n                            if (!range.native.collapsed) {\n                                positions.push([\n                                    range.end.node,\n                                    range.end.offset\n                                ]);\n                            }\n                            var indexes = positions.map(function(position) {\n                                var _position = _slicedToArray(position, 2), node = _position[0], offset = _position[1];\n                                var blot = _parchment2.default.find(node, true);\n                                var index = blot.offset(_this4.scroll);\n                                if (offset === 0) {\n                                    return index;\n                                } else if (blot instanceof _parchment2.default.Container) {\n                                    return index + blot.length();\n                                } else {\n                                    return index + blot.index(node, offset);\n                                }\n                            });\n                            var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);\n                            var start = Math.min.apply(Math, [\n                                end\n                            ].concat(_toConsumableArray(indexes)));\n                            return new Range(start, end - start);\n                        }\n                    },\n                    {\n                        key: \"normalizeNative\",\n                        value: function normalizeNative(nativeRange) {\n                            if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {\n                                return null;\n                            }\n                            var range = {\n                                start: {\n                                    node: nativeRange.startContainer,\n                                    offset: nativeRange.startOffset\n                                },\n                                end: {\n                                    node: nativeRange.endContainer,\n                                    offset: nativeRange.endOffset\n                                },\n                                native: nativeRange\n                            };\n                            [\n                                range.start,\n                                range.end\n                            ].forEach(function(position) {\n                                var node = position.node, offset = position.offset;\n                                while(!(node instanceof Text) && node.childNodes.length > 0){\n                                    if (node.childNodes.length > offset) {\n                                        node = node.childNodes[offset];\n                                        offset = 0;\n                                    } else if (node.childNodes.length === offset) {\n                                        node = node.lastChild;\n                                        offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                                position.node = node, position.offset = offset;\n                            });\n                            return range;\n                        }\n                    },\n                    {\n                        key: \"rangeToNative\",\n                        value: function rangeToNative(range) {\n                            var _this5 = this;\n                            var indexes = range.collapsed ? [\n                                range.index\n                            ] : [\n                                range.index,\n                                range.index + range.length\n                            ];\n                            var args = [];\n                            var scrollLength = this.scroll.length();\n                            indexes.forEach(function(index, i) {\n                                index = Math.min(scrollLength - 1, index);\n                                var node = void 0, _scroll$leaf5 = _this5.scroll.leaf(index), _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2), leaf = _scroll$leaf6[0], offset = _scroll$leaf6[1];\n                                var _leaf$position5 = leaf.position(offset, i !== 0);\n                                var _leaf$position6 = _slicedToArray(_leaf$position5, 2);\n                                node = _leaf$position6[0];\n                                offset = _leaf$position6[1];\n                                args.push(node, offset);\n                            });\n                            if (args.length < 2) {\n                                args = args.concat(args);\n                            }\n                            return args;\n                        }\n                    },\n                    {\n                        key: \"scrollIntoView\",\n                        value: function scrollIntoView(scrollingContainer) {\n                            var range = this.lastRange;\n                            if (range == null) return;\n                            var bounds = this.getBounds(range.index, range.length);\n                            if (bounds == null) return;\n                            var limit = this.scroll.length() - 1;\n                            var _scroll$line = this.scroll.line(Math.min(range.index, limit)), _scroll$line2 = _slicedToArray(_scroll$line, 1), first = _scroll$line2[0];\n                            var last = first;\n                            if (range.length > 0) {\n                                var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));\n                                var _scroll$line4 = _slicedToArray(_scroll$line3, 1);\n                                last = _scroll$line4[0];\n                            }\n                            if (first == null || last == null) return;\n                            var scrollBounds = scrollingContainer.getBoundingClientRect();\n                            if (bounds.top < scrollBounds.top) {\n                                scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;\n                            } else if (bounds.bottom > scrollBounds.bottom) {\n                                scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;\n                            }\n                        }\n                    },\n                    {\n                        key: \"setNativeRange\",\n                        value: function setNativeRange(startNode, startOffset) {\n                            var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;\n                            var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;\n                            var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n                            debug.info(\"setNativeRange\", startNode, startOffset, endNode, endOffset);\n                            if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {\n                                return;\n                            }\n                            var selection = document.getSelection();\n                            if (selection == null) return;\n                            if (startNode != null) {\n                                if (!this.hasFocus()) this.root.focus();\n                                var native = (this.getNativeRange() || {}).native;\n                                if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {\n                                    if (startNode.tagName == \"BR\") {\n                                        startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);\n                                        startNode = startNode.parentNode;\n                                    }\n                                    if (endNode.tagName == \"BR\") {\n                                        endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);\n                                        endNode = endNode.parentNode;\n                                    }\n                                    var range = document.createRange();\n                                    range.setStart(startNode, startOffset);\n                                    range.setEnd(endNode, endOffset);\n                                    selection.removeAllRanges();\n                                    selection.addRange(range);\n                                }\n                            } else {\n                                selection.removeAllRanges();\n                                this.root.blur();\n                                document.body.focus(); // root.blur() not enough on IE11+Travis+SauceLabs (but not local VMs)\n                            }\n                        }\n                    },\n                    {\n                        key: \"setRange\",\n                        value: function setRange(range) {\n                            var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                            var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;\n                            if (typeof force === \"string\") {\n                                source = force;\n                                force = false;\n                            }\n                            debug.info(\"setRange\", range);\n                            if (range != null) {\n                                var args = this.rangeToNative(range);\n                                this.setNativeRange.apply(this, _toConsumableArray(args).concat([\n                                    force\n                                ]));\n                            } else {\n                                this.setNativeRange(null);\n                            }\n                            this.update(source);\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update() {\n                            var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;\n                            var oldRange = this.lastRange;\n                            var _getRange = this.getRange(), _getRange2 = _slicedToArray(_getRange, 2), lastRange = _getRange2[0], nativeRange = _getRange2[1];\n                            this.lastRange = lastRange;\n                            if (this.lastRange != null) {\n                                this.savedRange = this.lastRange;\n                            }\n                            if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {\n                                var _emitter;\n                                if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {\n                                    this.cursor.restore();\n                                }\n                                var args = [\n                                    _emitter4.default.events.SELECTION_CHANGE,\n                                    (0, _clone2.default)(this.lastRange),\n                                    (0, _clone2.default)(oldRange),\n                                    source\n                                ];\n                                (_emitter = this.emitter).emit.apply(_emitter, [\n                                    _emitter4.default.events.EDITOR_CHANGE\n                                ].concat(args));\n                                if (source !== _emitter4.default.sources.SILENT) {\n                                    var _emitter2;\n                                    (_emitter2 = this.emitter).emit.apply(_emitter2, args);\n                                }\n                            }\n                        }\n                    }\n                ]);\n                return Selection;\n            }();\n            function contains(parent, descendant) {\n                try {\n                    // Firefox inserts inaccessible nodes around video elements\n                    descendant.parentNode;\n                } catch (e) {\n                    return false;\n                }\n                // IE11 has bug with Text nodes\n                // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect\n                if (descendant instanceof Text) {\n                    descendant = descendant.parentNode;\n                }\n                return parent.contains(descendant);\n            }\n            exports1.Range = Range;\n            exports1.default = Selection;\n        /***/ },\n        /* 16 */ /***/ function(module1, exports1, __nested_webpack_require_179379__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_179379__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Break = function(_Parchment$Embed) {\n                _inherits(Break, _Parchment$Embed);\n                function Break() {\n                    _classCallCheck(this, Break);\n                    return _possibleConstructorReturn(this, (Break.__proto__ || Object.getPrototypeOf(Break)).apply(this, arguments));\n                }\n                _createClass(Break, [\n                    {\n                        key: \"insertInto\",\n                        value: function insertInto(parent, ref) {\n                            if (parent.children.length === 0) {\n                                _get(Break.prototype.__proto__ || Object.getPrototypeOf(Break.prototype), \"insertInto\", this).call(this, parent, ref);\n                            } else {\n                                this.remove();\n                            }\n                        }\n                    },\n                    {\n                        key: \"length\",\n                        value: function length() {\n                            return 0;\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return \"\";\n                        }\n                    }\n                ], [\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return undefined;\n                        }\n                    }\n                ]);\n                return Break;\n            }(_parchment2.default.Embed);\n            Break.blotName = \"break\";\n            Break.tagName = \"BR\";\n            exports1.default = Break;\n        /***/ },\n        /* 17 */ /***/ function(module1, exports1, __nested_webpack_require_184658__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var linked_list_1 = __nested_webpack_require_184658__(44);\n            var shadow_1 = __nested_webpack_require_184658__(30);\n            var Registry = __nested_webpack_require_184658__(1);\n            var ContainerBlot = /** @class */ function(_super) {\n                __extends(ContainerBlot, _super);\n                function ContainerBlot(domNode) {\n                    var _this = _super.call(this, domNode) || this;\n                    _this.build();\n                    return _this;\n                }\n                ContainerBlot.prototype.appendChild = function(other) {\n                    this.insertBefore(other);\n                };\n                ContainerBlot.prototype.attach = function() {\n                    _super.prototype.attach.call(this);\n                    this.children.forEach(function(child) {\n                        child.attach();\n                    });\n                };\n                ContainerBlot.prototype.build = function() {\n                    var _this = this;\n                    this.children = new linked_list_1.default();\n                    // Need to be reversed for if DOM nodes already in order\n                    [].slice.call(this.domNode.childNodes).reverse().forEach(function(node) {\n                        try {\n                            var child = makeBlot(node);\n                            _this.insertBefore(child, _this.children.head || undefined);\n                        } catch (err) {\n                            if (err instanceof Registry.ParchmentError) return;\n                            else throw err;\n                        }\n                    });\n                };\n                ContainerBlot.prototype.deleteAt = function(index, length) {\n                    if (index === 0 && length === this.length()) {\n                        return this.remove();\n                    }\n                    this.children.forEachAt(index, length, function(child, offset, length) {\n                        child.deleteAt(offset, length);\n                    });\n                };\n                ContainerBlot.prototype.descendant = function(criteria, index) {\n                    var _a = this.children.find(index), child = _a[0], offset = _a[1];\n                    if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {\n                        return [\n                            child,\n                            offset\n                        ];\n                    } else if (child instanceof ContainerBlot) {\n                        return child.descendant(criteria, offset);\n                    } else {\n                        return [\n                            null,\n                            -1\n                        ];\n                    }\n                };\n                ContainerBlot.prototype.descendants = function(criteria, index, length) {\n                    if (index === void 0) {\n                        index = 0;\n                    }\n                    if (length === void 0) {\n                        length = Number.MAX_VALUE;\n                    }\n                    var descendants = [];\n                    var lengthLeft = length;\n                    this.children.forEachAt(index, length, function(child, index, length) {\n                        if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {\n                            descendants.push(child);\n                        }\n                        if (child instanceof ContainerBlot) {\n                            descendants = descendants.concat(child.descendants(criteria, index, lengthLeft));\n                        }\n                        lengthLeft -= length;\n                    });\n                    return descendants;\n                };\n                ContainerBlot.prototype.detach = function() {\n                    this.children.forEach(function(child) {\n                        child.detach();\n                    });\n                    _super.prototype.detach.call(this);\n                };\n                ContainerBlot.prototype.formatAt = function(index, length, name, value) {\n                    this.children.forEachAt(index, length, function(child, offset, length) {\n                        child.formatAt(offset, length, name, value);\n                    });\n                };\n                ContainerBlot.prototype.insertAt = function(index, value, def) {\n                    var _a = this.children.find(index), child = _a[0], offset = _a[1];\n                    if (child) {\n                        child.insertAt(offset, value, def);\n                    } else {\n                        var blot = def == null ? Registry.create(\"text\", value) : Registry.create(value, def);\n                        this.appendChild(blot);\n                    }\n                };\n                ContainerBlot.prototype.insertBefore = function(childBlot, refBlot) {\n                    if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function(child) {\n                        return childBlot instanceof child;\n                    })) {\n                        throw new Registry.ParchmentError(\"Cannot insert \" + childBlot.statics.blotName + \" into \" + this.statics.blotName);\n                    }\n                    childBlot.insertInto(this, refBlot);\n                };\n                ContainerBlot.prototype.length = function() {\n                    return this.children.reduce(function(memo, child) {\n                        return memo + child.length();\n                    }, 0);\n                };\n                ContainerBlot.prototype.moveChildren = function(targetParent, refNode) {\n                    this.children.forEach(function(child) {\n                        targetParent.insertBefore(child, refNode);\n                    });\n                };\n                ContainerBlot.prototype.optimize = function(context) {\n                    _super.prototype.optimize.call(this, context);\n                    if (this.children.length === 0) {\n                        if (this.statics.defaultChild != null) {\n                            var child = Registry.create(this.statics.defaultChild);\n                            this.appendChild(child);\n                            child.optimize(context);\n                        } else {\n                            this.remove();\n                        }\n                    }\n                };\n                ContainerBlot.prototype.path = function(index, inclusive) {\n                    if (inclusive === void 0) {\n                        inclusive = false;\n                    }\n                    var _a = this.children.find(index, inclusive), child = _a[0], offset = _a[1];\n                    var position = [\n                        [\n                            this,\n                            index\n                        ]\n                    ];\n                    if (child instanceof ContainerBlot) {\n                        return position.concat(child.path(offset, inclusive));\n                    } else if (child != null) {\n                        position.push([\n                            child,\n                            offset\n                        ]);\n                    }\n                    return position;\n                };\n                ContainerBlot.prototype.removeChild = function(child) {\n                    this.children.remove(child);\n                };\n                ContainerBlot.prototype.replace = function(target) {\n                    if (target instanceof ContainerBlot) {\n                        target.moveChildren(this);\n                    }\n                    _super.prototype.replace.call(this, target);\n                };\n                ContainerBlot.prototype.split = function(index, force) {\n                    if (force === void 0) {\n                        force = false;\n                    }\n                    if (!force) {\n                        if (index === 0) return this;\n                        if (index === this.length()) return this.next;\n                    }\n                    var after = this.clone();\n                    this.parent.insertBefore(after, this.next);\n                    this.children.forEachAt(index, this.length(), function(child, offset, length) {\n                        child = child.split(offset, force);\n                        after.appendChild(child);\n                    });\n                    return after;\n                };\n                ContainerBlot.prototype.unwrap = function() {\n                    this.moveChildren(this.parent, this.next);\n                    this.remove();\n                };\n                ContainerBlot.prototype.update = function(mutations, context) {\n                    var _this = this;\n                    var addedNodes = [];\n                    var removedNodes = [];\n                    mutations.forEach(function(mutation) {\n                        if (mutation.target === _this.domNode && mutation.type === \"childList\") {\n                            addedNodes.push.apply(addedNodes, mutation.addedNodes);\n                            removedNodes.push.apply(removedNodes, mutation.removedNodes);\n                        }\n                    });\n                    removedNodes.forEach(function(node) {\n                        // Check node has actually been removed\n                        // One exception is Chrome does not immediately remove IFRAMEs\n                        // from DOM but MutationRecord is correct in its reported removal\n                        if (node.parentNode != null && // @ts-ignore\n                        node.tagName !== \"IFRAME\" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n                            return;\n                        }\n                        var blot = Registry.find(node);\n                        if (blot == null) return;\n                        if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {\n                            blot.detach();\n                        }\n                    });\n                    addedNodes.filter(function(node) {\n                        return node.parentNode == _this.domNode;\n                    }).sort(function(a, b) {\n                        if (a === b) return 0;\n                        if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n                            return 1;\n                        }\n                        return -1;\n                    }).forEach(function(node) {\n                        var refBlot = null;\n                        if (node.nextSibling != null) {\n                            refBlot = Registry.find(node.nextSibling);\n                        }\n                        var blot = makeBlot(node);\n                        if (blot.next != refBlot || blot.next == null) {\n                            if (blot.parent != null) {\n                                blot.parent.removeChild(_this);\n                            }\n                            _this.insertBefore(blot, refBlot || undefined);\n                        }\n                    });\n                };\n                return ContainerBlot;\n            }(shadow_1.default);\n            function makeBlot(node) {\n                var blot = Registry.find(node);\n                if (blot == null) {\n                    try {\n                        blot = Registry.create(node);\n                    } catch (e) {\n                        blot = Registry.create(Registry.Scope.INLINE);\n                        [].slice.call(node.childNodes).forEach(function(child) {\n                            // @ts-ignore\n                            blot.domNode.appendChild(child);\n                        });\n                        if (node.parentNode) {\n                            node.parentNode.replaceChild(blot.domNode, node);\n                        }\n                        blot.attach();\n                    }\n                }\n                return blot;\n            }\n            exports1.default = ContainerBlot;\n        /***/ },\n        /* 18 */ /***/ function(module1, exports1, __nested_webpack_require_197722__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var attributor_1 = __nested_webpack_require_197722__(12);\n            var store_1 = __nested_webpack_require_197722__(31);\n            var container_1 = __nested_webpack_require_197722__(17);\n            var Registry = __nested_webpack_require_197722__(1);\n            var FormatBlot = /** @class */ function(_super) {\n                __extends(FormatBlot, _super);\n                function FormatBlot(domNode) {\n                    var _this = _super.call(this, domNode) || this;\n                    _this.attributes = new store_1.default(_this.domNode);\n                    return _this;\n                }\n                FormatBlot.formats = function(domNode) {\n                    if (typeof this.tagName === \"string\") {\n                        return true;\n                    } else if (Array.isArray(this.tagName)) {\n                        return domNode.tagName.toLowerCase();\n                    }\n                    return undefined;\n                };\n                FormatBlot.prototype.format = function(name, value) {\n                    var format = Registry.query(name);\n                    if (format instanceof attributor_1.default) {\n                        this.attributes.attribute(format, value);\n                    } else if (value) {\n                        if (format != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {\n                            this.replaceWith(name, value);\n                        }\n                    }\n                };\n                FormatBlot.prototype.formats = function() {\n                    var formats = this.attributes.values();\n                    var format = this.statics.formats(this.domNode);\n                    if (format != null) {\n                        formats[this.statics.blotName] = format;\n                    }\n                    return formats;\n                };\n                FormatBlot.prototype.replaceWith = function(name, value) {\n                    var replacement = _super.prototype.replaceWith.call(this, name, value);\n                    this.attributes.copy(replacement);\n                    return replacement;\n                };\n                FormatBlot.prototype.update = function(mutations, context) {\n                    var _this = this;\n                    _super.prototype.update.call(this, mutations, context);\n                    if (mutations.some(function(mutation) {\n                        return mutation.target === _this.domNode && mutation.type === \"attributes\";\n                    })) {\n                        this.attributes.build();\n                    }\n                };\n                FormatBlot.prototype.wrap = function(name, value) {\n                    var wrapper = _super.prototype.wrap.call(this, name, value);\n                    if (wrapper instanceof FormatBlot && wrapper.statics.scope === this.statics.scope) {\n                        this.attributes.move(wrapper);\n                    }\n                    return wrapper;\n                };\n                return FormatBlot;\n            }(container_1.default);\n            exports1.default = FormatBlot;\n        /***/ },\n        /* 19 */ /***/ function(module1, exports1, __nested_webpack_require_201739__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var shadow_1 = __nested_webpack_require_201739__(30);\n            var Registry = __nested_webpack_require_201739__(1);\n            var LeafBlot = /** @class */ function(_super) {\n                __extends(LeafBlot, _super);\n                function LeafBlot() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                LeafBlot.value = function(domNode) {\n                    return true;\n                };\n                LeafBlot.prototype.index = function(node, offset) {\n                    if (this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n                        return Math.min(offset, 1);\n                    }\n                    return -1;\n                };\n                LeafBlot.prototype.position = function(index, inclusive) {\n                    var offset = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);\n                    if (index > 0) offset += 1;\n                    return [\n                        this.parent.domNode,\n                        offset\n                    ];\n                };\n                LeafBlot.prototype.value = function() {\n                    var _a;\n                    return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;\n                };\n                LeafBlot.scope = Registry.Scope.INLINE_BLOT;\n                return LeafBlot;\n            }(shadow_1.default);\n            exports1.default = LeafBlot;\n        /***/ },\n        /* 20 */ /***/ function(module1, exports1, __nested_webpack_require_204201__) {\n            var equal = __nested_webpack_require_204201__(11);\n            var extend = __nested_webpack_require_204201__(3);\n            var lib = {\n                attributes: {\n                    compose: function(a, b, keepNull) {\n                        if (typeof a !== \"object\") a = {};\n                        if (typeof b !== \"object\") b = {};\n                        var attributes = extend(true, {}, b);\n                        if (!keepNull) {\n                            attributes = Object.keys(attributes).reduce(function(copy, key) {\n                                if (attributes[key] != null) {\n                                    copy[key] = attributes[key];\n                                }\n                                return copy;\n                            }, {});\n                        }\n                        for(var key in a){\n                            if (a[key] !== undefined && b[key] === undefined) {\n                                attributes[key] = a[key];\n                            }\n                        }\n                        return Object.keys(attributes).length > 0 ? attributes : undefined;\n                    },\n                    diff: function(a, b) {\n                        if (typeof a !== \"object\") a = {};\n                        if (typeof b !== \"object\") b = {};\n                        var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function(attributes, key) {\n                            if (!equal(a[key], b[key])) {\n                                attributes[key] = b[key] === undefined ? null : b[key];\n                            }\n                            return attributes;\n                        }, {});\n                        return Object.keys(attributes).length > 0 ? attributes : undefined;\n                    },\n                    transform: function(a, b, priority) {\n                        if (typeof a !== \"object\") return b;\n                        if (typeof b !== \"object\") return undefined;\n                        if (!priority) return b; // b simply overwrites us without priority\n                        var attributes = Object.keys(b).reduce(function(attributes, key) {\n                            if (a[key] === undefined) attributes[key] = b[key]; // null is a valid value\n                            return attributes;\n                        }, {});\n                        return Object.keys(attributes).length > 0 ? attributes : undefined;\n                    }\n                },\n                iterator: function(ops) {\n                    return new Iterator(ops);\n                },\n                length: function(op) {\n                    if (typeof op[\"delete\"] === \"number\") {\n                        return op[\"delete\"];\n                    } else if (typeof op.retain === \"number\") {\n                        return op.retain;\n                    } else {\n                        return typeof op.insert === \"string\" ? op.insert.length : 1;\n                    }\n                }\n            };\n            function Iterator(ops) {\n                this.ops = ops;\n                this.index = 0;\n                this.offset = 0;\n            }\n            ;\n            Iterator.prototype.hasNext = function() {\n                return this.peekLength() < Infinity;\n            };\n            Iterator.prototype.next = function(length) {\n                if (!length) length = Infinity;\n                var nextOp = this.ops[this.index];\n                if (nextOp) {\n                    var offset = this.offset;\n                    var opLength = lib.length(nextOp);\n                    if (length >= opLength - offset) {\n                        length = opLength - offset;\n                        this.index += 1;\n                        this.offset = 0;\n                    } else {\n                        this.offset += length;\n                    }\n                    if (typeof nextOp[\"delete\"] === \"number\") {\n                        return {\n                            \"delete\": length\n                        };\n                    } else {\n                        var retOp = {};\n                        if (nextOp.attributes) {\n                            retOp.attributes = nextOp.attributes;\n                        }\n                        if (typeof nextOp.retain === \"number\") {\n                            retOp.retain = length;\n                        } else if (typeof nextOp.insert === \"string\") {\n                            retOp.insert = nextOp.insert.substr(offset, length);\n                        } else {\n                            // offset should === 0, length should === 1\n                            retOp.insert = nextOp.insert;\n                        }\n                        return retOp;\n                    }\n                } else {\n                    return {\n                        retain: Infinity\n                    };\n                }\n            };\n            Iterator.prototype.peek = function() {\n                return this.ops[this.index];\n            };\n            Iterator.prototype.peekLength = function() {\n                if (this.ops[this.index]) {\n                    // Should never return 0 if our index is being managed correctly\n                    return lib.length(this.ops[this.index]) - this.offset;\n                } else {\n                    return Infinity;\n                }\n            };\n            Iterator.prototype.peekType = function() {\n                if (this.ops[this.index]) {\n                    if (typeof this.ops[this.index][\"delete\"] === \"number\") {\n                        return \"delete\";\n                    } else if (typeof this.ops[this.index].retain === \"number\") {\n                        return \"retain\";\n                    } else {\n                        return \"insert\";\n                    }\n                }\n                return \"retain\";\n            };\n            Iterator.prototype.rest = function() {\n                if (!this.hasNext()) {\n                    return [];\n                } else if (this.offset === 0) {\n                    return this.ops.slice(this.index);\n                } else {\n                    var offset = this.offset;\n                    var index = this.index;\n                    var next = this.next();\n                    var rest = this.ops.slice(this.index);\n                    this.offset = offset;\n                    this.index = index;\n                    return [\n                        next\n                    ].concat(rest);\n                }\n            };\n            module1.exports = lib;\n        /***/ },\n        /* 21 */ /***/ function(module1, exports1) {\n            var clone = function() {\n                \"use strict\";\n                function _instanceof(obj, type) {\n                    return type != null && obj instanceof type;\n                }\n                var nativeMap;\n                try {\n                    nativeMap = Map;\n                } catch (_) {\n                    // maybe a reference error because no `Map`. Give it a dummy value that no\n                    // value will ever be an instanceof.\n                    nativeMap = function() {};\n                }\n                var nativeSet;\n                try {\n                    nativeSet = Set;\n                } catch (_) {\n                    nativeSet = function() {};\n                }\n                var nativePromise;\n                try {\n                    nativePromise = Promise;\n                } catch (_) {\n                    nativePromise = function() {};\n                }\n                /**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/ function clone(parent, circular, depth, prototype, includeNonEnumerable) {\n                    if (typeof circular === \"object\") {\n                        depth = circular.depth;\n                        prototype = circular.prototype;\n                        includeNonEnumerable = circular.includeNonEnumerable;\n                        circular = circular.circular;\n                    }\n                    // maintain two arrays for circular references, where corresponding parents\n                    // and children have the same index\n                    var allParents = [];\n                    var allChildren = [];\n                    var useBuffer = typeof Buffer != \"undefined\";\n                    if (typeof circular == \"undefined\") circular = true;\n                    if (typeof depth == \"undefined\") depth = Infinity;\n                    // recurse this function so we don't reset allParents and allChildren\n                    function _clone(parent, depth) {\n                        // cloning null always returns null\n                        if (parent === null) return null;\n                        if (depth === 0) return parent;\n                        var child;\n                        var proto;\n                        if (typeof parent != \"object\") {\n                            return parent;\n                        }\n                        if (_instanceof(parent, nativeMap)) {\n                            child = new nativeMap();\n                        } else if (_instanceof(parent, nativeSet)) {\n                            child = new nativeSet();\n                        } else if (_instanceof(parent, nativePromise)) {\n                            child = new nativePromise(function(resolve, reject) {\n                                parent.then(function(value) {\n                                    resolve(_clone(value, depth - 1));\n                                }, function(err) {\n                                    reject(_clone(err, depth - 1));\n                                });\n                            });\n                        } else if (clone.__isArray(parent)) {\n                            child = [];\n                        } else if (clone.__isRegExp(parent)) {\n                            child = new RegExp(parent.source, __getRegExpFlags(parent));\n                            if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n                        } else if (clone.__isDate(parent)) {\n                            child = new Date(parent.getTime());\n                        } else if (useBuffer && Buffer.isBuffer(parent)) {\n                            if (Buffer.allocUnsafe) {\n                                // Node.js >= 4.5.0\n                                child = Buffer.allocUnsafe(parent.length);\n                            } else {\n                                // Older Node.js versions\n                                child = new Buffer(parent.length);\n                            }\n                            parent.copy(child);\n                            return child;\n                        } else if (_instanceof(parent, Error)) {\n                            child = Object.create(parent);\n                        } else {\n                            if (typeof prototype == \"undefined\") {\n                                proto = Object.getPrototypeOf(parent);\n                                child = Object.create(proto);\n                            } else {\n                                child = Object.create(prototype);\n                                proto = prototype;\n                            }\n                        }\n                        if (circular) {\n                            var index = allParents.indexOf(parent);\n                            if (index != -1) {\n                                return allChildren[index];\n                            }\n                            allParents.push(parent);\n                            allChildren.push(child);\n                        }\n                        if (_instanceof(parent, nativeMap)) {\n                            parent.forEach(function(value, key) {\n                                var keyChild = _clone(key, depth - 1);\n                                var valueChild = _clone(value, depth - 1);\n                                child.set(keyChild, valueChild);\n                            });\n                        }\n                        if (_instanceof(parent, nativeSet)) {\n                            parent.forEach(function(value) {\n                                var entryChild = _clone(value, depth - 1);\n                                child.add(entryChild);\n                            });\n                        }\n                        for(var i in parent){\n                            var attrs;\n                            if (proto) {\n                                attrs = Object.getOwnPropertyDescriptor(proto, i);\n                            }\n                            if (attrs && attrs.set == null) {\n                                continue;\n                            }\n                            child[i] = _clone(parent[i], depth - 1);\n                        }\n                        if (Object.getOwnPropertySymbols) {\n                            var symbols = Object.getOwnPropertySymbols(parent);\n                            for(var i = 0; i < symbols.length; i++){\n                                // Don't need to worry about cloning a symbol because it is a primitive,\n                                // like a number or string.\n                                var symbol = symbols[i];\n                                var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n                                if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n                                    continue;\n                                }\n                                child[symbol] = _clone(parent[symbol], depth - 1);\n                                if (!descriptor.enumerable) {\n                                    Object.defineProperty(child, symbol, {\n                                        enumerable: false\n                                    });\n                                }\n                            }\n                        }\n                        if (includeNonEnumerable) {\n                            var allPropertyNames = Object.getOwnPropertyNames(parent);\n                            for(var i = 0; i < allPropertyNames.length; i++){\n                                var propertyName = allPropertyNames[i];\n                                var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n                                if (descriptor && descriptor.enumerable) {\n                                    continue;\n                                }\n                                child[propertyName] = _clone(parent[propertyName], depth - 1);\n                                Object.defineProperty(child, propertyName, {\n                                    enumerable: false\n                                });\n                            }\n                        }\n                        return child;\n                    }\n                    return _clone(parent, depth);\n                }\n                /**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */ clone.clonePrototype = function clonePrototype(parent) {\n                    if (parent === null) return null;\n                    var c = function() {};\n                    c.prototype = parent;\n                    return new c();\n                };\n                // private utility functions\n                function __objToStr(o) {\n                    return Object.prototype.toString.call(o);\n                }\n                clone.__objToStr = __objToStr;\n                function __isDate(o) {\n                    return typeof o === \"object\" && __objToStr(o) === \"[object Date]\";\n                }\n                clone.__isDate = __isDate;\n                function __isArray(o) {\n                    return typeof o === \"object\" && __objToStr(o) === \"[object Array]\";\n                }\n                clone.__isArray = __isArray;\n                function __isRegExp(o) {\n                    return typeof o === \"object\" && __objToStr(o) === \"[object RegExp]\";\n                }\n                clone.__isRegExp = __isRegExp;\n                function __getRegExpFlags(re) {\n                    var flags = \"\";\n                    if (re.global) flags += \"g\";\n                    if (re.ignoreCase) flags += \"i\";\n                    if (re.multiline) flags += \"m\";\n                    return flags;\n                }\n                clone.__getRegExpFlags = __getRegExpFlags;\n                return clone;\n            }();\n            if (typeof module1 === \"object\" && module1.exports) {\n                module1.exports = clone;\n            }\n        /***/ },\n        /* 22 */ /***/ function(module1, exports1, __nested_webpack_require_222007__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_222007__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _emitter = __nested_webpack_require_222007__(8);\n            var _emitter2 = _interopRequireDefault(_emitter);\n            var _block = __nested_webpack_require_222007__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _break = __nested_webpack_require_222007__(16);\n            var _break2 = _interopRequireDefault(_break);\n            var _code = __nested_webpack_require_222007__(13);\n            var _code2 = _interopRequireDefault(_code);\n            var _container = __nested_webpack_require_222007__(25);\n            var _container2 = _interopRequireDefault(_container);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            function isLine(blot) {\n                return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;\n            }\n            var Scroll = function(_Parchment$Scroll) {\n                _inherits(Scroll, _Parchment$Scroll);\n                function Scroll(domNode, config) {\n                    _classCallCheck(this, Scroll);\n                    var _this = _possibleConstructorReturn(this, (Scroll.__proto__ || Object.getPrototypeOf(Scroll)).call(this, domNode));\n                    _this.emitter = config.emitter;\n                    if (Array.isArray(config.whitelist)) {\n                        _this.whitelist = config.whitelist.reduce(function(whitelist, format) {\n                            whitelist[format] = true;\n                            return whitelist;\n                        }, {});\n                    }\n                    // Some reason fixes composition issues with character languages in Windows/Chrome, Safari\n                    _this.domNode.addEventListener(\"DOMNodeInserted\", function() {});\n                    _this.optimize();\n                    _this.enable();\n                    return _this;\n                }\n                _createClass(Scroll, [\n                    {\n                        key: \"batchStart\",\n                        value: function batchStart() {\n                            this.batch = true;\n                        }\n                    },\n                    {\n                        key: \"batchEnd\",\n                        value: function batchEnd() {\n                            this.batch = false;\n                            this.optimize();\n                        }\n                    },\n                    {\n                        key: \"deleteAt\",\n                        value: function deleteAt(index, length) {\n                            var _line = this.line(index), _line2 = _slicedToArray(_line, 2), first = _line2[0], offset = _line2[1];\n                            var _line3 = this.line(index + length), _line4 = _slicedToArray(_line3, 1), last = _line4[0];\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"deleteAt\", this).call(this, index, length);\n                            if (last != null && first !== last && offset > 0) {\n                                if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {\n                                    this.optimize();\n                                    return;\n                                }\n                                if (first instanceof _code2.default) {\n                                    var newlineIndex = first.newlineIndex(first.length(), true);\n                                    if (newlineIndex > -1) {\n                                        first = first.split(newlineIndex + 1);\n                                        if (first === last) {\n                                            this.optimize();\n                                            return;\n                                        }\n                                    }\n                                } else if (last instanceof _code2.default) {\n                                    var _newlineIndex = last.newlineIndex(0);\n                                    if (_newlineIndex > -1) {\n                                        last.split(_newlineIndex + 1);\n                                    }\n                                }\n                                var ref = last.children.head instanceof _break2.default ? null : last.children.head;\n                                first.moveChildren(last, ref);\n                                first.remove();\n                            }\n                            this.optimize();\n                        }\n                    },\n                    {\n                        key: \"enable\",\n                        value: function enable() {\n                            var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                            this.domNode.setAttribute(\"contenteditable\", enabled);\n                        }\n                    },\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, format, value) {\n                            if (this.whitelist != null && !this.whitelist[format]) return;\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"formatAt\", this).call(this, index, length, format, value);\n                            this.optimize();\n                        }\n                    },\n                    {\n                        key: \"insertAt\",\n                        value: function insertAt(index, value, def) {\n                            if (def != null && this.whitelist != null && !this.whitelist[value]) return;\n                            if (index >= this.length()) {\n                                if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {\n                                    var blot = _parchment2.default.create(this.statics.defaultChild);\n                                    this.appendChild(blot);\n                                    if (def == null && value.endsWith(\"\\n\")) {\n                                        value = value.slice(0, -1);\n                                    }\n                                    blot.insertAt(0, value, def);\n                                } else {\n                                    var embed = _parchment2.default.create(value, def);\n                                    this.appendChild(embed);\n                                }\n                            } else {\n                                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"insertAt\", this).call(this, index, value, def);\n                            }\n                            this.optimize();\n                        }\n                    },\n                    {\n                        key: \"insertBefore\",\n                        value: function insertBefore(blot, ref) {\n                            if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {\n                                var wrapper = _parchment2.default.create(this.statics.defaultChild);\n                                wrapper.appendChild(blot);\n                                blot = wrapper;\n                            }\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"insertBefore\", this).call(this, blot, ref);\n                        }\n                    },\n                    {\n                        key: \"leaf\",\n                        value: function leaf(index) {\n                            return this.path(index).pop() || [\n                                null,\n                                -1\n                            ];\n                        }\n                    },\n                    {\n                        key: \"line\",\n                        value: function line(index) {\n                            if (index === this.length()) {\n                                return this.line(index - 1);\n                            }\n                            return this.descendant(isLine, index);\n                        }\n                    },\n                    {\n                        key: \"lines\",\n                        value: function lines() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n                            var getLines = function getLines(blot, index, length) {\n                                var lines = [], lengthLeft = length;\n                                blot.children.forEachAt(index, length, function(child, index, length) {\n                                    if (isLine(child)) {\n                                        lines.push(child);\n                                    } else if (child instanceof _parchment2.default.Container) {\n                                        lines = lines.concat(getLines(child, index, lengthLeft));\n                                    }\n                                    lengthLeft -= length;\n                                });\n                                return lines;\n                            };\n                            return getLines(this, index, length);\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize() {\n                            var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n                            var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            if (this.batch === true) return;\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"optimize\", this).call(this, mutations, context);\n                            if (mutations.length > 0) {\n                                this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);\n                            }\n                        }\n                    },\n                    {\n                        key: \"path\",\n                        value: function path(index) {\n                            return _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"path\", this).call(this, index).slice(1); // Exclude self\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(mutations) {\n                            if (this.batch === true) return;\n                            var source = _emitter2.default.sources.USER;\n                            if (typeof mutations === \"string\") {\n                                source = mutations;\n                            }\n                            if (!Array.isArray(mutations)) {\n                                mutations = this.observer.takeRecords();\n                            }\n                            if (mutations.length > 0) {\n                                this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);\n                            }\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"update\", this).call(this, mutations.concat([])); // pass copy\n                            if (mutations.length > 0) {\n                                this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);\n                            }\n                        }\n                    }\n                ]);\n                return Scroll;\n            }(_parchment2.default.Scroll);\n            Scroll.blotName = \"scroll\";\n            Scroll.className = \"ql-editor\";\n            Scroll.tagName = \"DIV\";\n            Scroll.defaultChild = \"block\";\n            Scroll.allowedChildren = [\n                _block2.default,\n                _block.BlockEmbed,\n                _container2.default\n            ];\n            exports1.default = Scroll;\n        /***/ },\n        /* 23 */ /***/ function(module1, exports1, __nested_webpack_require_238923__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.SHORTKEY = exports1.default = undefined;\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _clone = __nested_webpack_require_238923__(21);\n            var _clone2 = _interopRequireDefault(_clone);\n            var _deepEqual = __nested_webpack_require_238923__(11);\n            var _deepEqual2 = _interopRequireDefault(_deepEqual);\n            var _extend = __nested_webpack_require_238923__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _quillDelta = __nested_webpack_require_238923__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _op = __nested_webpack_require_238923__(20);\n            var _op2 = _interopRequireDefault(_op);\n            var _parchment = __nested_webpack_require_238923__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_238923__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _logger = __nested_webpack_require_238923__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            var _module = __nested_webpack_require_238923__(9);\n            var _module2 = _interopRequireDefault(_module);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var debug = (0, _logger2.default)(\"quill:keyboard\");\n            var SHORTKEY = /Mac/i.test(navigator.platform) ? \"metaKey\" : \"ctrlKey\";\n            var Keyboard = function(_Module) {\n                _inherits(Keyboard, _Module);\n                _createClass(Keyboard, null, [\n                    {\n                        key: \"match\",\n                        value: function match(evt, binding) {\n                            binding = normalize(binding);\n                            if ([\n                                \"altKey\",\n                                \"ctrlKey\",\n                                \"metaKey\",\n                                \"shiftKey\"\n                            ].some(function(key) {\n                                return !!binding[key] !== evt[key] && binding[key] !== null;\n                            })) {\n                                return false;\n                            }\n                            return binding.key === (evt.which || evt.keyCode);\n                        }\n                    }\n                ]);\n                function Keyboard(quill, options) {\n                    _classCallCheck(this, Keyboard);\n                    var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this, quill, options));\n                    _this.bindings = {};\n                    Object.keys(_this.options.bindings).forEach(function(name) {\n                        if (name === \"list autofill\" && quill.scroll.whitelist != null && !quill.scroll.whitelist[\"list\"]) {\n                            return;\n                        }\n                        if (_this.options.bindings[name]) {\n                            _this.addBinding(_this.options.bindings[name]);\n                        }\n                    });\n                    _this.addBinding({\n                        key: Keyboard.keys.ENTER,\n                        shiftKey: null\n                    }, handleEnter);\n                    _this.addBinding({\n                        key: Keyboard.keys.ENTER,\n                        metaKey: null,\n                        ctrlKey: null,\n                        altKey: null\n                    }, function() {});\n                    if (/Firefox/i.test(navigator.userAgent)) {\n                        // Need to handle delete and backspace for Firefox in the general case #1171\n                        _this.addBinding({\n                            key: Keyboard.keys.BACKSPACE\n                        }, {\n                            collapsed: true\n                        }, handleBackspace);\n                        _this.addBinding({\n                            key: Keyboard.keys.DELETE\n                        }, {\n                            collapsed: true\n                        }, handleDelete);\n                    } else {\n                        _this.addBinding({\n                            key: Keyboard.keys.BACKSPACE\n                        }, {\n                            collapsed: true,\n                            prefix: /^.?$/\n                        }, handleBackspace);\n                        _this.addBinding({\n                            key: Keyboard.keys.DELETE\n                        }, {\n                            collapsed: true,\n                            suffix: /^.?$/\n                        }, handleDelete);\n                    }\n                    _this.addBinding({\n                        key: Keyboard.keys.BACKSPACE\n                    }, {\n                        collapsed: false\n                    }, handleDeleteRange);\n                    _this.addBinding({\n                        key: Keyboard.keys.DELETE\n                    }, {\n                        collapsed: false\n                    }, handleDeleteRange);\n                    _this.addBinding({\n                        key: Keyboard.keys.BACKSPACE,\n                        altKey: null,\n                        ctrlKey: null,\n                        metaKey: null,\n                        shiftKey: null\n                    }, {\n                        collapsed: true,\n                        offset: 0\n                    }, handleBackspace);\n                    _this.listen();\n                    return _this;\n                }\n                _createClass(Keyboard, [\n                    {\n                        key: \"addBinding\",\n                        value: function addBinding(key) {\n                            var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            var binding = normalize(key);\n                            if (binding == null || binding.key == null) {\n                                return debug.warn(\"Attempted to add invalid keyboard binding\", binding);\n                            }\n                            if (typeof context === \"function\") {\n                                context = {\n                                    handler: context\n                                };\n                            }\n                            if (typeof handler === \"function\") {\n                                handler = {\n                                    handler: handler\n                                };\n                            }\n                            binding = (0, _extend2.default)(binding, context, handler);\n                            this.bindings[binding.key] = this.bindings[binding.key] || [];\n                            this.bindings[binding.key].push(binding);\n                        }\n                    },\n                    {\n                        key: \"listen\",\n                        value: function listen() {\n                            var _this2 = this;\n                            this.quill.root.addEventListener(\"keydown\", function(evt) {\n                                if (evt.defaultPrevented) return;\n                                var which = evt.which || evt.keyCode;\n                                var bindings = (_this2.bindings[which] || []).filter(function(binding) {\n                                    return Keyboard.match(evt, binding);\n                                });\n                                if (bindings.length === 0) return;\n                                var range = _this2.quill.getSelection();\n                                if (range == null || !_this2.quill.hasFocus()) return;\n                                var _quill$getLine = _this2.quill.getLine(range.index), _quill$getLine2 = _slicedToArray(_quill$getLine, 2), line = _quill$getLine2[0], offset = _quill$getLine2[1];\n                                var _quill$getLeaf = _this2.quill.getLeaf(range.index), _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2), leafStart = _quill$getLeaf2[0], offsetStart = _quill$getLeaf2[1];\n                                var _ref = range.length === 0 ? [\n                                    leafStart,\n                                    offsetStart\n                                ] : _this2.quill.getLeaf(range.index + range.length), _ref2 = _slicedToArray(_ref, 2), leafEnd = _ref2[0], offsetEnd = _ref2[1];\n                                var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : \"\";\n                                var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : \"\";\n                                var curContext = {\n                                    collapsed: range.length === 0,\n                                    empty: range.length === 0 && line.length() <= 1,\n                                    format: _this2.quill.getFormat(range),\n                                    offset: offset,\n                                    prefix: prefixText,\n                                    suffix: suffixText\n                                };\n                                var prevented = bindings.some(function(binding) {\n                                    if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;\n                                    if (binding.empty != null && binding.empty !== curContext.empty) return false;\n                                    if (binding.offset != null && binding.offset !== curContext.offset) return false;\n                                    if (Array.isArray(binding.format)) {\n                                        // any format is present\n                                        if (binding.format.every(function(name) {\n                                            return curContext.format[name] == null;\n                                        })) {\n                                            return false;\n                                        }\n                                    } else if (_typeof(binding.format) === \"object\") {\n                                        // all formats must match\n                                        if (!Object.keys(binding.format).every(function(name) {\n                                            if (binding.format[name] === true) return curContext.format[name] != null;\n                                            if (binding.format[name] === false) return curContext.format[name] == null;\n                                            return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);\n                                        })) {\n                                            return false;\n                                        }\n                                    }\n                                    if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;\n                                    if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;\n                                    return binding.handler.call(_this2, range, curContext) !== true;\n                                });\n                                if (prevented) {\n                                    evt.preventDefault();\n                                }\n                            });\n                        }\n                    }\n                ]);\n                return Keyboard;\n            }(_module2.default);\n            Keyboard.keys = {\n                BACKSPACE: 8,\n                TAB: 9,\n                ENTER: 13,\n                ESCAPE: 27,\n                LEFT: 37,\n                UP: 38,\n                RIGHT: 39,\n                DOWN: 40,\n                DELETE: 46\n            };\n            Keyboard.DEFAULTS = {\n                bindings: {\n                    \"bold\": makeFormatHandler(\"bold\"),\n                    \"italic\": makeFormatHandler(\"italic\"),\n                    \"underline\": makeFormatHandler(\"underline\"),\n                    \"indent\": {\n                        // highlight tab or tab at beginning of list, indent or blockquote\n                        key: Keyboard.keys.TAB,\n                        format: [\n                            \"blockquote\",\n                            \"indent\",\n                            \"list\"\n                        ],\n                        handler: function handler(range, context) {\n                            if (context.collapsed && context.offset !== 0) return true;\n                            this.quill.format(\"indent\", \"+1\", _quill2.default.sources.USER);\n                        }\n                    },\n                    \"outdent\": {\n                        key: Keyboard.keys.TAB,\n                        shiftKey: true,\n                        format: [\n                            \"blockquote\",\n                            \"indent\",\n                            \"list\"\n                        ],\n                        // highlight tab or tab at beginning of list, indent or blockquote\n                        handler: function handler(range, context) {\n                            if (context.collapsed && context.offset !== 0) return true;\n                            this.quill.format(\"indent\", \"-1\", _quill2.default.sources.USER);\n                        }\n                    },\n                    \"outdent backspace\": {\n                        key: Keyboard.keys.BACKSPACE,\n                        collapsed: true,\n                        shiftKey: null,\n                        metaKey: null,\n                        ctrlKey: null,\n                        altKey: null,\n                        format: [\n                            \"indent\",\n                            \"list\"\n                        ],\n                        offset: 0,\n                        handler: function handler(range, context) {\n                            if (context.format.indent != null) {\n                                this.quill.format(\"indent\", \"-1\", _quill2.default.sources.USER);\n                            } else if (context.format.list != null) {\n                                this.quill.format(\"list\", false, _quill2.default.sources.USER);\n                            }\n                        }\n                    },\n                    \"indent code-block\": makeCodeBlockHandler(true),\n                    \"outdent code-block\": makeCodeBlockHandler(false),\n                    \"remove tab\": {\n                        key: Keyboard.keys.TAB,\n                        shiftKey: true,\n                        collapsed: true,\n                        prefix: /\\t$/,\n                        handler: function handler(range) {\n                            this.quill.deleteText(range.index - 1, 1, _quill2.default.sources.USER);\n                        }\n                    },\n                    \"tab\": {\n                        key: Keyboard.keys.TAB,\n                        handler: function handler(range) {\n                            this.quill.history.cutoff();\n                            var delta = new _quillDelta2.default().retain(range.index).delete(range.length).insert(\"\t\");\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                            this.quill.history.cutoff();\n                            this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n                        }\n                    },\n                    \"list empty enter\": {\n                        key: Keyboard.keys.ENTER,\n                        collapsed: true,\n                        format: [\n                            \"list\"\n                        ],\n                        empty: true,\n                        handler: function handler(range, context) {\n                            this.quill.format(\"list\", false, _quill2.default.sources.USER);\n                            if (context.format.indent) {\n                                this.quill.format(\"indent\", false, _quill2.default.sources.USER);\n                            }\n                        }\n                    },\n                    \"checklist enter\": {\n                        key: Keyboard.keys.ENTER,\n                        collapsed: true,\n                        format: {\n                            list: \"checked\"\n                        },\n                        handler: function handler(range) {\n                            var _quill$getLine3 = this.quill.getLine(range.index), _quill$getLine4 = _slicedToArray(_quill$getLine3, 2), line = _quill$getLine4[0], offset = _quill$getLine4[1];\n                            var formats = (0, _extend2.default)({}, line.formats(), {\n                                list: \"checked\"\n                            });\n                            var delta = new _quillDelta2.default().retain(range.index).insert(\"\\n\", formats).retain(line.length() - offset - 1).retain(1, {\n                                list: \"unchecked\"\n                            });\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                            this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n                            this.quill.scrollIntoView();\n                        }\n                    },\n                    \"header enter\": {\n                        key: Keyboard.keys.ENTER,\n                        collapsed: true,\n                        format: [\n                            \"header\"\n                        ],\n                        suffix: /^$/,\n                        handler: function handler(range, context) {\n                            var _quill$getLine5 = this.quill.getLine(range.index), _quill$getLine6 = _slicedToArray(_quill$getLine5, 2), line = _quill$getLine6[0], offset = _quill$getLine6[1];\n                            var delta = new _quillDelta2.default().retain(range.index).insert(\"\\n\", context.format).retain(line.length() - offset - 1).retain(1, {\n                                header: null\n                            });\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                            this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n                            this.quill.scrollIntoView();\n                        }\n                    },\n                    \"list autofill\": {\n                        key: \" \",\n                        collapsed: true,\n                        format: {\n                            list: false\n                        },\n                        prefix: /^\\s*?(\\d+\\.|-|\\*|\\[ ?\\]|\\[x\\])$/,\n                        handler: function handler(range, context) {\n                            var length = context.prefix.length;\n                            var _quill$getLine7 = this.quill.getLine(range.index), _quill$getLine8 = _slicedToArray(_quill$getLine7, 2), line = _quill$getLine8[0], offset = _quill$getLine8[1];\n                            if (offset > length) return true;\n                            var value = void 0;\n                            switch(context.prefix.trim()){\n                                case \"[]\":\n                                case \"[ ]\":\n                                    value = \"unchecked\";\n                                    break;\n                                case \"[x]\":\n                                    value = \"checked\";\n                                    break;\n                                case \"-\":\n                                case \"*\":\n                                    value = \"bullet\";\n                                    break;\n                                default:\n                                    value = \"ordered\";\n                            }\n                            this.quill.insertText(range.index, \" \", _quill2.default.sources.USER);\n                            this.quill.history.cutoff();\n                            var delta = new _quillDelta2.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, {\n                                list: value\n                            });\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                            this.quill.history.cutoff();\n                            this.quill.setSelection(range.index - length, _quill2.default.sources.SILENT);\n                        }\n                    },\n                    \"code exit\": {\n                        key: Keyboard.keys.ENTER,\n                        collapsed: true,\n                        format: [\n                            \"code-block\"\n                        ],\n                        prefix: /\\n\\n$/,\n                        suffix: /^\\s+$/,\n                        handler: function handler(range) {\n                            var _quill$getLine9 = this.quill.getLine(range.index), _quill$getLine10 = _slicedToArray(_quill$getLine9, 2), line = _quill$getLine10[0], offset = _quill$getLine10[1];\n                            var delta = new _quillDelta2.default().retain(range.index + line.length() - offset - 2).retain(1, {\n                                \"code-block\": null\n                            }).delete(1);\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                        }\n                    },\n                    \"embed left\": makeEmbedArrowHandler(Keyboard.keys.LEFT, false),\n                    \"embed left shift\": makeEmbedArrowHandler(Keyboard.keys.LEFT, true),\n                    \"embed right\": makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),\n                    \"embed right shift\": makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)\n                }\n            };\n            function makeEmbedArrowHandler(key, shiftKey) {\n                var _ref3;\n                var where = key === Keyboard.keys.LEFT ? \"prefix\" : \"suffix\";\n                return _ref3 = {\n                    key: key,\n                    shiftKey: shiftKey,\n                    altKey: null\n                }, _defineProperty(_ref3, where, /^$/), _defineProperty(_ref3, \"handler\", function handler(range) {\n                    var index = range.index;\n                    if (key === Keyboard.keys.RIGHT) {\n                        index += range.length + 1;\n                    }\n                    var _quill$getLeaf3 = this.quill.getLeaf(index), _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1), leaf = _quill$getLeaf4[0];\n                    if (!(leaf instanceof _parchment2.default.Embed)) return true;\n                    if (key === Keyboard.keys.LEFT) {\n                        if (shiftKey) {\n                            this.quill.setSelection(range.index - 1, range.length + 1, _quill2.default.sources.USER);\n                        } else {\n                            this.quill.setSelection(range.index - 1, _quill2.default.sources.USER);\n                        }\n                    } else {\n                        if (shiftKey) {\n                            this.quill.setSelection(range.index, range.length + 1, _quill2.default.sources.USER);\n                        } else {\n                            this.quill.setSelection(range.index + range.length + 1, _quill2.default.sources.USER);\n                        }\n                    }\n                    return false;\n                }), _ref3;\n            }\n            function handleBackspace(range, context) {\n                if (range.index === 0 || this.quill.getLength() <= 1) return;\n                var _quill$getLine11 = this.quill.getLine(range.index), _quill$getLine12 = _slicedToArray(_quill$getLine11, 1), line = _quill$getLine12[0];\n                var formats = {};\n                if (context.offset === 0) {\n                    var _quill$getLine13 = this.quill.getLine(range.index - 1), _quill$getLine14 = _slicedToArray(_quill$getLine13, 1), prev = _quill$getLine14[0];\n                    if (prev != null && prev.length() > 1) {\n                        var curFormats = line.formats();\n                        var prevFormats = this.quill.getFormat(range.index - 1, 1);\n                        formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};\n                    }\n                }\n                // Check for astral symbols\n                var length = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]$/.test(context.prefix) ? 2 : 1;\n                this.quill.deleteText(range.index - length, length, _quill2.default.sources.USER);\n                if (Object.keys(formats).length > 0) {\n                    this.quill.formatLine(range.index - length, length, formats, _quill2.default.sources.USER);\n                }\n                this.quill.focus();\n            }\n            function handleDelete(range, context) {\n                // Check for astral symbols\n                var length = /^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/.test(context.suffix) ? 2 : 1;\n                if (range.index >= this.quill.getLength() - length) return;\n                var formats = {}, nextLength = 0;\n                var _quill$getLine15 = this.quill.getLine(range.index), _quill$getLine16 = _slicedToArray(_quill$getLine15, 1), line = _quill$getLine16[0];\n                if (context.offset >= line.length() - 1) {\n                    var _quill$getLine17 = this.quill.getLine(range.index + 1), _quill$getLine18 = _slicedToArray(_quill$getLine17, 1), next = _quill$getLine18[0];\n                    if (next) {\n                        var curFormats = line.formats();\n                        var nextFormats = this.quill.getFormat(range.index, 1);\n                        formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};\n                        nextLength = next.length();\n                    }\n                }\n                this.quill.deleteText(range.index, length, _quill2.default.sources.USER);\n                if (Object.keys(formats).length > 0) {\n                    this.quill.formatLine(range.index + nextLength - 1, length, formats, _quill2.default.sources.USER);\n                }\n            }\n            function handleDeleteRange(range) {\n                var lines = this.quill.getLines(range);\n                var formats = {};\n                if (lines.length > 1) {\n                    var firstFormats = lines[0].formats();\n                    var lastFormats = lines[lines.length - 1].formats();\n                    formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};\n                }\n                this.quill.deleteText(range, _quill2.default.sources.USER);\n                if (Object.keys(formats).length > 0) {\n                    this.quill.formatLine(range.index, 1, formats, _quill2.default.sources.USER);\n                }\n                this.quill.setSelection(range.index, _quill2.default.sources.SILENT);\n                this.quill.focus();\n            }\n            function handleEnter(range, context) {\n                var _this3 = this;\n                if (range.length > 0) {\n                    this.quill.scroll.deleteAt(range.index, range.length); // So we do not trigger text-change\n                }\n                var lineFormats = Object.keys(context.format).reduce(function(lineFormats, format) {\n                    if (_parchment2.default.query(format, _parchment2.default.Scope.BLOCK) && !Array.isArray(context.format[format])) {\n                        lineFormats[format] = context.format[format];\n                    }\n                    return lineFormats;\n                }, {});\n                this.quill.insertText(range.index, \"\\n\", lineFormats, _quill2.default.sources.USER);\n                // Earlier scroll.deleteAt might have messed up our selection,\n                // so insertText's built in selection preservation is not reliable\n                this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n                this.quill.focus();\n                Object.keys(context.format).forEach(function(name) {\n                    if (lineFormats[name] != null) return;\n                    if (Array.isArray(context.format[name])) return;\n                    if (name === \"link\") return;\n                    _this3.quill.format(name, context.format[name], _quill2.default.sources.USER);\n                });\n            }\n            function makeCodeBlockHandler(indent) {\n                return {\n                    key: Keyboard.keys.TAB,\n                    shiftKey: !indent,\n                    format: {\n                        \"code-block\": true\n                    },\n                    handler: function handler(range) {\n                        var CodeBlock = _parchment2.default.query(\"code-block\");\n                        var index = range.index, length = range.length;\n                        var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index), _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2), block = _quill$scroll$descend2[0], offset = _quill$scroll$descend2[1];\n                        if (block == null) return;\n                        var scrollIndex = this.quill.getIndex(block);\n                        var start = block.newlineIndex(offset, true) + 1;\n                        var end = block.newlineIndex(scrollIndex + offset + length);\n                        var lines = block.domNode.textContent.slice(start, end).split(\"\\n\");\n                        offset = 0;\n                        lines.forEach(function(line, i) {\n                            if (indent) {\n                                block.insertAt(start + offset, CodeBlock.TAB);\n                                offset += CodeBlock.TAB.length;\n                                if (i === 0) {\n                                    index += CodeBlock.TAB.length;\n                                } else {\n                                    length += CodeBlock.TAB.length;\n                                }\n                            } else if (line.startsWith(CodeBlock.TAB)) {\n                                block.deleteAt(start + offset, CodeBlock.TAB.length);\n                                offset -= CodeBlock.TAB.length;\n                                if (i === 0) {\n                                    index -= CodeBlock.TAB.length;\n                                } else {\n                                    length -= CodeBlock.TAB.length;\n                                }\n                            }\n                            offset += line.length + 1;\n                        });\n                        this.quill.update(_quill2.default.sources.USER);\n                        this.quill.setSelection(index, length, _quill2.default.sources.SILENT);\n                    }\n                };\n            }\n            function makeFormatHandler(format) {\n                return {\n                    key: format[0].toUpperCase(),\n                    shortKey: true,\n                    handler: function handler(range, context) {\n                        this.quill.format(format, !context.format[format], _quill2.default.sources.USER);\n                    }\n                };\n            }\n            function normalize(binding) {\n                if (typeof binding === \"string\" || typeof binding === \"number\") {\n                    return normalize({\n                        key: binding\n                    });\n                }\n                if ((typeof binding === \"undefined\" ? \"undefined\" : _typeof(binding)) === \"object\") {\n                    binding = (0, _clone2.default)(binding, false);\n                }\n                if (typeof binding.key === \"string\") {\n                    if (Keyboard.keys[binding.key.toUpperCase()] != null) {\n                        binding.key = Keyboard.keys[binding.key.toUpperCase()];\n                    } else if (binding.key.length === 1) {\n                        binding.key = binding.key.toUpperCase().charCodeAt(0);\n                    } else {\n                        return null;\n                    }\n                }\n                if (binding.shortKey) {\n                    binding[SHORTKEY] = binding.shortKey;\n                    delete binding.shortKey;\n                }\n                return binding;\n            }\n            exports1.default = Keyboard;\n            exports1.SHORTKEY = SHORTKEY;\n        /***/ },\n        /* 24 */ /***/ function(module1, exports1, __nested_webpack_require_275926__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _parchment = __nested_webpack_require_275926__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _text = __nested_webpack_require_275926__(7);\n            var _text2 = _interopRequireDefault(_text);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Cursor = function(_Parchment$Embed) {\n                _inherits(Cursor, _Parchment$Embed);\n                _createClass(Cursor, null, [\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return undefined;\n                        }\n                    }\n                ]);\n                function Cursor(domNode, selection) {\n                    _classCallCheck(this, Cursor);\n                    var _this = _possibleConstructorReturn(this, (Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call(this, domNode));\n                    _this.selection = selection;\n                    _this.textNode = document.createTextNode(Cursor.CONTENTS);\n                    _this.domNode.appendChild(_this.textNode);\n                    _this._length = 0;\n                    return _this;\n                }\n                _createClass(Cursor, [\n                    {\n                        key: \"detach\",\n                        value: function detach() {\n                            // super.detach() will also clear domNode.__blot\n                            if (this.parent != null) this.parent.removeChild(this);\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (this._length !== 0) {\n                                return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), \"format\", this).call(this, name, value);\n                            }\n                            var target = this, index = 0;\n                            while(target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT){\n                                index += target.offset(target.parent);\n                                target = target.parent;\n                            }\n                            if (target != null) {\n                                this._length = Cursor.CONTENTS.length;\n                                target.optimize();\n                                target.formatAt(index, Cursor.CONTENTS.length, name, value);\n                                this._length = 0;\n                            }\n                        }\n                    },\n                    {\n                        key: \"index\",\n                        value: function index(node, offset) {\n                            if (node === this.textNode) return 0;\n                            return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), \"index\", this).call(this, node, offset);\n                        }\n                    },\n                    {\n                        key: \"length\",\n                        value: function length() {\n                            return this._length;\n                        }\n                    },\n                    {\n                        key: \"position\",\n                        value: function position() {\n                            return [\n                                this.textNode,\n                                this.textNode.data.length\n                            ];\n                        }\n                    },\n                    {\n                        key: \"remove\",\n                        value: function remove() {\n                            _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), \"remove\", this).call(this);\n                            this.parent = null;\n                        }\n                    },\n                    {\n                        key: \"restore\",\n                        value: function restore() {\n                            if (this.selection.composing || this.parent == null) return;\n                            var textNode = this.textNode;\n                            var range = this.selection.getNativeRange();\n                            var restoreText = void 0, start = void 0, end = void 0;\n                            if (range != null && range.start.node === textNode && range.end.node === textNode) {\n                                var _ref = [\n                                    textNode,\n                                    range.start.offset,\n                                    range.end.offset\n                                ];\n                                restoreText = _ref[0];\n                                start = _ref[1];\n                                end = _ref[2];\n                            }\n                            // Link format will insert text outside of anchor tag\n                            while(this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode){\n                                this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);\n                            }\n                            if (this.textNode.data !== Cursor.CONTENTS) {\n                                var text = this.textNode.data.split(Cursor.CONTENTS).join(\"\");\n                                if (this.next instanceof _text2.default) {\n                                    restoreText = this.next.domNode;\n                                    this.next.insertAt(0, text);\n                                    this.textNode.data = Cursor.CONTENTS;\n                                } else {\n                                    this.textNode.data = text;\n                                    this.parent.insertBefore(_parchment2.default.create(this.textNode), this);\n                                    this.textNode = document.createTextNode(Cursor.CONTENTS);\n                                    this.domNode.appendChild(this.textNode);\n                                }\n                            }\n                            this.remove();\n                            if (start != null) {\n                                var _map = [\n                                    start,\n                                    end\n                                ].map(function(offset) {\n                                    return Math.max(0, Math.min(restoreText.data.length, offset - 1));\n                                });\n                                var _map2 = _slicedToArray(_map, 2);\n                                start = _map2[0];\n                                end = _map2[1];\n                                return {\n                                    startNode: restoreText,\n                                    startOffset: start,\n                                    endNode: restoreText,\n                                    endOffset: end\n                                };\n                            }\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(mutations, context) {\n                            var _this2 = this;\n                            if (mutations.some(function(mutation) {\n                                return mutation.type === \"characterData\" && mutation.target === _this2.textNode;\n                            })) {\n                                var range = this.restore();\n                                if (range) context.range = range;\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return \"\";\n                        }\n                    }\n                ]);\n                return Cursor;\n            }(_parchment2.default.Embed);\n            Cursor.blotName = \"cursor\";\n            Cursor.className = \"ql-cursor\";\n            Cursor.tagName = \"span\";\n            Cursor.CONTENTS = \"\\uFEFF\"; // Zero width no break space\n            exports1.default = Cursor;\n        /***/ },\n        /* 25 */ /***/ function(module1, exports1, __nested_webpack_require_288843__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _parchment = __nested_webpack_require_288843__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _block = __nested_webpack_require_288843__(4);\n            var _block2 = _interopRequireDefault(_block);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Container = function(_Parchment$Container) {\n                _inherits(Container, _Parchment$Container);\n                function Container() {\n                    _classCallCheck(this, Container);\n                    return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));\n                }\n                return Container;\n            }(_parchment2.default.Container);\n            Container.allowedChildren = [\n                _block2.default,\n                _block.BlockEmbed,\n                Container\n            ];\n            exports1.default = Container;\n        /***/ },\n        /* 26 */ /***/ function(module1, exports1, __nested_webpack_require_291431__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.ColorStyle = exports1.ColorClass = exports1.ColorAttributor = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_291431__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ColorAttributor = function(_Parchment$Attributor) {\n                _inherits(ColorAttributor, _Parchment$Attributor);\n                function ColorAttributor() {\n                    _classCallCheck(this, ColorAttributor);\n                    return _possibleConstructorReturn(this, (ColorAttributor.__proto__ || Object.getPrototypeOf(ColorAttributor)).apply(this, arguments));\n                }\n                _createClass(ColorAttributor, [\n                    {\n                        key: \"value\",\n                        value: function value(domNode) {\n                            var value = _get(ColorAttributor.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor.prototype), \"value\", this).call(this, domNode);\n                            if (!value.startsWith(\"rgb(\")) return value;\n                            value = value.replace(/^[^\\d]+/, \"\").replace(/[^\\d]+$/, \"\");\n                            return \"#\" + value.split(\",\").map(function(component) {\n                                return (\"00\" + parseInt(component).toString(16)).slice(-2);\n                            }).join(\"\");\n                        }\n                    }\n                ]);\n                return ColorAttributor;\n            }(_parchment2.default.Attributor.Style);\n            var ColorClass = new _parchment2.default.Attributor.Class(\"color\", \"ql-color\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            var ColorStyle = new ColorAttributor(\"color\", \"color\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            exports1.ColorAttributor = ColorAttributor;\n            exports1.ColorClass = ColorClass;\n            exports1.ColorStyle = ColorStyle;\n        /***/ },\n        /* 27 */ /***/ function(module1, exports1, __nested_webpack_require_296833__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.sanitize = exports1.default = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _inline = __nested_webpack_require_296833__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Link = function(_Inline) {\n                _inherits(Link, _Inline);\n                function Link() {\n                    _classCallCheck(this, Link);\n                    return _possibleConstructorReturn(this, (Link.__proto__ || Object.getPrototypeOf(Link)).apply(this, arguments));\n                }\n                _createClass(Link, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (name !== this.statics.blotName || !value) return _get(Link.prototype.__proto__ || Object.getPrototypeOf(Link.prototype), \"format\", this).call(this, name, value);\n                            value = this.constructor.sanitize(value);\n                            this.domNode.setAttribute(\"href\", value);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var node = _get(Link.__proto__ || Object.getPrototypeOf(Link), \"create\", this).call(this, value);\n                            value = this.sanitize(value);\n                            node.setAttribute(\"href\", value);\n                            node.setAttribute(\"rel\", \"noopener noreferrer\");\n                            node.setAttribute(\"target\", \"_blank\");\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return domNode.getAttribute(\"href\");\n                        }\n                    },\n                    {\n                        key: \"sanitize\",\n                        value: function sanitize(url) {\n                            return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;\n                        }\n                    }\n                ]);\n                return Link;\n            }(_inline2.default);\n            Link.blotName = \"link\";\n            Link.tagName = \"A\";\n            Link.SANITIZED_URL = \"about:blank\";\n            Link.PROTOCOL_WHITELIST = [\n                \"http\",\n                \"https\",\n                \"mailto\",\n                \"tel\"\n            ];\n            function _sanitize(url, protocols) {\n                var anchor = document.createElement(\"a\");\n                anchor.href = url;\n                var protocol = anchor.href.slice(0, anchor.href.indexOf(\":\"));\n                return protocols.indexOf(protocol) > -1;\n            }\n            exports1.default = Link;\n            exports1.sanitize = _sanitize;\n        /***/ },\n        /* 28 */ /***/ function(module1, exports1, __nested_webpack_require_303158__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _keyboard = __nested_webpack_require_303158__(23);\n            var _keyboard2 = _interopRequireDefault(_keyboard);\n            var _dropdown = __nested_webpack_require_303158__(107);\n            var _dropdown2 = _interopRequireDefault(_dropdown);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var optionsCounter = 0;\n            function toggleAriaAttribute(element, attribute) {\n                element.setAttribute(attribute, !(element.getAttribute(attribute) === \"true\"));\n            }\n            var Picker = function() {\n                function Picker(select) {\n                    var _this = this;\n                    _classCallCheck(this, Picker);\n                    this.select = select;\n                    this.container = document.createElement(\"span\");\n                    this.buildPicker();\n                    this.select.style.display = \"none\";\n                    this.select.parentNode.insertBefore(this.container, this.select);\n                    this.label.addEventListener(\"mousedown\", function() {\n                        _this.togglePicker();\n                    });\n                    this.label.addEventListener(\"keydown\", function(event) {\n                        switch(event.keyCode){\n                            // Allows the \"Enter\" key to open the picker\n                            case _keyboard2.default.keys.ENTER:\n                                _this.togglePicker();\n                                break;\n                            // Allows the \"Escape\" key to close the picker\n                            case _keyboard2.default.keys.ESCAPE:\n                                _this.escape();\n                                event.preventDefault();\n                                break;\n                            default:\n                        }\n                    });\n                    this.select.addEventListener(\"change\", this.update.bind(this));\n                }\n                _createClass(Picker, [\n                    {\n                        key: \"togglePicker\",\n                        value: function togglePicker() {\n                            this.container.classList.toggle(\"ql-expanded\");\n                            // Toggle aria-expanded and aria-hidden to make the picker accessible\n                            toggleAriaAttribute(this.label, \"aria-expanded\");\n                            toggleAriaAttribute(this.options, \"aria-hidden\");\n                        }\n                    },\n                    {\n                        key: \"buildItem\",\n                        value: function buildItem(option) {\n                            var _this2 = this;\n                            var item = document.createElement(\"span\");\n                            item.tabIndex = \"0\";\n                            item.setAttribute(\"role\", \"button\");\n                            item.classList.add(\"ql-picker-item\");\n                            if (option.hasAttribute(\"value\")) {\n                                item.setAttribute(\"data-value\", option.getAttribute(\"value\"));\n                            }\n                            if (option.textContent) {\n                                item.setAttribute(\"data-label\", option.textContent);\n                            }\n                            item.addEventListener(\"click\", function() {\n                                _this2.selectItem(item, true);\n                            });\n                            item.addEventListener(\"keydown\", function(event) {\n                                switch(event.keyCode){\n                                    // Allows the \"Enter\" key to select an item\n                                    case _keyboard2.default.keys.ENTER:\n                                        _this2.selectItem(item, true);\n                                        event.preventDefault();\n                                        break;\n                                    // Allows the \"Escape\" key to close the picker\n                                    case _keyboard2.default.keys.ESCAPE:\n                                        _this2.escape();\n                                        event.preventDefault();\n                                        break;\n                                    default:\n                                }\n                            });\n                            return item;\n                        }\n                    },\n                    {\n                        key: \"buildLabel\",\n                        value: function buildLabel() {\n                            var label = document.createElement(\"span\");\n                            label.classList.add(\"ql-picker-label\");\n                            label.innerHTML = _dropdown2.default;\n                            label.tabIndex = \"0\";\n                            label.setAttribute(\"role\", \"button\");\n                            label.setAttribute(\"aria-expanded\", \"false\");\n                            this.container.appendChild(label);\n                            return label;\n                        }\n                    },\n                    {\n                        key: \"buildOptions\",\n                        value: function buildOptions() {\n                            var _this3 = this;\n                            var options = document.createElement(\"span\");\n                            options.classList.add(\"ql-picker-options\");\n                            // Don't want screen readers to read this until options are visible\n                            options.setAttribute(\"aria-hidden\", \"true\");\n                            options.tabIndex = \"-1\";\n                            // Need a unique id for aria-controls\n                            options.id = \"ql-picker-options-\" + optionsCounter;\n                            optionsCounter += 1;\n                            this.label.setAttribute(\"aria-controls\", options.id);\n                            this.options = options;\n                            [].slice.call(this.select.options).forEach(function(option) {\n                                var item = _this3.buildItem(option);\n                                options.appendChild(item);\n                                if (option.selected === true) {\n                                    _this3.selectItem(item);\n                                }\n                            });\n                            this.container.appendChild(options);\n                        }\n                    },\n                    {\n                        key: \"buildPicker\",\n                        value: function buildPicker() {\n                            var _this4 = this;\n                            [].slice.call(this.select.attributes).forEach(function(item) {\n                                _this4.container.setAttribute(item.name, item.value);\n                            });\n                            this.container.classList.add(\"ql-picker\");\n                            this.label = this.buildLabel();\n                            this.buildOptions();\n                        }\n                    },\n                    {\n                        key: \"escape\",\n                        value: function escape() {\n                            var _this5 = this;\n                            // Close menu and return focus to trigger label\n                            this.close();\n                            // Need setTimeout for accessibility to ensure that the browser executes\n                            // focus on the next process thread and after any DOM content changes\n                            setTimeout(function() {\n                                return _this5.label.focus();\n                            }, 1);\n                        }\n                    },\n                    {\n                        key: \"close\",\n                        value: function close() {\n                            this.container.classList.remove(\"ql-expanded\");\n                            this.label.setAttribute(\"aria-expanded\", \"false\");\n                            this.options.setAttribute(\"aria-hidden\", \"true\");\n                        }\n                    },\n                    {\n                        key: \"selectItem\",\n                        value: function selectItem(item) {\n                            var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                            var selected = this.container.querySelector(\".ql-selected\");\n                            if (item === selected) return;\n                            if (selected != null) {\n                                selected.classList.remove(\"ql-selected\");\n                            }\n                            if (item == null) return;\n                            item.classList.add(\"ql-selected\");\n                            this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);\n                            if (item.hasAttribute(\"data-value\")) {\n                                this.label.setAttribute(\"data-value\", item.getAttribute(\"data-value\"));\n                            } else {\n                                this.label.removeAttribute(\"data-value\");\n                            }\n                            if (item.hasAttribute(\"data-label\")) {\n                                this.label.setAttribute(\"data-label\", item.getAttribute(\"data-label\"));\n                            } else {\n                                this.label.removeAttribute(\"data-label\");\n                            }\n                            if (trigger) {\n                                if (typeof Event === \"function\") {\n                                    this.select.dispatchEvent(new Event(\"change\"));\n                                } else if ((typeof Event === \"undefined\" ? \"undefined\" : _typeof(Event)) === \"object\") {\n                                    // IE11\n                                    var event = document.createEvent(\"Event\");\n                                    event.initEvent(\"change\", true, true);\n                                    this.select.dispatchEvent(event);\n                                }\n                                this.close();\n                            }\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update() {\n                            var option = void 0;\n                            if (this.select.selectedIndex > -1) {\n                                var item = this.container.querySelector(\".ql-picker-options\").children[this.select.selectedIndex];\n                                option = this.select.options[this.select.selectedIndex];\n                                this.selectItem(item);\n                            } else {\n                                this.selectItem(null);\n                            }\n                            var isActive = option != null && option !== this.select.querySelector(\"option[selected]\");\n                            this.label.classList.toggle(\"ql-active\", isActive);\n                        }\n                    }\n                ]);\n                return Picker;\n            }();\n            exports1.default = Picker;\n        /***/ },\n        /* 29 */ /***/ function(module1, exports1, __nested_webpack_require_316188__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _parchment = __nested_webpack_require_316188__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_316188__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _block = __nested_webpack_require_316188__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _break = __nested_webpack_require_316188__(16);\n            var _break2 = _interopRequireDefault(_break);\n            var _container = __nested_webpack_require_316188__(25);\n            var _container2 = _interopRequireDefault(_container);\n            var _cursor = __nested_webpack_require_316188__(24);\n            var _cursor2 = _interopRequireDefault(_cursor);\n            var _embed = __nested_webpack_require_316188__(35);\n            var _embed2 = _interopRequireDefault(_embed);\n            var _inline = __nested_webpack_require_316188__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            var _scroll = __nested_webpack_require_316188__(22);\n            var _scroll2 = _interopRequireDefault(_scroll);\n            var _text = __nested_webpack_require_316188__(7);\n            var _text2 = _interopRequireDefault(_text);\n            var _clipboard = __nested_webpack_require_316188__(55);\n            var _clipboard2 = _interopRequireDefault(_clipboard);\n            var _history = __nested_webpack_require_316188__(42);\n            var _history2 = _interopRequireDefault(_history);\n            var _keyboard = __nested_webpack_require_316188__(23);\n            var _keyboard2 = _interopRequireDefault(_keyboard);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            _quill2.default.register({\n                \"blots/block\": _block2.default,\n                \"blots/block/embed\": _block.BlockEmbed,\n                \"blots/break\": _break2.default,\n                \"blots/container\": _container2.default,\n                \"blots/cursor\": _cursor2.default,\n                \"blots/embed\": _embed2.default,\n                \"blots/inline\": _inline2.default,\n                \"blots/scroll\": _scroll2.default,\n                \"blots/text\": _text2.default,\n                \"modules/clipboard\": _clipboard2.default,\n                \"modules/history\": _history2.default,\n                \"modules/keyboard\": _keyboard2.default\n            });\n            _parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);\n            exports1.default = _quill2.default;\n        /***/ },\n        /* 30 */ /***/ function(module1, exports1, __nested_webpack_require_318905__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var Registry = __nested_webpack_require_318905__(1);\n            var ShadowBlot = /** @class */ function() {\n                function ShadowBlot(domNode) {\n                    this.domNode = domNode;\n                    // @ts-ignore\n                    this.domNode[Registry.DATA_KEY] = {\n                        blot: this\n                    };\n                }\n                Object.defineProperty(ShadowBlot.prototype, \"statics\", {\n                    // Hack for accessing inherited static methods\n                    get: function() {\n                        return this.constructor;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                ShadowBlot.create = function(value) {\n                    if (this.tagName == null) {\n                        throw new Registry.ParchmentError(\"Blot definition missing tagName\");\n                    }\n                    var node;\n                    if (Array.isArray(this.tagName)) {\n                        if (typeof value === \"string\") {\n                            value = value.toUpperCase();\n                            if (parseInt(value).toString() === value) {\n                                value = parseInt(value);\n                            }\n                        }\n                        if (typeof value === \"number\") {\n                            node = document.createElement(this.tagName[value - 1]);\n                        } else if (this.tagName.indexOf(value) > -1) {\n                            node = document.createElement(value);\n                        } else {\n                            node = document.createElement(this.tagName[0]);\n                        }\n                    } else {\n                        node = document.createElement(this.tagName);\n                    }\n                    if (this.className) {\n                        node.classList.add(this.className);\n                    }\n                    return node;\n                };\n                ShadowBlot.prototype.attach = function() {\n                    if (this.parent != null) {\n                        this.scroll = this.parent.scroll;\n                    }\n                };\n                ShadowBlot.prototype.clone = function() {\n                    var domNode = this.domNode.cloneNode(false);\n                    return Registry.create(domNode);\n                };\n                ShadowBlot.prototype.detach = function() {\n                    if (this.parent != null) this.parent.removeChild(this);\n                    // @ts-ignore\n                    delete this.domNode[Registry.DATA_KEY];\n                };\n                ShadowBlot.prototype.deleteAt = function(index, length) {\n                    var blot = this.isolate(index, length);\n                    blot.remove();\n                };\n                ShadowBlot.prototype.formatAt = function(index, length, name, value) {\n                    var blot = this.isolate(index, length);\n                    if (Registry.query(name, Registry.Scope.BLOT) != null && value) {\n                        blot.wrap(name, value);\n                    } else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {\n                        var parent = Registry.create(this.statics.scope);\n                        blot.wrap(parent);\n                        parent.format(name, value);\n                    }\n                };\n                ShadowBlot.prototype.insertAt = function(index, value, def) {\n                    var blot = def == null ? Registry.create(\"text\", value) : Registry.create(value, def);\n                    var ref = this.split(index);\n                    this.parent.insertBefore(blot, ref);\n                };\n                ShadowBlot.prototype.insertInto = function(parentBlot, refBlot) {\n                    if (refBlot === void 0) {\n                        refBlot = null;\n                    }\n                    if (this.parent != null) {\n                        this.parent.children.remove(this);\n                    }\n                    var refDomNode = null;\n                    parentBlot.children.insertBefore(this, refBlot);\n                    if (refBlot != null) {\n                        refDomNode = refBlot.domNode;\n                    }\n                    if (this.domNode.parentNode != parentBlot.domNode || this.domNode.nextSibling != refDomNode) {\n                        parentBlot.domNode.insertBefore(this.domNode, refDomNode);\n                    }\n                    this.parent = parentBlot;\n                    this.attach();\n                };\n                ShadowBlot.prototype.isolate = function(index, length) {\n                    var target = this.split(index);\n                    target.split(length);\n                    return target;\n                };\n                ShadowBlot.prototype.length = function() {\n                    return 1;\n                };\n                ShadowBlot.prototype.offset = function(root) {\n                    if (root === void 0) {\n                        root = this.parent;\n                    }\n                    if (this.parent == null || this == root) return 0;\n                    return this.parent.children.offset(this) + this.parent.offset(root);\n                };\n                ShadowBlot.prototype.optimize = function(context) {\n                    // TODO clean up once we use WeakMap\n                    // @ts-ignore\n                    if (this.domNode[Registry.DATA_KEY] != null) {\n                        // @ts-ignore\n                        delete this.domNode[Registry.DATA_KEY].mutations;\n                    }\n                };\n                ShadowBlot.prototype.remove = function() {\n                    if (this.domNode.parentNode != null) {\n                        this.domNode.parentNode.removeChild(this.domNode);\n                    }\n                    this.detach();\n                };\n                ShadowBlot.prototype.replace = function(target) {\n                    if (target.parent == null) return;\n                    target.parent.insertBefore(this, target.next);\n                    target.remove();\n                };\n                ShadowBlot.prototype.replaceWith = function(name, value) {\n                    var replacement = typeof name === \"string\" ? Registry.create(name, value) : name;\n                    replacement.replace(this);\n                    return replacement;\n                };\n                ShadowBlot.prototype.split = function(index, force) {\n                    return index === 0 ? this : this.next;\n                };\n                ShadowBlot.prototype.update = function(mutations, context) {\n                // Nothing to do by default\n                };\n                ShadowBlot.prototype.wrap = function(name, value) {\n                    var wrapper = typeof name === \"string\" ? Registry.create(name, value) : name;\n                    if (this.parent != null) {\n                        this.parent.insertBefore(wrapper, this.next);\n                    }\n                    wrapper.appendChild(this);\n                    return wrapper;\n                };\n                ShadowBlot.blotName = \"abstract\";\n                return ShadowBlot;\n            }();\n            exports1.default = ShadowBlot;\n        /***/ },\n        /* 31 */ /***/ function(module1, exports1, __nested_webpack_require_326438__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var attributor_1 = __nested_webpack_require_326438__(12);\n            var class_1 = __nested_webpack_require_326438__(32);\n            var style_1 = __nested_webpack_require_326438__(33);\n            var Registry = __nested_webpack_require_326438__(1);\n            var AttributorStore = /** @class */ function() {\n                function AttributorStore(domNode) {\n                    this.attributes = {};\n                    this.domNode = domNode;\n                    this.build();\n                }\n                AttributorStore.prototype.attribute = function(attribute, value) {\n                    // verb\n                    if (value) {\n                        if (attribute.add(this.domNode, value)) {\n                            if (attribute.value(this.domNode) != null) {\n                                this.attributes[attribute.attrName] = attribute;\n                            } else {\n                                delete this.attributes[attribute.attrName];\n                            }\n                        }\n                    } else {\n                        attribute.remove(this.domNode);\n                        delete this.attributes[attribute.attrName];\n                    }\n                };\n                AttributorStore.prototype.build = function() {\n                    var _this = this;\n                    this.attributes = {};\n                    var attributes = attributor_1.default.keys(this.domNode);\n                    var classes = class_1.default.keys(this.domNode);\n                    var styles = style_1.default.keys(this.domNode);\n                    attributes.concat(classes).concat(styles).forEach(function(name) {\n                        var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);\n                        if (attr instanceof attributor_1.default) {\n                            _this.attributes[attr.attrName] = attr;\n                        }\n                    });\n                };\n                AttributorStore.prototype.copy = function(target) {\n                    var _this = this;\n                    Object.keys(this.attributes).forEach(function(key) {\n                        var value = _this.attributes[key].value(_this.domNode);\n                        target.format(key, value);\n                    });\n                };\n                AttributorStore.prototype.move = function(target) {\n                    var _this = this;\n                    this.copy(target);\n                    Object.keys(this.attributes).forEach(function(key) {\n                        _this.attributes[key].remove(_this.domNode);\n                    });\n                    this.attributes = {};\n                };\n                AttributorStore.prototype.values = function() {\n                    var _this = this;\n                    return Object.keys(this.attributes).reduce(function(attributes, name) {\n                        attributes[name] = _this.attributes[name].value(_this.domNode);\n                        return attributes;\n                    }, {});\n                };\n                return AttributorStore;\n            }();\n            exports1.default = AttributorStore;\n        /***/ },\n        /* 32 */ /***/ function(module1, exports1, __nested_webpack_require_329783__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var attributor_1 = __nested_webpack_require_329783__(12);\n            function match(node, prefix) {\n                var className = node.getAttribute(\"class\") || \"\";\n                return className.split(/\\s+/).filter(function(name) {\n                    return name.indexOf(prefix + \"-\") === 0;\n                });\n            }\n            var ClassAttributor = /** @class */ function(_super) {\n                __extends(ClassAttributor, _super);\n                function ClassAttributor() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                ClassAttributor.keys = function(node) {\n                    return (node.getAttribute(\"class\") || \"\").split(/\\s+/).map(function(name) {\n                        return name.split(\"-\").slice(0, -1).join(\"-\");\n                    });\n                };\n                ClassAttributor.prototype.add = function(node, value) {\n                    if (!this.canAdd(node, value)) return false;\n                    this.remove(node);\n                    node.classList.add(this.keyName + \"-\" + value);\n                    return true;\n                };\n                ClassAttributor.prototype.remove = function(node) {\n                    var matches = match(node, this.keyName);\n                    matches.forEach(function(name) {\n                        node.classList.remove(name);\n                    });\n                    if (node.classList.length === 0) {\n                        node.removeAttribute(\"class\");\n                    }\n                };\n                ClassAttributor.prototype.value = function(node) {\n                    var result = match(node, this.keyName)[0] || \"\";\n                    var value = result.slice(this.keyName.length + 1); // +1 for hyphen\n                    return this.canAdd(node, value) ? value : \"\";\n                };\n                return ClassAttributor;\n            }(attributor_1.default);\n            exports1.default = ClassAttributor;\n        /***/ },\n        /* 33 */ /***/ function(module1, exports1, __nested_webpack_require_332722__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var attributor_1 = __nested_webpack_require_332722__(12);\n            function camelize(name) {\n                var parts = name.split(\"-\");\n                var rest = parts.slice(1).map(function(part) {\n                    return part[0].toUpperCase() + part.slice(1);\n                }).join(\"\");\n                return parts[0] + rest;\n            }\n            var StyleAttributor = /** @class */ function(_super) {\n                __extends(StyleAttributor, _super);\n                function StyleAttributor() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                StyleAttributor.keys = function(node) {\n                    return (node.getAttribute(\"style\") || \"\").split(\";\").map(function(value) {\n                        var arr = value.split(\":\");\n                        return arr[0].trim();\n                    });\n                };\n                StyleAttributor.prototype.add = function(node, value) {\n                    if (!this.canAdd(node, value)) return false;\n                    // @ts-ignore\n                    node.style[camelize(this.keyName)] = value;\n                    return true;\n                };\n                StyleAttributor.prototype.remove = function(node) {\n                    // @ts-ignore\n                    node.style[camelize(this.keyName)] = \"\";\n                    if (!node.getAttribute(\"style\")) {\n                        node.removeAttribute(\"style\");\n                    }\n                };\n                StyleAttributor.prototype.value = function(node) {\n                    // @ts-ignore\n                    var value = node.style[camelize(this.keyName)];\n                    return this.canAdd(node, value) ? value : \"\";\n                };\n                return StyleAttributor;\n            }(attributor_1.default);\n            exports1.default = StyleAttributor;\n        /***/ },\n        /* 34 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var Theme = function() {\n                function Theme(quill, options) {\n                    _classCallCheck(this, Theme);\n                    this.quill = quill;\n                    this.options = options;\n                    this.modules = {};\n                }\n                _createClass(Theme, [\n                    {\n                        key: \"init\",\n                        value: function init() {\n                            var _this = this;\n                            Object.keys(this.options.modules).forEach(function(name) {\n                                if (_this.modules[name] == null) {\n                                    _this.addModule(name);\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"addModule\",\n                        value: function addModule(name) {\n                            var moduleClass = this.quill.constructor.import(\"modules/\" + name);\n                            this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});\n                            return this.modules[name];\n                        }\n                    }\n                ]);\n                return Theme;\n            }();\n            Theme.DEFAULTS = {\n                modules: {}\n            };\n            Theme.themes = {\n                \"default\": Theme\n            };\n            exports1.default = Theme;\n        /***/ },\n        /* 35 */ /***/ function(module1, exports1, __nested_webpack_require_338354__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_338354__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _text = __nested_webpack_require_338354__(7);\n            var _text2 = _interopRequireDefault(_text);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var GUARD_TEXT = \"\\uFEFF\";\n            var Embed = function(_Parchment$Embed) {\n                _inherits(Embed, _Parchment$Embed);\n                function Embed(node) {\n                    _classCallCheck(this, Embed);\n                    var _this = _possibleConstructorReturn(this, (Embed.__proto__ || Object.getPrototypeOf(Embed)).call(this, node));\n                    _this.contentNode = document.createElement(\"span\");\n                    _this.contentNode.setAttribute(\"contenteditable\", false);\n                    [].slice.call(_this.domNode.childNodes).forEach(function(childNode) {\n                        _this.contentNode.appendChild(childNode);\n                    });\n                    _this.leftGuard = document.createTextNode(GUARD_TEXT);\n                    _this.rightGuard = document.createTextNode(GUARD_TEXT);\n                    _this.domNode.appendChild(_this.leftGuard);\n                    _this.domNode.appendChild(_this.contentNode);\n                    _this.domNode.appendChild(_this.rightGuard);\n                    return _this;\n                }\n                _createClass(Embed, [\n                    {\n                        key: \"index\",\n                        value: function index(node, offset) {\n                            if (node === this.leftGuard) return 0;\n                            if (node === this.rightGuard) return 1;\n                            return _get(Embed.prototype.__proto__ || Object.getPrototypeOf(Embed.prototype), \"index\", this).call(this, node, offset);\n                        }\n                    },\n                    {\n                        key: \"restore\",\n                        value: function restore(node) {\n                            var range = void 0, textNode = void 0;\n                            var text = node.data.split(GUARD_TEXT).join(\"\");\n                            if (node === this.leftGuard) {\n                                if (this.prev instanceof _text2.default) {\n                                    var prevLength = this.prev.length();\n                                    this.prev.insertAt(prevLength, text);\n                                    range = {\n                                        startNode: this.prev.domNode,\n                                        startOffset: prevLength + text.length\n                                    };\n                                } else {\n                                    textNode = document.createTextNode(text);\n                                    this.parent.insertBefore(_parchment2.default.create(textNode), this);\n                                    range = {\n                                        startNode: textNode,\n                                        startOffset: text.length\n                                    };\n                                }\n                            } else if (node === this.rightGuard) {\n                                if (this.next instanceof _text2.default) {\n                                    this.next.insertAt(0, text);\n                                    range = {\n                                        startNode: this.next.domNode,\n                                        startOffset: text.length\n                                    };\n                                } else {\n                                    textNode = document.createTextNode(text);\n                                    this.parent.insertBefore(_parchment2.default.create(textNode), this.next);\n                                    range = {\n                                        startNode: textNode,\n                                        startOffset: text.length\n                                    };\n                                }\n                            }\n                            node.data = GUARD_TEXT;\n                            return range;\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(mutations, context) {\n                            var _this2 = this;\n                            mutations.forEach(function(mutation) {\n                                if (mutation.type === \"characterData\" && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {\n                                    var range = _this2.restore(mutation.target);\n                                    if (range) context.range = range;\n                                }\n                            });\n                        }\n                    }\n                ]);\n                return Embed;\n            }(_parchment2.default.Embed);\n            exports1.default = Embed;\n        /***/ },\n        /* 36 */ /***/ function(module1, exports1, __nested_webpack_require_346729__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.AlignStyle = exports1.AlignClass = exports1.AlignAttribute = undefined;\n            var _parchment = __nested_webpack_require_346729__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            var config = {\n                scope: _parchment2.default.Scope.BLOCK,\n                whitelist: [\n                    \"right\",\n                    \"center\",\n                    \"justify\"\n                ]\n            };\n            var AlignAttribute = new _parchment2.default.Attributor.Attribute(\"align\", \"align\", config);\n            var AlignClass = new _parchment2.default.Attributor.Class(\"align\", \"ql-align\", config);\n            var AlignStyle = new _parchment2.default.Attributor.Style(\"align\", \"text-align\", config);\n            exports1.AlignAttribute = AlignAttribute;\n            exports1.AlignClass = AlignClass;\n            exports1.AlignStyle = AlignStyle;\n        /***/ },\n        /* 37 */ /***/ function(module1, exports1, __nested_webpack_require_348021__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.BackgroundStyle = exports1.BackgroundClass = undefined;\n            var _parchment = __nested_webpack_require_348021__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _color = __nested_webpack_require_348021__(26);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            var BackgroundClass = new _parchment2.default.Attributor.Class(\"background\", \"ql-bg\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            var BackgroundStyle = new _color.ColorAttributor(\"background\", \"background-color\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            exports1.BackgroundClass = BackgroundClass;\n            exports1.BackgroundStyle = BackgroundStyle;\n        /***/ },\n        /* 38 */ /***/ function(module1, exports1, __nested_webpack_require_349113__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.DirectionStyle = exports1.DirectionClass = exports1.DirectionAttribute = undefined;\n            var _parchment = __nested_webpack_require_349113__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            var config = {\n                scope: _parchment2.default.Scope.BLOCK,\n                whitelist: [\n                    \"rtl\"\n                ]\n            };\n            var DirectionAttribute = new _parchment2.default.Attributor.Attribute(\"direction\", \"dir\", config);\n            var DirectionClass = new _parchment2.default.Attributor.Class(\"direction\", \"ql-direction\", config);\n            var DirectionStyle = new _parchment2.default.Attributor.Style(\"direction\", \"direction\", config);\n            exports1.DirectionAttribute = DirectionAttribute;\n            exports1.DirectionClass = DirectionClass;\n            exports1.DirectionStyle = DirectionStyle;\n        /***/ },\n        /* 39 */ /***/ function(module1, exports1, __nested_webpack_require_350403__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.FontClass = exports1.FontStyle = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_350403__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var config = {\n                scope: _parchment2.default.Scope.INLINE,\n                whitelist: [\n                    \"serif\",\n                    \"monospace\"\n                ]\n            };\n            var FontClass = new _parchment2.default.Attributor.Class(\"font\", \"ql-font\", config);\n            var FontStyleAttributor = function(_Parchment$Attributor) {\n                _inherits(FontStyleAttributor, _Parchment$Attributor);\n                function FontStyleAttributor() {\n                    _classCallCheck(this, FontStyleAttributor);\n                    return _possibleConstructorReturn(this, (FontStyleAttributor.__proto__ || Object.getPrototypeOf(FontStyleAttributor)).apply(this, arguments));\n                }\n                _createClass(FontStyleAttributor, [\n                    {\n                        key: \"value\",\n                        value: function value(node) {\n                            return _get(FontStyleAttributor.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor.prototype), \"value\", this).call(this, node).replace(/[\"']/g, \"\");\n                        }\n                    }\n                ]);\n                return FontStyleAttributor;\n            }(_parchment2.default.Attributor.Style);\n            var FontStyle = new FontStyleAttributor(\"font\", \"font-family\", config);\n            exports1.FontStyle = FontStyle;\n            exports1.FontClass = FontClass;\n        /***/ },\n        /* 40 */ /***/ function(module1, exports1, __nested_webpack_require_355469__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.SizeStyle = exports1.SizeClass = undefined;\n            var _parchment = __nested_webpack_require_355469__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            var SizeClass = new _parchment2.default.Attributor.Class(\"size\", \"ql-size\", {\n                scope: _parchment2.default.Scope.INLINE,\n                whitelist: [\n                    \"small\",\n                    \"large\",\n                    \"huge\"\n                ]\n            });\n            var SizeStyle = new _parchment2.default.Attributor.Style(\"size\", \"font-size\", {\n                scope: _parchment2.default.Scope.INLINE,\n                whitelist: [\n                    \"10px\",\n                    \"18px\",\n                    \"32px\"\n                ]\n            });\n            exports1.SizeClass = SizeClass;\n            exports1.SizeStyle = SizeStyle;\n        /***/ },\n        /* 41 */ /***/ function(module1, exports1, __nested_webpack_require_356724__) {\n            \"use strict\";\n            module1.exports = {\n                \"align\": {\n                    \"\": __nested_webpack_require_356724__(76),\n                    \"center\": __nested_webpack_require_356724__(77),\n                    \"right\": __nested_webpack_require_356724__(78),\n                    \"justify\": __nested_webpack_require_356724__(79)\n                },\n                \"background\": __nested_webpack_require_356724__(80),\n                \"blockquote\": __nested_webpack_require_356724__(81),\n                \"bold\": __nested_webpack_require_356724__(82),\n                \"clean\": __nested_webpack_require_356724__(83),\n                \"code\": __nested_webpack_require_356724__(58),\n                \"code-block\": __nested_webpack_require_356724__(58),\n                \"color\": __nested_webpack_require_356724__(84),\n                \"direction\": {\n                    \"\": __nested_webpack_require_356724__(85),\n                    \"rtl\": __nested_webpack_require_356724__(86)\n                },\n                \"float\": {\n                    \"center\": __nested_webpack_require_356724__(87),\n                    \"full\": __nested_webpack_require_356724__(88),\n                    \"left\": __nested_webpack_require_356724__(89),\n                    \"right\": __nested_webpack_require_356724__(90)\n                },\n                \"formula\": __nested_webpack_require_356724__(91),\n                \"header\": {\n                    \"1\": __nested_webpack_require_356724__(92),\n                    \"2\": __nested_webpack_require_356724__(93)\n                },\n                \"italic\": __nested_webpack_require_356724__(94),\n                \"image\": __nested_webpack_require_356724__(95),\n                \"indent\": {\n                    \"+1\": __nested_webpack_require_356724__(96),\n                    \"-1\": __nested_webpack_require_356724__(97)\n                },\n                \"link\": __nested_webpack_require_356724__(98),\n                \"list\": {\n                    \"ordered\": __nested_webpack_require_356724__(99),\n                    \"bullet\": __nested_webpack_require_356724__(100),\n                    \"check\": __nested_webpack_require_356724__(101)\n                },\n                \"script\": {\n                    \"sub\": __nested_webpack_require_356724__(102),\n                    \"super\": __nested_webpack_require_356724__(103)\n                },\n                \"strike\": __nested_webpack_require_356724__(104),\n                \"underline\": __nested_webpack_require_356724__(105),\n                \"video\": __nested_webpack_require_356724__(106)\n            };\n        /***/ },\n        /* 42 */ /***/ function(module1, exports1, __nested_webpack_require_358938__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.getLastChangeIndex = exports1.default = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _parchment = __nested_webpack_require_358938__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_358938__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _module = __nested_webpack_require_358938__(9);\n            var _module2 = _interopRequireDefault(_module);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var History = function(_Module) {\n                _inherits(History, _Module);\n                function History(quill, options) {\n                    _classCallCheck(this, History);\n                    var _this = _possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).call(this, quill, options));\n                    _this.lastRecorded = 0;\n                    _this.ignoreChange = false;\n                    _this.clear();\n                    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(eventName, delta, oldDelta, source) {\n                        if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange) return;\n                        if (!_this.options.userOnly || source === _quill2.default.sources.USER) {\n                            _this.record(delta, oldDelta);\n                        } else {\n                            _this.transform(delta);\n                        }\n                    });\n                    _this.quill.keyboard.addBinding({\n                        key: \"Z\",\n                        shortKey: true\n                    }, _this.undo.bind(_this));\n                    _this.quill.keyboard.addBinding({\n                        key: \"Z\",\n                        shortKey: true,\n                        shiftKey: true\n                    }, _this.redo.bind(_this));\n                    if (/Win/i.test(navigator.platform)) {\n                        _this.quill.keyboard.addBinding({\n                            key: \"Y\",\n                            shortKey: true\n                        }, _this.redo.bind(_this));\n                    }\n                    return _this;\n                }\n                _createClass(History, [\n                    {\n                        key: \"change\",\n                        value: function change(source, dest) {\n                            if (this.stack[source].length === 0) return;\n                            var delta = this.stack[source].pop();\n                            this.stack[dest].push(delta);\n                            this.lastRecorded = 0;\n                            this.ignoreChange = true;\n                            this.quill.updateContents(delta[source], _quill2.default.sources.USER);\n                            this.ignoreChange = false;\n                            var index = getLastChangeIndex(delta[source]);\n                            this.quill.setSelection(index);\n                        }\n                    },\n                    {\n                        key: \"clear\",\n                        value: function clear() {\n                            this.stack = {\n                                undo: [],\n                                redo: []\n                            };\n                        }\n                    },\n                    {\n                        key: \"cutoff\",\n                        value: function cutoff() {\n                            this.lastRecorded = 0;\n                        }\n                    },\n                    {\n                        key: \"record\",\n                        value: function record(changeDelta, oldDelta) {\n                            if (changeDelta.ops.length === 0) return;\n                            this.stack.redo = [];\n                            var undoDelta = this.quill.getContents().diff(oldDelta);\n                            var timestamp = Date.now();\n                            if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {\n                                var delta = this.stack.undo.pop();\n                                undoDelta = undoDelta.compose(delta.undo);\n                                changeDelta = delta.redo.compose(changeDelta);\n                            } else {\n                                this.lastRecorded = timestamp;\n                            }\n                            this.stack.undo.push({\n                                redo: changeDelta,\n                                undo: undoDelta\n                            });\n                            if (this.stack.undo.length > this.options.maxStack) {\n                                this.stack.undo.shift();\n                            }\n                        }\n                    },\n                    {\n                        key: \"redo\",\n                        value: function redo() {\n                            this.change(\"redo\", \"undo\");\n                        }\n                    },\n                    {\n                        key: \"transform\",\n                        value: function transform(delta) {\n                            this.stack.undo.forEach(function(change) {\n                                change.undo = delta.transform(change.undo, true);\n                                change.redo = delta.transform(change.redo, true);\n                            });\n                            this.stack.redo.forEach(function(change) {\n                                change.undo = delta.transform(change.undo, true);\n                                change.redo = delta.transform(change.redo, true);\n                            });\n                        }\n                    },\n                    {\n                        key: \"undo\",\n                        value: function undo() {\n                            this.change(\"undo\", \"redo\");\n                        }\n                    }\n                ]);\n                return History;\n            }(_module2.default);\n            History.DEFAULTS = {\n                delay: 1000,\n                maxStack: 100,\n                userOnly: false\n            };\n            function endsWithNewlineChange(delta) {\n                var lastOp = delta.ops[delta.ops.length - 1];\n                if (lastOp == null) return false;\n                if (lastOp.insert != null) {\n                    return typeof lastOp.insert === \"string\" && lastOp.insert.endsWith(\"\\n\");\n                }\n                if (lastOp.attributes != null) {\n                    return Object.keys(lastOp.attributes).some(function(attr) {\n                        return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;\n                    });\n                }\n                return false;\n            }\n            function getLastChangeIndex(delta) {\n                var deleteLength = delta.reduce(function(length, op) {\n                    length += op.delete || 0;\n                    return length;\n                }, 0);\n                var changeIndex = delta.length() - deleteLength;\n                if (endsWithNewlineChange(delta)) {\n                    changeIndex -= 1;\n                }\n                return changeIndex;\n            }\n            exports1.default = History;\n            exports1.getLastChangeIndex = getLastChangeIndex;\n        /***/ },\n        /* 43 */ /***/ function(module1, exports1, __nested_webpack_require_368774__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.BaseTooltip = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _extend = __nested_webpack_require_368774__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _quillDelta = __nested_webpack_require_368774__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _emitter = __nested_webpack_require_368774__(8);\n            var _emitter2 = _interopRequireDefault(_emitter);\n            var _keyboard = __nested_webpack_require_368774__(23);\n            var _keyboard2 = _interopRequireDefault(_keyboard);\n            var _theme = __nested_webpack_require_368774__(34);\n            var _theme2 = _interopRequireDefault(_theme);\n            var _colorPicker = __nested_webpack_require_368774__(59);\n            var _colorPicker2 = _interopRequireDefault(_colorPicker);\n            var _iconPicker = __nested_webpack_require_368774__(60);\n            var _iconPicker2 = _interopRequireDefault(_iconPicker);\n            var _picker = __nested_webpack_require_368774__(28);\n            var _picker2 = _interopRequireDefault(_picker);\n            var _tooltip = __nested_webpack_require_368774__(61);\n            var _tooltip2 = _interopRequireDefault(_tooltip);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ALIGNS = [\n                false,\n                \"center\",\n                \"right\",\n                \"justify\"\n            ];\n            var COLORS = [\n                \"#000000\",\n                \"#e60000\",\n                \"#ff9900\",\n                \"#ffff00\",\n                \"#008a00\",\n                \"#0066cc\",\n                \"#9933ff\",\n                \"#ffffff\",\n                \"#facccc\",\n                \"#ffebcc\",\n                \"#ffffcc\",\n                \"#cce8cc\",\n                \"#cce0f5\",\n                \"#ebd6ff\",\n                \"#bbbbbb\",\n                \"#f06666\",\n                \"#ffc266\",\n                \"#ffff66\",\n                \"#66b966\",\n                \"#66a3e0\",\n                \"#c285ff\",\n                \"#888888\",\n                \"#a10000\",\n                \"#b26b00\",\n                \"#b2b200\",\n                \"#006100\",\n                \"#0047b2\",\n                \"#6b24b2\",\n                \"#444444\",\n                \"#5c0000\",\n                \"#663d00\",\n                \"#666600\",\n                \"#003700\",\n                \"#002966\",\n                \"#3d1466\"\n            ];\n            var FONTS = [\n                false,\n                \"serif\",\n                \"monospace\"\n            ];\n            var HEADERS = [\n                \"1\",\n                \"2\",\n                \"3\",\n                false\n            ];\n            var SIZES = [\n                \"small\",\n                false,\n                \"large\",\n                \"huge\"\n            ];\n            var BaseTheme = function(_Theme) {\n                _inherits(BaseTheme, _Theme);\n                function BaseTheme(quill, options) {\n                    _classCallCheck(this, BaseTheme);\n                    var _this = _possibleConstructorReturn(this, (BaseTheme.__proto__ || Object.getPrototypeOf(BaseTheme)).call(this, quill, options));\n                    var listener = function listener(e) {\n                        if (!document.body.contains(quill.root)) {\n                            return document.body.removeEventListener(\"click\", listener);\n                        }\n                        if (_this.tooltip != null && !_this.tooltip.root.contains(e.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {\n                            _this.tooltip.hide();\n                        }\n                        if (_this.pickers != null) {\n                            _this.pickers.forEach(function(picker) {\n                                if (!picker.container.contains(e.target)) {\n                                    picker.close();\n                                }\n                            });\n                        }\n                    };\n                    quill.emitter.listenDOM(\"click\", document.body, listener);\n                    return _this;\n                }\n                _createClass(BaseTheme, [\n                    {\n                        key: \"addModule\",\n                        value: function addModule(name) {\n                            var module1 = _get(BaseTheme.prototype.__proto__ || Object.getPrototypeOf(BaseTheme.prototype), \"addModule\", this).call(this, name);\n                            if (name === \"toolbar\") {\n                                this.extendToolbar(module1);\n                            }\n                            return module1;\n                        }\n                    },\n                    {\n                        key: \"buildButtons\",\n                        value: function buildButtons(buttons, icons) {\n                            buttons.forEach(function(button) {\n                                var className = button.getAttribute(\"class\") || \"\";\n                                className.split(/\\s+/).forEach(function(name) {\n                                    if (!name.startsWith(\"ql-\")) return;\n                                    name = name.slice(\"ql-\".length);\n                                    if (icons[name] == null) return;\n                                    if (name === \"direction\") {\n                                        button.innerHTML = icons[name][\"\"] + icons[name][\"rtl\"];\n                                    } else if (typeof icons[name] === \"string\") {\n                                        button.innerHTML = icons[name];\n                                    } else {\n                                        var value = button.value || \"\";\n                                        if (value != null && icons[name][value]) {\n                                            button.innerHTML = icons[name][value];\n                                        }\n                                    }\n                                });\n                            });\n                        }\n                    },\n                    {\n                        key: \"buildPickers\",\n                        value: function buildPickers(selects, icons) {\n                            var _this2 = this;\n                            this.pickers = selects.map(function(select) {\n                                if (select.classList.contains(\"ql-align\")) {\n                                    if (select.querySelector(\"option\") == null) {\n                                        fillSelect(select, ALIGNS);\n                                    }\n                                    return new _iconPicker2.default(select, icons.align);\n                                } else if (select.classList.contains(\"ql-background\") || select.classList.contains(\"ql-color\")) {\n                                    var format = select.classList.contains(\"ql-background\") ? \"background\" : \"color\";\n                                    if (select.querySelector(\"option\") == null) {\n                                        fillSelect(select, COLORS, format === \"background\" ? \"#ffffff\" : \"#000000\");\n                                    }\n                                    return new _colorPicker2.default(select, icons[format]);\n                                } else {\n                                    if (select.querySelector(\"option\") == null) {\n                                        if (select.classList.contains(\"ql-font\")) {\n                                            fillSelect(select, FONTS);\n                                        } else if (select.classList.contains(\"ql-header\")) {\n                                            fillSelect(select, HEADERS);\n                                        } else if (select.classList.contains(\"ql-size\")) {\n                                            fillSelect(select, SIZES);\n                                        }\n                                    }\n                                    return new _picker2.default(select);\n                                }\n                            });\n                            var update = function update() {\n                                _this2.pickers.forEach(function(picker) {\n                                    picker.update();\n                                });\n                            };\n                            this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);\n                        }\n                    }\n                ]);\n                return BaseTheme;\n            }(_theme2.default);\n            BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {\n                modules: {\n                    toolbar: {\n                        handlers: {\n                            formula: function formula() {\n                                this.quill.theme.tooltip.edit(\"formula\");\n                            },\n                            image: function image() {\n                                var _this3 = this;\n                                var fileInput = this.container.querySelector(\"input.ql-image[type=file]\");\n                                if (fileInput == null) {\n                                    fileInput = document.createElement(\"input\");\n                                    fileInput.setAttribute(\"type\", \"file\");\n                                    fileInput.setAttribute(\"accept\", \"image/png, image/gif, image/jpeg, image/bmp, image/x-icon\");\n                                    fileInput.classList.add(\"ql-image\");\n                                    fileInput.addEventListener(\"change\", function() {\n                                        if (fileInput.files != null && fileInput.files[0] != null) {\n                                            var reader = new FileReader();\n                                            reader.onload = function(e) {\n                                                var range = _this3.quill.getSelection(true);\n                                                _this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({\n                                                    image: e.target.result\n                                                }), _emitter2.default.sources.USER);\n                                                _this3.quill.setSelection(range.index + 1, _emitter2.default.sources.SILENT);\n                                                fileInput.value = \"\";\n                                            };\n                                            reader.readAsDataURL(fileInput.files[0]);\n                                        }\n                                    });\n                                    this.container.appendChild(fileInput);\n                                }\n                                fileInput.click();\n                            },\n                            video: function video() {\n                                this.quill.theme.tooltip.edit(\"video\");\n                            }\n                        }\n                    }\n                }\n            });\n            var BaseTooltip = function(_Tooltip) {\n                _inherits(BaseTooltip, _Tooltip);\n                function BaseTooltip(quill, boundsContainer) {\n                    _classCallCheck(this, BaseTooltip);\n                    var _this4 = _possibleConstructorReturn(this, (BaseTooltip.__proto__ || Object.getPrototypeOf(BaseTooltip)).call(this, quill, boundsContainer));\n                    _this4.textbox = _this4.root.querySelector('input[type=\"text\"]');\n                    _this4.listen();\n                    return _this4;\n                }\n                _createClass(BaseTooltip, [\n                    {\n                        key: \"listen\",\n                        value: function listen() {\n                            var _this5 = this;\n                            this.textbox.addEventListener(\"keydown\", function(event) {\n                                if (_keyboard2.default.match(event, \"enter\")) {\n                                    _this5.save();\n                                    event.preventDefault();\n                                } else if (_keyboard2.default.match(event, \"escape\")) {\n                                    _this5.cancel();\n                                    event.preventDefault();\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"cancel\",\n                        value: function cancel() {\n                            this.hide();\n                        }\n                    },\n                    {\n                        key: \"edit\",\n                        value: function edit() {\n                            var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"link\";\n                            var preview = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n                            this.root.classList.remove(\"ql-hidden\");\n                            this.root.classList.add(\"ql-editing\");\n                            if (preview != null) {\n                                this.textbox.value = preview;\n                            } else if (mode !== this.root.getAttribute(\"data-mode\")) {\n                                this.textbox.value = \"\";\n                            }\n                            this.position(this.quill.getBounds(this.quill.selection.savedRange));\n                            this.textbox.select();\n                            this.textbox.setAttribute(\"placeholder\", this.textbox.getAttribute(\"data-\" + mode) || \"\");\n                            this.root.setAttribute(\"data-mode\", mode);\n                        }\n                    },\n                    {\n                        key: \"restoreFocus\",\n                        value: function restoreFocus() {\n                            var scrollTop = this.quill.scrollingContainer.scrollTop;\n                            this.quill.focus();\n                            this.quill.scrollingContainer.scrollTop = scrollTop;\n                        }\n                    },\n                    {\n                        key: \"save\",\n                        value: function save() {\n                            var value = this.textbox.value;\n                            switch(this.root.getAttribute(\"data-mode\")){\n                                case \"link\":\n                                    {\n                                        var scrollTop = this.quill.root.scrollTop;\n                                        if (this.linkRange) {\n                                            this.quill.formatText(this.linkRange, \"link\", value, _emitter2.default.sources.USER);\n                                            delete this.linkRange;\n                                        } else {\n                                            this.restoreFocus();\n                                            this.quill.format(\"link\", value, _emitter2.default.sources.USER);\n                                        }\n                                        this.quill.root.scrollTop = scrollTop;\n                                        break;\n                                    }\n                                case \"video\":\n                                    {\n                                        value = extractVideoUrl(value);\n                                    }\n                                case \"formula\":\n                                    {\n                                        if (!value) break;\n                                        var range = this.quill.getSelection(true);\n                                        if (range != null) {\n                                            var index = range.index + range.length;\n                                            this.quill.insertEmbed(index, this.root.getAttribute(\"data-mode\"), value, _emitter2.default.sources.USER);\n                                            if (this.root.getAttribute(\"data-mode\") === \"formula\") {\n                                                this.quill.insertText(index + 1, \" \", _emitter2.default.sources.USER);\n                                            }\n                                            this.quill.setSelection(index + 2, _emitter2.default.sources.USER);\n                                        }\n                                        break;\n                                    }\n                                default:\n                            }\n                            this.textbox.value = \"\";\n                            this.hide();\n                        }\n                    }\n                ]);\n                return BaseTooltip;\n            }(_tooltip2.default);\n            function extractVideoUrl(url) {\n                var match = url.match(/^(?:(https?):\\/\\/)?(?:(?:www|m)\\.)?youtube\\.com\\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\\/\\/)?(?:(?:www|m)\\.)?youtu\\.be\\/([a-zA-Z0-9_-]+)/);\n                if (match) {\n                    return (match[1] || \"https\") + \"://www.youtube.com/embed/\" + match[2] + \"?showinfo=0\";\n                }\n                if (match = url.match(/^(?:(https?):\\/\\/)?(?:www\\.)?vimeo\\.com\\/(\\d+)/)) {\n                    // eslint-disable-line no-cond-assign\n                    return (match[1] || \"https\") + \"://player.vimeo.com/video/\" + match[2] + \"/\";\n                }\n                return url;\n            }\n            function fillSelect(select, values) {\n                var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                values.forEach(function(value) {\n                    var option = document.createElement(\"option\");\n                    if (value === defaultValue) {\n                        option.setAttribute(\"selected\", \"selected\");\n                    } else {\n                        option.setAttribute(\"value\", value);\n                    }\n                    select.appendChild(option);\n                });\n            }\n            exports1.BaseTooltip = BaseTooltip;\n            exports1.default = BaseTheme;\n        /***/ },\n        /* 44 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var LinkedList = /** @class */ function() {\n                function LinkedList() {\n                    this.head = this.tail = null;\n                    this.length = 0;\n                }\n                LinkedList.prototype.append = function() {\n                    var nodes = [];\n                    for(var _i = 0; _i < arguments.length; _i++){\n                        nodes[_i] = arguments[_i];\n                    }\n                    this.insertBefore(nodes[0], null);\n                    if (nodes.length > 1) {\n                        this.append.apply(this, nodes.slice(1));\n                    }\n                };\n                LinkedList.prototype.contains = function(node) {\n                    var cur, next = this.iterator();\n                    while(cur = next()){\n                        if (cur === node) return true;\n                    }\n                    return false;\n                };\n                LinkedList.prototype.insertBefore = function(node, refNode) {\n                    if (!node) return;\n                    node.next = refNode;\n                    if (refNode != null) {\n                        node.prev = refNode.prev;\n                        if (refNode.prev != null) {\n                            refNode.prev.next = node;\n                        }\n                        refNode.prev = node;\n                        if (refNode === this.head) {\n                            this.head = node;\n                        }\n                    } else if (this.tail != null) {\n                        this.tail.next = node;\n                        node.prev = this.tail;\n                        this.tail = node;\n                    } else {\n                        node.prev = null;\n                        this.head = this.tail = node;\n                    }\n                    this.length += 1;\n                };\n                LinkedList.prototype.offset = function(target) {\n                    var index = 0, cur = this.head;\n                    while(cur != null){\n                        if (cur === target) return index;\n                        index += cur.length();\n                        cur = cur.next;\n                    }\n                    return -1;\n                };\n                LinkedList.prototype.remove = function(node) {\n                    if (!this.contains(node)) return;\n                    if (node.prev != null) node.prev.next = node.next;\n                    if (node.next != null) node.next.prev = node.prev;\n                    if (node === this.head) this.head = node.next;\n                    if (node === this.tail) this.tail = node.prev;\n                    this.length -= 1;\n                };\n                LinkedList.prototype.iterator = function(curNode) {\n                    if (curNode === void 0) {\n                        curNode = this.head;\n                    }\n                    // TODO use yield when we can\n                    return function() {\n                        var ret = curNode;\n                        if (curNode != null) curNode = curNode.next;\n                        return ret;\n                    };\n                };\n                LinkedList.prototype.find = function(index, inclusive) {\n                    if (inclusive === void 0) {\n                        inclusive = false;\n                    }\n                    var cur, next = this.iterator();\n                    while(cur = next()){\n                        var length = cur.length();\n                        if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0)) {\n                            return [\n                                cur,\n                                index\n                            ];\n                        }\n                        index -= length;\n                    }\n                    return [\n                        null,\n                        0\n                    ];\n                };\n                LinkedList.prototype.forEach = function(callback) {\n                    var cur, next = this.iterator();\n                    while(cur = next()){\n                        callback(cur);\n                    }\n                };\n                LinkedList.prototype.forEachAt = function(index, length, callback) {\n                    if (length <= 0) return;\n                    var _a = this.find(index), startNode = _a[0], offset = _a[1];\n                    var cur, curIndex = index - offset, next = this.iterator(startNode);\n                    while((cur = next()) && curIndex < index + length){\n                        var curLength = cur.length();\n                        if (index > curIndex) {\n                            callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));\n                        } else {\n                            callback(cur, 0, Math.min(curLength, index + length - curIndex));\n                        }\n                        curIndex += curLength;\n                    }\n                };\n                LinkedList.prototype.map = function(callback) {\n                    return this.reduce(function(memo, cur) {\n                        memo.push(callback(cur));\n                        return memo;\n                    }, []);\n                };\n                LinkedList.prototype.reduce = function(callback, memo) {\n                    var cur, next = this.iterator();\n                    while(cur = next()){\n                        memo = callback(memo, cur);\n                    }\n                    return memo;\n                };\n                return LinkedList;\n            }();\n            exports1.default = LinkedList;\n        /***/ },\n        /* 45 */ /***/ function(module1, exports1, __nested_webpack_require_396182__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var container_1 = __nested_webpack_require_396182__(17);\n            var Registry = __nested_webpack_require_396182__(1);\n            var OBSERVER_CONFIG = {\n                attributes: true,\n                characterData: true,\n                characterDataOldValue: true,\n                childList: true,\n                subtree: true\n            };\n            var MAX_OPTIMIZE_ITERATIONS = 100;\n            var ScrollBlot = /** @class */ function(_super) {\n                __extends(ScrollBlot, _super);\n                function ScrollBlot(node) {\n                    var _this = _super.call(this, node) || this;\n                    _this.scroll = _this;\n                    _this.observer = new MutationObserver(function(mutations) {\n                        _this.update(mutations);\n                    });\n                    _this.observer.observe(_this.domNode, OBSERVER_CONFIG);\n                    _this.attach();\n                    return _this;\n                }\n                ScrollBlot.prototype.detach = function() {\n                    _super.prototype.detach.call(this);\n                    this.observer.disconnect();\n                };\n                ScrollBlot.prototype.deleteAt = function(index, length) {\n                    this.update();\n                    if (index === 0 && length === this.length()) {\n                        this.children.forEach(function(child) {\n                            child.remove();\n                        });\n                    } else {\n                        _super.prototype.deleteAt.call(this, index, length);\n                    }\n                };\n                ScrollBlot.prototype.formatAt = function(index, length, name, value) {\n                    this.update();\n                    _super.prototype.formatAt.call(this, index, length, name, value);\n                };\n                ScrollBlot.prototype.insertAt = function(index, value, def) {\n                    this.update();\n                    _super.prototype.insertAt.call(this, index, value, def);\n                };\n                ScrollBlot.prototype.optimize = function(mutations, context) {\n                    var _this = this;\n                    if (mutations === void 0) {\n                        mutations = [];\n                    }\n                    if (context === void 0) {\n                        context = {};\n                    }\n                    _super.prototype.optimize.call(this, context);\n                    // We must modify mutations directly, cannot make copy and then modify\n                    var records = [].slice.call(this.observer.takeRecords());\n                    // Array.push currently seems to be implemented by a non-tail recursive function\n                    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n                    while(records.length > 0)mutations.push(records.pop());\n                    // TODO use WeakMap\n                    var mark = function(blot, markParent) {\n                        if (markParent === void 0) {\n                            markParent = true;\n                        }\n                        if (blot == null || blot === _this) return;\n                        if (blot.domNode.parentNode == null) return;\n                        // @ts-ignore\n                        if (blot.domNode[Registry.DATA_KEY].mutations == null) {\n                            // @ts-ignore\n                            blot.domNode[Registry.DATA_KEY].mutations = [];\n                        }\n                        if (markParent) mark(blot.parent);\n                    };\n                    var optimize = function(blot) {\n                        // Post-order traversal\n                        if (// @ts-ignore\n                        blot.domNode[Registry.DATA_KEY] == null || // @ts-ignore\n                        blot.domNode[Registry.DATA_KEY].mutations == null) {\n                            return;\n                        }\n                        if (blot instanceof container_1.default) {\n                            blot.children.forEach(optimize);\n                        }\n                        blot.optimize(context);\n                    };\n                    var remaining = mutations;\n                    for(var i = 0; remaining.length > 0; i += 1){\n                        if (i >= MAX_OPTIMIZE_ITERATIONS) {\n                            throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n                        }\n                        remaining.forEach(function(mutation) {\n                            var blot = Registry.find(mutation.target, true);\n                            if (blot == null) return;\n                            if (blot.domNode === mutation.target) {\n                                if (mutation.type === \"childList\") {\n                                    mark(Registry.find(mutation.previousSibling, false));\n                                    [].forEach.call(mutation.addedNodes, function(node) {\n                                        var child = Registry.find(node, false);\n                                        mark(child, false);\n                                        if (child instanceof container_1.default) {\n                                            child.children.forEach(function(grandChild) {\n                                                mark(grandChild, false);\n                                            });\n                                        }\n                                    });\n                                } else if (mutation.type === \"attributes\") {\n                                    mark(blot.prev);\n                                }\n                            }\n                            mark(blot);\n                        });\n                        this.children.forEach(optimize);\n                        remaining = [].slice.call(this.observer.takeRecords());\n                        records = remaining.slice();\n                        while(records.length > 0)mutations.push(records.pop());\n                    }\n                };\n                ScrollBlot.prototype.update = function(mutations, context) {\n                    var _this = this;\n                    if (context === void 0) {\n                        context = {};\n                    }\n                    mutations = mutations || this.observer.takeRecords();\n                    // TODO use WeakMap\n                    mutations.map(function(mutation) {\n                        var blot = Registry.find(mutation.target, true);\n                        if (blot == null) return null;\n                        // @ts-ignore\n                        if (blot.domNode[Registry.DATA_KEY].mutations == null) {\n                            // @ts-ignore\n                            blot.domNode[Registry.DATA_KEY].mutations = [\n                                mutation\n                            ];\n                            return blot;\n                        } else {\n                            // @ts-ignore\n                            blot.domNode[Registry.DATA_KEY].mutations.push(mutation);\n                            return null;\n                        }\n                    }).forEach(function(blot) {\n                        if (blot == null || blot === _this || //@ts-ignore\n                        blot.domNode[Registry.DATA_KEY] == null) return;\n                        // @ts-ignore\n                        blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);\n                    });\n                    // @ts-ignore\n                    if (this.domNode[Registry.DATA_KEY].mutations != null) {\n                        // @ts-ignore\n                        _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);\n                    }\n                    this.optimize(mutations, context);\n                };\n                ScrollBlot.blotName = \"scroll\";\n                ScrollBlot.defaultChild = \"block\";\n                ScrollBlot.scope = Registry.Scope.BLOCK_BLOT;\n                ScrollBlot.tagName = \"DIV\";\n                return ScrollBlot;\n            }(container_1.default);\n            exports1.default = ScrollBlot;\n        /***/ },\n        /* 46 */ /***/ function(module1, exports1, __nested_webpack_require_405318__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var format_1 = __nested_webpack_require_405318__(18);\n            var Registry = __nested_webpack_require_405318__(1);\n            // Shallow object comparison\n            function isEqual(obj1, obj2) {\n                if (Object.keys(obj1).length !== Object.keys(obj2).length) return false;\n                // @ts-ignore\n                for(var prop in obj1){\n                    // @ts-ignore\n                    if (obj1[prop] !== obj2[prop]) return false;\n                }\n                return true;\n            }\n            var InlineBlot = /** @class */ function(_super) {\n                __extends(InlineBlot, _super);\n                function InlineBlot() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                InlineBlot.formats = function(domNode) {\n                    if (domNode.tagName === InlineBlot.tagName) return undefined;\n                    return _super.formats.call(this, domNode);\n                };\n                InlineBlot.prototype.format = function(name, value) {\n                    var _this = this;\n                    if (name === this.statics.blotName && !value) {\n                        this.children.forEach(function(child) {\n                            if (!(child instanceof format_1.default)) {\n                                child = child.wrap(InlineBlot.blotName, true);\n                            }\n                            _this.attributes.copy(child);\n                        });\n                        this.unwrap();\n                    } else {\n                        _super.prototype.format.call(this, name, value);\n                    }\n                };\n                InlineBlot.prototype.formatAt = function(index, length, name, value) {\n                    if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {\n                        var blot = this.isolate(index, length);\n                        blot.format(name, value);\n                    } else {\n                        _super.prototype.formatAt.call(this, index, length, name, value);\n                    }\n                };\n                InlineBlot.prototype.optimize = function(context) {\n                    _super.prototype.optimize.call(this, context);\n                    var formats = this.formats();\n                    if (Object.keys(formats).length === 0) {\n                        return this.unwrap(); // unformatted span\n                    }\n                    var next = this.next;\n                    if (next instanceof InlineBlot && next.prev === this && isEqual(formats, next.formats())) {\n                        next.moveChildren(this);\n                        next.remove();\n                    }\n                };\n                InlineBlot.blotName = \"inline\";\n                InlineBlot.scope = Registry.Scope.INLINE_BLOT;\n                InlineBlot.tagName = \"SPAN\";\n                return InlineBlot;\n            }(format_1.default);\n            exports1.default = InlineBlot;\n        /***/ },\n        /* 47 */ /***/ function(module1, exports1, __nested_webpack_require_409272__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var format_1 = __nested_webpack_require_409272__(18);\n            var Registry = __nested_webpack_require_409272__(1);\n            var BlockBlot = /** @class */ function(_super) {\n                __extends(BlockBlot, _super);\n                function BlockBlot() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                BlockBlot.formats = function(domNode) {\n                    var tagName = Registry.query(BlockBlot.blotName).tagName;\n                    if (domNode.tagName === tagName) return undefined;\n                    return _super.formats.call(this, domNode);\n                };\n                BlockBlot.prototype.format = function(name, value) {\n                    if (Registry.query(name, Registry.Scope.BLOCK) == null) {\n                        return;\n                    } else if (name === this.statics.blotName && !value) {\n                        this.replaceWith(BlockBlot.blotName);\n                    } else {\n                        _super.prototype.format.call(this, name, value);\n                    }\n                };\n                BlockBlot.prototype.formatAt = function(index, length, name, value) {\n                    if (Registry.query(name, Registry.Scope.BLOCK) != null) {\n                        this.format(name, value);\n                    } else {\n                        _super.prototype.formatAt.call(this, index, length, name, value);\n                    }\n                };\n                BlockBlot.prototype.insertAt = function(index, value, def) {\n                    if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {\n                        // Insert text or inline\n                        _super.prototype.insertAt.call(this, index, value, def);\n                    } else {\n                        var after = this.split(index);\n                        var blot = Registry.create(value, def);\n                        after.parent.insertBefore(blot, after);\n                    }\n                };\n                BlockBlot.prototype.update = function(mutations, context) {\n                    if (navigator.userAgent.match(/Trident/)) {\n                        this.build();\n                    } else {\n                        _super.prototype.update.call(this, mutations, context);\n                    }\n                };\n                BlockBlot.blotName = \"block\";\n                BlockBlot.scope = Registry.Scope.BLOCK_BLOT;\n                BlockBlot.tagName = \"P\";\n                return BlockBlot;\n            }(format_1.default);\n            exports1.default = BlockBlot;\n        /***/ },\n        /* 48 */ /***/ function(module1, exports1, __nested_webpack_require_412820__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var leaf_1 = __nested_webpack_require_412820__(19);\n            var EmbedBlot = /** @class */ function(_super) {\n                __extends(EmbedBlot, _super);\n                function EmbedBlot() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                EmbedBlot.formats = function(domNode) {\n                    return undefined;\n                };\n                EmbedBlot.prototype.format = function(name, value) {\n                    // super.formatAt wraps, which is what we want in general,\n                    // but this allows subclasses to overwrite for formats\n                    // that just apply to particular embeds\n                    _super.prototype.formatAt.call(this, 0, this.length(), name, value);\n                };\n                EmbedBlot.prototype.formatAt = function(index, length, name, value) {\n                    if (index === 0 && length === this.length()) {\n                        this.format(name, value);\n                    } else {\n                        _super.prototype.formatAt.call(this, index, length, name, value);\n                    }\n                };\n                EmbedBlot.prototype.formats = function() {\n                    return this.statics.formats(this.domNode);\n                };\n                return EmbedBlot;\n            }(leaf_1.default);\n            exports1.default = EmbedBlot;\n        /***/ },\n        /* 49 */ /***/ function(module1, exports1, __nested_webpack_require_415170__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var leaf_1 = __nested_webpack_require_415170__(19);\n            var Registry = __nested_webpack_require_415170__(1);\n            var TextBlot = /** @class */ function(_super) {\n                __extends(TextBlot, _super);\n                function TextBlot(node) {\n                    var _this = _super.call(this, node) || this;\n                    _this.text = _this.statics.value(_this.domNode);\n                    return _this;\n                }\n                TextBlot.create = function(value) {\n                    return document.createTextNode(value);\n                };\n                TextBlot.value = function(domNode) {\n                    var text = domNode.data;\n                    // @ts-ignore\n                    if (text[\"normalize\"]) text = text[\"normalize\"]();\n                    return text;\n                };\n                TextBlot.prototype.deleteAt = function(index, length) {\n                    this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);\n                };\n                TextBlot.prototype.index = function(node, offset) {\n                    if (this.domNode === node) {\n                        return offset;\n                    }\n                    return -1;\n                };\n                TextBlot.prototype.insertAt = function(index, value, def) {\n                    if (def == null) {\n                        this.text = this.text.slice(0, index) + value + this.text.slice(index);\n                        this.domNode.data = this.text;\n                    } else {\n                        _super.prototype.insertAt.call(this, index, value, def);\n                    }\n                };\n                TextBlot.prototype.length = function() {\n                    return this.text.length;\n                };\n                TextBlot.prototype.optimize = function(context) {\n                    _super.prototype.optimize.call(this, context);\n                    this.text = this.statics.value(this.domNode);\n                    if (this.text.length === 0) {\n                        this.remove();\n                    } else if (this.next instanceof TextBlot && this.next.prev === this) {\n                        this.insertAt(this.length(), this.next.value());\n                        this.next.remove();\n                    }\n                };\n                TextBlot.prototype.position = function(index, inclusive) {\n                    if (inclusive === void 0) {\n                        inclusive = false;\n                    }\n                    return [\n                        this.domNode,\n                        index\n                    ];\n                };\n                TextBlot.prototype.split = function(index, force) {\n                    if (force === void 0) {\n                        force = false;\n                    }\n                    if (!force) {\n                        if (index === 0) return this;\n                        if (index === this.length()) return this.next;\n                    }\n                    var after = Registry.create(this.domNode.splitText(index));\n                    this.parent.insertBefore(after, this.next);\n                    this.text = this.statics.value(this.domNode);\n                    return after;\n                };\n                TextBlot.prototype.update = function(mutations, context) {\n                    var _this = this;\n                    if (mutations.some(function(mutation) {\n                        return mutation.type === \"characterData\" && mutation.target === _this.domNode;\n                    })) {\n                        this.text = this.statics.value(this.domNode);\n                    }\n                };\n                TextBlot.prototype.value = function() {\n                    return this.text;\n                };\n                TextBlot.blotName = \"text\";\n                TextBlot.scope = Registry.Scope.INLINE_BLOT;\n                return TextBlot;\n            }(leaf_1.default);\n            exports1.default = TextBlot;\n        /***/ },\n        /* 50 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var elem = document.createElement(\"div\");\n            elem.classList.toggle(\"test-class\", false);\n            if (elem.classList.contains(\"test-class\")) {\n                var _toggle = DOMTokenList.prototype.toggle;\n                DOMTokenList.prototype.toggle = function(token, force) {\n                    if (arguments.length > 1 && !this.contains(token) === !force) {\n                        return force;\n                    } else {\n                        return _toggle.call(this, token);\n                    }\n                };\n            }\n            if (!String.prototype.startsWith) {\n                String.prototype.startsWith = function(searchString, position) {\n                    position = position || 0;\n                    return this.substr(position, searchString.length) === searchString;\n                };\n            }\n            if (!String.prototype.endsWith) {\n                String.prototype.endsWith = function(searchString, position) {\n                    var subjectString = this.toString();\n                    if (typeof position !== \"number\" || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\n                        position = subjectString.length;\n                    }\n                    position -= searchString.length;\n                    var lastIndex = subjectString.indexOf(searchString, position);\n                    return lastIndex !== -1 && lastIndex === position;\n                };\n            }\n            if (!Array.prototype.find) {\n                Object.defineProperty(Array.prototype, \"find\", {\n                    value: function value(predicate) {\n                        if (this === null) {\n                            throw new TypeError(\"Array.prototype.find called on null or undefined\");\n                        }\n                        if (typeof predicate !== \"function\") {\n                            throw new TypeError(\"predicate must be a function\");\n                        }\n                        var list = Object(this);\n                        var length = list.length >>> 0;\n                        var thisArg = arguments[1];\n                        var value;\n                        for(var i = 0; i < length; i++){\n                            value = list[i];\n                            if (predicate.call(thisArg, value, i, list)) {\n                                return value;\n                            }\n                        }\n                        return undefined;\n                    }\n                });\n            }\n            document.addEventListener(\"DOMContentLoaded\", function() {\n                // Disable resizing in Firefox\n                document.execCommand(\"enableObjectResizing\", false, false);\n                // Disable automatic linkifying in IE11\n                document.execCommand(\"autoUrlDetect\", false, false);\n            });\n        /***/ },\n        /* 51 */ /***/ function(module1, exports1) {\n            /**\n * This library modifies the diff-patch-match library by Neil Fraser\n * by removing the patch and match functionality and certain advanced\n * options in the diff function. The original license is as follows:\n *\n * ===\n *\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */ var DIFF_DELETE = -1;\n            var DIFF_INSERT = 1;\n            var DIFF_EQUAL = 0;\n            /**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {Int} cursor_pos Expected edit position in text1 (optional)\n * @return {Array} Array of diff tuples.\n */ function diff_main(text1, text2, cursor_pos) {\n                // Check for equality (speedup).\n                if (text1 == text2) {\n                    if (text1) {\n                        return [\n                            [\n                                DIFF_EQUAL,\n                                text1\n                            ]\n                        ];\n                    }\n                    return [];\n                }\n                // Check cursor_pos within bounds\n                if (cursor_pos < 0 || text1.length < cursor_pos) {\n                    cursor_pos = null;\n                }\n                // Trim off common prefix (speedup).\n                var commonlength = diff_commonPrefix(text1, text2);\n                var commonprefix = text1.substring(0, commonlength);\n                text1 = text1.substring(commonlength);\n                text2 = text2.substring(commonlength);\n                // Trim off common suffix (speedup).\n                commonlength = diff_commonSuffix(text1, text2);\n                var commonsuffix = text1.substring(text1.length - commonlength);\n                text1 = text1.substring(0, text1.length - commonlength);\n                text2 = text2.substring(0, text2.length - commonlength);\n                // Compute the diff on the middle block.\n                var diffs = diff_compute_(text1, text2);\n                // Restore the prefix and suffix.\n                if (commonprefix) {\n                    diffs.unshift([\n                        DIFF_EQUAL,\n                        commonprefix\n                    ]);\n                }\n                if (commonsuffix) {\n                    diffs.push([\n                        DIFF_EQUAL,\n                        commonsuffix\n                    ]);\n                }\n                diff_cleanupMerge(diffs);\n                if (cursor_pos != null) {\n                    diffs = fix_cursor(diffs, cursor_pos);\n                }\n                diffs = fix_emoji(diffs);\n                return diffs;\n            }\n            ;\n            /**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n */ function diff_compute_(text1, text2) {\n                var diffs;\n                if (!text1) {\n                    // Just add some text (speedup).\n                    return [\n                        [\n                            DIFF_INSERT,\n                            text2\n                        ]\n                    ];\n                }\n                if (!text2) {\n                    // Just delete some text (speedup).\n                    return [\n                        [\n                            DIFF_DELETE,\n                            text1\n                        ]\n                    ];\n                }\n                var longtext = text1.length > text2.length ? text1 : text2;\n                var shorttext = text1.length > text2.length ? text2 : text1;\n                var i = longtext.indexOf(shorttext);\n                if (i != -1) {\n                    // Shorter text is inside the longer text (speedup).\n                    diffs = [\n                        [\n                            DIFF_INSERT,\n                            longtext.substring(0, i)\n                        ],\n                        [\n                            DIFF_EQUAL,\n                            shorttext\n                        ],\n                        [\n                            DIFF_INSERT,\n                            longtext.substring(i + shorttext.length)\n                        ]\n                    ];\n                    // Swap insertions for deletions if diff is reversed.\n                    if (text1.length > text2.length) {\n                        diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n                    }\n                    return diffs;\n                }\n                if (shorttext.length == 1) {\n                    // Single character string.\n                    // After the previous speedup, the character can't be an equality.\n                    return [\n                        [\n                            DIFF_DELETE,\n                            text1\n                        ],\n                        [\n                            DIFF_INSERT,\n                            text2\n                        ]\n                    ];\n                }\n                // Check to see if the problem can be split in two.\n                var hm = diff_halfMatch_(text1, text2);\n                if (hm) {\n                    // A half-match was found, sort out the return data.\n                    var text1_a = hm[0];\n                    var text1_b = hm[1];\n                    var text2_a = hm[2];\n                    var text2_b = hm[3];\n                    var mid_common = hm[4];\n                    // Send both pairs off for separate processing.\n                    var diffs_a = diff_main(text1_a, text2_a);\n                    var diffs_b = diff_main(text1_b, text2_b);\n                    // Merge the results.\n                    return diffs_a.concat([\n                        [\n                            DIFF_EQUAL,\n                            mid_common\n                        ]\n                    ], diffs_b);\n                }\n                return diff_bisect_(text1, text2);\n            }\n            ;\n            /**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n * @private\n */ function diff_bisect_(text1, text2) {\n                // Cache the text lengths to prevent multiple calls.\n                var text1_length = text1.length;\n                var text2_length = text2.length;\n                var max_d = Math.ceil((text1_length + text2_length) / 2);\n                var v_offset = max_d;\n                var v_length = 2 * max_d;\n                var v1 = new Array(v_length);\n                var v2 = new Array(v_length);\n                // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n                // integers and undefined.\n                for(var x = 0; x < v_length; x++){\n                    v1[x] = -1;\n                    v2[x] = -1;\n                }\n                v1[v_offset + 1] = 0;\n                v2[v_offset + 1] = 0;\n                var delta = text1_length - text2_length;\n                // If the total number of characters is odd, then the front path will collide\n                // with the reverse path.\n                var front = delta % 2 != 0;\n                // Offsets for start and end of k loop.\n                // Prevents mapping of space beyond the grid.\n                var k1start = 0;\n                var k1end = 0;\n                var k2start = 0;\n                var k2end = 0;\n                for(var d = 0; d < max_d; d++){\n                    // Walk the front path one step.\n                    for(var k1 = -d + k1start; k1 <= d - k1end; k1 += 2){\n                        var k1_offset = v_offset + k1;\n                        var x1;\n                        if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {\n                            x1 = v1[k1_offset + 1];\n                        } else {\n                            x1 = v1[k1_offset - 1] + 1;\n                        }\n                        var y1 = x1 - k1;\n                        while(x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)){\n                            x1++;\n                            y1++;\n                        }\n                        v1[k1_offset] = x1;\n                        if (x1 > text1_length) {\n                            // Ran off the right of the graph.\n                            k1end += 2;\n                        } else if (y1 > text2_length) {\n                            // Ran off the bottom of the graph.\n                            k1start += 2;\n                        } else if (front) {\n                            var k2_offset = v_offset + delta - k1;\n                            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n                                // Mirror x2 onto top-left coordinate system.\n                                var x2 = text1_length - v2[k2_offset];\n                                if (x1 >= x2) {\n                                    // Overlap detected.\n                                    return diff_bisectSplit_(text1, text2, x1, y1);\n                                }\n                            }\n                        }\n                    }\n                    // Walk the reverse path one step.\n                    for(var k2 = -d + k2start; k2 <= d - k2end; k2 += 2){\n                        var k2_offset = v_offset + k2;\n                        var x2;\n                        if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {\n                            x2 = v2[k2_offset + 1];\n                        } else {\n                            x2 = v2[k2_offset - 1] + 1;\n                        }\n                        var y2 = x2 - k2;\n                        while(x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)){\n                            x2++;\n                            y2++;\n                        }\n                        v2[k2_offset] = x2;\n                        if (x2 > text1_length) {\n                            // Ran off the left of the graph.\n                            k2end += 2;\n                        } else if (y2 > text2_length) {\n                            // Ran off the top of the graph.\n                            k2start += 2;\n                        } else if (!front) {\n                            var k1_offset = v_offset + delta - k2;\n                            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n                                var x1 = v1[k1_offset];\n                                var y1 = v_offset + x1 - k1_offset;\n                                // Mirror x2 onto top-left coordinate system.\n                                x2 = text1_length - x2;\n                                if (x1 >= x2) {\n                                    // Overlap detected.\n                                    return diff_bisectSplit_(text1, text2, x1, y1);\n                                }\n                            }\n                        }\n                    }\n                }\n                // Diff took too long and hit the deadline or\n                // number of diffs equals number of characters, no commonality at all.\n                return [\n                    [\n                        DIFF_DELETE,\n                        text1\n                    ],\n                    [\n                        DIFF_INSERT,\n                        text2\n                    ]\n                ];\n            }\n            ;\n            /**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @return {Array} Array of diff tuples.\n */ function diff_bisectSplit_(text1, text2, x, y) {\n                var text1a = text1.substring(0, x);\n                var text2a = text2.substring(0, y);\n                var text1b = text1.substring(x);\n                var text2b = text2.substring(y);\n                // Compute both diffs serially.\n                var diffs = diff_main(text1a, text2a);\n                var diffsb = diff_main(text1b, text2b);\n                return diffs.concat(diffsb);\n            }\n            ;\n            /**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */ function diff_commonPrefix(text1, text2) {\n                // Quick check for common null cases.\n                if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n                    return 0;\n                }\n                // Binary search.\n                // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n                var pointermin = 0;\n                var pointermax = Math.min(text1.length, text2.length);\n                var pointermid = pointermax;\n                var pointerstart = 0;\n                while(pointermin < pointermid){\n                    if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {\n                        pointermin = pointermid;\n                        pointerstart = pointermin;\n                    } else {\n                        pointermax = pointermid;\n                    }\n                    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n                }\n                return pointermid;\n            }\n            ;\n            /**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */ function diff_commonSuffix(text1, text2) {\n                // Quick check for common null cases.\n                if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n                    return 0;\n                }\n                // Binary search.\n                // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n                var pointermin = 0;\n                var pointermax = Math.min(text1.length, text2.length);\n                var pointermid = pointermax;\n                var pointerend = 0;\n                while(pointermin < pointermid){\n                    if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n                        pointermin = pointermid;\n                        pointerend = pointermin;\n                    } else {\n                        pointermax = pointermid;\n                    }\n                    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n                }\n                return pointermid;\n            }\n            ;\n            /**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n */ function diff_halfMatch_(text1, text2) {\n                var longtext = text1.length > text2.length ? text1 : text2;\n                var shorttext = text1.length > text2.length ? text2 : text1;\n                if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n                    return null; // Pointless.\n                }\n                /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */ function diff_halfMatchI_(longtext, shorttext, i) {\n                    // Start with a 1/4 length substring at position i as a seed.\n                    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n                    var j = -1;\n                    var best_common = \"\";\n                    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n                    while((j = shorttext.indexOf(seed, j + 1)) != -1){\n                        var prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));\n                        var suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n                        if (best_common.length < suffixLength + prefixLength) {\n                            best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n                            best_longtext_a = longtext.substring(0, i - suffixLength);\n                            best_longtext_b = longtext.substring(i + prefixLength);\n                            best_shorttext_a = shorttext.substring(0, j - suffixLength);\n                            best_shorttext_b = shorttext.substring(j + prefixLength);\n                        }\n                    }\n                    if (best_common.length * 2 >= longtext.length) {\n                        return [\n                            best_longtext_a,\n                            best_longtext_b,\n                            best_shorttext_a,\n                            best_shorttext_b,\n                            best_common\n                        ];\n                    } else {\n                        return null;\n                    }\n                }\n                // First check if the second quarter is the seed for a half-match.\n                var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));\n                // Check again based on the third quarter.\n                var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));\n                var hm;\n                if (!hm1 && !hm2) {\n                    return null;\n                } else if (!hm2) {\n                    hm = hm1;\n                } else if (!hm1) {\n                    hm = hm2;\n                } else {\n                    // Both matched.  Select the longest.\n                    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n                }\n                // A half-match was found, sort out the return data.\n                var text1_a, text1_b, text2_a, text2_b;\n                if (text1.length > text2.length) {\n                    text1_a = hm[0];\n                    text1_b = hm[1];\n                    text2_a = hm[2];\n                    text2_b = hm[3];\n                } else {\n                    text2_a = hm[0];\n                    text2_b = hm[1];\n                    text1_a = hm[2];\n                    text1_b = hm[3];\n                }\n                var mid_common = hm[4];\n                return [\n                    text1_a,\n                    text1_b,\n                    text2_a,\n                    text2_b,\n                    mid_common\n                ];\n            }\n            ;\n            /**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {Array} diffs Array of diff tuples.\n */ function diff_cleanupMerge(diffs) {\n                diffs.push([\n                    DIFF_EQUAL,\n                    \"\"\n                ]); // Add a dummy entry at the end.\n                var pointer = 0;\n                var count_delete = 0;\n                var count_insert = 0;\n                var text_delete = \"\";\n                var text_insert = \"\";\n                var commonlength;\n                while(pointer < diffs.length){\n                    switch(diffs[pointer][0]){\n                        case DIFF_INSERT:\n                            count_insert++;\n                            text_insert += diffs[pointer][1];\n                            pointer++;\n                            break;\n                        case DIFF_DELETE:\n                            count_delete++;\n                            text_delete += diffs[pointer][1];\n                            pointer++;\n                            break;\n                        case DIFF_EQUAL:\n                            // Upon reaching an equality, check for prior redundancies.\n                            if (count_delete + count_insert > 1) {\n                                if (count_delete !== 0 && count_insert !== 0) {\n                                    // Factor out any common prefixies.\n                                    commonlength = diff_commonPrefix(text_insert, text_delete);\n                                    if (commonlength !== 0) {\n                                        if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {\n                                            diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);\n                                        } else {\n                                            diffs.splice(0, 0, [\n                                                DIFF_EQUAL,\n                                                text_insert.substring(0, commonlength)\n                                            ]);\n                                            pointer++;\n                                        }\n                                        text_insert = text_insert.substring(commonlength);\n                                        text_delete = text_delete.substring(commonlength);\n                                    }\n                                    // Factor out any common suffixies.\n                                    commonlength = diff_commonSuffix(text_insert, text_delete);\n                                    if (commonlength !== 0) {\n                                        diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n                                        text_insert = text_insert.substring(0, text_insert.length - commonlength);\n                                        text_delete = text_delete.substring(0, text_delete.length - commonlength);\n                                    }\n                                }\n                                // Delete the offending records and add the merged ones.\n                                if (count_delete === 0) {\n                                    diffs.splice(pointer - count_insert, count_delete + count_insert, [\n                                        DIFF_INSERT,\n                                        text_insert\n                                    ]);\n                                } else if (count_insert === 0) {\n                                    diffs.splice(pointer - count_delete, count_delete + count_insert, [\n                                        DIFF_DELETE,\n                                        text_delete\n                                    ]);\n                                } else {\n                                    diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [\n                                        DIFF_DELETE,\n                                        text_delete\n                                    ], [\n                                        DIFF_INSERT,\n                                        text_insert\n                                    ]);\n                                }\n                                pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n                            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n                                // Merge this equality with the previous one.\n                                diffs[pointer - 1][1] += diffs[pointer][1];\n                                diffs.splice(pointer, 1);\n                            } else {\n                                pointer++;\n                            }\n                            count_insert = 0;\n                            count_delete = 0;\n                            text_delete = \"\";\n                            text_insert = \"\";\n                            break;\n                    }\n                }\n                if (diffs[diffs.length - 1][1] === \"\") {\n                    diffs.pop(); // Remove the dummy entry at the end.\n                }\n                // Second pass: look for single edits surrounded on both sides by equalities\n                // which can be shifted sideways to eliminate an equality.\n                // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n                var changes = false;\n                pointer = 1;\n                // Intentionally ignore the first and last element (don't need checking).\n                while(pointer < diffs.length - 1){\n                    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {\n                        // This is a single edit surrounded by equalities.\n                        if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n                            // Shift the edit over the previous equality.\n                            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n                            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n                            diffs.splice(pointer - 1, 1);\n                            changes = true;\n                        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {\n                            // Shift the edit over the next equality.\n                            diffs[pointer - 1][1] += diffs[pointer + 1][1];\n                            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n                            diffs.splice(pointer + 1, 1);\n                            changes = true;\n                        }\n                    }\n                    pointer++;\n                }\n                // If shifts were made, the diff needs reordering and another shift sweep.\n                if (changes) {\n                    diff_cleanupMerge(diffs);\n                }\n            }\n            ;\n            var diff = diff_main;\n            diff.INSERT = DIFF_INSERT;\n            diff.DELETE = DIFF_DELETE;\n            diff.EQUAL = DIFF_EQUAL;\n            module1.exports = diff;\n            /*\n * Modify a diff such that the cursor position points to the start of a change:\n * E.g.\n *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)\n *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]\n *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)\n *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]\n *\n * @param {Array} diffs Array of diff tuples\n * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!\n * @return {Array} A tuple [cursor location in the modified diff, modified diff]\n */ function cursor_normalize_diff(diffs, cursor_pos) {\n                if (cursor_pos === 0) {\n                    return [\n                        DIFF_EQUAL,\n                        diffs\n                    ];\n                }\n                for(var current_pos = 0, i = 0; i < diffs.length; i++){\n                    var d = diffs[i];\n                    if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {\n                        var next_pos = current_pos + d[1].length;\n                        if (cursor_pos === next_pos) {\n                            return [\n                                i + 1,\n                                diffs\n                            ];\n                        } else if (cursor_pos < next_pos) {\n                            // copy to prevent side effects\n                            diffs = diffs.slice();\n                            // split d into two diff changes\n                            var split_pos = cursor_pos - current_pos;\n                            var d_left = [\n                                d[0],\n                                d[1].slice(0, split_pos)\n                            ];\n                            var d_right = [\n                                d[0],\n                                d[1].slice(split_pos)\n                            ];\n                            diffs.splice(i, 1, d_left, d_right);\n                            return [\n                                i + 1,\n                                diffs\n                            ];\n                        } else {\n                            current_pos = next_pos;\n                        }\n                    }\n                }\n                throw new Error(\"cursor_pos is out of bounds!\");\n            }\n            /*\n * Modify a diff such that the edit position is \"shifted\" to the proposed edit location (cursor_position).\n *\n * Case 1)\n *   Check if a naive shift is possible:\n *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)\n *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result\n * Case 2)\n *   Check if the following shifts are possible:\n *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']\n *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']\n *         ^            ^\n *         d          d_next\n *\n * @param {Array} diffs Array of diff tuples\n * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!\n * @return {Array} Array of diff tuples\n */ function fix_cursor(diffs, cursor_pos) {\n                var norm = cursor_normalize_diff(diffs, cursor_pos);\n                var ndiffs = norm[1];\n                var cursor_pointer = norm[0];\n                var d = ndiffs[cursor_pointer];\n                var d_next = ndiffs[cursor_pointer + 1];\n                if (d == null) {\n                    // Text was deleted from end of original string,\n                    // cursor is now out of bounds in new string\n                    return diffs;\n                } else if (d[0] !== DIFF_EQUAL) {\n                    // A modification happened at the cursor location.\n                    // This is the expected outcome, so we can return the original diff.\n                    return diffs;\n                } else {\n                    if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {\n                        // Case 1)\n                        // It is possible to perform a naive shift\n                        ndiffs.splice(cursor_pointer, 2, d_next, d);\n                        return merge_tuples(ndiffs, cursor_pointer, 2);\n                    } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {\n                        // Case 2)\n                        // d[1] is a prefix of d_next[1]\n                        // We can assume that d_next[0] !== 0, since d[0] === 0\n                        // Shift edit locations..\n                        ndiffs.splice(cursor_pointer, 2, [\n                            d_next[0],\n                            d[1]\n                        ], [\n                            0,\n                            d[1]\n                        ]);\n                        var suffix = d_next[1].slice(d[1].length);\n                        if (suffix.length > 0) {\n                            ndiffs.splice(cursor_pointer + 2, 0, [\n                                d_next[0],\n                                suffix\n                            ]);\n                        }\n                        return merge_tuples(ndiffs, cursor_pointer, 3);\n                    } else {\n                        // Not possible to perform any modification\n                        return diffs;\n                    }\n                }\n            }\n            /*\n * Check diff did not split surrogate pairs.\n * Ex. [0, '\\uD83D'], [-1, '\\uDC36'], [1, '\\uDC2F'] -> [-1, '\\uD83D\\uDC36'], [1, '\\uD83D\\uDC2F']\n *     '\\uD83D\\uDC36' === '🐶', '\\uD83D\\uDC2F' === '🐯'\n *\n * @param {Array} diffs Array of diff tuples\n * @return {Array} Array of diff tuples\n */ function fix_emoji(diffs) {\n                var compact = false;\n                var starts_with_pair_end = function(str) {\n                    return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;\n                };\n                var ends_with_pair_start = function(str) {\n                    return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;\n                };\n                for(var i = 2; i < diffs.length; i += 1){\n                    if (diffs[i - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i - 2][1]) && diffs[i - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i - 1][1]) && diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {\n                        compact = true;\n                        diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];\n                        diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];\n                        diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);\n                    }\n                }\n                if (!compact) {\n                    return diffs;\n                }\n                var fixed_diffs = [];\n                for(var i = 0; i < diffs.length; i += 1){\n                    if (diffs[i][1].length > 0) {\n                        fixed_diffs.push(diffs[i]);\n                    }\n                }\n                return fixed_diffs;\n            }\n            /*\n * Try to merge tuples with their neigbors in a given range.\n * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']\n *\n * @param {Array} diffs Array of diff tuples.\n * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).\n * @param {Int} length Number of consecutive elements to check.\n * @return {Array} Array of merged diff tuples.\n */ function merge_tuples(diffs, start, length) {\n                // Check from (start-1) to (start+length).\n                for(var i = start + length - 1; i >= 0 && i >= start - 1; i--){\n                    if (i + 1 < diffs.length) {\n                        var left_d = diffs[i];\n                        var right_d = diffs[i + 1];\n                        if (left_d[0] === right_d[1]) {\n                            diffs.splice(i, 2, [\n                                left_d[0],\n                                left_d[1] + right_d[1]\n                            ]);\n                        }\n                    }\n                }\n                return diffs;\n            }\n        /***/ },\n        /* 52 */ /***/ function(module1, exports1) {\n            exports1 = module1.exports = typeof Object.keys === \"function\" ? Object.keys : shim;\n            exports1.shim = shim;\n            function shim(obj) {\n                var keys = [];\n                for(var key in obj)keys.push(key);\n                return keys;\n            }\n        /***/ },\n        /* 53 */ /***/ function(module1, exports1) {\n            var supportsArgumentsClass = function() {\n                return Object.prototype.toString.call(arguments);\n            }() == \"[object Arguments]\";\n            exports1 = module1.exports = supportsArgumentsClass ? supported : unsupported;\n            exports1.supported = supported;\n            function supported(object) {\n                return Object.prototype.toString.call(object) == \"[object Arguments]\";\n            }\n            ;\n            exports1.unsupported = unsupported;\n            function unsupported(object) {\n                return object && typeof object == \"object\" && typeof object.length == \"number\" && Object.prototype.hasOwnProperty.call(object, \"callee\") && !Object.prototype.propertyIsEnumerable.call(object, \"callee\") || false;\n            }\n            ;\n        /***/ },\n        /* 54 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            var has = Object.prototype.hasOwnProperty, prefix = \"~\";\n            /**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @api private\n */ function Events() {}\n            //\n            // We try to not inherit from `Object.prototype`. In some engines creating an\n            // instance in this way is faster than calling `Object.create(null)` directly.\n            // If `Object.create(null)` is not supported we prefix the event names with a\n            // character to make sure that the built-in object properties are not\n            // overridden or used as an attack vector.\n            //\n            if (Object.create) {\n                Events.prototype = Object.create(null);\n                //\n                // This hack is needed because the `__proto__` property is still inherited in\n                // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n                //\n                if (!new Events().__proto__) prefix = false;\n            }\n            /**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {Mixed} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @api private\n */ function EE(fn, context, once) {\n                this.fn = fn;\n                this.context = context;\n                this.once = once || false;\n            }\n            /**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @api public\n */ function EventEmitter() {\n                this._events = new Events();\n                this._eventsCount = 0;\n            }\n            /**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */ EventEmitter.prototype.eventNames = function eventNames() {\n                var names = [], events, name;\n                if (this._eventsCount === 0) return names;\n                for(name in events = this._events){\n                    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n                }\n                if (Object.getOwnPropertySymbols) {\n                    return names.concat(Object.getOwnPropertySymbols(events));\n                }\n                return names;\n            };\n            /**\n * Return the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Boolean} exists Only check if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */ EventEmitter.prototype.listeners = function listeners(event, exists) {\n                var evt = prefix ? prefix + event : event, available = this._events[evt];\n                if (exists) return !!available;\n                if (!available) return [];\n                if (available.fn) return [\n                    available.fn\n                ];\n                for(var i = 0, l = available.length, ee = new Array(l); i < l; i++){\n                    ee[i] = available[i].fn;\n                }\n                return ee;\n            };\n            /**\n * Calls each of the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @api public\n */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n                var evt = prefix ? prefix + event : event;\n                if (!this._events[evt]) return false;\n                var listeners = this._events[evt], len = arguments.length, args, i;\n                if (listeners.fn) {\n                    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n                    switch(len){\n                        case 1:\n                            return listeners.fn.call(listeners.context), true;\n                        case 2:\n                            return listeners.fn.call(listeners.context, a1), true;\n                        case 3:\n                            return listeners.fn.call(listeners.context, a1, a2), true;\n                        case 4:\n                            return listeners.fn.call(listeners.context, a1, a2, a3), true;\n                        case 5:\n                            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n                        case 6:\n                            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n                    }\n                    for(i = 1, args = new Array(len - 1); i < len; i++){\n                        args[i - 1] = arguments[i];\n                    }\n                    listeners.fn.apply(listeners.context, args);\n                } else {\n                    var length = listeners.length, j;\n                    for(i = 0; i < length; i++){\n                        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n                        switch(len){\n                            case 1:\n                                listeners[i].fn.call(listeners[i].context);\n                                break;\n                            case 2:\n                                listeners[i].fn.call(listeners[i].context, a1);\n                                break;\n                            case 3:\n                                listeners[i].fn.call(listeners[i].context, a1, a2);\n                                break;\n                            case 4:\n                                listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                                break;\n                            default:\n                                if (!args) for(j = 1, args = new Array(len - 1); j < len; j++){\n                                    args[j - 1] = arguments[j];\n                                }\n                                listeners[i].fn.apply(listeners[i].context, args);\n                        }\n                    }\n                }\n                return true;\n            };\n            /**\n * Add a listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */ EventEmitter.prototype.on = function on(event, fn, context) {\n                var listener = new EE(fn, context || this), evt = prefix ? prefix + event : event;\n                if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n                else if (!this._events[evt].fn) this._events[evt].push(listener);\n                else this._events[evt] = [\n                    this._events[evt],\n                    listener\n                ];\n                return this;\n            };\n            /**\n * Add a one-time listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */ EventEmitter.prototype.once = function once(event, fn, context) {\n                var listener = new EE(fn, context || this, true), evt = prefix ? prefix + event : event;\n                if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n                else if (!this._events[evt].fn) this._events[evt].push(listener);\n                else this._events[evt] = [\n                    this._events[evt],\n                    listener\n                ];\n                return this;\n            };\n            /**\n * Remove the listeners of a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {Mixed} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @api public\n */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n                var evt = prefix ? prefix + event : event;\n                if (!this._events[evt]) return this;\n                if (!fn) {\n                    if (--this._eventsCount === 0) this._events = new Events();\n                    else delete this._events[evt];\n                    return this;\n                }\n                var listeners = this._events[evt];\n                if (listeners.fn) {\n                    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n                        if (--this._eventsCount === 0) this._events = new Events();\n                        else delete this._events[evt];\n                    }\n                } else {\n                    for(var i = 0, events = [], length = listeners.length; i < length; i++){\n                        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n                            events.push(listeners[i]);\n                        }\n                    }\n                    //\n                    // Reset the array, or remove it completely if we have no more listeners.\n                    //\n                    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n                    else if (--this._eventsCount === 0) this._events = new Events();\n                    else delete this._events[evt];\n                }\n                return this;\n            };\n            /**\n * Remove all listeners, or those of the specified event.\n *\n * @param {String|Symbol} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @api public\n */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n                var evt;\n                if (event) {\n                    evt = prefix ? prefix + event : event;\n                    if (this._events[evt]) {\n                        if (--this._eventsCount === 0) this._events = new Events();\n                        else delete this._events[evt];\n                    }\n                } else {\n                    this._events = new Events();\n                    this._eventsCount = 0;\n                }\n                return this;\n            };\n            //\n            // Alias methods names because people roll like that.\n            //\n            EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n            EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n            //\n            // This function doesn't apply anymore.\n            //\n            EventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n                return this;\n            };\n            //\n            // Expose the prefix.\n            //\n            EventEmitter.prefixed = prefix;\n            //\n            // Allow `EventEmitter` to be imported as module namespace.\n            //\n            EventEmitter.EventEmitter = EventEmitter;\n            //\n            // Expose the module.\n            //\n            if (\"undefined\" !== typeof module1) {\n                module1.exports = EventEmitter;\n            }\n        /***/ },\n        /* 55 */ /***/ function(module1, exports1, __nested_webpack_require_472657__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.matchText = exports1.matchSpacing = exports1.matchNewline = exports1.matchBlot = exports1.matchAttributor = exports1.default = undefined;\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _extend2 = __nested_webpack_require_472657__(3);\n            var _extend3 = _interopRequireDefault(_extend2);\n            var _quillDelta = __nested_webpack_require_472657__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _parchment = __nested_webpack_require_472657__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_472657__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _logger = __nested_webpack_require_472657__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            var _module = __nested_webpack_require_472657__(9);\n            var _module2 = _interopRequireDefault(_module);\n            var _align = __nested_webpack_require_472657__(36);\n            var _background = __nested_webpack_require_472657__(37);\n            var _code = __nested_webpack_require_472657__(13);\n            var _code2 = _interopRequireDefault(_code);\n            var _color = __nested_webpack_require_472657__(26);\n            var _direction = __nested_webpack_require_472657__(38);\n            var _font = __nested_webpack_require_472657__(39);\n            var _size = __nested_webpack_require_472657__(40);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var debug = (0, _logger2.default)(\"quill:clipboard\");\n            var DOM_KEY = \"__ql-matcher\";\n            var CLIPBOARD_CONFIG = [\n                [\n                    Node.TEXT_NODE,\n                    matchText\n                ],\n                [\n                    Node.TEXT_NODE,\n                    matchNewline\n                ],\n                [\n                    \"br\",\n                    matchBreak\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchNewline\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchBlot\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchSpacing\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchAttributor\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchStyles\n                ],\n                [\n                    \"li\",\n                    matchIndent\n                ],\n                [\n                    \"b\",\n                    matchAlias.bind(matchAlias, \"bold\")\n                ],\n                [\n                    \"i\",\n                    matchAlias.bind(matchAlias, \"italic\")\n                ],\n                [\n                    \"style\",\n                    matchIgnore\n                ]\n            ];\n            var ATTRIBUTE_ATTRIBUTORS = [\n                _align.AlignAttribute,\n                _direction.DirectionAttribute\n            ].reduce(function(memo, attr) {\n                memo[attr.keyName] = attr;\n                return memo;\n            }, {});\n            var STYLE_ATTRIBUTORS = [\n                _align.AlignStyle,\n                _background.BackgroundStyle,\n                _color.ColorStyle,\n                _direction.DirectionStyle,\n                _font.FontStyle,\n                _size.SizeStyle\n            ].reduce(function(memo, attr) {\n                memo[attr.keyName] = attr;\n                return memo;\n            }, {});\n            var Clipboard = function(_Module) {\n                _inherits(Clipboard, _Module);\n                function Clipboard(quill, options) {\n                    _classCallCheck(this, Clipboard);\n                    var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this, quill, options));\n                    _this.quill.root.addEventListener(\"paste\", _this.onPaste.bind(_this));\n                    _this.container = _this.quill.addContainer(\"ql-clipboard\");\n                    _this.container.setAttribute(\"contenteditable\", true);\n                    _this.container.setAttribute(\"tabindex\", -1);\n                    _this.matchers = [];\n                    CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function(_ref) {\n                        var _ref2 = _slicedToArray(_ref, 2), selector = _ref2[0], matcher = _ref2[1];\n                        if (!options.matchVisual && matcher === matchSpacing) return;\n                        _this.addMatcher(selector, matcher);\n                    });\n                    return _this;\n                }\n                _createClass(Clipboard, [\n                    {\n                        key: \"addMatcher\",\n                        value: function addMatcher(selector, matcher) {\n                            this.matchers.push([\n                                selector,\n                                matcher\n                            ]);\n                        }\n                    },\n                    {\n                        key: \"convert\",\n                        value: function convert(html) {\n                            if (typeof html === \"string\") {\n                                this.container.innerHTML = html.replace(/\\>\\r?\\n +\\</g, \"><\"); // Remove spaces between tags\n                                return this.convert();\n                            }\n                            var formats = this.quill.getFormat(this.quill.selection.savedRange.index);\n                            if (formats[_code2.default.blotName]) {\n                                var text = this.container.innerText;\n                                this.container.innerHTML = \"\";\n                                return new _quillDelta2.default().insert(text, _defineProperty({}, _code2.default.blotName, formats[_code2.default.blotName]));\n                            }\n                            var _prepareMatching = this.prepareMatching(), _prepareMatching2 = _slicedToArray(_prepareMatching, 2), elementMatchers = _prepareMatching2[0], textMatchers = _prepareMatching2[1];\n                            var delta = traverse(this.container, elementMatchers, textMatchers);\n                            // Remove trailing newline\n                            if (deltaEndsWith(delta, \"\\n\") && delta.ops[delta.ops.length - 1].attributes == null) {\n                                delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));\n                            }\n                            debug.log(\"convert\", this.container.innerHTML, delta);\n                            this.container.innerHTML = \"\";\n                            return delta;\n                        }\n                    },\n                    {\n                        key: \"dangerouslyPasteHTML\",\n                        value: function dangerouslyPasteHTML(index, html) {\n                            var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _quill2.default.sources.API;\n                            if (typeof index === \"string\") {\n                                this.quill.setContents(this.convert(index), html);\n                                this.quill.setSelection(0, _quill2.default.sources.SILENT);\n                            } else {\n                                var paste = this.convert(html);\n                                this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste), source);\n                                this.quill.setSelection(index + paste.length(), _quill2.default.sources.SILENT);\n                            }\n                        }\n                    },\n                    {\n                        key: \"onPaste\",\n                        value: function onPaste(e) {\n                            var _this2 = this;\n                            if (e.defaultPrevented || !this.quill.isEnabled()) return;\n                            var range = this.quill.getSelection();\n                            var delta = new _quillDelta2.default().retain(range.index);\n                            var scrollTop = this.quill.scrollingContainer.scrollTop;\n                            this.container.focus();\n                            this.quill.selection.update(_quill2.default.sources.SILENT);\n                            setTimeout(function() {\n                                delta = delta.concat(_this2.convert()).delete(range.length);\n                                _this2.quill.updateContents(delta, _quill2.default.sources.USER);\n                                // range.length contributes to delta.length()\n                                _this2.quill.setSelection(delta.length() - range.length, _quill2.default.sources.SILENT);\n                                _this2.quill.scrollingContainer.scrollTop = scrollTop;\n                                _this2.quill.focus();\n                            }, 1);\n                        }\n                    },\n                    {\n                        key: \"prepareMatching\",\n                        value: function prepareMatching() {\n                            var _this3 = this;\n                            var elementMatchers = [], textMatchers = [];\n                            this.matchers.forEach(function(pair) {\n                                var _pair = _slicedToArray(pair, 2), selector = _pair[0], matcher = _pair[1];\n                                switch(selector){\n                                    case Node.TEXT_NODE:\n                                        textMatchers.push(matcher);\n                                        break;\n                                    case Node.ELEMENT_NODE:\n                                        elementMatchers.push(matcher);\n                                        break;\n                                    default:\n                                        [].forEach.call(_this3.container.querySelectorAll(selector), function(node) {\n                                            // TODO use weakmap\n                                            node[DOM_KEY] = node[DOM_KEY] || [];\n                                            node[DOM_KEY].push(matcher);\n                                        });\n                                        break;\n                                }\n                            });\n                            return [\n                                elementMatchers,\n                                textMatchers\n                            ];\n                        }\n                    }\n                ]);\n                return Clipboard;\n            }(_module2.default);\n            Clipboard.DEFAULTS = {\n                matchers: [],\n                matchVisual: true\n            };\n            function applyFormat(delta, format, value) {\n                if ((typeof format === \"undefined\" ? \"undefined\" : _typeof(format)) === \"object\") {\n                    return Object.keys(format).reduce(function(delta, key) {\n                        return applyFormat(delta, key, format[key]);\n                    }, delta);\n                } else {\n                    return delta.reduce(function(delta, op) {\n                        if (op.attributes && op.attributes[format]) {\n                            return delta.push(op);\n                        } else {\n                            return delta.insert(op.insert, (0, _extend3.default)({}, _defineProperty({}, format, value), op.attributes));\n                        }\n                    }, new _quillDelta2.default());\n                }\n            }\n            function computeStyle(node) {\n                if (node.nodeType !== Node.ELEMENT_NODE) return {};\n                var DOM_KEY = \"__ql-computed-style\";\n                return node[DOM_KEY] || (node[DOM_KEY] = window.getComputedStyle(node));\n            }\n            function deltaEndsWith(delta, text) {\n                var endText = \"\";\n                for(var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i){\n                    var op = delta.ops[i];\n                    if (typeof op.insert !== \"string\") break;\n                    endText = op.insert + endText;\n                }\n                return endText.slice(-1 * text.length) === text;\n            }\n            function isLine(node) {\n                if (node.childNodes.length === 0) return false; // Exclude embed blocks\n                var style = computeStyle(node);\n                return [\n                    \"block\",\n                    \"list-item\"\n                ].indexOf(style.display) > -1;\n            }\n            function traverse(node, elementMatchers, textMatchers) {\n                // Post-order\n                if (node.nodeType === node.TEXT_NODE) {\n                    return textMatchers.reduce(function(delta, matcher) {\n                        return matcher(node, delta);\n                    }, new _quillDelta2.default());\n                } else if (node.nodeType === node.ELEMENT_NODE) {\n                    return [].reduce.call(node.childNodes || [], function(delta, childNode) {\n                        var childrenDelta = traverse(childNode, elementMatchers, textMatchers);\n                        if (childNode.nodeType === node.ELEMENT_NODE) {\n                            childrenDelta = elementMatchers.reduce(function(childrenDelta, matcher) {\n                                return matcher(childNode, childrenDelta);\n                            }, childrenDelta);\n                            childrenDelta = (childNode[DOM_KEY] || []).reduce(function(childrenDelta, matcher) {\n                                return matcher(childNode, childrenDelta);\n                            }, childrenDelta);\n                        }\n                        return delta.concat(childrenDelta);\n                    }, new _quillDelta2.default());\n                } else {\n                    return new _quillDelta2.default();\n                }\n            }\n            function matchAlias(format, node, delta) {\n                return applyFormat(delta, format, true);\n            }\n            function matchAttributor(node, delta) {\n                var attributes = _parchment2.default.Attributor.Attribute.keys(node);\n                var classes = _parchment2.default.Attributor.Class.keys(node);\n                var styles = _parchment2.default.Attributor.Style.keys(node);\n                var formats = {};\n                attributes.concat(classes).concat(styles).forEach(function(name) {\n                    var attr = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);\n                    if (attr != null) {\n                        formats[attr.attrName] = attr.value(node);\n                        if (formats[attr.attrName]) return;\n                    }\n                    attr = ATTRIBUTE_ATTRIBUTORS[name];\n                    if (attr != null && (attr.attrName === name || attr.keyName === name)) {\n                        formats[attr.attrName] = attr.value(node) || undefined;\n                    }\n                    attr = STYLE_ATTRIBUTORS[name];\n                    if (attr != null && (attr.attrName === name || attr.keyName === name)) {\n                        attr = STYLE_ATTRIBUTORS[name];\n                        formats[attr.attrName] = attr.value(node) || undefined;\n                    }\n                });\n                if (Object.keys(formats).length > 0) {\n                    delta = applyFormat(delta, formats);\n                }\n                return delta;\n            }\n            function matchBlot(node, delta) {\n                var match = _parchment2.default.query(node);\n                if (match == null) return delta;\n                if (match.prototype instanceof _parchment2.default.Embed) {\n                    var embed = {};\n                    var value = match.value(node);\n                    if (value != null) {\n                        embed[match.blotName] = value;\n                        delta = new _quillDelta2.default().insert(embed, match.formats(node));\n                    }\n                } else if (typeof match.formats === \"function\") {\n                    delta = applyFormat(delta, match.blotName, match.formats(node));\n                }\n                return delta;\n            }\n            function matchBreak(node, delta) {\n                if (!deltaEndsWith(delta, \"\\n\")) {\n                    delta.insert(\"\\n\");\n                }\n                return delta;\n            }\n            function matchIgnore() {\n                return new _quillDelta2.default();\n            }\n            function matchIndent(node, delta) {\n                var match = _parchment2.default.query(node);\n                if (match == null || match.blotName !== \"list-item\" || !deltaEndsWith(delta, \"\\n\")) {\n                    return delta;\n                }\n                var indent = -1, parent = node.parentNode;\n                while(!parent.classList.contains(\"ql-clipboard\")){\n                    if ((_parchment2.default.query(parent) || {}).blotName === \"list\") {\n                        indent += 1;\n                    }\n                    parent = parent.parentNode;\n                }\n                if (indent <= 0) return delta;\n                return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, {\n                    indent: indent\n                }));\n            }\n            function matchNewline(node, delta) {\n                if (!deltaEndsWith(delta, \"\\n\")) {\n                    if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {\n                        delta.insert(\"\\n\");\n                    }\n                }\n                return delta;\n            }\n            function matchSpacing(node, delta) {\n                if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, \"\\n\\n\")) {\n                    var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);\n                    if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {\n                        delta.insert(\"\\n\");\n                    }\n                }\n                return delta;\n            }\n            function matchStyles(node, delta) {\n                var formats = {};\n                var style = node.style || {};\n                if (style.fontStyle && computeStyle(node).fontStyle === \"italic\") {\n                    formats.italic = true;\n                }\n                if (style.fontWeight && (computeStyle(node).fontWeight.startsWith(\"bold\") || parseInt(computeStyle(node).fontWeight) >= 700)) {\n                    formats.bold = true;\n                }\n                if (Object.keys(formats).length > 0) {\n                    delta = applyFormat(delta, formats);\n                }\n                if (parseFloat(style.textIndent || 0) > 0) {\n                    // Could be 0.5in\n                    delta = new _quillDelta2.default().insert(\"\t\").concat(delta);\n                }\n                return delta;\n            }\n            function matchText(node, delta) {\n                var text = node.data;\n                // Word represents empty line with <o:p>&nbsp;</o:p>\n                if (node.parentNode.tagName === \"O:P\") {\n                    return delta.insert(text.trim());\n                }\n                if (text.trim().length === 0 && node.parentNode.classList.contains(\"ql-clipboard\")) {\n                    return delta;\n                }\n                if (!computeStyle(node.parentNode).whiteSpace.startsWith(\"pre\")) {\n                    // eslint-disable-next-line func-style\n                    var replacer = function replacer(collapse, match) {\n                        match = match.replace(/[^\\u00a0]/g, \"\"); // \\u00a0 is nbsp;\n                        return match.length < 1 && collapse ? \" \" : match;\n                    };\n                    text = text.replace(/\\r\\n/g, \" \").replace(/\\n/g, \" \");\n                    text = text.replace(/\\s\\s+/g, replacer.bind(replacer, true)); // collapse whitespace\n                    if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {\n                        text = text.replace(/^\\s+/, replacer.bind(replacer, false));\n                    }\n                    if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {\n                        text = text.replace(/\\s+$/, replacer.bind(replacer, false));\n                    }\n                }\n                return delta.insert(text);\n            }\n            exports1.default = Clipboard;\n            exports1.matchAttributor = matchAttributor;\n            exports1.matchBlot = matchBlot;\n            exports1.matchNewline = matchNewline;\n            exports1.matchSpacing = matchSpacing;\n            exports1.matchText = matchText;\n        /***/ },\n        /* 56 */ /***/ function(module1, exports1, __nested_webpack_require_498245__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _inline = __nested_webpack_require_498245__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Bold = function(_Inline) {\n                _inherits(Bold, _Inline);\n                function Bold() {\n                    _classCallCheck(this, Bold);\n                    return _possibleConstructorReturn(this, (Bold.__proto__ || Object.getPrototypeOf(Bold)).apply(this, arguments));\n                }\n                _createClass(Bold, [\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            _get(Bold.prototype.__proto__ || Object.getPrototypeOf(Bold.prototype), \"optimize\", this).call(this, context);\n                            if (this.domNode.tagName !== this.statics.tagName[0]) {\n                                this.replaceWith(this.statics.blotName);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create() {\n                            return _get(Bold.__proto__ || Object.getPrototypeOf(Bold), \"create\", this).call(this);\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats() {\n                            return true;\n                        }\n                    }\n                ]);\n                return Bold;\n            }(_inline2.default);\n            Bold.blotName = \"bold\";\n            Bold.tagName = [\n                \"STRONG\",\n                \"B\"\n            ];\n            exports1.default = Bold;\n        /***/ },\n        /* 57 */ /***/ function(module1, exports1, __nested_webpack_require_503400__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.addControls = exports1.default = undefined;\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _quillDelta = __nested_webpack_require_503400__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _parchment = __nested_webpack_require_503400__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_503400__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _logger = __nested_webpack_require_503400__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            var _module = __nested_webpack_require_503400__(9);\n            var _module2 = _interopRequireDefault(_module);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var debug = (0, _logger2.default)(\"quill:toolbar\");\n            var Toolbar = function(_Module) {\n                _inherits(Toolbar, _Module);\n                function Toolbar(quill, options) {\n                    _classCallCheck(this, Toolbar);\n                    var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, quill, options));\n                    if (Array.isArray(_this.options.container)) {\n                        var container = document.createElement(\"div\");\n                        addControls(container, _this.options.container);\n                        quill.container.parentNode.insertBefore(container, quill.container);\n                        _this.container = container;\n                    } else if (typeof _this.options.container === \"string\") {\n                        _this.container = document.querySelector(_this.options.container);\n                    } else {\n                        _this.container = _this.options.container;\n                    }\n                    if (!(_this.container instanceof HTMLElement)) {\n                        var _ret;\n                        return _ret = debug.error(\"Container required for toolbar\", _this.options), _possibleConstructorReturn(_this, _ret);\n                    }\n                    _this.container.classList.add(\"ql-toolbar\");\n                    _this.controls = [];\n                    _this.handlers = {};\n                    Object.keys(_this.options.handlers).forEach(function(format) {\n                        _this.addHandler(format, _this.options.handlers[format]);\n                    });\n                    [].forEach.call(_this.container.querySelectorAll(\"button, select\"), function(input) {\n                        _this.attach(input);\n                    });\n                    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(type, range) {\n                        if (type === _quill2.default.events.SELECTION_CHANGE) {\n                            _this.update(range);\n                        }\n                    });\n                    _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {\n                        var _this$quill$selection = _this.quill.selection.getRange(), _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1), range = _this$quill$selection2[0]; // quill.getSelection triggers update\n                        _this.update(range);\n                    });\n                    return _this;\n                }\n                _createClass(Toolbar, [\n                    {\n                        key: \"addHandler\",\n                        value: function addHandler(format, handler) {\n                            this.handlers[format] = handler;\n                        }\n                    },\n                    {\n                        key: \"attach\",\n                        value: function attach(input) {\n                            var _this2 = this;\n                            var format = [].find.call(input.classList, function(className) {\n                                return className.indexOf(\"ql-\") === 0;\n                            });\n                            if (!format) return;\n                            format = format.slice(\"ql-\".length);\n                            if (input.tagName === \"BUTTON\") {\n                                input.setAttribute(\"type\", \"button\");\n                            }\n                            if (this.handlers[format] == null) {\n                                if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format] == null) {\n                                    debug.warn(\"ignoring attaching to disabled format\", format, input);\n                                    return;\n                                }\n                                if (_parchment2.default.query(format) == null) {\n                                    debug.warn(\"ignoring attaching to nonexistent format\", format, input);\n                                    return;\n                                }\n                            }\n                            var eventName = input.tagName === \"SELECT\" ? \"change\" : \"click\";\n                            input.addEventListener(eventName, function(e) {\n                                var value = void 0;\n                                if (input.tagName === \"SELECT\") {\n                                    if (input.selectedIndex < 0) return;\n                                    var selected = input.options[input.selectedIndex];\n                                    if (selected.hasAttribute(\"selected\")) {\n                                        value = false;\n                                    } else {\n                                        value = selected.value || false;\n                                    }\n                                } else {\n                                    if (input.classList.contains(\"ql-active\")) {\n                                        value = false;\n                                    } else {\n                                        value = input.value || !input.hasAttribute(\"value\");\n                                    }\n                                    e.preventDefault();\n                                }\n                                _this2.quill.focus();\n                                var _quill$selection$getR = _this2.quill.selection.getRange(), _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1), range = _quill$selection$getR2[0];\n                                if (_this2.handlers[format] != null) {\n                                    _this2.handlers[format].call(_this2, value);\n                                } else if (_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed) {\n                                    value = prompt(\"Enter \" + format);\n                                    if (!value) return;\n                                    _this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty({}, format, value)), _quill2.default.sources.USER);\n                                } else {\n                                    _this2.quill.format(format, value, _quill2.default.sources.USER);\n                                }\n                                _this2.update(range);\n                            });\n                            // TODO use weakmap\n                            this.controls.push([\n                                format,\n                                input\n                            ]);\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(range) {\n                            var formats = range == null ? {} : this.quill.getFormat(range);\n                            this.controls.forEach(function(pair) {\n                                var _pair = _slicedToArray(pair, 2), format = _pair[0], input = _pair[1];\n                                if (input.tagName === \"SELECT\") {\n                                    var option = void 0;\n                                    if (range == null) {\n                                        option = null;\n                                    } else if (formats[format] == null) {\n                                        option = input.querySelector(\"option[selected]\");\n                                    } else if (!Array.isArray(formats[format])) {\n                                        var value = formats[format];\n                                        if (typeof value === \"string\") {\n                                            value = value.replace(/\\\"/g, '\\\\\"');\n                                        }\n                                        option = input.querySelector('option[value=\"' + value + '\"]');\n                                    }\n                                    if (option == null) {\n                                        input.value = \"\"; // TODO make configurable?\n                                        input.selectedIndex = -1;\n                                    } else {\n                                        option.selected = true;\n                                    }\n                                } else {\n                                    if (range == null) {\n                                        input.classList.remove(\"ql-active\");\n                                    } else if (input.hasAttribute(\"value\")) {\n                                        // both being null should match (default values)\n                                        // '1' should match with 1 (headers)\n                                        var isActive = formats[format] === input.getAttribute(\"value\") || formats[format] != null && formats[format].toString() === input.getAttribute(\"value\") || formats[format] == null && !input.getAttribute(\"value\");\n                                        input.classList.toggle(\"ql-active\", isActive);\n                                    } else {\n                                        input.classList.toggle(\"ql-active\", formats[format] != null);\n                                    }\n                                }\n                            });\n                        }\n                    }\n                ]);\n                return Toolbar;\n            }(_module2.default);\n            Toolbar.DEFAULTS = {};\n            function addButton(container, format, value) {\n                var input = document.createElement(\"button\");\n                input.setAttribute(\"type\", \"button\");\n                input.classList.add(\"ql-\" + format);\n                if (value != null) {\n                    input.value = value;\n                }\n                container.appendChild(input);\n            }\n            function addControls(container, groups) {\n                if (!Array.isArray(groups[0])) {\n                    groups = [\n                        groups\n                    ];\n                }\n                groups.forEach(function(controls) {\n                    var group = document.createElement(\"span\");\n                    group.classList.add(\"ql-formats\");\n                    controls.forEach(function(control) {\n                        if (typeof control === \"string\") {\n                            addButton(group, control);\n                        } else {\n                            var format = Object.keys(control)[0];\n                            var value = control[format];\n                            if (Array.isArray(value)) {\n                                addSelect(group, format, value);\n                            } else {\n                                addButton(group, format, value);\n                            }\n                        }\n                    });\n                    container.appendChild(group);\n                });\n            }\n            function addSelect(container, format, values) {\n                var input = document.createElement(\"select\");\n                input.classList.add(\"ql-\" + format);\n                values.forEach(function(value) {\n                    var option = document.createElement(\"option\");\n                    if (value !== false) {\n                        option.setAttribute(\"value\", value);\n                    } else {\n                        option.setAttribute(\"selected\", \"selected\");\n                    }\n                    input.appendChild(option);\n                });\n                container.appendChild(input);\n            }\n            Toolbar.DEFAULTS = {\n                container: null,\n                handlers: {\n                    clean: function clean() {\n                        var _this3 = this;\n                        var range = this.quill.getSelection();\n                        if (range == null) return;\n                        if (range.length == 0) {\n                            var formats = this.quill.getFormat();\n                            Object.keys(formats).forEach(function(name) {\n                                // Clean functionality in existing apps only clean inline formats\n                                if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {\n                                    _this3.quill.format(name, false);\n                                }\n                            });\n                        } else {\n                            this.quill.removeFormat(range, _quill2.default.sources.USER);\n                        }\n                    },\n                    direction: function direction(value) {\n                        var align = this.quill.getFormat()[\"align\"];\n                        if (value === \"rtl\" && align == null) {\n                            this.quill.format(\"align\", \"right\", _quill2.default.sources.USER);\n                        } else if (!value && align === \"right\") {\n                            this.quill.format(\"align\", false, _quill2.default.sources.USER);\n                        }\n                        this.quill.format(\"direction\", value, _quill2.default.sources.USER);\n                    },\n                    indent: function indent(value) {\n                        var range = this.quill.getSelection();\n                        var formats = this.quill.getFormat(range);\n                        var indent = parseInt(formats.indent || 0);\n                        if (value === \"+1\" || value === \"-1\") {\n                            var modifier = value === \"+1\" ? 1 : -1;\n                            if (formats.direction === \"rtl\") modifier *= -1;\n                            this.quill.format(\"indent\", indent + modifier, _quill2.default.sources.USER);\n                        }\n                    },\n                    link: function link(value) {\n                        if (value === true) {\n                            value = prompt(\"Enter link URL:\");\n                        }\n                        this.quill.format(\"link\", value, _quill2.default.sources.USER);\n                    },\n                    list: function list(value) {\n                        var range = this.quill.getSelection();\n                        var formats = this.quill.getFormat(range);\n                        if (value === \"check\") {\n                            if (formats[\"list\"] === \"checked\" || formats[\"list\"] === \"unchecked\") {\n                                this.quill.format(\"list\", false, _quill2.default.sources.USER);\n                            } else {\n                                this.quill.format(\"list\", \"unchecked\", _quill2.default.sources.USER);\n                            }\n                        } else {\n                            this.quill.format(\"list\", value, _quill2.default.sources.USER);\n                        }\n                    }\n                }\n            };\n            exports1.default = Toolbar;\n            exports1.addControls = addControls;\n        /***/ },\n        /* 58 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>';\n        /***/ },\n        /* 59 */ /***/ function(module1, exports1, __nested_webpack_require_523754__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _picker = __nested_webpack_require_523754__(28);\n            var _picker2 = _interopRequireDefault(_picker);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ColorPicker = function(_Picker) {\n                _inherits(ColorPicker, _Picker);\n                function ColorPicker(select, label) {\n                    _classCallCheck(this, ColorPicker);\n                    var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, select));\n                    _this.label.innerHTML = label;\n                    _this.container.classList.add(\"ql-color-picker\");\n                    [].slice.call(_this.container.querySelectorAll(\".ql-picker-item\"), 0, 7).forEach(function(item) {\n                        item.classList.add(\"ql-primary\");\n                    });\n                    return _this;\n                }\n                _createClass(ColorPicker, [\n                    {\n                        key: \"buildItem\",\n                        value: function buildItem(option) {\n                            var item = _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), \"buildItem\", this).call(this, option);\n                            item.style.backgroundColor = option.getAttribute(\"value\") || \"\";\n                            return item;\n                        }\n                    },\n                    {\n                        key: \"selectItem\",\n                        value: function selectItem(item, trigger) {\n                            _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), \"selectItem\", this).call(this, item, trigger);\n                            var colorLabel = this.label.querySelector(\".ql-color-label\");\n                            var value = item ? item.getAttribute(\"data-value\") || \"\" : \"\";\n                            if (colorLabel) {\n                                if (colorLabel.tagName === \"line\") {\n                                    colorLabel.style.stroke = value;\n                                } else {\n                                    colorLabel.style.fill = value;\n                                }\n                            }\n                        }\n                    }\n                ]);\n                return ColorPicker;\n            }(_picker2.default);\n            exports1.default = ColorPicker;\n        /***/ },\n        /* 60 */ /***/ function(module1, exports1, __nested_webpack_require_529569__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _picker = __nested_webpack_require_529569__(28);\n            var _picker2 = _interopRequireDefault(_picker);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var IconPicker = function(_Picker) {\n                _inherits(IconPicker, _Picker);\n                function IconPicker(select, icons) {\n                    _classCallCheck(this, IconPicker);\n                    var _this = _possibleConstructorReturn(this, (IconPicker.__proto__ || Object.getPrototypeOf(IconPicker)).call(this, select));\n                    _this.container.classList.add(\"ql-icon-picker\");\n                    [].forEach.call(_this.container.querySelectorAll(\".ql-picker-item\"), function(item) {\n                        item.innerHTML = icons[item.getAttribute(\"data-value\") || \"\"];\n                    });\n                    _this.defaultItem = _this.container.querySelector(\".ql-selected\");\n                    _this.selectItem(_this.defaultItem);\n                    return _this;\n                }\n                _createClass(IconPicker, [\n                    {\n                        key: \"selectItem\",\n                        value: function selectItem(item, trigger) {\n                            _get(IconPicker.prototype.__proto__ || Object.getPrototypeOf(IconPicker.prototype), \"selectItem\", this).call(this, item, trigger);\n                            item = item || this.defaultItem;\n                            this.label.innerHTML = item.innerHTML;\n                        }\n                    }\n                ]);\n                return IconPicker;\n            }(_picker2.default);\n            exports1.default = IconPicker;\n        /***/ },\n        /* 61 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var Tooltip = function() {\n                function Tooltip(quill, boundsContainer) {\n                    var _this = this;\n                    _classCallCheck(this, Tooltip);\n                    this.quill = quill;\n                    this.boundsContainer = boundsContainer || document.body;\n                    this.root = quill.addContainer(\"ql-tooltip\");\n                    this.root.innerHTML = this.constructor.TEMPLATE;\n                    if (this.quill.root === this.quill.scrollingContainer) {\n                        this.quill.root.addEventListener(\"scroll\", function() {\n                            _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + \"px\";\n                        });\n                    }\n                    this.hide();\n                }\n                _createClass(Tooltip, [\n                    {\n                        key: \"hide\",\n                        value: function hide() {\n                            this.root.classList.add(\"ql-hidden\");\n                        }\n                    },\n                    {\n                        key: \"position\",\n                        value: function position(reference) {\n                            var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;\n                            // root.scrollTop should be 0 if scrollContainer !== root\n                            var top = reference.bottom + this.quill.root.scrollTop;\n                            this.root.style.left = left + \"px\";\n                            this.root.style.top = top + \"px\";\n                            this.root.classList.remove(\"ql-flip\");\n                            var containerBounds = this.boundsContainer.getBoundingClientRect();\n                            var rootBounds = this.root.getBoundingClientRect();\n                            var shift = 0;\n                            if (rootBounds.right > containerBounds.right) {\n                                shift = containerBounds.right - rootBounds.right;\n                                this.root.style.left = left + shift + \"px\";\n                            }\n                            if (rootBounds.left < containerBounds.left) {\n                                shift = containerBounds.left - rootBounds.left;\n                                this.root.style.left = left + shift + \"px\";\n                            }\n                            if (rootBounds.bottom > containerBounds.bottom) {\n                                var height = rootBounds.bottom - rootBounds.top;\n                                var verticalShift = reference.bottom - reference.top + height;\n                                this.root.style.top = top - verticalShift + \"px\";\n                                this.root.classList.add(\"ql-flip\");\n                            }\n                            return shift;\n                        }\n                    },\n                    {\n                        key: \"show\",\n                        value: function show() {\n                            this.root.classList.remove(\"ql-editing\");\n                            this.root.classList.remove(\"ql-hidden\");\n                        }\n                    }\n                ]);\n                return Tooltip;\n            }();\n            exports1.default = Tooltip;\n        /***/ },\n        /* 62 */ /***/ function(module1, exports1, __nested_webpack_require_539245__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _extend = __nested_webpack_require_539245__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _emitter = __nested_webpack_require_539245__(8);\n            var _emitter2 = _interopRequireDefault(_emitter);\n            var _base = __nested_webpack_require_539245__(43);\n            var _base2 = _interopRequireDefault(_base);\n            var _link = __nested_webpack_require_539245__(27);\n            var _link2 = _interopRequireDefault(_link);\n            var _selection = __nested_webpack_require_539245__(15);\n            var _icons = __nested_webpack_require_539245__(41);\n            var _icons2 = _interopRequireDefault(_icons);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var TOOLBAR_CONFIG = [\n                [\n                    {\n                        header: [\n                            \"1\",\n                            \"2\",\n                            \"3\",\n                            false\n                        ]\n                    }\n                ],\n                [\n                    \"bold\",\n                    \"italic\",\n                    \"underline\",\n                    \"link\"\n                ],\n                [\n                    {\n                        list: \"ordered\"\n                    },\n                    {\n                        list: \"bullet\"\n                    }\n                ],\n                [\n                    \"clean\"\n                ]\n            ];\n            var SnowTheme = function(_BaseTheme) {\n                _inherits(SnowTheme, _BaseTheme);\n                function SnowTheme(quill, options) {\n                    _classCallCheck(this, SnowTheme);\n                    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {\n                        options.modules.toolbar.container = TOOLBAR_CONFIG;\n                    }\n                    var _this = _possibleConstructorReturn(this, (SnowTheme.__proto__ || Object.getPrototypeOf(SnowTheme)).call(this, quill, options));\n                    _this.quill.container.classList.add(\"ql-snow\");\n                    return _this;\n                }\n                _createClass(SnowTheme, [\n                    {\n                        key: \"extendToolbar\",\n                        value: function extendToolbar(toolbar) {\n                            toolbar.container.classList.add(\"ql-snow\");\n                            this.buildButtons([].slice.call(toolbar.container.querySelectorAll(\"button\")), _icons2.default);\n                            this.buildPickers([].slice.call(toolbar.container.querySelectorAll(\"select\")), _icons2.default);\n                            this.tooltip = new SnowTooltip(this.quill, this.options.bounds);\n                            if (toolbar.container.querySelector(\".ql-link\")) {\n                                this.quill.keyboard.addBinding({\n                                    key: \"K\",\n                                    shortKey: true\n                                }, function(range, context) {\n                                    toolbar.handlers[\"link\"].call(toolbar, !context.format.link);\n                                });\n                            }\n                        }\n                    }\n                ]);\n                return SnowTheme;\n            }(_base2.default);\n            SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {\n                modules: {\n                    toolbar: {\n                        handlers: {\n                            link: function link(value) {\n                                if (value) {\n                                    var range = this.quill.getSelection();\n                                    if (range == null || range.length == 0) return;\n                                    var preview = this.quill.getText(range);\n                                    if (/^\\S+@\\S+\\.\\S+$/.test(preview) && preview.indexOf(\"mailto:\") !== 0) {\n                                        preview = \"mailto:\" + preview;\n                                    }\n                                    var tooltip = this.quill.theme.tooltip;\n                                    tooltip.edit(\"link\", preview);\n                                } else {\n                                    this.quill.format(\"link\", false);\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n            var SnowTooltip = function(_BaseTooltip) {\n                _inherits(SnowTooltip, _BaseTooltip);\n                function SnowTooltip(quill, bounds) {\n                    _classCallCheck(this, SnowTooltip);\n                    var _this2 = _possibleConstructorReturn(this, (SnowTooltip.__proto__ || Object.getPrototypeOf(SnowTooltip)).call(this, quill, bounds));\n                    _this2.preview = _this2.root.querySelector(\"a.ql-preview\");\n                    return _this2;\n                }\n                _createClass(SnowTooltip, [\n                    {\n                        key: \"listen\",\n                        value: function listen() {\n                            var _this3 = this;\n                            _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), \"listen\", this).call(this);\n                            this.root.querySelector(\"a.ql-action\").addEventListener(\"click\", function(event) {\n                                if (_this3.root.classList.contains(\"ql-editing\")) {\n                                    _this3.save();\n                                } else {\n                                    _this3.edit(\"link\", _this3.preview.textContent);\n                                }\n                                event.preventDefault();\n                            });\n                            this.root.querySelector(\"a.ql-remove\").addEventListener(\"click\", function(event) {\n                                if (_this3.linkRange != null) {\n                                    var range = _this3.linkRange;\n                                    _this3.restoreFocus();\n                                    _this3.quill.formatText(range, \"link\", false, _emitter2.default.sources.USER);\n                                    delete _this3.linkRange;\n                                }\n                                event.preventDefault();\n                                _this3.hide();\n                            });\n                            this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function(range, oldRange, source) {\n                                if (range == null) return;\n                                if (range.length === 0 && source === _emitter2.default.sources.USER) {\n                                    var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range.index), _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2), link = _quill$scroll$descend2[0], offset = _quill$scroll$descend2[1];\n                                    if (link != null) {\n                                        _this3.linkRange = new _selection.Range(range.index - offset, link.length());\n                                        var preview = _link2.default.formats(link.domNode);\n                                        _this3.preview.textContent = preview;\n                                        _this3.preview.setAttribute(\"href\", preview);\n                                        _this3.show();\n                                        _this3.position(_this3.quill.getBounds(_this3.linkRange));\n                                        return;\n                                    }\n                                } else {\n                                    delete _this3.linkRange;\n                                }\n                                _this3.hide();\n                            });\n                        }\n                    },\n                    {\n                        key: \"show\",\n                        value: function show() {\n                            _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), \"show\", this).call(this);\n                            this.root.removeAttribute(\"data-mode\");\n                        }\n                    }\n                ]);\n                return SnowTooltip;\n            }(_base.BaseTooltip);\n            SnowTooltip.TEMPLATE = [\n                '<a class=\"ql-preview\" rel=\"noopener noreferrer\" target=\"_blank\" href=\"about:blank\"></a>',\n                '<input type=\"text\" data-formula=\"e=mc^2\" data-link=\"https://quilljs.com\" data-video=\"Embed URL\">',\n                '<a class=\"ql-action\"></a>',\n                '<a class=\"ql-remove\"></a>'\n            ].join(\"\");\n            exports1.default = SnowTheme;\n        /***/ },\n        /* 63 */ /***/ function(module1, exports1, __nested_webpack_require_552749__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _core = __nested_webpack_require_552749__(29);\n            var _core2 = _interopRequireDefault(_core);\n            var _align = __nested_webpack_require_552749__(36);\n            var _direction = __nested_webpack_require_552749__(38);\n            var _indent = __nested_webpack_require_552749__(64);\n            var _blockquote = __nested_webpack_require_552749__(65);\n            var _blockquote2 = _interopRequireDefault(_blockquote);\n            var _header = __nested_webpack_require_552749__(66);\n            var _header2 = _interopRequireDefault(_header);\n            var _list = __nested_webpack_require_552749__(67);\n            var _list2 = _interopRequireDefault(_list);\n            var _background = __nested_webpack_require_552749__(37);\n            var _color = __nested_webpack_require_552749__(26);\n            var _font = __nested_webpack_require_552749__(39);\n            var _size = __nested_webpack_require_552749__(40);\n            var _bold = __nested_webpack_require_552749__(56);\n            var _bold2 = _interopRequireDefault(_bold);\n            var _italic = __nested_webpack_require_552749__(68);\n            var _italic2 = _interopRequireDefault(_italic);\n            var _link = __nested_webpack_require_552749__(27);\n            var _link2 = _interopRequireDefault(_link);\n            var _script = __nested_webpack_require_552749__(69);\n            var _script2 = _interopRequireDefault(_script);\n            var _strike = __nested_webpack_require_552749__(70);\n            var _strike2 = _interopRequireDefault(_strike);\n            var _underline = __nested_webpack_require_552749__(71);\n            var _underline2 = _interopRequireDefault(_underline);\n            var _image = __nested_webpack_require_552749__(72);\n            var _image2 = _interopRequireDefault(_image);\n            var _video = __nested_webpack_require_552749__(73);\n            var _video2 = _interopRequireDefault(_video);\n            var _code = __nested_webpack_require_552749__(13);\n            var _code2 = _interopRequireDefault(_code);\n            var _formula = __nested_webpack_require_552749__(74);\n            var _formula2 = _interopRequireDefault(_formula);\n            var _syntax = __nested_webpack_require_552749__(75);\n            var _syntax2 = _interopRequireDefault(_syntax);\n            var _toolbar = __nested_webpack_require_552749__(57);\n            var _toolbar2 = _interopRequireDefault(_toolbar);\n            var _icons = __nested_webpack_require_552749__(41);\n            var _icons2 = _interopRequireDefault(_icons);\n            var _picker = __nested_webpack_require_552749__(28);\n            var _picker2 = _interopRequireDefault(_picker);\n            var _colorPicker = __nested_webpack_require_552749__(59);\n            var _colorPicker2 = _interopRequireDefault(_colorPicker);\n            var _iconPicker = __nested_webpack_require_552749__(60);\n            var _iconPicker2 = _interopRequireDefault(_iconPicker);\n            var _tooltip = __nested_webpack_require_552749__(61);\n            var _tooltip2 = _interopRequireDefault(_tooltip);\n            var _bubble = __nested_webpack_require_552749__(108);\n            var _bubble2 = _interopRequireDefault(_bubble);\n            var _snow = __nested_webpack_require_552749__(62);\n            var _snow2 = _interopRequireDefault(_snow);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            _core2.default.register({\n                \"attributors/attribute/direction\": _direction.DirectionAttribute,\n                \"attributors/class/align\": _align.AlignClass,\n                \"attributors/class/background\": _background.BackgroundClass,\n                \"attributors/class/color\": _color.ColorClass,\n                \"attributors/class/direction\": _direction.DirectionClass,\n                \"attributors/class/font\": _font.FontClass,\n                \"attributors/class/size\": _size.SizeClass,\n                \"attributors/style/align\": _align.AlignStyle,\n                \"attributors/style/background\": _background.BackgroundStyle,\n                \"attributors/style/color\": _color.ColorStyle,\n                \"attributors/style/direction\": _direction.DirectionStyle,\n                \"attributors/style/font\": _font.FontStyle,\n                \"attributors/style/size\": _size.SizeStyle\n            }, true);\n            _core2.default.register({\n                \"formats/align\": _align.AlignClass,\n                \"formats/direction\": _direction.DirectionClass,\n                \"formats/indent\": _indent.IndentClass,\n                \"formats/background\": _background.BackgroundStyle,\n                \"formats/color\": _color.ColorStyle,\n                \"formats/font\": _font.FontClass,\n                \"formats/size\": _size.SizeClass,\n                \"formats/blockquote\": _blockquote2.default,\n                \"formats/code-block\": _code2.default,\n                \"formats/header\": _header2.default,\n                \"formats/list\": _list2.default,\n                \"formats/bold\": _bold2.default,\n                \"formats/code\": _code.Code,\n                \"formats/italic\": _italic2.default,\n                \"formats/link\": _link2.default,\n                \"formats/script\": _script2.default,\n                \"formats/strike\": _strike2.default,\n                \"formats/underline\": _underline2.default,\n                \"formats/image\": _image2.default,\n                \"formats/video\": _video2.default,\n                \"formats/list/item\": _list.ListItem,\n                \"modules/formula\": _formula2.default,\n                \"modules/syntax\": _syntax2.default,\n                \"modules/toolbar\": _toolbar2.default,\n                \"themes/bubble\": _bubble2.default,\n                \"themes/snow\": _snow2.default,\n                \"ui/icons\": _icons2.default,\n                \"ui/picker\": _picker2.default,\n                \"ui/icon-picker\": _iconPicker2.default,\n                \"ui/color-picker\": _colorPicker2.default,\n                \"ui/tooltip\": _tooltip2.default\n            }, true);\n            exports1.default = _core2.default;\n        /***/ },\n        /* 64 */ /***/ function(module1, exports1, __nested_webpack_require_558721__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.IndentClass = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_558721__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var IdentAttributor = function(_Parchment$Attributor) {\n                _inherits(IdentAttributor, _Parchment$Attributor);\n                function IdentAttributor() {\n                    _classCallCheck(this, IdentAttributor);\n                    return _possibleConstructorReturn(this, (IdentAttributor.__proto__ || Object.getPrototypeOf(IdentAttributor)).apply(this, arguments));\n                }\n                _createClass(IdentAttributor, [\n                    {\n                        key: \"add\",\n                        value: function add(node, value) {\n                            if (value === \"+1\" || value === \"-1\") {\n                                var indent = this.value(node) || 0;\n                                value = value === \"+1\" ? indent + 1 : indent - 1;\n                            }\n                            if (value === 0) {\n                                this.remove(node);\n                                return true;\n                            } else {\n                                return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), \"add\", this).call(this, node, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"canAdd\",\n                        value: function canAdd(node, value) {\n                            return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), \"canAdd\", this).call(this, node, value) || _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), \"canAdd\", this).call(this, node, parseInt(value));\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(node) {\n                            return parseInt(_get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), \"value\", this).call(this, node)) || undefined; // Don't return NaN\n                        }\n                    }\n                ]);\n                return IdentAttributor;\n            }(_parchment2.default.Attributor.Class);\n            var IndentClass = new IdentAttributor(\"indent\", \"ql-indent\", {\n                scope: _parchment2.default.Scope.BLOCK,\n                whitelist: [\n                    1,\n                    2,\n                    3,\n                    4,\n                    5,\n                    6,\n                    7,\n                    8\n                ]\n            });\n            exports1.IndentClass = IndentClass;\n        /***/ },\n        /* 65 */ /***/ function(module1, exports1, __nested_webpack_require_564983__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _block = __nested_webpack_require_564983__(4);\n            var _block2 = _interopRequireDefault(_block);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Blockquote = function(_Block) {\n                _inherits(Blockquote, _Block);\n                function Blockquote() {\n                    _classCallCheck(this, Blockquote);\n                    return _possibleConstructorReturn(this, (Blockquote.__proto__ || Object.getPrototypeOf(Blockquote)).apply(this, arguments));\n                }\n                return Blockquote;\n            }(_block2.default);\n            Blockquote.blotName = \"blockquote\";\n            Blockquote.tagName = \"blockquote\";\n            exports1.default = Blockquote;\n        /***/ },\n        /* 66 */ /***/ function(module1, exports1, __nested_webpack_require_567362__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _block = __nested_webpack_require_567362__(4);\n            var _block2 = _interopRequireDefault(_block);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Header = function(_Block) {\n                _inherits(Header, _Block);\n                function Header() {\n                    _classCallCheck(this, Header);\n                    return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).apply(this, arguments));\n                }\n                _createClass(Header, null, [\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return this.tagName.indexOf(domNode.tagName) + 1;\n                        }\n                    }\n                ]);\n                return Header;\n            }(_block2.default);\n            Header.blotName = \"header\";\n            Header.tagName = [\n                \"H1\",\n                \"H2\",\n                \"H3\",\n                \"H4\",\n                \"H5\",\n                \"H6\"\n            ];\n            exports1.default = Header;\n        /***/ },\n        /* 67 */ /***/ function(module1, exports1, __nested_webpack_require_571012__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.ListItem = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_571012__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _block = __nested_webpack_require_571012__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _container = __nested_webpack_require_571012__(25);\n            var _container2 = _interopRequireDefault(_container);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ListItem = function(_Block) {\n                _inherits(ListItem, _Block);\n                function ListItem() {\n                    _classCallCheck(this, ListItem);\n                    return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).apply(this, arguments));\n                }\n                _createClass(ListItem, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (name === List.blotName && !value) {\n                                this.replaceWith(_parchment2.default.create(this.statics.scope));\n                            } else {\n                                _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), \"format\", this).call(this, name, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"remove\",\n                        value: function remove() {\n                            if (this.prev == null && this.next == null) {\n                                this.parent.remove();\n                            } else {\n                                _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), \"remove\", this).call(this);\n                            }\n                        }\n                    },\n                    {\n                        key: \"replaceWith\",\n                        value: function replaceWith(name, value) {\n                            this.parent.isolate(this.offset(this.parent), this.length());\n                            if (name === this.parent.statics.blotName) {\n                                this.parent.replaceWith(name, value);\n                                return this;\n                            } else {\n                                this.parent.unwrap();\n                                return _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), \"replaceWith\", this).call(this, name, value);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return domNode.tagName === this.tagName ? undefined : _get(ListItem.__proto__ || Object.getPrototypeOf(ListItem), \"formats\", this).call(this, domNode);\n                        }\n                    }\n                ]);\n                return ListItem;\n            }(_block2.default);\n            ListItem.blotName = \"list-item\";\n            ListItem.tagName = \"LI\";\n            var List = function(_Container) {\n                _inherits(List, _Container);\n                _createClass(List, null, [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var tagName = value === \"ordered\" ? \"OL\" : \"UL\";\n                            var node = _get(List.__proto__ || Object.getPrototypeOf(List), \"create\", this).call(this, tagName);\n                            if (value === \"checked\" || value === \"unchecked\") {\n                                node.setAttribute(\"data-checked\", value === \"checked\");\n                            }\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            if (domNode.tagName === \"OL\") return \"ordered\";\n                            if (domNode.tagName === \"UL\") {\n                                if (domNode.hasAttribute(\"data-checked\")) {\n                                    return domNode.getAttribute(\"data-checked\") === \"true\" ? \"checked\" : \"unchecked\";\n                                } else {\n                                    return \"bullet\";\n                                }\n                            }\n                            return undefined;\n                        }\n                    }\n                ]);\n                function List(domNode) {\n                    _classCallCheck(this, List);\n                    var _this2 = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, domNode));\n                    var listEventHandler = function listEventHandler(e) {\n                        if (e.target.parentNode !== domNode) return;\n                        var format = _this2.statics.formats(domNode);\n                        var blot = _parchment2.default.find(e.target);\n                        if (format === \"checked\") {\n                            blot.format(\"list\", \"unchecked\");\n                        } else if (format === \"unchecked\") {\n                            blot.format(\"list\", \"checked\");\n                        }\n                    };\n                    domNode.addEventListener(\"touchstart\", listEventHandler);\n                    domNode.addEventListener(\"mousedown\", listEventHandler);\n                    return _this2;\n                }\n                _createClass(List, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (this.children.length > 0) {\n                                this.children.tail.format(name, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats() {\n                            // We don't inherit from FormatBlot\n                            return _defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));\n                        }\n                    },\n                    {\n                        key: \"insertBefore\",\n                        value: function insertBefore(blot, ref) {\n                            if (blot instanceof ListItem) {\n                                _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), \"insertBefore\", this).call(this, blot, ref);\n                            } else {\n                                var index = ref == null ? this.length() : ref.offset(this);\n                                var after = this.split(index);\n                                after.parent.insertBefore(blot, after);\n                            }\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), \"optimize\", this).call(this, context);\n                            var next = this.next;\n                            if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute(\"data-checked\") === this.domNode.getAttribute(\"data-checked\")) {\n                                next.moveChildren(this);\n                                next.remove();\n                            }\n                        }\n                    },\n                    {\n                        key: \"replace\",\n                        value: function replace(target) {\n                            if (target.statics.blotName !== this.statics.blotName) {\n                                var item = _parchment2.default.create(this.statics.defaultChild);\n                                target.moveChildren(item);\n                                this.appendChild(item);\n                            }\n                            _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), \"replace\", this).call(this, target);\n                        }\n                    }\n                ]);\n                return List;\n            }(_container2.default);\n            List.blotName = \"list\";\n            List.scope = _parchment2.default.Scope.BLOCK_BLOT;\n            List.tagName = [\n                \"OL\",\n                \"UL\"\n            ];\n            List.defaultChild = \"list-item\";\n            List.allowedChildren = [\n                ListItem\n            ];\n            exports1.ListItem = ListItem;\n            exports1.default = List;\n        /***/ },\n        /* 68 */ /***/ function(module1, exports1, __nested_webpack_require_583767__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _bold = __nested_webpack_require_583767__(56);\n            var _bold2 = _interopRequireDefault(_bold);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Italic = function(_Bold) {\n                _inherits(Italic, _Bold);\n                function Italic() {\n                    _classCallCheck(this, Italic);\n                    return _possibleConstructorReturn(this, (Italic.__proto__ || Object.getPrototypeOf(Italic)).apply(this, arguments));\n                }\n                return Italic;\n            }(_bold2.default);\n            Italic.blotName = \"italic\";\n            Italic.tagName = [\n                \"EM\",\n                \"I\"\n            ];\n            exports1.default = Italic;\n        /***/ },\n        /* 69 */ /***/ function(module1, exports1, __nested_webpack_require_586142__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _inline = __nested_webpack_require_586142__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Script = function(_Inline) {\n                _inherits(Script, _Inline);\n                function Script() {\n                    _classCallCheck(this, Script);\n                    return _possibleConstructorReturn(this, (Script.__proto__ || Object.getPrototypeOf(Script)).apply(this, arguments));\n                }\n                _createClass(Script, null, [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            if (value === \"super\") {\n                                return document.createElement(\"sup\");\n                            } else if (value === \"sub\") {\n                                return document.createElement(\"sub\");\n                            } else {\n                                return _get(Script.__proto__ || Object.getPrototypeOf(Script), \"create\", this).call(this, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            if (domNode.tagName === \"SUB\") return \"sub\";\n                            if (domNode.tagName === \"SUP\") return \"super\";\n                            return undefined;\n                        }\n                    }\n                ]);\n                return Script;\n            }(_inline2.default);\n            Script.blotName = \"script\";\n            Script.tagName = [\n                \"SUB\",\n                \"SUP\"\n            ];\n            exports1.default = Script;\n        /***/ },\n        /* 70 */ /***/ function(module1, exports1, __nested_webpack_require_591306__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _inline = __nested_webpack_require_591306__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Strike = function(_Inline) {\n                _inherits(Strike, _Inline);\n                function Strike() {\n                    _classCallCheck(this, Strike);\n                    return _possibleConstructorReturn(this, (Strike.__proto__ || Object.getPrototypeOf(Strike)).apply(this, arguments));\n                }\n                return Strike;\n            }(_inline2.default);\n            Strike.blotName = \"strike\";\n            Strike.tagName = \"S\";\n            exports1.default = Strike;\n        /***/ },\n        /* 71 */ /***/ function(module1, exports1, __nested_webpack_require_593638__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _inline = __nested_webpack_require_593638__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Underline = function(_Inline) {\n                _inherits(Underline, _Inline);\n                function Underline() {\n                    _classCallCheck(this, Underline);\n                    return _possibleConstructorReturn(this, (Underline.__proto__ || Object.getPrototypeOf(Underline)).apply(this, arguments));\n                }\n                return Underline;\n            }(_inline2.default);\n            Underline.blotName = \"underline\";\n            Underline.tagName = \"U\";\n            exports1.default = Underline;\n        /***/ },\n        /* 72 */ /***/ function(module1, exports1, __nested_webpack_require_596003__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_596003__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _link = __nested_webpack_require_596003__(27);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ATTRIBUTES = [\n                \"alt\",\n                \"height\",\n                \"width\"\n            ];\n            var Image = function(_Parchment$Embed) {\n                _inherits(Image, _Parchment$Embed);\n                function Image() {\n                    _classCallCheck(this, Image);\n                    return _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).apply(this, arguments));\n                }\n                _createClass(Image, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (ATTRIBUTES.indexOf(name) > -1) {\n                                if (value) {\n                                    this.domNode.setAttribute(name, value);\n                                } else {\n                                    this.domNode.removeAttribute(name);\n                                }\n                            } else {\n                                _get(Image.prototype.__proto__ || Object.getPrototypeOf(Image.prototype), \"format\", this).call(this, name, value);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var node = _get(Image.__proto__ || Object.getPrototypeOf(Image), \"create\", this).call(this, value);\n                            if (typeof value === \"string\") {\n                                node.setAttribute(\"src\", this.sanitize(value));\n                            }\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return ATTRIBUTES.reduce(function(formats, attribute) {\n                                if (domNode.hasAttribute(attribute)) {\n                                    formats[attribute] = domNode.getAttribute(attribute);\n                                }\n                                return formats;\n                            }, {});\n                        }\n                    },\n                    {\n                        key: \"match\",\n                        value: function match(url) {\n                            return /\\.(jpe?g|gif|png)$/.test(url) || /^data:image\\/.+;base64/.test(url);\n                        }\n                    },\n                    {\n                        key: \"sanitize\",\n                        value: function sanitize(url) {\n                            return (0, _link.sanitize)(url, [\n                                \"http\",\n                                \"https\",\n                                \"data\"\n                            ]) ? url : \"//:0\";\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(domNode) {\n                            return domNode.getAttribute(\"src\");\n                        }\n                    }\n                ]);\n                return Image;\n            }(_parchment2.default.Embed);\n            Image.blotName = \"image\";\n            Image.tagName = \"IMG\";\n            exports1.default = Image;\n        /***/ },\n        /* 73 */ /***/ function(module1, exports1, __nested_webpack_require_602992__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _block = __nested_webpack_require_602992__(4);\n            var _link = __nested_webpack_require_602992__(27);\n            var _link2 = _interopRequireDefault(_link);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ATTRIBUTES = [\n                \"height\",\n                \"width\"\n            ];\n            var Video = function(_BlockEmbed) {\n                _inherits(Video, _BlockEmbed);\n                function Video() {\n                    _classCallCheck(this, Video);\n                    return _possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));\n                }\n                _createClass(Video, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (ATTRIBUTES.indexOf(name) > -1) {\n                                if (value) {\n                                    this.domNode.setAttribute(name, value);\n                                } else {\n                                    this.domNode.removeAttribute(name);\n                                }\n                            } else {\n                                _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), \"format\", this).call(this, name, value);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var node = _get(Video.__proto__ || Object.getPrototypeOf(Video), \"create\", this).call(this, value);\n                            node.setAttribute(\"frameborder\", \"0\");\n                            node.setAttribute(\"allowfullscreen\", true);\n                            node.setAttribute(\"src\", this.sanitize(value));\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return ATTRIBUTES.reduce(function(formats, attribute) {\n                                if (domNode.hasAttribute(attribute)) {\n                                    formats[attribute] = domNode.getAttribute(attribute);\n                                }\n                                return formats;\n                            }, {});\n                        }\n                    },\n                    {\n                        key: \"sanitize\",\n                        value: function sanitize(url) {\n                            return _link2.default.sanitize(url);\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(domNode) {\n                            return domNode.getAttribute(\"src\");\n                        }\n                    }\n                ]);\n                return Video;\n            }(_block.BlockEmbed);\n            Video.blotName = \"video\";\n            Video.className = \"ql-video\";\n            Video.tagName = \"IFRAME\";\n            exports1.default = Video;\n        /***/ },\n        /* 74 */ /***/ function(module1, exports1, __nested_webpack_require_609584__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.FormulaBlot = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _embed = __nested_webpack_require_609584__(35);\n            var _embed2 = _interopRequireDefault(_embed);\n            var _quill = __nested_webpack_require_609584__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _module = __nested_webpack_require_609584__(9);\n            var _module2 = _interopRequireDefault(_module);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var FormulaBlot = function(_Embed) {\n                _inherits(FormulaBlot, _Embed);\n                function FormulaBlot() {\n                    _classCallCheck(this, FormulaBlot);\n                    return _possibleConstructorReturn(this, (FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot)).apply(this, arguments));\n                }\n                _createClass(FormulaBlot, null, [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var node = _get(FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot), \"create\", this).call(this, value);\n                            if (typeof value === \"string\") {\n                                window.katex.render(value, node, {\n                                    throwOnError: false,\n                                    errorColor: \"#f00\"\n                                });\n                                node.setAttribute(\"data-value\", value);\n                            }\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(domNode) {\n                            return domNode.getAttribute(\"data-value\");\n                        }\n                    }\n                ]);\n                return FormulaBlot;\n            }(_embed2.default);\n            FormulaBlot.blotName = \"formula\";\n            FormulaBlot.className = \"ql-formula\";\n            FormulaBlot.tagName = \"SPAN\";\n            var Formula = function(_Module) {\n                _inherits(Formula, _Module);\n                _createClass(Formula, null, [\n                    {\n                        key: \"register\",\n                        value: function register() {\n                            _quill2.default.register(FormulaBlot, true);\n                        }\n                    }\n                ]);\n                function Formula() {\n                    _classCallCheck(this, Formula);\n                    var _this2 = _possibleConstructorReturn(this, (Formula.__proto__ || Object.getPrototypeOf(Formula)).call(this));\n                    if (window.katex == null) {\n                        throw new Error(\"Formula module requires KaTeX.\");\n                    }\n                    return _this2;\n                }\n                return Formula;\n            }(_module2.default);\n            exports1.FormulaBlot = FormulaBlot;\n            exports1.default = Formula;\n        /***/ },\n        /* 75 */ /***/ function(module1, exports1, __nested_webpack_require_615984__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.CodeToken = exports1.CodeBlock = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_615984__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_615984__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _module = __nested_webpack_require_615984__(9);\n            var _module2 = _interopRequireDefault(_module);\n            var _code = __nested_webpack_require_615984__(13);\n            var _code2 = _interopRequireDefault(_code);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var SyntaxCodeBlock = function(_CodeBlock) {\n                _inherits(SyntaxCodeBlock, _CodeBlock);\n                function SyntaxCodeBlock() {\n                    _classCallCheck(this, SyntaxCodeBlock);\n                    return _possibleConstructorReturn(this, (SyntaxCodeBlock.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock)).apply(this, arguments));\n                }\n                _createClass(SyntaxCodeBlock, [\n                    {\n                        key: \"replaceWith\",\n                        value: function replaceWith(block) {\n                            this.domNode.textContent = this.domNode.textContent;\n                            this.attach();\n                            _get(SyntaxCodeBlock.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock.prototype), \"replaceWith\", this).call(this, block);\n                        }\n                    },\n                    {\n                        key: \"highlight\",\n                        value: function highlight(_highlight) {\n                            var text = this.domNode.textContent;\n                            if (this.cachedText !== text) {\n                                if (text.trim().length > 0 || this.cachedText == null) {\n                                    this.domNode.innerHTML = _highlight(text);\n                                    this.domNode.normalize();\n                                    this.attach();\n                                }\n                                this.cachedText = text;\n                            }\n                        }\n                    }\n                ]);\n                return SyntaxCodeBlock;\n            }(_code2.default);\n            SyntaxCodeBlock.className = \"ql-syntax\";\n            var CodeToken = new _parchment2.default.Attributor.Class(\"token\", \"hljs\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            var Syntax = function(_Module) {\n                _inherits(Syntax, _Module);\n                _createClass(Syntax, null, [\n                    {\n                        key: \"register\",\n                        value: function register() {\n                            _quill2.default.register(CodeToken, true);\n                            _quill2.default.register(SyntaxCodeBlock, true);\n                        }\n                    }\n                ]);\n                function Syntax(quill, options) {\n                    _classCallCheck(this, Syntax);\n                    var _this2 = _possibleConstructorReturn(this, (Syntax.__proto__ || Object.getPrototypeOf(Syntax)).call(this, quill, options));\n                    if (typeof _this2.options.highlight !== \"function\") {\n                        throw new Error(\"Syntax module requires highlight.js. Please include the library on the page before Quill.\");\n                    }\n                    var timer = null;\n                    _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {\n                        clearTimeout(timer);\n                        timer = setTimeout(function() {\n                            _this2.highlight();\n                            timer = null;\n                        }, _this2.options.interval);\n                    });\n                    _this2.highlight();\n                    return _this2;\n                }\n                _createClass(Syntax, [\n                    {\n                        key: \"highlight\",\n                        value: function highlight() {\n                            var _this3 = this;\n                            if (this.quill.selection.composing) return;\n                            this.quill.update(_quill2.default.sources.USER);\n                            var range = this.quill.getSelection();\n                            this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function(code) {\n                                code.highlight(_this3.options.highlight);\n                            });\n                            this.quill.update(_quill2.default.sources.SILENT);\n                            if (range != null) {\n                                this.quill.setSelection(range, _quill2.default.sources.SILENT);\n                            }\n                        }\n                    }\n                ]);\n                return Syntax;\n            }(_module2.default);\n            Syntax.DEFAULTS = {\n                highlight: function() {\n                    if (window.hljs == null) return null;\n                    return function(text) {\n                        var result = window.hljs.highlightAuto(text);\n                        return result.value;\n                    };\n                }(),\n                interval: 1000\n            };\n            exports1.CodeBlock = SyntaxCodeBlock;\n            exports1.CodeToken = CodeToken;\n            exports1.default = Syntax;\n        /***/ },\n        /* 76 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>';\n        /***/ },\n        /* 77 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>';\n        /***/ },\n        /* 78 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>';\n        /***/ },\n        /* 79 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>';\n        /***/ },\n        /* 80 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>';\n        /***/ },\n        /* 81 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>';\n        /***/ },\n        /* 82 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>';\n        /***/ },\n        /* 83 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>';\n        /***/ },\n        /* 84 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>';\n        /***/ },\n        /* 85 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>';\n        /***/ },\n        /* 86 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>';\n        /***/ },\n        /* 87 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>';\n        /***/ },\n        /* 88 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>';\n        /***/ },\n        /* 89 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>';\n        /***/ },\n        /* 90 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>';\n        /***/ },\n        /* 91 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>';\n        /***/ },\n        /* 92 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>';\n        /***/ },\n        /* 93 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>';\n        /***/ },\n        /* 94 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>';\n        /***/ },\n        /* 95 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>';\n        /***/ },\n        /* 96 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>';\n        /***/ },\n        /* 97 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>';\n        /***/ },\n        /* 98 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>';\n        /***/ },\n        /* 99 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>';\n        /***/ },\n        /* 100 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>';\n        /***/ },\n        /* 101 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>';\n        /***/ },\n        /* 102 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>';\n        /***/ },\n        /* 103 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>';\n        /***/ },\n        /* 104 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>';\n        /***/ },\n        /* 105 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>';\n        /***/ },\n        /* 106 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>';\n        /***/ },\n        /* 107 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>';\n        /***/ },\n        /* 108 */ /***/ function(module1, exports1, __nested_webpack_require_642536__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.BubbleTooltip = undefined;\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _extend = __nested_webpack_require_642536__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _emitter = __nested_webpack_require_642536__(8);\n            var _emitter2 = _interopRequireDefault(_emitter);\n            var _base = __nested_webpack_require_642536__(43);\n            var _base2 = _interopRequireDefault(_base);\n            var _selection = __nested_webpack_require_642536__(15);\n            var _icons = __nested_webpack_require_642536__(41);\n            var _icons2 = _interopRequireDefault(_icons);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var TOOLBAR_CONFIG = [\n                [\n                    \"bold\",\n                    \"italic\",\n                    \"link\"\n                ],\n                [\n                    {\n                        header: 1\n                    },\n                    {\n                        header: 2\n                    },\n                    \"blockquote\"\n                ]\n            ];\n            var BubbleTheme = function(_BaseTheme) {\n                _inherits(BubbleTheme, _BaseTheme);\n                function BubbleTheme(quill, options) {\n                    _classCallCheck(this, BubbleTheme);\n                    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {\n                        options.modules.toolbar.container = TOOLBAR_CONFIG;\n                    }\n                    var _this = _possibleConstructorReturn(this, (BubbleTheme.__proto__ || Object.getPrototypeOf(BubbleTheme)).call(this, quill, options));\n                    _this.quill.container.classList.add(\"ql-bubble\");\n                    return _this;\n                }\n                _createClass(BubbleTheme, [\n                    {\n                        key: \"extendToolbar\",\n                        value: function extendToolbar(toolbar) {\n                            this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);\n                            this.tooltip.root.appendChild(toolbar.container);\n                            this.buildButtons([].slice.call(toolbar.container.querySelectorAll(\"button\")), _icons2.default);\n                            this.buildPickers([].slice.call(toolbar.container.querySelectorAll(\"select\")), _icons2.default);\n                        }\n                    }\n                ]);\n                return BubbleTheme;\n            }(_base2.default);\n            BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {\n                modules: {\n                    toolbar: {\n                        handlers: {\n                            link: function link(value) {\n                                if (!value) {\n                                    this.quill.format(\"link\", false);\n                                } else {\n                                    this.quill.theme.tooltip.edit();\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n            var BubbleTooltip = function(_BaseTooltip) {\n                _inherits(BubbleTooltip, _BaseTooltip);\n                function BubbleTooltip(quill, bounds) {\n                    _classCallCheck(this, BubbleTooltip);\n                    var _this2 = _possibleConstructorReturn(this, (BubbleTooltip.__proto__ || Object.getPrototypeOf(BubbleTooltip)).call(this, quill, bounds));\n                    _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function(type, range, oldRange, source) {\n                        if (type !== _emitter2.default.events.SELECTION_CHANGE) return;\n                        if (range != null && range.length > 0 && source === _emitter2.default.sources.USER) {\n                            _this2.show();\n                            // Lock our width so we will expand beyond our offsetParent boundaries\n                            _this2.root.style.left = \"0px\";\n                            _this2.root.style.width = \"\";\n                            _this2.root.style.width = _this2.root.offsetWidth + \"px\";\n                            var lines = _this2.quill.getLines(range.index, range.length);\n                            if (lines.length === 1) {\n                                _this2.position(_this2.quill.getBounds(range));\n                            } else {\n                                var lastLine = lines[lines.length - 1];\n                                var index = _this2.quill.getIndex(lastLine);\n                                var length = Math.min(lastLine.length() - 1, range.index + range.length - index);\n                                var _bounds = _this2.quill.getBounds(new _selection.Range(index, length));\n                                _this2.position(_bounds);\n                            }\n                        } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {\n                            _this2.hide();\n                        }\n                    });\n                    return _this2;\n                }\n                _createClass(BubbleTooltip, [\n                    {\n                        key: \"listen\",\n                        value: function listen() {\n                            var _this3 = this;\n                            _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), \"listen\", this).call(this);\n                            this.root.querySelector(\".ql-close\").addEventListener(\"click\", function() {\n                                _this3.root.classList.remove(\"ql-editing\");\n                            });\n                            this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function() {\n                                // Let selection be restored by toolbar handlers before repositioning\n                                setTimeout(function() {\n                                    if (_this3.root.classList.contains(\"ql-hidden\")) return;\n                                    var range = _this3.quill.getSelection();\n                                    if (range != null) {\n                                        _this3.position(_this3.quill.getBounds(range));\n                                    }\n                                }, 1);\n                            });\n                        }\n                    },\n                    {\n                        key: \"cancel\",\n                        value: function cancel() {\n                            this.show();\n                        }\n                    },\n                    {\n                        key: \"position\",\n                        value: function position(reference) {\n                            var shift = _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), \"position\", this).call(this, reference);\n                            var arrow = this.root.querySelector(\".ql-tooltip-arrow\");\n                            arrow.style.marginLeft = \"\";\n                            if (shift === 0) return shift;\n                            arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + \"px\";\n                        }\n                    }\n                ]);\n                return BubbleTooltip;\n            }(_base.BaseTooltip);\n            BubbleTooltip.TEMPLATE = [\n                '<span class=\"ql-tooltip-arrow\"></span>',\n                '<div class=\"ql-tooltip-editor\">',\n                '<input type=\"text\" data-formula=\"e=mc^2\" data-link=\"https://quilljs.com\" data-video=\"Embed URL\">',\n                '<a class=\"ql-close\"></a>',\n                \"</div>\"\n            ].join(\"\");\n            exports1.BubbleTooltip = BubbleTooltip;\n            exports1.default = BubbleTheme;\n        /***/ },\n        /* 109 */ /***/ function(module1, exports1, __nested_webpack_require_653689__) {\n            module1.exports = __nested_webpack_require_653689__(63);\n        /***/ }\n    ])[\"default\"];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSXZsQyxRQUFRc2xDLE1BQU16RixXQUFXLEdBQUcsSUFBSTt3QkFDaEU7b0JBQ0Y7aUJBQUU7Z0JBRUYsT0FBT3FGO1lBQ1QsRUFBRWpGLE1BQU0zVCxXQUFXO1lBRW5CNFksY0FBY3ZGLFFBQVEsR0FBRztnQkFBQztnQkFBMEM7Z0JBQW1DO2dCQUFvRztnQkFBNEI7YUFBUyxDQUFDN2xDLElBQUksQ0FBQztZQUV0UG5MLFNBQVF1MkMsYUFBYSxHQUFHQTtZQUN4QnYyQyxTQUFRc0QsT0FBTyxHQUFHa3pDO1FBRWxCLEdBQUcsR0FBRztRQUNOLE9BQU8sR0FDUCxHQUFHLEdBQUksU0FBU3YyQyxPQUFNLEVBQUVELFFBQU8sRUFBRU8saUNBQW1CO1lBRXBETixRQUFPRCxPQUFPLEdBQUdPLGlDQUFtQkEsQ0FBQztRQUdyQyxHQUFHLEdBQUc7S0FDSSxDQUFDLENBQUMsVUFBVTtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2JhbGFuY2UtY29kZS1hbGxpYW5jZS8uL25vZGVfbW9kdWxlcy9xdWlsbC9kaXN0L3F1aWxsLmpzPzk5ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBRdWlsbCBFZGl0b3IgdjEuMy43XG4gKiBodHRwczovL3F1aWxsanMuY29tL1xuICogQ29weXJpZ2h0IChjKSAyMDE0LCBKYXNvbiBDaGVuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMsIHNhbGVzZm9yY2UuY29tXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlF1aWxsXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlF1aWxsXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMDkpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnRhaW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG52YXIgZm9ybWF0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbnZhciBsZWFmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbnZhciBzY3JvbGxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xudmFyIGlubGluZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG52YXIgYmxvY2tfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xudmFyIGVtYmVkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KTtcbnZhciB0ZXh0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcbnZhciBhdHRyaWJ1dG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBjbGFzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgc3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHN0b3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgUGFyY2htZW50ID0ge1xuICAgIFNjb3BlOiBSZWdpc3RyeS5TY29wZSxcbiAgICBjcmVhdGU6IFJlZ2lzdHJ5LmNyZWF0ZSxcbiAgICBmaW5kOiBSZWdpc3RyeS5maW5kLFxuICAgIHF1ZXJ5OiBSZWdpc3RyeS5xdWVyeSxcbiAgICByZWdpc3RlcjogUmVnaXN0cnkucmVnaXN0ZXIsXG4gICAgQ29udGFpbmVyOiBjb250YWluZXJfMS5kZWZhdWx0LFxuICAgIEZvcm1hdDogZm9ybWF0XzEuZGVmYXVsdCxcbiAgICBMZWFmOiBsZWFmXzEuZGVmYXVsdCxcbiAgICBFbWJlZDogZW1iZWRfMS5kZWZhdWx0LFxuICAgIFNjcm9sbDogc2Nyb2xsXzEuZGVmYXVsdCxcbiAgICBCbG9jazogYmxvY2tfMS5kZWZhdWx0LFxuICAgIElubGluZTogaW5saW5lXzEuZGVmYXVsdCxcbiAgICBUZXh0OiB0ZXh0XzEuZGVmYXVsdCxcbiAgICBBdHRyaWJ1dG9yOiB7XG4gICAgICAgIEF0dHJpYnV0ZTogYXR0cmlidXRvcl8xLmRlZmF1bHQsXG4gICAgICAgIENsYXNzOiBjbGFzc18xLmRlZmF1bHQsXG4gICAgICAgIFN0eWxlOiBzdHlsZV8xLmRlZmF1bHQsXG4gICAgICAgIFN0b3JlOiBzdG9yZV8xLmRlZmF1bHQsXG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBQYXJjaG1lbnQ7XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYXJjaG1lbnRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFyY2htZW50RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFyY2htZW50RXJyb3IobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtZXNzYWdlID0gJ1tQYXJjaG1lbnRdICcgKyBtZXNzYWdlO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBfdGhpcy5uYW1lID0gX3RoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGFyY2htZW50RXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlBhcmNobWVudEVycm9yID0gUGFyY2htZW50RXJyb3I7XG52YXIgYXR0cmlidXRlcyA9IHt9O1xudmFyIGNsYXNzZXMgPSB7fTtcbnZhciB0YWdzID0ge307XG52YXIgdHlwZXMgPSB7fTtcbmV4cG9ydHMuREFUQV9LRVkgPSAnX19ibG90JztcbnZhciBTY29wZTtcbihmdW5jdGlvbiAoU2NvcGUpIHtcbiAgICBTY29wZVtTY29wZVtcIlRZUEVcIl0gPSAzXSA9IFwiVFlQRVwiO1xuICAgIFNjb3BlW1Njb3BlW1wiTEVWRUxcIl0gPSAxMl0gPSBcIkxFVkVMXCI7XG4gICAgU2NvcGVbU2NvcGVbXCJBVFRSSUJVVEVcIl0gPSAxM10gPSBcIkFUVFJJQlVURVwiO1xuICAgIFNjb3BlW1Njb3BlW1wiQkxPVFwiXSA9IDE0XSA9IFwiQkxPVFwiO1xuICAgIFNjb3BlW1Njb3BlW1wiSU5MSU5FXCJdID0gN10gPSBcIklOTElORVwiO1xuICAgIFNjb3BlW1Njb3BlW1wiQkxPQ0tcIl0gPSAxMV0gPSBcIkJMT0NLXCI7XG4gICAgU2NvcGVbU2NvcGVbXCJCTE9DS19CTE9UXCJdID0gMTBdID0gXCJCTE9DS19CTE9UXCI7XG4gICAgU2NvcGVbU2NvcGVbXCJJTkxJTkVfQkxPVFwiXSA9IDZdID0gXCJJTkxJTkVfQkxPVFwiO1xuICAgIFNjb3BlW1Njb3BlW1wiQkxPQ0tfQVRUUklCVVRFXCJdID0gOV0gPSBcIkJMT0NLX0FUVFJJQlVURVwiO1xuICAgIFNjb3BlW1Njb3BlW1wiSU5MSU5FX0FUVFJJQlVURVwiXSA9IDVdID0gXCJJTkxJTkVfQVRUUklCVVRFXCI7XG4gICAgU2NvcGVbU2NvcGVbXCJBTllcIl0gPSAxNV0gPSBcIkFOWVwiO1xufSkoU2NvcGUgPSBleHBvcnRzLlNjb3BlIHx8IChleHBvcnRzLlNjb3BlID0ge30pKTtcbmZ1bmN0aW9uIGNyZWF0ZShpbnB1dCwgdmFsdWUpIHtcbiAgICB2YXIgbWF0Y2ggPSBxdWVyeShpbnB1dCk7XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcmNobWVudEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSBcIiArIGlucHV0ICsgXCIgYmxvdFwiKTtcbiAgICB9XG4gICAgdmFyIEJsb3RDbGFzcyA9IG1hdGNoO1xuICAgIHZhciBub2RlID0gXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlucHV0IGluc3RhbmNlb2YgTm9kZSB8fCBpbnB1dFsnbm9kZVR5cGUnXSA9PT0gTm9kZS5URVhUX05PREUgPyBpbnB1dCA6IEJsb3RDbGFzcy5jcmVhdGUodmFsdWUpO1xuICAgIHJldHVybiBuZXcgQmxvdENsYXNzKG5vZGUsIHZhbHVlKTtcbn1cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZnVuY3Rpb24gZmluZChub2RlLCBidWJibGUpIHtcbiAgICBpZiAoYnViYmxlID09PSB2b2lkIDApIHsgYnViYmxlID0gZmFsc2U7IH1cbiAgICBpZiAobm9kZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKG5vZGVbZXhwb3J0cy5EQVRBX0tFWV0gIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG5vZGVbZXhwb3J0cy5EQVRBX0tFWV0uYmxvdDtcbiAgICBpZiAoYnViYmxlKVxuICAgICAgICByZXR1cm4gZmluZChub2RlLnBhcmVudE5vZGUsIGJ1YmJsZSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmZpbmQgPSBmaW5kO1xuZnVuY3Rpb24gcXVlcnkocXVlcnksIHNjb3BlKSB7XG4gICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHsgc2NvcGUgPSBTY29wZS5BTlk7IH1cbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWF0Y2ggPSB0eXBlc1txdWVyeV0gfHwgYXR0cmlidXRlc1txdWVyeV07XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICB9XG4gICAgZWxzZSBpZiAocXVlcnkgaW5zdGFuY2VvZiBUZXh0IHx8IHF1ZXJ5Wydub2RlVHlwZSddID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICBtYXRjaCA9IHR5cGVzWyd0ZXh0J107XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKHF1ZXJ5ICYgU2NvcGUuTEVWRUwgJiBTY29wZS5CTE9DSykge1xuICAgICAgICAgICAgbWF0Y2ggPSB0eXBlc1snYmxvY2snXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChxdWVyeSAmIFNjb3BlLkxFVkVMICYgU2NvcGUuSU5MSU5FKSB7XG4gICAgICAgICAgICBtYXRjaCA9IHR5cGVzWydpbmxpbmUnXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChxdWVyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHZhciBuYW1lcyA9IChxdWVyeS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gbmFtZXMpIHtcbiAgICAgICAgICAgIG1hdGNoID0gY2xhc3Nlc1tuYW1lc1tpXV07XG4gICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSBtYXRjaCB8fCB0YWdzW3F1ZXJ5LnRhZ05hbWVdO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChzY29wZSAmIFNjb3BlLkxFVkVMICYgbWF0Y2guc2NvcGUgJiYgc2NvcGUgJiBTY29wZS5UWVBFICYgbWF0Y2guc2NvcGUpXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMucXVlcnkgPSBxdWVyeTtcbmZ1bmN0aW9uIHJlZ2lzdGVyKCkge1xuICAgIHZhciBEZWZpbml0aW9ucyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIERlZmluaXRpb25zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmIChEZWZpbml0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybiBEZWZpbml0aW9ucy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdpc3RlcihkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBEZWZpbml0aW9uID0gRGVmaW5pdGlvbnNbMF07XG4gICAgaWYgKHR5cGVvZiBEZWZpbml0aW9uLmJsb3ROYW1lICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgRGVmaW5pdGlvbi5hdHRyTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcmNobWVudEVycm9yKCdJbnZhbGlkIGRlZmluaXRpb24nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoRGVmaW5pdGlvbi5ibG90TmFtZSA9PT0gJ2Fic3RyYWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgUGFyY2htZW50RXJyb3IoJ0Nhbm5vdCByZWdpc3RlciBhYnN0cmFjdCBjbGFzcycpO1xuICAgIH1cbiAgICB0eXBlc1tEZWZpbml0aW9uLmJsb3ROYW1lIHx8IERlZmluaXRpb24uYXR0ck5hbWVdID0gRGVmaW5pdGlvbjtcbiAgICBpZiAodHlwZW9mIERlZmluaXRpb24ua2V5TmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXR0cmlidXRlc1tEZWZpbml0aW9uLmtleU5hbWVdID0gRGVmaW5pdGlvbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChEZWZpbml0aW9uLmNsYXNzTmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGFzc2VzW0RlZmluaXRpb24uY2xhc3NOYW1lXSA9IERlZmluaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKERlZmluaXRpb24udGFnTmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShEZWZpbml0aW9uLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgRGVmaW5pdGlvbi50YWdOYW1lID0gRGVmaW5pdGlvbi50YWdOYW1lLm1hcChmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRGVmaW5pdGlvbi50YWdOYW1lID0gRGVmaW5pdGlvbi50YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGFnTmFtZXMgPSBBcnJheS5pc0FycmF5KERlZmluaXRpb24udGFnTmFtZSkgPyBEZWZpbml0aW9uLnRhZ05hbWUgOiBbRGVmaW5pdGlvbi50YWdOYW1lXTtcbiAgICAgICAgICAgIHRhZ05hbWVzLmZvckVhY2goZnVuY3Rpb24gKHRhZykge1xuICAgICAgICAgICAgICAgIGlmICh0YWdzW3RhZ10gPT0gbnVsbCB8fCBEZWZpbml0aW9uLmNsYXNzTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ3NbdGFnXSA9IERlZmluaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIERlZmluaXRpb247XG59XG5leHBvcnRzLnJlZ2lzdGVyID0gcmVnaXN0ZXI7XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkaWZmID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XG52YXIgZXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbnZhciBleHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIG9wID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cblxudmFyIE5VTExfQ0hBUkFDVEVSID0gU3RyaW5nLmZyb21DaGFyQ29kZSgwKTsgIC8vIFBsYWNlaG9sZGVyIGNoYXIgZm9yIGVtYmVkIGluIGRpZmYoKVxuXG5cbnZhciBEZWx0YSA9IGZ1bmN0aW9uIChvcHMpIHtcbiAgLy8gQXNzdW1lIHdlIGFyZSBnaXZlbiBhIHdlbGwgZm9ybWVkIG9wc1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHMpKSB7XG4gICAgdGhpcy5vcHMgPSBvcHM7XG4gIH0gZWxzZSBpZiAob3BzICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheShvcHMub3BzKSkge1xuICAgIHRoaXMub3BzID0gb3BzLm9wcztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wcyA9IFtdO1xuICB9XG59O1xuXG5cbkRlbHRhLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodGV4dCwgYXR0cmlidXRlcykge1xuICB2YXIgbmV3T3AgPSB7fTtcbiAgaWYgKHRleHQubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcztcbiAgbmV3T3AuaW5zZXJ0ID0gdGV4dDtcbiAgaWYgKGF0dHJpYnV0ZXMgIT0gbnVsbCAmJiB0eXBlb2YgYXR0cmlidXRlcyA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgIG5ld09wLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICB9XG4gIHJldHVybiB0aGlzLnB1c2gobmV3T3ApO1xufTtcblxuRGVsdGEucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA8PSAwKSByZXR1cm4gdGhpcztcbiAgcmV0dXJuIHRoaXMucHVzaCh7ICdkZWxldGUnOiBsZW5ndGggfSk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUucmV0YWluID0gZnVuY3Rpb24gKGxlbmd0aCwgYXR0cmlidXRlcykge1xuICBpZiAobGVuZ3RoIDw9IDApIHJldHVybiB0aGlzO1xuICB2YXIgbmV3T3AgPSB7IHJldGFpbjogbGVuZ3RoIH07XG4gIGlmIChhdHRyaWJ1dGVzICE9IG51bGwgJiYgdHlwZW9mIGF0dHJpYnV0ZXMgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICBuZXdPcC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgfVxuICByZXR1cm4gdGhpcy5wdXNoKG5ld09wKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG5ld09wKSB7XG4gIHZhciBpbmRleCA9IHRoaXMub3BzLmxlbmd0aDtcbiAgdmFyIGxhc3RPcCA9IHRoaXMub3BzW2luZGV4IC0gMV07XG4gIG5ld09wID0gZXh0ZW5kKHRydWUsIHt9LCBuZXdPcCk7XG4gIGlmICh0eXBlb2YgbGFzdE9wID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh0eXBlb2YgbmV3T3BbJ2RlbGV0ZSddID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGFzdE9wWydkZWxldGUnXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMub3BzW2luZGV4IC0gMV0gPSB7ICdkZWxldGUnOiBsYXN0T3BbJ2RlbGV0ZSddICsgbmV3T3BbJ2RlbGV0ZSddIH07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gU2luY2UgaXQgZG9lcyBub3QgbWF0dGVyIGlmIHdlIGluc2VydCBiZWZvcmUgb3IgYWZ0ZXIgZGVsZXRpbmcgYXQgdGhlIHNhbWUgaW5kZXgsXG4gICAgLy8gYWx3YXlzIHByZWZlciB0byBpbnNlcnQgZmlyc3RcbiAgICBpZiAodHlwZW9mIGxhc3RPcFsnZGVsZXRlJ10gPT09ICdudW1iZXInICYmIG5ld09wLmluc2VydCAhPSBudWxsKSB7XG4gICAgICBpbmRleCAtPSAxO1xuICAgICAgbGFzdE9wID0gdGhpcy5vcHNbaW5kZXggLSAxXTtcbiAgICAgIGlmICh0eXBlb2YgbGFzdE9wICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLm9wcy51bnNoaWZ0KG5ld09wKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlcXVhbChuZXdPcC5hdHRyaWJ1dGVzLCBsYXN0T3AuYXR0cmlidXRlcykpIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3T3AuaW5zZXJ0ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgbGFzdE9wLmluc2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vcHNbaW5kZXggLSAxXSA9IHsgaW5zZXJ0OiBsYXN0T3AuaW5zZXJ0ICsgbmV3T3AuaW5zZXJ0IH07XG4gICAgICAgIGlmICh0eXBlb2YgbmV3T3AuYXR0cmlidXRlcyA9PT0gJ29iamVjdCcpIHRoaXMub3BzW2luZGV4IC0gMV0uYXR0cmlidXRlcyA9IG5ld09wLmF0dHJpYnV0ZXNcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdPcC5yZXRhaW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBsYXN0T3AucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLm9wc1tpbmRleCAtIDFdID0geyByZXRhaW46IGxhc3RPcC5yZXRhaW4gKyBuZXdPcC5yZXRhaW4gfTtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPcC5hdHRyaWJ1dGVzID09PSAnb2JqZWN0JykgdGhpcy5vcHNbaW5kZXggLSAxXS5hdHRyaWJ1dGVzID0gbmV3T3AuYXR0cmlidXRlc1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGluZGV4ID09PSB0aGlzLm9wcy5sZW5ndGgpIHtcbiAgICB0aGlzLm9wcy5wdXNoKG5ld09wKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wcy5zcGxpY2UoaW5kZXgsIDAsIG5ld09wKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5jaG9wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGFzdE9wID0gdGhpcy5vcHNbdGhpcy5vcHMubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0T3AgJiYgbGFzdE9wLnJldGFpbiAmJiAhbGFzdE9wLmF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLm9wcy5wb3AoKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gIHJldHVybiB0aGlzLm9wcy5maWx0ZXIocHJlZGljYXRlKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICB0aGlzLm9wcy5mb3JFYWNoKHByZWRpY2F0ZSk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICByZXR1cm4gdGhpcy5vcHMubWFwKHByZWRpY2F0ZSk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUucGFydGl0aW9uID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICB2YXIgcGFzc2VkID0gW10sIGZhaWxlZCA9IFtdO1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24ob3ApIHtcbiAgICB2YXIgdGFyZ2V0ID0gcHJlZGljYXRlKG9wKSA/IHBhc3NlZCA6IGZhaWxlZDtcbiAgICB0YXJnZXQucHVzaChvcCk7XG4gIH0pO1xuICByZXR1cm4gW3Bhc3NlZCwgZmFpbGVkXTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAocHJlZGljYXRlLCBpbml0aWFsKSB7XG4gIHJldHVybiB0aGlzLm9wcy5yZWR1Y2UocHJlZGljYXRlLCBpbml0aWFsKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5jaGFuZ2VMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlZHVjZShmdW5jdGlvbiAobGVuZ3RoLCBlbGVtKSB7XG4gICAgaWYgKGVsZW0uaW5zZXJ0KSB7XG4gICAgICByZXR1cm4gbGVuZ3RoICsgb3AubGVuZ3RoKGVsZW0pO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5kZWxldGUpIHtcbiAgICAgIHJldHVybiBsZW5ndGggLSBlbGVtLmRlbGV0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfSwgMCk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWR1Y2UoZnVuY3Rpb24gKGxlbmd0aCwgZWxlbSkge1xuICAgIHJldHVybiBsZW5ndGggKyBvcC5sZW5ndGgoZWxlbSk7XG4gIH0sIDApO1xufTtcblxuRGVsdGEucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicpIGVuZCA9IEluZmluaXR5O1xuICB2YXIgb3BzID0gW107XG4gIHZhciBpdGVyID0gb3AuaXRlcmF0b3IodGhpcy5vcHMpO1xuICB2YXIgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBlbmQgJiYgaXRlci5oYXNOZXh0KCkpIHtcbiAgICB2YXIgbmV4dE9wO1xuICAgIGlmIChpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBuZXh0T3AgPSBpdGVyLm5leHQoc3RhcnQgLSBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRPcCA9IGl0ZXIubmV4dChlbmQgLSBpbmRleCk7XG4gICAgICBvcHMucHVzaChuZXh0T3ApO1xuICAgIH1cbiAgICBpbmRleCArPSBvcC5sZW5ndGgobmV4dE9wKTtcbiAgfVxuICByZXR1cm4gbmV3IERlbHRhKG9wcyk7XG59O1xuXG5cbkRlbHRhLnByb3RvdHlwZS5jb21wb3NlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHZhciB0aGlzSXRlciA9IG9wLml0ZXJhdG9yKHRoaXMub3BzKTtcbiAgdmFyIG90aGVySXRlciA9IG9wLml0ZXJhdG9yKG90aGVyLm9wcyk7XG4gIHZhciBvcHMgPSBbXTtcbiAgdmFyIGZpcnN0T3RoZXIgPSBvdGhlckl0ZXIucGVlaygpO1xuICBpZiAoZmlyc3RPdGhlciAhPSBudWxsICYmIHR5cGVvZiBmaXJzdE90aGVyLnJldGFpbiA9PT0gJ251bWJlcicgJiYgZmlyc3RPdGhlci5hdHRyaWJ1dGVzID09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RMZWZ0ID0gZmlyc3RPdGhlci5yZXRhaW47XG4gICAgd2hpbGUgKHRoaXNJdGVyLnBlZWtUeXBlKCkgPT09ICdpbnNlcnQnICYmIHRoaXNJdGVyLnBlZWtMZW5ndGgoKSA8PSBmaXJzdExlZnQpIHtcbiAgICAgIGZpcnN0TGVmdCAtPSB0aGlzSXRlci5wZWVrTGVuZ3RoKCk7XG4gICAgICBvcHMucHVzaCh0aGlzSXRlci5uZXh0KCkpO1xuICAgIH1cbiAgICBpZiAoZmlyc3RPdGhlci5yZXRhaW4gLSBmaXJzdExlZnQgPiAwKSB7XG4gICAgICBvdGhlckl0ZXIubmV4dChmaXJzdE90aGVyLnJldGFpbiAtIGZpcnN0TGVmdCk7XG4gICAgfVxuICB9XG4gIHZhciBkZWx0YSA9IG5ldyBEZWx0YShvcHMpO1xuICB3aGlsZSAodGhpc0l0ZXIuaGFzTmV4dCgpIHx8IG90aGVySXRlci5oYXNOZXh0KCkpIHtcbiAgICBpZiAob3RoZXJJdGVyLnBlZWtUeXBlKCkgPT09ICdpbnNlcnQnKSB7XG4gICAgICBkZWx0YS5wdXNoKG90aGVySXRlci5uZXh0KCkpO1xuICAgIH0gZWxzZSBpZiAodGhpc0l0ZXIucGVla1R5cGUoKSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgIGRlbHRhLnB1c2godGhpc0l0ZXIubmV4dCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHRoaXNJdGVyLnBlZWtMZW5ndGgoKSwgb3RoZXJJdGVyLnBlZWtMZW5ndGgoKSk7XG4gICAgICB2YXIgdGhpc09wID0gdGhpc0l0ZXIubmV4dChsZW5ndGgpO1xuICAgICAgdmFyIG90aGVyT3AgPSBvdGhlckl0ZXIubmV4dChsZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBvdGhlck9wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIG5ld09wID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc09wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBuZXdPcC5yZXRhaW4gPSBsZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3T3AuaW5zZXJ0ID0gdGhpc09wLmluc2VydDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVzZXJ2ZSBudWxsIHdoZW4gY29tcG9zaW5nIHdpdGggYSByZXRhaW4sIG90aGVyd2lzZSByZW1vdmUgaXQgZm9yIGluc2VydHNcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBvcC5hdHRyaWJ1dGVzLmNvbXBvc2UodGhpc09wLmF0dHJpYnV0ZXMsIG90aGVyT3AuYXR0cmlidXRlcywgdHlwZW9mIHRoaXNPcC5yZXRhaW4gPT09ICdudW1iZXInKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIG5ld09wLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICBkZWx0YS5wdXNoKG5ld09wKTtcblxuICAgICAgICAvLyBPcHRpbWl6YXRpb24gaWYgcmVzdCBvZiBvdGhlciBpcyBqdXN0IHJldGFpblxuICAgICAgICBpZiAoIW90aGVySXRlci5oYXNOZXh0KCkgJiYgZXF1YWwoZGVsdGEub3BzW2RlbHRhLm9wcy5sZW5ndGggLSAxXSwgbmV3T3ApKSB7XG4gICAgICAgICAgdmFyIHJlc3QgPSBuZXcgRGVsdGEodGhpc0l0ZXIucmVzdCgpKTtcbiAgICAgICAgICByZXR1cm4gZGVsdGEuY29uY2F0KHJlc3QpLmNob3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBPdGhlciBvcCBzaG91bGQgYmUgZGVsZXRlLCB3ZSBjb3VsZCBiZSBhbiBpbnNlcnQgb3IgcmV0YWluXG4gICAgICAvLyBJbnNlcnQgKyBkZWxldGUgY2FuY2VscyBvdXRcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG90aGVyT3BbJ2RlbGV0ZSddID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdGhpc09wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZGVsdGEucHVzaChvdGhlck9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlbHRhLmNob3AoKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgdmFyIGRlbHRhID0gbmV3IERlbHRhKHRoaXMub3BzLnNsaWNlKCkpO1xuICBpZiAob3RoZXIub3BzLmxlbmd0aCA+IDApIHtcbiAgICBkZWx0YS5wdXNoKG90aGVyLm9wc1swXSk7XG4gICAgZGVsdGEub3BzID0gZGVsdGEub3BzLmNvbmNhdChvdGhlci5vcHMuc2xpY2UoMSkpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKG90aGVyLCBpbmRleCkge1xuICBpZiAodGhpcy5vcHMgPT09IG90aGVyLm9wcykge1xuICAgIHJldHVybiBuZXcgRGVsdGEoKTtcbiAgfVxuICB2YXIgc3RyaW5ncyA9IFt0aGlzLCBvdGhlcl0ubWFwKGZ1bmN0aW9uIChkZWx0YSkge1xuICAgIHJldHVybiBkZWx0YS5tYXAoZnVuY3Rpb24gKG9wKSB7XG4gICAgICBpZiAob3AuaW5zZXJ0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnID8gb3AuaW5zZXJ0IDogTlVMTF9DSEFSQUNURVI7XG4gICAgICB9XG4gICAgICB2YXIgcHJlcCA9IChkZWx0YSA9PT0gb3RoZXIpID8gJ29uJyA6ICd3aXRoJztcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGlmZigpIGNhbGxlZCAnICsgcHJlcCArICcgbm9uLWRvY3VtZW50Jyk7XG4gICAgfSkuam9pbignJyk7XG4gIH0pO1xuICB2YXIgZGVsdGEgPSBuZXcgRGVsdGEoKTtcbiAgdmFyIGRpZmZSZXN1bHQgPSBkaWZmKHN0cmluZ3NbMF0sIHN0cmluZ3NbMV0sIGluZGV4KTtcbiAgdmFyIHRoaXNJdGVyID0gb3AuaXRlcmF0b3IodGhpcy5vcHMpO1xuICB2YXIgb3RoZXJJdGVyID0gb3AuaXRlcmF0b3Iob3RoZXIub3BzKTtcbiAgZGlmZlJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICB2YXIgbGVuZ3RoID0gY29tcG9uZW50WzFdLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgdmFyIG9wTGVuZ3RoID0gMDtcbiAgICAgIHN3aXRjaCAoY29tcG9uZW50WzBdKSB7XG4gICAgICAgIGNhc2UgZGlmZi5JTlNFUlQ6XG4gICAgICAgICAgb3BMZW5ndGggPSBNYXRoLm1pbihvdGhlckl0ZXIucGVla0xlbmd0aCgpLCBsZW5ndGgpO1xuICAgICAgICAgIGRlbHRhLnB1c2gob3RoZXJJdGVyLm5leHQob3BMZW5ndGgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBkaWZmLkRFTEVURTpcbiAgICAgICAgICBvcExlbmd0aCA9IE1hdGgubWluKGxlbmd0aCwgdGhpc0l0ZXIucGVla0xlbmd0aCgpKTtcbiAgICAgICAgICB0aGlzSXRlci5uZXh0KG9wTGVuZ3RoKTtcbiAgICAgICAgICBkZWx0YVsnZGVsZXRlJ10ob3BMZW5ndGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGRpZmYuRVFVQUw6XG4gICAgICAgICAgb3BMZW5ndGggPSBNYXRoLm1pbih0aGlzSXRlci5wZWVrTGVuZ3RoKCksIG90aGVySXRlci5wZWVrTGVuZ3RoKCksIGxlbmd0aCk7XG4gICAgICAgICAgdmFyIHRoaXNPcCA9IHRoaXNJdGVyLm5leHQob3BMZW5ndGgpO1xuICAgICAgICAgIHZhciBvdGhlck9wID0gb3RoZXJJdGVyLm5leHQob3BMZW5ndGgpO1xuICAgICAgICAgIGlmIChlcXVhbCh0aGlzT3AuaW5zZXJ0LCBvdGhlck9wLmluc2VydCkpIHtcbiAgICAgICAgICAgIGRlbHRhLnJldGFpbihvcExlbmd0aCwgb3AuYXR0cmlidXRlcy5kaWZmKHRoaXNPcC5hdHRyaWJ1dGVzLCBvdGhlck9wLmF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGEucHVzaChvdGhlck9wKVsnZGVsZXRlJ10ob3BMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxlbmd0aCAtPSBvcExlbmd0aDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGVsdGEuY2hvcCgpO1xufTtcblxuRGVsdGEucHJvdG90eXBlLmVhY2hMaW5lID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgbmV3bGluZSkge1xuICBuZXdsaW5lID0gbmV3bGluZSB8fCAnXFxuJztcbiAgdmFyIGl0ZXIgPSBvcC5pdGVyYXRvcih0aGlzLm9wcyk7XG4gIHZhciBsaW5lID0gbmV3IERlbHRhKCk7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgaWYgKGl0ZXIucGVla1R5cGUoKSAhPT0gJ2luc2VydCcpIHJldHVybjtcbiAgICB2YXIgdGhpc09wID0gaXRlci5wZWVrKCk7XG4gICAgdmFyIHN0YXJ0ID0gb3AubGVuZ3RoKHRoaXNPcCkgLSBpdGVyLnBlZWtMZW5ndGgoKTtcbiAgICB2YXIgaW5kZXggPSB0eXBlb2YgdGhpc09wLmluc2VydCA9PT0gJ3N0cmluZycgP1xuICAgICAgdGhpc09wLmluc2VydC5pbmRleE9mKG5ld2xpbmUsIHN0YXJ0KSAtIHN0YXJ0IDogLTE7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgbGluZS5wdXNoKGl0ZXIubmV4dCgpKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID4gMCkge1xuICAgICAgbGluZS5wdXNoKGl0ZXIubmV4dChpbmRleCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJlZGljYXRlKGxpbmUsIGl0ZXIubmV4dCgxKS5hdHRyaWJ1dGVzIHx8IHt9LCBpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaSArPSAxO1xuICAgICAgbGluZSA9IG5ldyBEZWx0YSgpO1xuICAgIH1cbiAgfVxuICBpZiAobGluZS5sZW5ndGgoKSA+IDApIHtcbiAgICBwcmVkaWNhdGUobGluZSwge30sIGkpO1xuICB9XG59O1xuXG5EZWx0YS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKG90aGVyLCBwcmlvcml0eSkge1xuICBwcmlvcml0eSA9ICEhcHJpb3JpdHk7XG4gIGlmICh0eXBlb2Ygb3RoZXIgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9zaXRpb24ob3RoZXIsIHByaW9yaXR5KTtcbiAgfVxuICB2YXIgdGhpc0l0ZXIgPSBvcC5pdGVyYXRvcih0aGlzLm9wcyk7XG4gIHZhciBvdGhlckl0ZXIgPSBvcC5pdGVyYXRvcihvdGhlci5vcHMpO1xuICB2YXIgZGVsdGEgPSBuZXcgRGVsdGEoKTtcbiAgd2hpbGUgKHRoaXNJdGVyLmhhc05leHQoKSB8fCBvdGhlckl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgaWYgKHRoaXNJdGVyLnBlZWtUeXBlKCkgPT09ICdpbnNlcnQnICYmIChwcmlvcml0eSB8fCBvdGhlckl0ZXIucGVla1R5cGUoKSAhPT0gJ2luc2VydCcpKSB7XG4gICAgICBkZWx0YS5yZXRhaW4ob3AubGVuZ3RoKHRoaXNJdGVyLm5leHQoKSkpO1xuICAgIH0gZWxzZSBpZiAob3RoZXJJdGVyLnBlZWtUeXBlKCkgPT09ICdpbnNlcnQnKSB7XG4gICAgICBkZWx0YS5wdXNoKG90aGVySXRlci5uZXh0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4odGhpc0l0ZXIucGVla0xlbmd0aCgpLCBvdGhlckl0ZXIucGVla0xlbmd0aCgpKTtcbiAgICAgIHZhciB0aGlzT3AgPSB0aGlzSXRlci5uZXh0KGxlbmd0aCk7XG4gICAgICB2YXIgb3RoZXJPcCA9IG90aGVySXRlci5uZXh0KGxlbmd0aCk7XG4gICAgICBpZiAodGhpc09wWydkZWxldGUnXSkge1xuICAgICAgICAvLyBPdXIgZGVsZXRlIGVpdGhlciBtYWtlcyB0aGVpciBkZWxldGUgcmVkdW5kYW50IG9yIHJlbW92ZXMgdGhlaXIgcmV0YWluXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChvdGhlck9wWydkZWxldGUnXSkge1xuICAgICAgICBkZWx0YS5wdXNoKG90aGVyT3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgcmV0YWluIGVpdGhlciB0aGVpciByZXRhaW4gb3IgaW5zZXJ0XG4gICAgICAgIGRlbHRhLnJldGFpbihsZW5ndGgsIG9wLmF0dHJpYnV0ZXMudHJhbnNmb3JtKHRoaXNPcC5hdHRyaWJ1dGVzLCBvdGhlck9wLmF0dHJpYnV0ZXMsIHByaW9yaXR5KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWx0YS5jaG9wKCk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUudHJhbnNmb3JtUG9zaXRpb24gPSBmdW5jdGlvbiAoaW5kZXgsIHByaW9yaXR5KSB7XG4gIHByaW9yaXR5ID0gISFwcmlvcml0eTtcbiAgdmFyIHRoaXNJdGVyID0gb3AuaXRlcmF0b3IodGhpcy5vcHMpO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgd2hpbGUgKHRoaXNJdGVyLmhhc05leHQoKSAmJiBvZmZzZXQgPD0gaW5kZXgpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpc0l0ZXIucGVla0xlbmd0aCgpO1xuICAgIHZhciBuZXh0VHlwZSA9IHRoaXNJdGVyLnBlZWtUeXBlKCk7XG4gICAgdGhpc0l0ZXIubmV4dCgpO1xuICAgIGlmIChuZXh0VHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgIGluZGV4IC09IE1hdGgubWluKGxlbmd0aCwgaW5kZXggLSBvZmZzZXQpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChuZXh0VHlwZSA9PT0gJ2luc2VydCcgJiYgKG9mZnNldCA8IGluZGV4IHx8ICFwcmlvcml0eSkpIHtcbiAgICAgIGluZGV4ICs9IGxlbmd0aDtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRGVsdGE7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XG5cdGlmICh0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBBcnJheS5pc0FycmF5KGFycik7XG5cdH1cblxuXHRyZXR1cm4gdG9TdHIuY2FsbChhcnIpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIGlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuXHRpZiAoIW9iaiB8fCB0b1N0ci5jYWxsKG9iaikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIGhhc093bkNvbnN0cnVjdG9yID0gaGFzT3duLmNhbGwob2JqLCAnY29uc3RydWN0b3InKTtcblx0dmFyIGhhc0lzUHJvdG90eXBlT2YgPSBvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSAmJiBoYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCAnaXNQcm90b3R5cGVPZicpO1xuXHQvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG5cdGlmIChvYmouY29uc3RydWN0b3IgJiYgIWhhc093bkNvbnN0cnVjdG9yICYmICFoYXNJc1Byb3RvdHlwZU9mKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsXG5cdC8vIGlmIGxhc3Qgb25lIGlzIG93biwgdGhlbiBhbGwgcHJvcGVydGllcyBhcmUgb3duLlxuXHR2YXIga2V5O1xuXHRmb3IgKGtleSBpbiBvYmopIHsgLyoqLyB9XG5cblx0cmV0dXJuIHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnIHx8IGhhc093bi5jYWxsKG9iaiwga2V5KTtcbn07XG5cbi8vIElmIG5hbWUgaXMgJ19fcHJvdG9fXycsIGFuZCBPYmplY3QuZGVmaW5lUHJvcGVydHkgaXMgYXZhaWxhYmxlLCBkZWZpbmUgX19wcm90b19fIGFzIGFuIG93biBwcm9wZXJ0eSBvbiB0YXJnZXRcbnZhciBzZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByb3BlcnR5KHRhcmdldCwgb3B0aW9ucykge1xuXHRpZiAoZGVmaW5lUHJvcGVydHkgJiYgb3B0aW9ucy5uYW1lID09PSAnX19wcm90b19fJykge1xuXHRcdGRlZmluZVByb3BlcnR5KHRhcmdldCwgb3B0aW9ucy5uYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0dmFsdWU6IG9wdGlvbnMubmV3VmFsdWUsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHRhcmdldFtvcHRpb25zLm5hbWVdID0gb3B0aW9ucy5uZXdWYWx1ZTtcblx0fVxufTtcblxuLy8gUmV0dXJuIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIF9fcHJvdG9fXyBpZiAnX19wcm90b19fJyBpcyBub3QgYW4gb3duIHByb3BlcnR5XG52YXIgZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0eShvYmosIG5hbWUpIHtcblx0aWYgKG5hbWUgPT09ICdfX3Byb3RvX18nKSB7XG5cdFx0aWYgKCFoYXNPd24uY2FsbChvYmosIG5hbWUpKSB7XG5cdFx0XHRyZXR1cm4gdm9pZCAwO1xuXHRcdH0gZWxzZSBpZiAoZ09QRCkge1xuXHRcdFx0Ly8gSW4gZWFybHkgdmVyc2lvbnMgb2Ygbm9kZSwgb2JqWydfX3Byb3RvX18nXSBpcyBidWdneSB3aGVuIG9iaiBoYXNcblx0XHRcdC8vIF9fcHJvdG9fXyBhcyBhbiBvd24gcHJvcGVydHkuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoKSB3b3Jrcy5cblx0XHRcdHJldHVybiBnT1BEKG9iaiwgbmFtZSkudmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG9ialtuYW1lXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXh0ZW5kKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmU7XG5cdHZhciB0YXJnZXQgPSBhcmd1bWVudHNbMF07XG5cdHZhciBpID0gMTtcblx0dmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdHZhciBkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XG5cdFx0Ly8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdGkgPSAyO1xuXHR9XG5cdGlmICh0YXJnZXQgPT0gbnVsbCB8fCAodHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJykpIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdGZvciAoOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzW2ldO1xuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAob3B0aW9ucyAhPSBudWxsKSB7XG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuXHRcdFx0XHRzcmMgPSBnZXRQcm9wZXJ0eSh0YXJnZXQsIG5hbWUpO1xuXHRcdFx0XHRjb3B5ID0gZ2V0UHJvcGVydHkob3B0aW9ucywgbmFtZSk7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAodGFyZ2V0ICE9PSBjb3B5KSB7XG5cdFx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdFx0aWYgKGRlZXAgJiYgY29weSAmJiAoaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBpc0FycmF5KGNvcHkpKSkpIHtcblx0XHRcdFx0XHRcdGlmIChjb3B5SXNBcnJheSkge1xuXHRcdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHRcdHNldFByb3BlcnR5KHRhcmdldCwgeyBuYW1lOiBuYW1lLCBuZXdWYWx1ZTogZXh0ZW5kKGRlZXAsIGNsb25lLCBjb3B5KSB9KTtcblxuXHRcdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBjb3B5ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0c2V0UHJvcGVydHkodGFyZ2V0LCB7IG5hbWU6IG5hbWUsIG5ld1ZhbHVlOiBjb3B5IH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5CbG9ja0VtYmVkID0gZXhwb3J0cy5idWJibGVGb3JtYXRzID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9leHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kKTtcblxudmFyIF9xdWlsbERlbHRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9xdWlsbERlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsRGVsdGEpO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfYnJlYWsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9icmVhazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icmVhayk7XG5cbnZhciBfaW5saW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9pbmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5saW5lKTtcblxudmFyIF90ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RleHQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBORVdMSU5FX0xFTkdUSCA9IDE7XG5cbnZhciBCbG9ja0VtYmVkID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkRW1iZWQpIHtcbiAgX2luaGVyaXRzKEJsb2NrRW1iZWQsIF9QYXJjaG1lbnQkRW1iZWQpO1xuXG4gIGZ1bmN0aW9uIEJsb2NrRW1iZWQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJsb2NrRW1iZWQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCbG9ja0VtYmVkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2tFbWJlZCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJsb2NrRW1iZWQsIFt7XG4gICAga2V5OiAnYXR0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoKCkge1xuICAgICAgX2dldChCbG9ja0VtYmVkLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrRW1iZWQucHJvdG90eXBlKSwgJ2F0dGFjaCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLlN0b3JlKHRoaXMuZG9tTm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVsdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWx0YSgpIHtcbiAgICAgIHJldHVybiBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5pbnNlcnQodGhpcy52YWx1ZSgpLCAoMCwgX2V4dGVuZDIuZGVmYXVsdCkodGhpcy5mb3JtYXRzKCksIHRoaXMuYXR0cmlidXRlcy52YWx1ZXMoKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZSA9IF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobmFtZSwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DS19BVFRSSUJVVEUpO1xuICAgICAgaWYgKGF0dHJpYnV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5hdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0QXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QXQoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCdcXG4nKSkge1xuICAgICAgICB2YXIgYmxvY2sgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZShCbG9jay5ibG90TmFtZSk7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShibG9jaywgaW5kZXggPT09IDAgPyB0aGlzIDogdGhpcy5uZXh0KTtcbiAgICAgICAgYmxvY2suaW5zZXJ0QXQoMCwgdmFsdWUuc2xpY2UoMCwgLTEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoQmxvY2tFbWJlZC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9ja0VtYmVkLnByb3RvdHlwZSksICdpbnNlcnRBdCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIHZhbHVlLCBkZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCbG9ja0VtYmVkO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkKTtcblxuQmxvY2tFbWJlZC5zY29wZSA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0tfQkxPVDtcbi8vIEl0IGlzIGltcG9ydGFudCBmb3IgY3Vyc29yIGJlaGF2aW9yIEJsb2NrRW1iZWRzIHVzZSB0YWdzIHRoYXQgYXJlIGJsb2NrIGxldmVsIGVsZW1lbnRzXG5cblxudmFyIEJsb2NrID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkQmxvY2spIHtcbiAgX2luaGVyaXRzKEJsb2NrLCBfUGFyY2htZW50JEJsb2NrKTtcblxuICBmdW5jdGlvbiBCbG9jayhkb21Ob2RlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJsb2NrKTtcblxuICAgIHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQmxvY2suX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jaykpLmNhbGwodGhpcywgZG9tTm9kZSkpO1xuXG4gICAgX3RoaXMyLmNhY2hlID0ge307XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCbG9jaywgW3tcbiAgICBrZXk6ICdkZWx0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbHRhKCkge1xuICAgICAgaWYgKHRoaXMuY2FjaGUuZGVsdGEgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNhY2hlLmRlbHRhID0gdGhpcy5kZXNjZW5kYW50cyhfcGFyY2htZW50Mi5kZWZhdWx0LkxlYWYpLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIGxlYWYpIHtcbiAgICAgICAgICBpZiAobGVhZi5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsdGEuaW5zZXJ0KGxlYWYudmFsdWUoKSwgYnViYmxlRm9ybWF0cyhsZWFmKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKSkuaW5zZXJ0KCdcXG4nLCBidWJibGVGb3JtYXRzKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlLmRlbHRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZUF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQXQoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAnZGVsZXRlQXQnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChsZW5ndGggPD0gMCkgcmV0dXJuO1xuICAgICAgaWYgKF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobmFtZSwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DSykpIHtcbiAgICAgICAgaWYgKGluZGV4ICsgbGVuZ3RoID09PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgICAgdGhpcy5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KEJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksICdmb3JtYXRBdCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIE1hdGgubWluKGxlbmd0aCwgdGhpcy5sZW5ndGgoKSAtIGluZGV4IC0gMSksIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICBpZiAoZGVmICE9IG51bGwpIHJldHVybiBfZ2V0KEJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksICdpbnNlcnRBdCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIHZhbHVlLCBkZWYpO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIGxpbmVzID0gdmFsdWUuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHRleHQgPSBsaW5lcy5zaGlmdCgpO1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCgpIC0gMSB8fCB0aGlzLmNoaWxkcmVuLnRhaWwgPT0gbnVsbCkge1xuICAgICAgICAgIF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ2luc2VydEF0JywgdGhpcykuY2FsbCh0aGlzLCBNYXRoLm1pbihpbmRleCwgdGhpcy5sZW5ndGgoKSAtIDEpLCB0ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuLnRhaWwuaW5zZXJ0QXQodGhpcy5jaGlsZHJlbi50YWlsLmxlbmd0aCgpLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICB9XG4gICAgICB2YXIgYmxvY2sgPSB0aGlzO1xuICAgICAgbGluZXMucmVkdWNlKGZ1bmN0aW9uIChpbmRleCwgbGluZSkge1xuICAgICAgICBibG9jayA9IGJsb2NrLnNwbGl0KGluZGV4LCB0cnVlKTtcbiAgICAgICAgYmxvY2suaW5zZXJ0QXQoMCwgbGluZSk7XG4gICAgICAgIHJldHVybiBsaW5lLmxlbmd0aDtcbiAgICAgIH0sIGluZGV4ICsgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEJlZm9yZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShibG90LCByZWYpIHtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5jaGlsZHJlbi5oZWFkO1xuICAgICAgX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAnaW5zZXJ0QmVmb3JlJywgdGhpcykuY2FsbCh0aGlzLCBibG90LCByZWYpO1xuICAgICAgaWYgKGhlYWQgaW5zdGFuY2VvZiBfYnJlYWsyLmRlZmF1bHQpIHtcbiAgICAgICAgaGVhZC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsZW5ndGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNhY2hlLmxlbmd0aCA9IF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ2xlbmd0aCcsIHRoaXMpLmNhbGwodGhpcykgKyBORVdMSU5FX0xFTkdUSDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtb3ZlQ2hpbGRyZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlQ2hpbGRyZW4odGFyZ2V0LCByZWYpIHtcbiAgICAgIF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ21vdmVDaGlsZHJlbicsIHRoaXMpLmNhbGwodGhpcywgdGFyZ2V0LCByZWYpO1xuICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29wdGltaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW1pemUoY29udGV4dCkge1xuICAgICAgX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAnb3B0aW1pemUnLCB0aGlzKS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BhdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoKGluZGV4KSB7XG4gICAgICByZXR1cm4gX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAncGF0aCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZUNoaWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICAgIF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ3JlbW92ZUNoaWxkJywgdGhpcykuY2FsbCh0aGlzLCBjaGlsZCk7XG4gICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3BsaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdChpbmRleCkge1xuICAgICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgaWYgKGZvcmNlICYmIChpbmRleCA9PT0gMCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCgpIC0gTkVXTElORV9MRU5HVEgpKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dCk7XG4gICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV4dCA9IF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ3NwbGl0JywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgZm9yY2UpO1xuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCbG9jaztcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5CbG9jayk7XG5cbkJsb2NrLmJsb3ROYW1lID0gJ2Jsb2NrJztcbkJsb2NrLnRhZ05hbWUgPSAnUCc7XG5CbG9jay5kZWZhdWx0Q2hpbGQgPSAnYnJlYWsnO1xuQmxvY2suYWxsb3dlZENoaWxkcmVuID0gW19pbmxpbmUyLmRlZmF1bHQsIF9wYXJjaG1lbnQyLmRlZmF1bHQuRW1iZWQsIF90ZXh0Mi5kZWZhdWx0XTtcblxuZnVuY3Rpb24gYnViYmxlRm9ybWF0cyhibG90KSB7XG4gIHZhciBmb3JtYXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBpZiAoYmxvdCA9PSBudWxsKSByZXR1cm4gZm9ybWF0cztcbiAgaWYgKHR5cGVvZiBibG90LmZvcm1hdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmb3JtYXRzID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKGZvcm1hdHMsIGJsb3QuZm9ybWF0cygpKTtcbiAgfVxuICBpZiAoYmxvdC5wYXJlbnQgPT0gbnVsbCB8fCBibG90LnBhcmVudC5ibG90TmFtZSA9PSAnc2Nyb2xsJyB8fCBibG90LnBhcmVudC5zdGF0aWNzLnNjb3BlICE9PSBibG90LnN0YXRpY3Muc2NvcGUpIHtcbiAgICByZXR1cm4gZm9ybWF0cztcbiAgfVxuICByZXR1cm4gYnViYmxlRm9ybWF0cyhibG90LnBhcmVudCwgZm9ybWF0cyk7XG59XG5cbmV4cG9ydHMuYnViYmxlRm9ybWF0cyA9IGJ1YmJsZUZvcm1hdHM7XG5leHBvcnRzLkJsb2NrRW1iZWQgPSBCbG9ja0VtYmVkO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2s7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5vdmVybG9hZCA9IGV4cG9ydHMuZXhwYW5kQ29uZmlnID0gdW5kZWZpbmVkO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XG5cbnZhciBfcXVpbGxEZWx0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfcXVpbGxEZWx0YTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbERlbHRhKTtcblxudmFyIF9lZGl0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxudmFyIF9lZGl0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWRpdG9yKTtcblxudmFyIF9lbWl0dGVyMyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBfZW1pdHRlcjQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbWl0dGVyMyk7XG5cbnZhciBfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9tb2R1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlKTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX3NlbGVjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG52YXIgX3NlbGVjdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZWxlY3Rpb24pO1xuXG52YXIgX2V4dGVuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZXh0ZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZCk7XG5cbnZhciBfbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ2dlcik7XG5cbnZhciBfdGhlbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblxudmFyIF90aGVtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aGVtZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBkZWJ1ZyA9ICgwLCBfbG9nZ2VyMi5kZWZhdWx0KSgncXVpbGwnKTtcblxudmFyIFF1aWxsID0gZnVuY3Rpb24gKCkge1xuICBfY3JlYXRlQ2xhc3MoUXVpbGwsIG51bGwsIFt7XG4gICAga2V5OiAnZGVidWcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWJ1ZyhsaW1pdCkge1xuICAgICAgaWYgKGxpbWl0ID09PSB0cnVlKSB7XG4gICAgICAgIGxpbWl0ID0gJ2xvZyc7XG4gICAgICB9XG4gICAgICBfbG9nZ2VyMi5kZWZhdWx0LmxldmVsKGxpbWl0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmaW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5fX3F1aWxsIHx8IF9wYXJjaG1lbnQyLmRlZmF1bHQuZmluZChub2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbXBvcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW1wb3J0KG5hbWUpIHtcbiAgICAgIGlmICh0aGlzLmltcG9ydHNbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBkZWJ1Zy5lcnJvcignQ2Fubm90IGltcG9ydCAnICsgbmFtZSArICcuIEFyZSB5b3Ugc3VyZSBpdCB3YXMgcmVnaXN0ZXJlZD8nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmltcG9ydHNbbmFtZV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVnaXN0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcihwYXRoLCB0YXJnZXQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBvdmVyd3JpdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGF0aC5hdHRyTmFtZSB8fCBwYXRoLmJsb3ROYW1lO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gcmVnaXN0ZXIoQmxvdCB8IEF0dHJpYnV0b3IsIG92ZXJ3cml0ZSlcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyKCdmb3JtYXRzLycgKyBuYW1lLCBwYXRoLCB0YXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHBhdGgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgX3RoaXMucmVnaXN0ZXIoa2V5LCBwYXRoW2tleV0sIHRhcmdldCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmltcG9ydHNbcGF0aF0gIT0gbnVsbCAmJiAhb3ZlcndyaXRlKSB7XG4gICAgICAgICAgZGVidWcud2FybignT3ZlcndyaXRpbmcgJyArIHBhdGggKyAnIHdpdGgnLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1wb3J0c1twYXRoXSA9IHRhcmdldDtcbiAgICAgICAgaWYgKChwYXRoLnN0YXJ0c1dpdGgoJ2Jsb3RzLycpIHx8IHBhdGguc3RhcnRzV2l0aCgnZm9ybWF0cy8nKSkgJiYgdGFyZ2V0LmJsb3ROYW1lICE9PSAnYWJzdHJhY3QnKSB7XG4gICAgICAgICAgX3BhcmNobWVudDIuZGVmYXVsdC5yZWdpc3Rlcih0YXJnZXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGguc3RhcnRzV2l0aCgnbW9kdWxlcycpICYmIHR5cGVvZiB0YXJnZXQucmVnaXN0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0YXJnZXQucmVnaXN0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFF1aWxsKGNvbnRhaW5lcikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1aWxsKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IGV4cGFuZENvbmZpZyhjb250YWluZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICBpZiAodGhpcy5jb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGRlYnVnLmVycm9yKCdJbnZhbGlkIFF1aWxsIGNvbnRhaW5lcicsIGNvbnRhaW5lcik7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgIFF1aWxsLmRlYnVnKHRoaXMub3B0aW9ucy5kZWJ1Zyk7XG4gICAgfVxuICAgIHZhciBodG1sID0gdGhpcy5jb250YWluZXIuaW5uZXJIVE1MLnRyaW0oKTtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdxbC1jb250YWluZXInKTtcbiAgICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICB0aGlzLmNvbnRhaW5lci5fX3F1aWxsID0gdGhpcztcbiAgICB0aGlzLnJvb3QgPSB0aGlzLmFkZENvbnRhaW5lcigncWwtZWRpdG9yJyk7XG4gICAgdGhpcy5yb290LmNsYXNzTGlzdC5hZGQoJ3FsLWJsYW5rJyk7XG4gICAgdGhpcy5yb290LnNldEF0dHJpYnV0ZSgnZGF0YS1ncmFtbScsIGZhbHNlKTtcbiAgICB0aGlzLnNjcm9sbGluZ0NvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5zY3JvbGxpbmdDb250YWluZXIgfHwgdGhpcy5yb290O1xuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBfZW1pdHRlcjQuZGVmYXVsdCgpO1xuICAgIHRoaXMuc2Nyb2xsID0gX3BhcmNobWVudDIuZGVmYXVsdC5jcmVhdGUodGhpcy5yb290LCB7XG4gICAgICBlbWl0dGVyOiB0aGlzLmVtaXR0ZXIsXG4gICAgICB3aGl0ZWxpc3Q6IHRoaXMub3B0aW9ucy5mb3JtYXRzXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3IgPSBuZXcgX2VkaXRvcjIuZGVmYXVsdCh0aGlzLnNjcm9sbCk7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgX3NlbGVjdGlvbjIuZGVmYXVsdCh0aGlzLnNjcm9sbCwgdGhpcy5lbWl0dGVyKTtcbiAgICB0aGlzLnRoZW1lID0gbmV3IHRoaXMub3B0aW9ucy50aGVtZSh0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMua2V5Ym9hcmQgPSB0aGlzLnRoZW1lLmFkZE1vZHVsZSgna2V5Ym9hcmQnKTtcbiAgICB0aGlzLmNsaXBib2FyZCA9IHRoaXMudGhlbWUuYWRkTW9kdWxlKCdjbGlwYm9hcmQnKTtcbiAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLnRoZW1lLmFkZE1vZHVsZSgnaGlzdG9yeScpO1xuICAgIHRoaXMudGhlbWUuaW5pdCgpO1xuICAgIHRoaXMuZW1pdHRlci5vbihfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuRURJVE9SX0NIQU5HRSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuVEVYVF9DSEFOR0UpIHtcbiAgICAgICAgX3RoaXMyLnJvb3QuY2xhc3NMaXN0LnRvZ2dsZSgncWwtYmxhbmsnLCBfdGhpczIuZWRpdG9yLmlzQmxhbmsoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0dGVyLm9uKF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfVVBEQVRFLCBmdW5jdGlvbiAoc291cmNlLCBtdXRhdGlvbnMpIHtcbiAgICAgIHZhciByYW5nZSA9IF90aGlzMi5zZWxlY3Rpb24ubGFzdFJhbmdlO1xuICAgICAgdmFyIGluZGV4ID0gcmFuZ2UgJiYgcmFuZ2UubGVuZ3RoID09PSAwID8gcmFuZ2UuaW5kZXggOiB1bmRlZmluZWQ7XG4gICAgICBtb2RpZnkuY2FsbChfdGhpczIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5lZGl0b3IudXBkYXRlKG51bGwsIG11dGF0aW9ucywgaW5kZXgpO1xuICAgICAgfSwgc291cmNlKTtcbiAgICB9KTtcbiAgICB2YXIgY29udGVudHMgPSB0aGlzLmNsaXBib2FyZC5jb252ZXJ0KCc8ZGl2IGNsYXNzPVxcJ3FsLWVkaXRvclxcJyBzdHlsZT1cIndoaXRlLXNwYWNlOiBub3JtYWw7XCI+JyArIGh0bWwgKyAnPHA+PGJyPjwvcD48L2Rpdj4nKTtcbiAgICB0aGlzLnNldENvbnRlbnRzKGNvbnRlbnRzKTtcbiAgICB0aGlzLmhpc3RvcnkuY2xlYXIoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyKSB7XG4gICAgICB0aGlzLnJvb3Quc2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlaG9sZGVyJywgdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZWFkT25seSkge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFF1aWxsLCBbe1xuICAgIGtleTogJ2FkZENvbnRhaW5lcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgIHZhciByZWZOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbnRhaW5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNvbnRhaW5lcjtcbiAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCByZWZOb2RlKTtcbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYmx1cicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlVGV4dChpbmRleCwgbGVuZ3RoLCBzb3VyY2UpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgX292ZXJsb2FkID0gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCwgc291cmNlKTtcblxuICAgICAgdmFyIF9vdmVybG9hZDIgPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQsIDQpO1xuXG4gICAgICBpbmRleCA9IF9vdmVybG9hZDJbMF07XG4gICAgICBsZW5ndGggPSBfb3ZlcmxvYWQyWzFdO1xuICAgICAgc291cmNlID0gX292ZXJsb2FkMlszXTtcblxuICAgICAgcmV0dXJuIG1vZGlmeS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5lZGl0b3IuZGVsZXRlVGV4dChpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH0sIHNvdXJjZSwgaW5kZXgsIC0xICogbGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIHRoaXMuZW5hYmxlKGZhbHNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB2YXIgZW5hYmxlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcblxuICAgICAgdGhpcy5zY3JvbGwuZW5hYmxlKGVuYWJsZWQpO1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnRvZ2dsZSgncWwtZGlzYWJsZWQnLCAhZW5hYmxlZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9jdXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLnNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3A7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5mb2N1cygpO1xuICAgICAgdGhpcy5zY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuQVBJO1xuXG4gICAgICByZXR1cm4gbW9kaWZ5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBfdGhpczQuZ2V0U2VsZWN0aW9uKHRydWUpO1xuICAgICAgICB2YXIgY2hhbmdlID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCk7XG4gICAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICAgICAgfSBlbHNlIGlmIChfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KG5hbWUsIF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0spKSB7XG4gICAgICAgICAgY2hhbmdlID0gX3RoaXM0LmVkaXRvci5mb3JtYXRMaW5lKHJhbmdlLmluZGV4LCByYW5nZS5sZW5ndGgsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgbmFtZSwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBfdGhpczQuc2VsZWN0aW9uLmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFuZ2UgPSBfdGhpczQuZWRpdG9yLmZvcm1hdFRleHQocmFuZ2UuaW5kZXgsIHJhbmdlLmxlbmd0aCwgX2RlZmluZVByb3BlcnR5KHt9LCBuYW1lLCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzNC5zZXRTZWxlY3Rpb24ocmFuZ2UsIF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICAgIH0sIHNvdXJjZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0TGluZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdExpbmUoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUsIHNvdXJjZSkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtYXRzID0gdm9pZCAwO1xuXG4gICAgICB2YXIgX292ZXJsb2FkMyA9IG92ZXJsb2FkKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlLCBzb3VyY2UpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkNCA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZDMsIDQpO1xuXG4gICAgICBpbmRleCA9IF9vdmVybG9hZDRbMF07XG4gICAgICBsZW5ndGggPSBfb3ZlcmxvYWQ0WzFdO1xuICAgICAgZm9ybWF0cyA9IF9vdmVybG9hZDRbMl07XG4gICAgICBzb3VyY2UgPSBfb3ZlcmxvYWQ0WzNdO1xuXG4gICAgICByZXR1cm4gbW9kaWZ5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM1LmVkaXRvci5mb3JtYXRMaW5lKGluZGV4LCBsZW5ndGgsIGZvcm1hdHMpO1xuICAgICAgfSwgc291cmNlLCBpbmRleCwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0VGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFRleHQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUsIHNvdXJjZSkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtYXRzID0gdm9pZCAwO1xuXG4gICAgICB2YXIgX292ZXJsb2FkNSA9IG92ZXJsb2FkKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlLCBzb3VyY2UpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkNiA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZDUsIDQpO1xuXG4gICAgICBpbmRleCA9IF9vdmVybG9hZDZbMF07XG4gICAgICBsZW5ndGggPSBfb3ZlcmxvYWQ2WzFdO1xuICAgICAgZm9ybWF0cyA9IF9vdmVybG9hZDZbMl07XG4gICAgICBzb3VyY2UgPSBfb3ZlcmxvYWQ2WzNdO1xuXG4gICAgICByZXR1cm4gbW9kaWZ5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM2LmVkaXRvci5mb3JtYXRUZXh0KGluZGV4LCBsZW5ndGgsIGZvcm1hdHMpO1xuICAgICAgfSwgc291cmNlLCBpbmRleCwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Qm91bmRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRzKGluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgICB2YXIgYm91bmRzID0gdm9pZCAwO1xuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYm91bmRzID0gdGhpcy5zZWxlY3Rpb24uZ2V0Qm91bmRzKGluZGV4LCBsZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm91bmRzID0gdGhpcy5zZWxlY3Rpb24uZ2V0Qm91bmRzKGluZGV4LmluZGV4LCBpbmRleC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRhaW5lckJvdW5kcyA9IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYm90dG9tOiBib3VuZHMuYm90dG9tIC0gY29udGFpbmVyQm91bmRzLnRvcCxcbiAgICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0LFxuICAgICAgICBsZWZ0OiBib3VuZHMubGVmdCAtIGNvbnRhaW5lckJvdW5kcy5sZWZ0LFxuICAgICAgICByaWdodDogYm91bmRzLnJpZ2h0IC0gY29udGFpbmVyQm91bmRzLmxlZnQsXG4gICAgICAgIHRvcDogYm91bmRzLnRvcCAtIGNvbnRhaW5lckJvdW5kcy50b3AsXG4gICAgICAgIHdpZHRoOiBib3VuZHMud2lkdGhcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q29udGVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZW50cygpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuZ2V0TGVuZ3RoKCkgLSBpbmRleDtcblxuICAgICAgdmFyIF9vdmVybG9hZDcgPSBvdmVybG9hZChpbmRleCwgbGVuZ3RoKTtcblxuICAgICAgdmFyIF9vdmVybG9hZDggPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQ3LCAyKTtcblxuICAgICAgaW5kZXggPSBfb3ZlcmxvYWQ4WzBdO1xuICAgICAgbGVuZ3RoID0gX292ZXJsb2FkOFsxXTtcblxuICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldENvbnRlbnRzKGluZGV4LCBsZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEZvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvcm1hdCgpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5nZXRTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0Rm9ybWF0KGluZGV4LCBsZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldEZvcm1hdChpbmRleC5pbmRleCwgaW5kZXgubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRJbmRleCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluZGV4KGJsb3QpIHtcbiAgICAgIHJldHVybiBibG90Lm9mZnNldCh0aGlzLnNjcm9sbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TGVuZ3RoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsLmxlbmd0aCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldExlYWYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZWFmKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGwubGVhZihpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TGluZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExpbmUoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbC5saW5lKGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRMaW5lcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExpbmVzKCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsLmxpbmVzKGluZGV4LmluZGV4LCBpbmRleC5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsLmxpbmVzKGluZGV4LCBsZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldE1vZHVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vZHVsZShuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVtZS5tb2R1bGVzW25hbWVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFNlbGVjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGlvbigpIHtcbiAgICAgIHZhciBmb2N1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgIGlmIChmb2N1cykgdGhpcy5mb2N1cygpO1xuICAgICAgdGhpcy51cGRhdGUoKTsgLy8gTWFrZSBzdXJlIHdlIGFjY2VzcyBnZXRSYW5nZSB3aXRoIGVkaXRvciBpbiBjb25zaXN0ZW50IHN0YXRlXG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uZ2V0UmFuZ2UoKVswXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuZ2V0TGVuZ3RoKCkgLSBpbmRleDtcblxuICAgICAgdmFyIF9vdmVybG9hZDkgPSBvdmVybG9hZChpbmRleCwgbGVuZ3RoKTtcblxuICAgICAgdmFyIF9vdmVybG9hZDEwID0gX3NsaWNlZFRvQXJyYXkoX292ZXJsb2FkOSwgMik7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkMTBbMF07XG4gICAgICBsZW5ndGggPSBfb3ZlcmxvYWQxMFsxXTtcblxuICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldFRleHQoaW5kZXgsIGxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFzRm9jdXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNGb2N1cygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5oYXNGb2N1cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEVtYmVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0RW1iZWQoaW5kZXgsIGVtYmVkLCB2YWx1ZSkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFF1aWxsLnNvdXJjZXMuQVBJO1xuXG4gICAgICByZXR1cm4gbW9kaWZ5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM3LmVkaXRvci5pbnNlcnRFbWJlZChpbmRleCwgZW1iZWQsIHZhbHVlKTtcbiAgICAgIH0sIHNvdXJjZSwgaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydFRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRUZXh0KGluZGV4LCB0ZXh0LCBuYW1lLCB2YWx1ZSwgc291cmNlKSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdHMgPSB2b2lkIDA7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQxMSA9IG92ZXJsb2FkKGluZGV4LCAwLCBuYW1lLCB2YWx1ZSwgc291cmNlKTtcblxuICAgICAgdmFyIF9vdmVybG9hZDEyID0gX3NsaWNlZFRvQXJyYXkoX292ZXJsb2FkMTEsIDQpO1xuXG4gICAgICBpbmRleCA9IF9vdmVybG9hZDEyWzBdO1xuICAgICAgZm9ybWF0cyA9IF9vdmVybG9hZDEyWzJdO1xuICAgICAgc291cmNlID0gX292ZXJsb2FkMTJbM107XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczguZWRpdG9yLmluc2VydFRleHQoaW5kZXgsIHRleHQsIGZvcm1hdHMpO1xuICAgICAgfSwgc291cmNlLCBpbmRleCwgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lzRW5hYmxlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1kaXNhYmxlZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29mZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXR0ZXIub2ZmLmFwcGx5KHRoaXMuZW1pdHRlciwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdHRlci5vbi5hcHBseSh0aGlzLmVtaXR0ZXIsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25jZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uY2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0dGVyLm9uY2UuYXBwbHkodGhpcy5lbWl0dGVyLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Bhc3RlSFRNTCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhc3RlSFRNTChpbmRleCwgaHRtbCwgc291cmNlKSB7XG4gICAgICB0aGlzLmNsaXBib2FyZC5kYW5nZXJvdXNseVBhc3RlSFRNTChpbmRleCwgaHRtbCwgc291cmNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVGb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGb3JtYXQoaW5kZXgsIGxlbmd0aCwgc291cmNlKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgdmFyIF9vdmVybG9hZDEzID0gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCwgc291cmNlKTtcblxuICAgICAgdmFyIF9vdmVybG9hZDE0ID0gX3NsaWNlZFRvQXJyYXkoX292ZXJsb2FkMTMsIDQpO1xuXG4gICAgICBpbmRleCA9IF9vdmVybG9hZDE0WzBdO1xuICAgICAgbGVuZ3RoID0gX292ZXJsb2FkMTRbMV07XG4gICAgICBzb3VyY2UgPSBfb3ZlcmxvYWQxNFszXTtcblxuICAgICAgcmV0dXJuIG1vZGlmeS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzOS5lZGl0b3IucmVtb3ZlRm9ybWF0KGluZGV4LCBsZW5ndGgpO1xuICAgICAgfSwgc291cmNlLCBpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2Nyb2xsSW50b1ZpZXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldygpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnNjcm9sbEludG9WaWV3KHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDb250ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbnRlbnRzKGRlbHRhKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuQVBJO1xuXG4gICAgICByZXR1cm4gbW9kaWZ5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdChkZWx0YSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBfdGhpczEwLmdldExlbmd0aCgpO1xuICAgICAgICB2YXIgZGVsZXRlZCA9IF90aGlzMTAuZWRpdG9yLmRlbGV0ZVRleHQoMCwgbGVuZ3RoKTtcbiAgICAgICAgdmFyIGFwcGxpZWQgPSBfdGhpczEwLmVkaXRvci5hcHBseURlbHRhKGRlbHRhKTtcbiAgICAgICAgdmFyIGxhc3RPcCA9IGFwcGxpZWQub3BzW2FwcGxpZWQub3BzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdE9wICE9IG51bGwgJiYgdHlwZW9mIGxhc3RPcC5pbnNlcnQgPT09ICdzdHJpbmcnICYmIGxhc3RPcC5pbnNlcnRbbGFzdE9wLmluc2VydC5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBfdGhpczEwLmVkaXRvci5kZWxldGVUZXh0KF90aGlzMTAuZ2V0TGVuZ3RoKCkgLSAxLCAxKTtcbiAgICAgICAgICBhcHBsaWVkLmRlbGV0ZSgxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0ID0gZGVsZXRlZC5jb21wb3NlKGFwcGxpZWQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSwgc291cmNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRTZWxlY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oaW5kZXgsIGxlbmd0aCwgc291cmNlKSB7XG4gICAgICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShudWxsLCBsZW5ndGggfHwgUXVpbGwuc291cmNlcy5BUEkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9vdmVybG9hZDE1ID0gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCwgc291cmNlKTtcblxuICAgICAgICB2YXIgX292ZXJsb2FkMTYgPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQxNSwgNCk7XG5cbiAgICAgICAgaW5kZXggPSBfb3ZlcmxvYWQxNlswXTtcbiAgICAgICAgbGVuZ3RoID0gX292ZXJsb2FkMTZbMV07XG4gICAgICAgIHNvdXJjZSA9IF9vdmVybG9hZDE2WzNdO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFJhbmdlKG5ldyBfc2VsZWN0aW9uLlJhbmdlKGluZGV4LCBsZW5ndGgpLCBzb3VyY2UpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNjcm9sbEludG9WaWV3KHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUZXh0KHRleHQpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuQVBJO1xuXG4gICAgICB2YXIgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5pbnNlcnQodGV4dCk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDb250ZW50cyhkZWx0YSwgc291cmNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlVTRVI7XG5cbiAgICAgIHZhciBjaGFuZ2UgPSB0aGlzLnNjcm9sbC51cGRhdGUoc291cmNlKTsgLy8gV2lsbCB1cGRhdGUgc2VsZWN0aW9uIGJlZm9yZSBzZWxlY3Rpb24udXBkYXRlKCkgZG9lcyBpZiB0ZXh0IGNoYW5nZXNcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnVwZGF0ZShzb3VyY2UpO1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVDb250ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNvbnRlbnRzKGRlbHRhKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuQVBJO1xuXG4gICAgICByZXR1cm4gbW9kaWZ5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdChkZWx0YSk7XG4gICAgICAgIHJldHVybiBfdGhpczExLmVkaXRvci5hcHBseURlbHRhKGRlbHRhLCBzb3VyY2UpO1xuICAgICAgfSwgc291cmNlLCB0cnVlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUXVpbGw7XG59KCk7XG5cblF1aWxsLkRFRkFVTFRTID0ge1xuICBib3VuZHM6IG51bGwsXG4gIGZvcm1hdHM6IG51bGwsXG4gIG1vZHVsZXM6IHt9LFxuICBwbGFjZWhvbGRlcjogJycsXG4gIHJlYWRPbmx5OiBmYWxzZSxcbiAgc2Nyb2xsaW5nQ29udGFpbmVyOiBudWxsLFxuICBzdHJpY3Q6IHRydWUsXG4gIHRoZW1lOiAnZGVmYXVsdCdcbn07XG5RdWlsbC5ldmVudHMgPSBfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHM7XG5RdWlsbC5zb3VyY2VzID0gX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuUXVpbGwudmVyc2lvbiA9ICBmYWxzZSA/ICdkZXYnIDogXCIxLjMuN1wiO1xuXG5RdWlsbC5pbXBvcnRzID0ge1xuICAnZGVsdGEnOiBfcXVpbGxEZWx0YTIuZGVmYXVsdCxcbiAgJ3BhcmNobWVudCc6IF9wYXJjaG1lbnQyLmRlZmF1bHQsXG4gICdjb3JlL21vZHVsZSc6IF9tb2R1bGUyLmRlZmF1bHQsXG4gICdjb3JlL3RoZW1lJzogX3RoZW1lMi5kZWZhdWx0XG59O1xuXG5mdW5jdGlvbiBleHBhbmRDb25maWcoY29udGFpbmVyLCB1c2VyQ29uZmlnKSB7XG4gIHVzZXJDb25maWcgPSAoMCwgX2V4dGVuZDIuZGVmYXVsdCkodHJ1ZSwge1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIG1vZHVsZXM6IHtcbiAgICAgIGNsaXBib2FyZDogdHJ1ZSxcbiAgICAgIGtleWJvYXJkOiB0cnVlLFxuICAgICAgaGlzdG9yeTogdHJ1ZVxuICAgIH1cbiAgfSwgdXNlckNvbmZpZyk7XG4gIGlmICghdXNlckNvbmZpZy50aGVtZSB8fCB1c2VyQ29uZmlnLnRoZW1lID09PSBRdWlsbC5ERUZBVUxUUy50aGVtZSkge1xuICAgIHVzZXJDb25maWcudGhlbWUgPSBfdGhlbWUyLmRlZmF1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdXNlckNvbmZpZy50aGVtZSA9IFF1aWxsLmltcG9ydCgndGhlbWVzLycgKyB1c2VyQ29uZmlnLnRoZW1lKTtcbiAgICBpZiAodXNlckNvbmZpZy50aGVtZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGhlbWUgJyArIHVzZXJDb25maWcudGhlbWUgKyAnLiBEaWQgeW91IHJlZ2lzdGVyIGl0PycpO1xuICAgIH1cbiAgfVxuICB2YXIgdGhlbWVDb25maWcgPSAoMCwgX2V4dGVuZDIuZGVmYXVsdCkodHJ1ZSwge30sIHVzZXJDb25maWcudGhlbWUuREVGQVVMVFMpO1xuICBbdGhlbWVDb25maWcsIHVzZXJDb25maWddLmZvckVhY2goZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIGNvbmZpZy5tb2R1bGVzID0gY29uZmlnLm1vZHVsZXMgfHwge307XG4gICAgT2JqZWN0LmtleXMoY29uZmlnLm1vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgaWYgKGNvbmZpZy5tb2R1bGVzW21vZHVsZV0gPT09IHRydWUpIHtcbiAgICAgICAgY29uZmlnLm1vZHVsZXNbbW9kdWxlXSA9IHt9O1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgdmFyIG1vZHVsZU5hbWVzID0gT2JqZWN0LmtleXModGhlbWVDb25maWcubW9kdWxlcykuY29uY2F0KE9iamVjdC5rZXlzKHVzZXJDb25maWcubW9kdWxlcykpO1xuICB2YXIgbW9kdWxlQ29uZmlnID0gbW9kdWxlTmFtZXMucmVkdWNlKGZ1bmN0aW9uIChjb25maWcsIG5hbWUpIHtcbiAgICB2YXIgbW9kdWxlQ2xhc3MgPSBRdWlsbC5pbXBvcnQoJ21vZHVsZXMvJyArIG5hbWUpO1xuICAgIGlmIChtb2R1bGVDbGFzcyA9PSBudWxsKSB7XG4gICAgICBkZWJ1Zy5lcnJvcignQ2Fubm90IGxvYWQgJyArIG5hbWUgKyAnIG1vZHVsZS4gQXJlIHlvdSBzdXJlIHlvdSByZWdpc3RlcmVkIGl0PycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWdbbmFtZV0gPSBtb2R1bGVDbGFzcy5ERUZBVUxUUyB8fCB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfSwge30pO1xuICAvLyBTcGVjaWFsIGNhc2UgdG9vbGJhciBzaG9ydGhhbmRcbiAgaWYgKHVzZXJDb25maWcubW9kdWxlcyAhPSBudWxsICYmIHVzZXJDb25maWcubW9kdWxlcy50b29sYmFyICYmIHVzZXJDb25maWcubW9kdWxlcy50b29sYmFyLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICB1c2VyQ29uZmlnLm1vZHVsZXMudG9vbGJhciA9IHtcbiAgICAgIGNvbnRhaW5lcjogdXNlckNvbmZpZy5tb2R1bGVzLnRvb2xiYXJcbiAgICB9O1xuICB9XG4gIHVzZXJDb25maWcgPSAoMCwgX2V4dGVuZDIuZGVmYXVsdCkodHJ1ZSwge30sIFF1aWxsLkRFRkFVTFRTLCB7IG1vZHVsZXM6IG1vZHVsZUNvbmZpZyB9LCB0aGVtZUNvbmZpZywgdXNlckNvbmZpZyk7XG4gIFsnYm91bmRzJywgJ2NvbnRhaW5lcicsICdzY3JvbGxpbmdDb250YWluZXInXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAodHlwZW9mIHVzZXJDb25maWdba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHVzZXJDb25maWdba2V5XSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodXNlckNvbmZpZ1trZXldKTtcbiAgICB9XG4gIH0pO1xuICB1c2VyQ29uZmlnLm1vZHVsZXMgPSBPYmplY3Qua2V5cyh1c2VyQ29uZmlnLm1vZHVsZXMpLnJlZHVjZShmdW5jdGlvbiAoY29uZmlnLCBuYW1lKSB7XG4gICAgaWYgKHVzZXJDb25maWcubW9kdWxlc1tuYW1lXSkge1xuICAgICAgY29uZmlnW25hbWVdID0gdXNlckNvbmZpZy5tb2R1bGVzW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xuICB9LCB7fSk7XG4gIHJldHVybiB1c2VyQ29uZmlnO1xufVxuXG4vLyBIYW5kbGUgc2VsZWN0aW9uIHByZXNlcnZhdGlvbiBhbmQgVEVYVF9DSEFOR0UgZW1pc3Npb25cbi8vIGNvbW1vbiB0byBtb2RpZmljYXRpb24gQVBJc1xuZnVuY3Rpb24gbW9kaWZ5KG1vZGlmaWVyLCBzb3VyY2UsIGluZGV4LCBzaGlmdCkge1xuICBpZiAodGhpcy5vcHRpb25zLnN0cmljdCAmJiAhdGhpcy5pc0VuYWJsZWQoKSAmJiBzb3VyY2UgPT09IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuVVNFUikge1xuICAgIHJldHVybiBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKTtcbiAgfVxuICB2YXIgcmFuZ2UgPSBpbmRleCA9PSBudWxsID8gbnVsbCA6IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBvbGREZWx0YSA9IHRoaXMuZWRpdG9yLmRlbHRhO1xuICB2YXIgY2hhbmdlID0gbW9kaWZpZXIoKTtcbiAgaWYgKHJhbmdlICE9IG51bGwpIHtcbiAgICBpZiAoaW5kZXggPT09IHRydWUpIGluZGV4ID0gcmFuZ2UuaW5kZXg7XG4gICAgaWYgKHNoaWZ0ID09IG51bGwpIHtcbiAgICAgIHJhbmdlID0gc2hpZnRSYW5nZShyYW5nZSwgY2hhbmdlLCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAoc2hpZnQgIT09IDApIHtcbiAgICAgIHJhbmdlID0gc2hpZnRSYW5nZShyYW5nZSwgaW5kZXgsIHNoaWZ0LCBzb3VyY2UpO1xuICAgIH1cbiAgICB0aGlzLnNldFNlbGVjdGlvbihyYW5nZSwgX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICB9XG4gIGlmIChjaGFuZ2UubGVuZ3RoKCkgPiAwKSB7XG4gICAgdmFyIF9lbWl0dGVyO1xuXG4gICAgdmFyIGFyZ3MgPSBbX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzLlRFWFRfQ0hBTkdFLCBjaGFuZ2UsIG9sZERlbHRhLCBzb3VyY2VdO1xuICAgIChfZW1pdHRlciA9IHRoaXMuZW1pdHRlcikuZW1pdC5hcHBseShfZW1pdHRlciwgW19lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5FRElUT1JfQ0hBTkdFXS5jb25jYXQoYXJncykpO1xuICAgIGlmIChzb3VyY2UgIT09IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKSB7XG4gICAgICB2YXIgX2VtaXR0ZXIyO1xuXG4gICAgICAoX2VtaXR0ZXIyID0gdGhpcy5lbWl0dGVyKS5lbWl0LmFwcGx5KF9lbWl0dGVyMiwgYXJncyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGFuZ2U7XG59XG5cbmZ1bmN0aW9uIG92ZXJsb2FkKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlLCBzb3VyY2UpIHtcbiAgdmFyIGZvcm1hdHMgPSB7fTtcbiAgaWYgKHR5cGVvZiBpbmRleC5pbmRleCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGluZGV4Lmxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBBbGxvdyBmb3IgdGhyb3dhd2F5IGVuZCAodXNlZCBieSBpbnNlcnRUZXh0L2luc2VydEVtYmVkKVxuICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgICAgc291cmNlID0gdmFsdWUsIHZhbHVlID0gbmFtZSwgbmFtZSA9IGxlbmd0aCwgbGVuZ3RoID0gaW5kZXgubGVuZ3RoLCBpbmRleCA9IGluZGV4LmluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSBpbmRleC5sZW5ndGgsIGluZGV4ID0gaW5kZXguaW5kZXg7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgc291cmNlID0gdmFsdWUsIHZhbHVlID0gbmFtZSwgbmFtZSA9IGxlbmd0aCwgbGVuZ3RoID0gMDtcbiAgfVxuICAvLyBIYW5kbGUgZm9ybWF0IGJlaW5nIG9iamVjdCwgdHdvIGZvcm1hdCBuYW1lL3ZhbHVlIHN0cmluZ3Mgb3IgZXhjbHVkZWRcbiAgaWYgKCh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgIGZvcm1hdHMgPSBuYW1lO1xuICAgIHNvdXJjZSA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBmb3JtYXRzW25hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZSA9IG5hbWU7XG4gICAgfVxuICB9XG4gIC8vIEhhbmRsZSBvcHRpb25hbCBzb3VyY2VcbiAgc291cmNlID0gc291cmNlIHx8IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuQVBJO1xuICByZXR1cm4gW2luZGV4LCBsZW5ndGgsIGZvcm1hdHMsIHNvdXJjZV07XG59XG5cbmZ1bmN0aW9uIHNoaWZ0UmFuZ2UocmFuZ2UsIGluZGV4LCBsZW5ndGgsIHNvdXJjZSkge1xuICBpZiAocmFuZ2UgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHZhciBzdGFydCA9IHZvaWQgMCxcbiAgICAgIGVuZCA9IHZvaWQgMDtcbiAgaWYgKGluZGV4IGluc3RhbmNlb2YgX3F1aWxsRGVsdGEyLmRlZmF1bHQpIHtcbiAgICB2YXIgX21hcCA9IFtyYW5nZS5pbmRleCwgcmFuZ2UuaW5kZXggKyByYW5nZS5sZW5ndGhdLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gaW5kZXgudHJhbnNmb3JtUG9zaXRpb24ocG9zLCBzb3VyY2UgIT09IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgfSk7XG5cbiAgICB2YXIgX21hcDIgPSBfc2xpY2VkVG9BcnJheShfbWFwLCAyKTtcblxuICAgIHN0YXJ0ID0gX21hcDJbMF07XG4gICAgZW5kID0gX21hcDJbMV07XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9tYXAzID0gW3JhbmdlLmluZGV4LCByYW5nZS5pbmRleCArIHJhbmdlLmxlbmd0aF0ubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIGlmIChwb3MgPCBpbmRleCB8fCBwb3MgPT09IGluZGV4ICYmIHNvdXJjZSA9PT0gX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5VU0VSKSByZXR1cm4gcG9zO1xuICAgICAgaWYgKGxlbmd0aCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBwb3MgKyBsZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoaW5kZXgsIHBvcyArIGxlbmd0aCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgX21hcDQgPSBfc2xpY2VkVG9BcnJheShfbWFwMywgMik7XG5cbiAgICBzdGFydCA9IF9tYXA0WzBdO1xuICAgIGVuZCA9IF9tYXA0WzFdO1xuICB9XG4gIHJldHVybiBuZXcgX3NlbGVjdGlvbi5SYW5nZShzdGFydCwgZW5kIC0gc3RhcnQpO1xufVxuXG5leHBvcnRzLmV4cGFuZENvbmZpZyA9IGV4cGFuZENvbmZpZztcbmV4cG9ydHMub3ZlcmxvYWQgPSBvdmVybG9hZDtcbmV4cG9ydHMuZGVmYXVsdCA9IFF1aWxsO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3RleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3RleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dCk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSW5saW5lID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkSW5saW5lKSB7XG4gIF9pbmhlcml0cyhJbmxpbmUsIF9QYXJjaG1lbnQkSW5saW5lKTtcblxuICBmdW5jdGlvbiBJbmxpbmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElubGluZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKElubGluZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKElubGluZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKElubGluZSwgW3tcbiAgICBrZXk6ICdmb3JtYXRBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAoSW5saW5lLmNvbXBhcmUodGhpcy5zdGF0aWNzLmJsb3ROYW1lLCBuYW1lKSA8IDAgJiYgX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShuYW1lLCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT1QpKSB7XG4gICAgICAgIHZhciBibG90ID0gdGhpcy5pc29sYXRlKGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBibG90LndyYXAobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KElubGluZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbmxpbmUucHJvdG90eXBlKSwgJ2Zvcm1hdEF0JywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb3B0aW1pemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpbWl6ZShjb250ZXh0KSB7XG4gICAgICBfZ2V0KElubGluZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbmxpbmUucHJvdG90eXBlKSwgJ29wdGltaXplJywgdGhpcykuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIElubGluZSAmJiBJbmxpbmUuY29tcGFyZSh0aGlzLnN0YXRpY3MuYmxvdE5hbWUsIHRoaXMucGFyZW50LnN0YXRpY3MuYmxvdE5hbWUpID4gMCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQuaXNvbGF0ZSh0aGlzLm9mZnNldCgpLCB0aGlzLmxlbmd0aCgpKTtcbiAgICAgICAgdGhpcy5tb3ZlQ2hpbGRyZW4ocGFyZW50KTtcbiAgICAgICAgcGFyZW50LndyYXAodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdjb21wYXJlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZShzZWxmLCBvdGhlcikge1xuICAgICAgdmFyIHNlbGZJbmRleCA9IElubGluZS5vcmRlci5pbmRleE9mKHNlbGYpO1xuICAgICAgdmFyIG90aGVySW5kZXggPSBJbmxpbmUub3JkZXIuaW5kZXhPZihvdGhlcik7XG4gICAgICBpZiAoc2VsZkluZGV4ID49IDAgfHwgb3RoZXJJbmRleCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmSW5kZXggLSBvdGhlckluZGV4O1xuICAgICAgfSBlbHNlIGlmIChzZWxmID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZiA8IG90aGVyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbmxpbmU7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuSW5saW5lKTtcblxuSW5saW5lLmFsbG93ZWRDaGlsZHJlbiA9IFtJbmxpbmUsIF9wYXJjaG1lbnQyLmRlZmF1bHQuRW1iZWQsIF90ZXh0Mi5kZWZhdWx0XTtcbi8vIExvd2VyIGluZGV4IG1lYW5zIGRlZXBlciBpbiB0aGUgRE9NIHRyZWUsIHNpbmNlIG5vdCBmb3VuZCAoLTEpIGlzIGZvciBlbWJlZHNcbklubGluZS5vcmRlciA9IFsnY3Vyc29yJywgJ2lubGluZScsIC8vIE11c3QgYmUgbG93ZXJcbid1bmRlcmxpbmUnLCAnc3RyaWtlJywgJ2l0YWxpYycsICdib2xkJywgJ3NjcmlwdCcsICdsaW5rJywgJ2NvZGUnIC8vIE11c3QgYmUgaGlnaGVyXG5dO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmxpbmU7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFRleHRCbG90ID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkVGV4dCkge1xuICBfaW5oZXJpdHMoVGV4dEJsb3QsIF9QYXJjaG1lbnQkVGV4dCk7XG5cbiAgZnVuY3Rpb24gVGV4dEJsb3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRCbG90KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGV4dEJsb3QuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUZXh0QmxvdCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIFRleHRCbG90O1xufShfcGFyY2htZW50Mi5kZWZhdWx0LlRleHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUZXh0QmxvdDtcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9ldmVudGVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcblxudmFyIF9ldmVudGVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRlbWl0dGVyKTtcblxudmFyIF9sb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgZGVidWcgPSAoMCwgX2xvZ2dlcjIuZGVmYXVsdCkoJ3F1aWxsOmV2ZW50cycpO1xuXG52YXIgRVZFTlRTID0gWydzZWxlY3Rpb25jaGFuZ2UnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnY2xpY2snXTtcblxuRVZFTlRTLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnFsLWNvbnRhaW5lcicpKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAvLyBUT0RPIHVzZSBXZWFrTWFwXG4gICAgICBpZiAobm9kZS5fX3F1aWxsICYmIG5vZGUuX19xdWlsbC5lbWl0dGVyKSB7XG4gICAgICAgIHZhciBfbm9kZSRfX3F1aWxsJGVtaXR0ZXI7XG5cbiAgICAgICAgKF9ub2RlJF9fcXVpbGwkZW1pdHRlciA9IG5vZGUuX19xdWlsbC5lbWl0dGVyKS5oYW5kbGVET00uYXBwbHkoX25vZGUkX19xdWlsbCRlbWl0dGVyLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTtcblxudmFyIEVtaXR0ZXIgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoRW1pdHRlciwgX0V2ZW50RW1pdHRlcik7XG5cbiAgZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW1pdHRlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRW1pdHRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEVtaXR0ZXIpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgIF90aGlzLm9uKCdlcnJvcicsIGRlYnVnLmVycm9yKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRW1pdHRlciwgW3tcbiAgICBrZXk6ICdlbWl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdCgpIHtcbiAgICAgIGRlYnVnLmxvZy5hcHBseShkZWJ1ZywgYXJndW1lbnRzKTtcbiAgICAgIF9nZXQoRW1pdHRlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFbWl0dGVyLnByb3RvdHlwZSksICdlbWl0JywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVET00nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVET00oZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgKHRoaXMubGlzdGVuZXJzW2V2ZW50LnR5cGVdIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBub2RlID0gX3JlZi5ub2RlLFxuICAgICAgICAgICAgaGFuZGxlciA9IF9yZWYuaGFuZGxlcjtcblxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBub2RlIHx8IG5vZGUuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgIGhhbmRsZXIuYXBwbHkodW5kZWZpbmVkLCBbZXZlbnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xpc3RlbkRPTScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbkRPTShldmVudE5hbWUsIG5vZGUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSkge1xuICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdLnB1c2goeyBub2RlOiBub2RlLCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFbWl0dGVyO1xufShfZXZlbnRlbWl0dGVyMi5kZWZhdWx0KTtcblxuRW1pdHRlci5ldmVudHMgPSB7XG4gIEVESVRPUl9DSEFOR0U6ICdlZGl0b3ItY2hhbmdlJyxcbiAgU0NST0xMX0JFRk9SRV9VUERBVEU6ICdzY3JvbGwtYmVmb3JlLXVwZGF0ZScsXG4gIFNDUk9MTF9PUFRJTUlaRTogJ3Njcm9sbC1vcHRpbWl6ZScsXG4gIFNDUk9MTF9VUERBVEU6ICdzY3JvbGwtdXBkYXRlJyxcbiAgU0VMRUNUSU9OX0NIQU5HRTogJ3NlbGVjdGlvbi1jaGFuZ2UnLFxuICBURVhUX0NIQU5HRTogJ3RleHQtY2hhbmdlJ1xufTtcbkVtaXR0ZXIuc291cmNlcyA9IHtcbiAgQVBJOiAnYXBpJyxcbiAgU0lMRU5UOiAnc2lsZW50JyxcbiAgVVNFUjogJ3VzZXInXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFbWl0dGVyO1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uIE1vZHVsZShxdWlsbCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZHVsZSk7XG5cbiAgdGhpcy5xdWlsbCA9IHF1aWxsO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xufTtcblxuTW9kdWxlLkRFRkFVTFRTID0ge307XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1vZHVsZTtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGxldmVscyA9IFsnZXJyb3InLCAnd2FybicsICdsb2cnLCAnaW5mbyddO1xudmFyIGxldmVsID0gJ3dhcm4nO1xuXG5mdW5jdGlvbiBkZWJ1ZyhtZXRob2QpIHtcbiAgaWYgKGxldmVscy5pbmRleE9mKG1ldGhvZCkgPD0gbGV2ZWxzLmluZGV4T2YobGV2ZWwpKSB7XG4gICAgdmFyIF9jb25zb2xlO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICAoX2NvbnNvbGUgPSBjb25zb2xlKVttZXRob2RdLmFwcGx5KF9jb25zb2xlLCBhcmdzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gIH1cbn1cblxuZnVuY3Rpb24gbmFtZXNwYWNlKG5zKSB7XG4gIHJldHVybiBsZXZlbHMucmVkdWNlKGZ1bmN0aW9uIChsb2dnZXIsIG1ldGhvZCkge1xuICAgIGxvZ2dlclttZXRob2RdID0gZGVidWcuYmluZChjb25zb2xlLCBtZXRob2QsIG5zKTtcbiAgICByZXR1cm4gbG9nZ2VyO1xuICB9LCB7fSk7XG59XG5cbmRlYnVnLmxldmVsID0gbmFtZXNwYWNlLmxldmVsID0gZnVuY3Rpb24gKG5ld0xldmVsKSB7XG4gIGxldmVsID0gbmV3TGV2ZWw7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBuYW1lc3BhY2U7XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XG52YXIgaXNBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRzLnN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgQXR0cmlidXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdHRyaWJ1dG9yKGF0dHJOYW1lLCBrZXlOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMuYXR0ck5hbWUgPSBhdHRyTmFtZTtcbiAgICAgICAgdGhpcy5rZXlOYW1lID0ga2V5TmFtZTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZUJpdCA9IFJlZ2lzdHJ5LlNjb3BlLlRZUEUgJiBSZWdpc3RyeS5TY29wZS5BVFRSSUJVVEU7XG4gICAgICAgIGlmIChvcHRpb25zLnNjb3BlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSB0eXBlIGJpdHMsIGZvcmNlIGF0dHJpYnV0ZSBiaXRcbiAgICAgICAgICAgIHRoaXMuc2NvcGUgPSAob3B0aW9ucy5zY29wZSAmIFJlZ2lzdHJ5LlNjb3BlLkxFVkVMKSB8IGF0dHJpYnV0ZUJpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUgPSBSZWdpc3RyeS5TY29wZS5BVFRSSUJVVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMud2hpdGVsaXN0ICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLndoaXRlbGlzdCA9IG9wdGlvbnMud2hpdGVsaXN0O1xuICAgIH1cbiAgICBBdHRyaWJ1dG9yLmtleXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gW10ubWFwLmNhbGwobm9kZS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdHRyaWJ1dG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKHRoaXMua2V5TmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEF0dHJpYnV0b3IucHJvdG90eXBlLmNhbkFkZCA9IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBSZWdpc3RyeS5xdWVyeShub2RlLCBSZWdpc3RyeS5TY29wZS5CTE9UICYgKHRoaXMuc2NvcGUgfCBSZWdpc3RyeS5TY29wZS5UWVBFKSk7XG4gICAgICAgIGlmIChtYXRjaCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy53aGl0ZWxpc3QgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hpdGVsaXN0LmluZGV4T2YodmFsdWUucmVwbGFjZSgvW1wiJ10vZywgJycpKSA+IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hpdGVsaXN0LmluZGV4T2YodmFsdWUpID4gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF0dHJpYnV0b3IucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHRoaXMua2V5TmFtZSk7XG4gICAgfTtcbiAgICBBdHRyaWJ1dG9yLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKHRoaXMua2V5TmFtZSk7XG4gICAgICAgIGlmICh0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcbiAgICByZXR1cm4gQXR0cmlidXRvcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBdHRyaWJ1dG9yO1xuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuQ29kZSA9IHVuZGVmaW5lZDtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcXVpbGxEZWx0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfcXVpbGxEZWx0YTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbERlbHRhKTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX2Jsb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9ibG9jazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ibG9jayk7XG5cbnZhciBfaW5saW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9pbmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5saW5lKTtcblxudmFyIF90ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RleHQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDb2RlID0gZnVuY3Rpb24gKF9JbmxpbmUpIHtcbiAgX2luaGVyaXRzKENvZGUsIF9JbmxpbmUpO1xuXG4gIGZ1bmN0aW9uIENvZGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvZGUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2RlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29kZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIENvZGU7XG59KF9pbmxpbmUyLmRlZmF1bHQpO1xuXG5Db2RlLmJsb3ROYW1lID0gJ2NvZGUnO1xuQ29kZS50YWdOYW1lID0gJ0NPREUnO1xuXG52YXIgQ29kZUJsb2NrID0gZnVuY3Rpb24gKF9CbG9jaykge1xuICBfaW5oZXJpdHMoQ29kZUJsb2NrLCBfQmxvY2spO1xuXG4gIGZ1bmN0aW9uIENvZGVCbG9jaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29kZUJsb2NrKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ29kZUJsb2NrLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29kZUJsb2NrKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29kZUJsb2NrLCBbe1xuICAgIGtleTogJ2RlbHRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsdGEoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHRleHQgPSB0aGlzLmRvbU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICBpZiAodGV4dC5lbmRzV2l0aCgnXFxuJykpIHtcbiAgICAgICAgLy8gU2hvdWxkIGFsd2F5cyBiZSB0cnVlXG4gICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0LnNwbGl0KCdcXG4nKS5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBmcmFnKSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5pbnNlcnQoZnJhZykuaW5zZXJ0KCdcXG4nLCBfdGhpczMuZm9ybWF0cygpKTtcbiAgICAgIH0sIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChuYW1lID09PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUgJiYgdmFsdWUpIHJldHVybjtcblxuICAgICAgdmFyIF9kZXNjZW5kYW50ID0gdGhpcy5kZXNjZW5kYW50KF90ZXh0Mi5kZWZhdWx0LCB0aGlzLmxlbmd0aCgpIC0gMSksXG4gICAgICAgICAgX2Rlc2NlbmRhbnQyID0gX3NsaWNlZFRvQXJyYXkoX2Rlc2NlbmRhbnQsIDEpLFxuICAgICAgICAgIHRleHQgPSBfZGVzY2VuZGFudDJbMF07XG5cbiAgICAgIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgdGV4dC5kZWxldGVBdCh0ZXh0Lmxlbmd0aCgpIC0gMSwgMSk7XG4gICAgICB9XG4gICAgICBfZ2V0KENvZGVCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2RlQmxvY2sucHJvdG90eXBlKSwgJ2Zvcm1hdCcsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIGlmIChfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KG5hbWUsIF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0spID09IG51bGwgfHwgbmFtZSA9PT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lICYmIHZhbHVlID09PSB0aGlzLnN0YXRpY3MuZm9ybWF0cyh0aGlzLmRvbU5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0TmV3bGluZSA9IHRoaXMubmV3bGluZUluZGV4KGluZGV4KTtcbiAgICAgIGlmIChuZXh0TmV3bGluZSA8IDAgfHwgbmV4dE5ld2xpbmUgPj0gaW5kZXggKyBsZW5ndGgpIHJldHVybjtcbiAgICAgIHZhciBwcmV2TmV3bGluZSA9IHRoaXMubmV3bGluZUluZGV4KGluZGV4LCB0cnVlKSArIDE7XG4gICAgICB2YXIgaXNvbGF0ZUxlbmd0aCA9IG5leHROZXdsaW5lIC0gcHJldk5ld2xpbmUgKyAxO1xuICAgICAgdmFyIGJsb3QgPSB0aGlzLmlzb2xhdGUocHJldk5ld2xpbmUsIGlzb2xhdGVMZW5ndGgpO1xuICAgICAgdmFyIG5leHQgPSBibG90Lm5leHQ7XG4gICAgICBibG90LmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIENvZGVCbG9jaykge1xuICAgICAgICBuZXh0LmZvcm1hdEF0KDAsIGluZGV4IC0gcHJldk5ld2xpbmUgKyBsZW5ndGggLSBpc29sYXRlTGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0QXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRBdChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgICAgaWYgKGRlZiAhPSBudWxsKSByZXR1cm47XG5cbiAgICAgIHZhciBfZGVzY2VuZGFudDMgPSB0aGlzLmRlc2NlbmRhbnQoX3RleHQyLmRlZmF1bHQsIGluZGV4KSxcbiAgICAgICAgICBfZGVzY2VuZGFudDQgPSBfc2xpY2VkVG9BcnJheShfZGVzY2VuZGFudDMsIDIpLFxuICAgICAgICAgIHRleHQgPSBfZGVzY2VuZGFudDRbMF0sXG4gICAgICAgICAgb2Zmc2V0ID0gX2Rlc2NlbmRhbnQ0WzFdO1xuXG4gICAgICB0ZXh0Lmluc2VydEF0KG9mZnNldCwgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xlbmd0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLmRvbU5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgaWYgKCF0aGlzLmRvbU5vZGUudGV4dENvbnRlbnQuZW5kc1dpdGgoJ1xcbicpKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduZXdsaW5lSW5kZXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdsaW5lSW5kZXgoc2VhcmNoSW5kZXgpIHtcbiAgICAgIHZhciByZXZlcnNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgaWYgKCFyZXZlcnNlKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmRvbU5vZGUudGV4dENvbnRlbnQuc2xpY2Uoc2VhcmNoSW5kZXgpLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID4gLTEgPyBzZWFyY2hJbmRleCArIG9mZnNldCA6IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tTm9kZS50ZXh0Q29udGVudC5zbGljZSgwLCBzZWFyY2hJbmRleCkubGFzdEluZGV4T2YoJ1xcbicpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29wdGltaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW1pemUoY29udGV4dCkge1xuICAgICAgaWYgKCF0aGlzLmRvbU5vZGUudGV4dENvbnRlbnQuZW5kc1dpdGgoJ1xcbicpKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoX3BhcmNobWVudDIuZGVmYXVsdC5jcmVhdGUoJ3RleHQnLCAnXFxuJykpO1xuICAgICAgfVxuICAgICAgX2dldChDb2RlQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29kZUJsb2NrLnByb3RvdHlwZSksICdvcHRpbWl6ZScsIHRoaXMpLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dDtcbiAgICAgIGlmIChuZXh0ICE9IG51bGwgJiYgbmV4dC5wcmV2ID09PSB0aGlzICYmIG5leHQuc3RhdGljcy5ibG90TmFtZSA9PT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lICYmIHRoaXMuc3RhdGljcy5mb3JtYXRzKHRoaXMuZG9tTm9kZSkgPT09IG5leHQuc3RhdGljcy5mb3JtYXRzKG5leHQuZG9tTm9kZSkpIHtcbiAgICAgICAgbmV4dC5vcHRpbWl6ZShjb250ZXh0KTtcbiAgICAgICAgbmV4dC5tb3ZlQ2hpbGRyZW4odGhpcyk7XG4gICAgICAgIG5leHQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVwbGFjZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UodGFyZ2V0KSB7XG4gICAgICBfZ2V0KENvZGVCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2RlQmxvY2sucHJvdG90eXBlKSwgJ3JlcGxhY2UnLCB0aGlzKS5jYWxsKHRoaXMsIHRhcmdldCk7XG4gICAgICBbXS5zbGljZS5jYWxsKHRoaXMuZG9tTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCcqJykpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGJsb3QgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmZpbmQobm9kZSk7XG4gICAgICAgIGlmIChibG90ID09IG51bGwpIHtcbiAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYmxvdCBpbnN0YW5jZW9mIF9wYXJjaG1lbnQyLmRlZmF1bHQuRW1iZWQpIHtcbiAgICAgICAgICBibG90LnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsb3QudW53cmFwKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICB2YXIgZG9tTm9kZSA9IF9nZXQoQ29kZUJsb2NrLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29kZUJsb2NrKSwgJ2NyZWF0ZScsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgZG9tTm9kZS5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCBmYWxzZSk7XG4gICAgICByZXR1cm4gZG9tTm9kZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cygpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2RlQmxvY2s7XG59KF9ibG9jazIuZGVmYXVsdCk7XG5cbkNvZGVCbG9jay5ibG90TmFtZSA9ICdjb2RlLWJsb2NrJztcbkNvZGVCbG9jay50YWdOYW1lID0gJ1BSRSc7XG5Db2RlQmxvY2suVEFCID0gJyAgJztcblxuZXhwb3J0cy5Db2RlID0gQ29kZTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvZGVCbG9jaztcblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9xdWlsbERlbHRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9xdWlsbERlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsRGVsdGEpO1xuXG52YXIgX29wID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBfb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb3ApO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfY29kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX2NvZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29kZSk7XG5cbnZhciBfY3Vyc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbnZhciBfY3Vyc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2N1cnNvcik7XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxudmFyIF9icmVhayA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX2JyZWFrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JyZWFrKTtcblxudmFyIF9jbG9uZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG52YXIgX2Nsb25lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb25lKTtcblxudmFyIF9kZWVwRXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9kZWVwRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVlcEVxdWFsKTtcblxudmFyIF9leHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2V4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQVNDSUkgPSAvXlsgLX5dKiQvO1xuXG52YXIgRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFZGl0b3Ioc2Nyb2xsKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkaXRvcik7XG5cbiAgICB0aGlzLnNjcm9sbCA9IHNjcm9sbDtcbiAgICB0aGlzLmRlbHRhID0gdGhpcy5nZXREZWx0YSgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVkaXRvciwgW3tcbiAgICBrZXk6ICdhcHBseURlbHRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlEZWx0YShkZWx0YSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGNvbnN1bWVOZXh0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zY3JvbGwudXBkYXRlKCk7XG4gICAgICB2YXIgc2Nyb2xsTGVuZ3RoID0gdGhpcy5zY3JvbGwubGVuZ3RoKCk7XG4gICAgICB0aGlzLnNjcm9sbC5iYXRjaFN0YXJ0KCk7XG4gICAgICBkZWx0YSA9IG5vcm1hbGl6ZURlbHRhKGRlbHRhKTtcbiAgICAgIGRlbHRhLnJlZHVjZShmdW5jdGlvbiAoaW5kZXgsIG9wKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBvcC5yZXRhaW4gfHwgb3AuZGVsZXRlIHx8IG9wLmluc2VydC5sZW5ndGggfHwgMTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBvcC5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgICAgICBpZiAob3AuaW5zZXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gb3AuaW5zZXJ0O1xuICAgICAgICAgICAgaWYgKHRleHQuZW5kc1dpdGgoJ1xcbicpICYmIGNvbnN1bWVOZXh0TmV3bGluZSkge1xuICAgICAgICAgICAgICBjb25zdW1lTmV4dE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ID49IHNjcm9sbExlbmd0aCAmJiAhdGV4dC5lbmRzV2l0aCgnXFxuJykpIHtcbiAgICAgICAgICAgICAgY29uc3VtZU5leHROZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNjcm9sbC5pbnNlcnRBdChpbmRleCwgdGV4dCk7XG5cbiAgICAgICAgICAgIHZhciBfc2Nyb2xsJGxpbmUgPSBfdGhpcy5zY3JvbGwubGluZShpbmRleCksXG4gICAgICAgICAgICAgICAgX3Njcm9sbCRsaW5lMiA9IF9zbGljZWRUb0FycmF5KF9zY3JvbGwkbGluZSwgMiksXG4gICAgICAgICAgICAgICAgbGluZSA9IF9zY3JvbGwkbGluZTJbMF0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3Njcm9sbCRsaW5lMlsxXTtcblxuICAgICAgICAgICAgdmFyIGZvcm1hdHMgPSAoMCwgX2V4dGVuZDIuZGVmYXVsdCkoe30sICgwLCBfYmxvY2suYnViYmxlRm9ybWF0cykobGluZSkpO1xuICAgICAgICAgICAgaWYgKGxpbmUgaW5zdGFuY2VvZiBfYmxvY2syLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgdmFyIF9saW5lJGRlc2NlbmRhbnQgPSBsaW5lLmRlc2NlbmRhbnQoX3BhcmNobWVudDIuZGVmYXVsdC5MZWFmLCBvZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgX2xpbmUkZGVzY2VuZGFudDIgPSBfc2xpY2VkVG9BcnJheShfbGluZSRkZXNjZW5kYW50LCAxKSxcbiAgICAgICAgICAgICAgICAgIGxlYWYgPSBfbGluZSRkZXNjZW5kYW50MlswXTtcblxuICAgICAgICAgICAgICBmb3JtYXRzID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKGZvcm1hdHMsICgwLCBfYmxvY2suYnViYmxlRm9ybWF0cykobGVhZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cmlidXRlcyA9IF9vcDIuZGVmYXVsdC5hdHRyaWJ1dGVzLmRpZmYoZm9ybWF0cywgYXR0cmlidXRlcykgfHwge307XG4gICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wLmluc2VydCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gT2JqZWN0LmtleXMob3AuaW5zZXJ0KVswXTsgLy8gVGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lIGtleVxuICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICBfdGhpcy5zY3JvbGwuaW5zZXJ0QXQoaW5kZXgsIGtleSwgb3AuaW5zZXJ0W2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY3JvbGxMZW5ndGggKz0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBfdGhpcy5zY3JvbGwuZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5kZXggKyBsZW5ndGg7XG4gICAgICB9LCAwKTtcbiAgICAgIGRlbHRhLnJlZHVjZShmdW5jdGlvbiAoaW5kZXgsIG9wKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3AuZGVsZXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIF90aGlzLnNjcm9sbC5kZWxldGVBdChpbmRleCwgb3AuZGVsZXRlKTtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4ICsgKG9wLnJldGFpbiB8fCBvcC5pbnNlcnQubGVuZ3RoIHx8IDEpO1xuICAgICAgfSwgMCk7XG4gICAgICB0aGlzLnNjcm9sbC5iYXRjaEVuZCgpO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGRlbHRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlVGV4dChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB0aGlzLnNjcm9sbC5kZWxldGVBdChpbmRleCwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4oaW5kZXgpLmRlbGV0ZShsZW5ndGgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRMaW5lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0TGluZShpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICB0aGlzLnNjcm9sbC51cGRhdGUoKTtcbiAgICAgIE9iamVjdC5rZXlzKGZvcm1hdHMpLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBpZiAoX3RoaXMyLnNjcm9sbC53aGl0ZWxpc3QgIT0gbnVsbCAmJiAhX3RoaXMyLnNjcm9sbC53aGl0ZWxpc3RbZm9ybWF0XSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGluZXMgPSBfdGhpczIuc2Nyb2xsLmxpbmVzKGluZGV4LCBNYXRoLm1heChsZW5ndGgsIDEpKTtcbiAgICAgICAgdmFyIGxlbmd0aFJlbWFpbmluZyA9IGxlbmd0aDtcbiAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZS5sZW5ndGgoKTtcbiAgICAgICAgICBpZiAoIShsaW5lIGluc3RhbmNlb2YgX2NvZGUyLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICBsaW5lLmZvcm1hdChmb3JtYXQsIGZvcm1hdHNbZm9ybWF0XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb2RlSW5kZXggPSBpbmRleCAtIGxpbmUub2Zmc2V0KF90aGlzMi5zY3JvbGwpO1xuICAgICAgICAgICAgdmFyIGNvZGVMZW5ndGggPSBsaW5lLm5ld2xpbmVJbmRleChjb2RlSW5kZXggKyBsZW5ndGhSZW1haW5pbmcpIC0gY29kZUluZGV4ICsgMTtcbiAgICAgICAgICAgIGxpbmUuZm9ybWF0QXQoY29kZUluZGV4LCBjb2RlTGVuZ3RoLCBmb3JtYXQsIGZvcm1hdHNbZm9ybWF0XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aFJlbWFpbmluZyAtPSBsaW5lTGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zY3JvbGwub3B0aW1pemUoKTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4oaW5kZXgpLnJldGFpbihsZW5ndGgsICgwLCBfY2xvbmUyLmRlZmF1bHQpKGZvcm1hdHMpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0VGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFRleHQoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtYXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgT2JqZWN0LmtleXMoZm9ybWF0cykuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIF90aGlzMy5zY3JvbGwuZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgZm9ybWF0LCBmb3JtYXRzW2Zvcm1hdF0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGluZGV4KS5yZXRhaW4obGVuZ3RoLCAoMCwgX2Nsb25lMi5kZWZhdWx0KShmb3JtYXRzKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldENvbnRlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGVudHMoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsdGEuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXREZWx0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlbHRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsLmxpbmVzKCkucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwgbGluZSkge1xuICAgICAgICByZXR1cm4gZGVsdGEuY29uY2F0KGxpbmUuZGVsdGEoKSk7XG4gICAgICB9LCBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Rm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0KGluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgICB2YXIgbGluZXMgPSBbXSxcbiAgICAgICAgICBsZWF2ZXMgPSBbXTtcbiAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zY3JvbGwucGF0aChpbmRleCkuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgIHZhciBfcGF0aCA9IF9zbGljZWRUb0FycmF5KHBhdGgsIDEpLFxuICAgICAgICAgICAgICBibG90ID0gX3BhdGhbMF07XG5cbiAgICAgICAgICBpZiAoYmxvdCBpbnN0YW5jZW9mIF9ibG9jazIuZGVmYXVsdCkge1xuICAgICAgICAgICAgbGluZXMucHVzaChibG90KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJsb3QgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LkxlYWYpIHtcbiAgICAgICAgICAgIGxlYXZlcy5wdXNoKGJsb3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lcyA9IHRoaXMuc2Nyb2xsLmxpbmVzKGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBsZWF2ZXMgPSB0aGlzLnNjcm9sbC5kZXNjZW5kYW50cyhfcGFyY2htZW50Mi5kZWZhdWx0LkxlYWYsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgdmFyIGZvcm1hdHNBcnIgPSBbbGluZXMsIGxlYXZlc10ubWFwKGZ1bmN0aW9uIChibG90cykge1xuICAgICAgICBpZiAoYmxvdHMubGVuZ3RoID09PSAwKSByZXR1cm4ge307XG4gICAgICAgIHZhciBmb3JtYXRzID0gKDAsIF9ibG9jay5idWJibGVGb3JtYXRzKShibG90cy5zaGlmdCgpKTtcbiAgICAgICAgd2hpbGUgKE9iamVjdC5rZXlzKGZvcm1hdHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgYmxvdCA9IGJsb3RzLnNoaWZ0KCk7XG4gICAgICAgICAgaWYgKGJsb3QgPT0gbnVsbCkgcmV0dXJuIGZvcm1hdHM7XG4gICAgICAgICAgZm9ybWF0cyA9IGNvbWJpbmVGb3JtYXRzKCgwLCBfYmxvY2suYnViYmxlRm9ybWF0cykoYmxvdCksIGZvcm1hdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX2V4dGVuZDIuZGVmYXVsdC5hcHBseShfZXh0ZW5kMi5kZWZhdWx0LCBmb3JtYXRzQXJyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDb250ZW50cyhpbmRleCwgbGVuZ3RoKS5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb3AuaW5zZXJ0ID09PSAnc3RyaW5nJztcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgcmV0dXJuIG9wLmluc2VydDtcbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEVtYmVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0RW1iZWQoaW5kZXgsIGVtYmVkLCB2YWx1ZSkge1xuICAgICAgdGhpcy5zY3JvbGwuaW5zZXJ0QXQoaW5kZXgsIGVtYmVkLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGluZGV4KS5pbnNlcnQoX2RlZmluZVByb3BlcnR5KHt9LCBlbWJlZCwgdmFsdWUpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0VGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFRleHQoaW5kZXgsIHRleHQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgZm9ybWF0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKTtcbiAgICAgIHRoaXMuc2Nyb2xsLmluc2VydEF0KGluZGV4LCB0ZXh0KTtcbiAgICAgIE9iamVjdC5rZXlzKGZvcm1hdHMpLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBfdGhpczQuc2Nyb2xsLmZvcm1hdEF0KGluZGV4LCB0ZXh0Lmxlbmd0aCwgZm9ybWF0LCBmb3JtYXRzW2Zvcm1hdF0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGluZGV4KS5pbnNlcnQodGV4dCwgKDAsIF9jbG9uZTIuZGVmYXVsdCkoZm9ybWF0cykpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc0JsYW5rJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNCbGFuaygpIHtcbiAgICAgIGlmICh0aGlzLnNjcm9sbC5jaGlsZHJlbi5sZW5ndGggPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcy5zY3JvbGwuY2hpbGRyZW4ubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGJsb2NrID0gdGhpcy5zY3JvbGwuY2hpbGRyZW4uaGVhZDtcbiAgICAgIGlmIChibG9jay5zdGF0aWNzLmJsb3ROYW1lICE9PSBfYmxvY2syLmRlZmF1bHQuYmxvdE5hbWUpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChibG9jay5jaGlsZHJlbi5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gYmxvY2suY2hpbGRyZW4uaGVhZCBpbnN0YW5jZW9mIF9icmVhazIuZGVmYXVsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVGb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGb3JtYXQoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgdmFyIHRleHQgPSB0aGlzLmdldFRleHQoaW5kZXgsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBfc2Nyb2xsJGxpbmUzID0gdGhpcy5zY3JvbGwubGluZShpbmRleCArIGxlbmd0aCksXG4gICAgICAgICAgX3Njcm9sbCRsaW5lNCA9IF9zbGljZWRUb0FycmF5KF9zY3JvbGwkbGluZTMsIDIpLFxuICAgICAgICAgIGxpbmUgPSBfc2Nyb2xsJGxpbmU0WzBdLFxuICAgICAgICAgIG9mZnNldCA9IF9zY3JvbGwkbGluZTRbMV07XG5cbiAgICAgIHZhciBzdWZmaXhMZW5ndGggPSAwLFxuICAgICAgICAgIHN1ZmZpeCA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpO1xuICAgICAgaWYgKGxpbmUgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIShsaW5lIGluc3RhbmNlb2YgX2NvZGUyLmRlZmF1bHQpKSB7XG4gICAgICAgICAgc3VmZml4TGVuZ3RoID0gbGluZS5sZW5ndGgoKSAtIG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWZmaXhMZW5ndGggPSBsaW5lLm5ld2xpbmVJbmRleChvZmZzZXQpIC0gb2Zmc2V0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBzdWZmaXggPSBsaW5lLmRlbHRhKCkuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzdWZmaXhMZW5ndGggLSAxKS5pbnNlcnQoJ1xcbicpO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRlbnRzID0gdGhpcy5nZXRDb250ZW50cyhpbmRleCwgbGVuZ3RoICsgc3VmZml4TGVuZ3RoKTtcbiAgICAgIHZhciBkaWZmID0gY29udGVudHMuZGlmZihuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5pbnNlcnQodGV4dCkuY29uY2F0KHN1ZmZpeCkpO1xuICAgICAgdmFyIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGluZGV4KS5jb25jYXQoZGlmZik7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseURlbHRhKGRlbHRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoY2hhbmdlKSB7XG4gICAgICB2YXIgbXV0YXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgIHZhciBjdXJzb3JJbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgb2xkRGVsdGEgPSB0aGlzLmRlbHRhO1xuICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPT09IDEgJiYgbXV0YXRpb25zWzBdLnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiBtdXRhdGlvbnNbMF0udGFyZ2V0LmRhdGEubWF0Y2goQVNDSUkpICYmIF9wYXJjaG1lbnQyLmRlZmF1bHQuZmluZChtdXRhdGlvbnNbMF0udGFyZ2V0KSkge1xuICAgICAgICAvLyBPcHRpbWl6YXRpb24gZm9yIGNoYXJhY3RlciBjaGFuZ2VzXG4gICAgICAgIHZhciB0ZXh0QmxvdCA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuZmluZChtdXRhdGlvbnNbMF0udGFyZ2V0KTtcbiAgICAgICAgdmFyIGZvcm1hdHMgPSAoMCwgX2Jsb2NrLmJ1YmJsZUZvcm1hdHMpKHRleHRCbG90KTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGV4dEJsb3Qub2Zmc2V0KHRoaXMuc2Nyb2xsKTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gbXV0YXRpb25zWzBdLm9sZFZhbHVlLnJlcGxhY2UoX2N1cnNvcjIuZGVmYXVsdC5DT05URU5UUywgJycpO1xuICAgICAgICB2YXIgb2xkVGV4dCA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLmluc2VydChvbGRWYWx1ZSk7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkuaW5zZXJ0KHRleHRCbG90LnZhbHVlKCkpO1xuICAgICAgICB2YXIgZGlmZkRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGluZGV4KS5jb25jYXQob2xkVGV4dC5kaWZmKG5ld1RleHQsIGN1cnNvckluZGV4KSk7XG4gICAgICAgIGNoYW5nZSA9IGRpZmZEZWx0YS5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBvcCkge1xuICAgICAgICAgIGlmIChvcC5pbnNlcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YS5pbnNlcnQob3AuaW5zZXJ0LCBmb3JtYXRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhLnB1c2gob3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkpO1xuICAgICAgICB0aGlzLmRlbHRhID0gb2xkRGVsdGEuY29tcG9zZShjaGFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWx0YSA9IHRoaXMuZ2V0RGVsdGEoKTtcbiAgICAgICAgaWYgKCFjaGFuZ2UgfHwgISgwLCBfZGVlcEVxdWFsMi5kZWZhdWx0KShvbGREZWx0YS5jb21wb3NlKGNoYW5nZSksIHRoaXMuZGVsdGEpKSB7XG4gICAgICAgICAgY2hhbmdlID0gb2xkRGVsdGEuZGlmZih0aGlzLmRlbHRhLCBjdXJzb3JJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVkaXRvcjtcbn0oKTtcblxuZnVuY3Rpb24gY29tYmluZUZvcm1hdHMoZm9ybWF0cywgY29tYmluZWQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbWJpbmVkKS5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgbmFtZSkge1xuICAgIGlmIChmb3JtYXRzW25hbWVdID09IG51bGwpIHJldHVybiBtZXJnZWQ7XG4gICAgaWYgKGNvbWJpbmVkW25hbWVdID09PSBmb3JtYXRzW25hbWVdKSB7XG4gICAgICBtZXJnZWRbbmFtZV0gPSBjb21iaW5lZFtuYW1lXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29tYmluZWRbbmFtZV0pKSB7XG4gICAgICBpZiAoY29tYmluZWRbbmFtZV0uaW5kZXhPZihmb3JtYXRzW25hbWVdKSA8IDApIHtcbiAgICAgICAgbWVyZ2VkW25hbWVdID0gY29tYmluZWRbbmFtZV0uY29uY2F0KFtmb3JtYXRzW25hbWVdXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlZFtuYW1lXSA9IFtjb21iaW5lZFtuYW1lXSwgZm9ybWF0c1tuYW1lXV07XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRGVsdGEoZGVsdGEpIHtcbiAgcmV0dXJuIGRlbHRhLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIG9wKSB7XG4gICAgaWYgKG9wLmluc2VydCA9PT0gMSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSAoMCwgX2Nsb25lMi5kZWZhdWx0KShvcC5hdHRyaWJ1dGVzKTtcbiAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzWydpbWFnZSddO1xuICAgICAgcmV0dXJuIGRlbHRhLmluc2VydCh7IGltYWdlOiBvcC5hdHRyaWJ1dGVzLmltYWdlIH0sIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBpZiAob3AuYXR0cmlidXRlcyAhPSBudWxsICYmIChvcC5hdHRyaWJ1dGVzLmxpc3QgPT09IHRydWUgfHwgb3AuYXR0cmlidXRlcy5idWxsZXQgPT09IHRydWUpKSB7XG4gICAgICBvcCA9ICgwLCBfY2xvbmUyLmRlZmF1bHQpKG9wKTtcbiAgICAgIGlmIChvcC5hdHRyaWJ1dGVzLmxpc3QpIHtcbiAgICAgICAgb3AuYXR0cmlidXRlcy5saXN0ID0gJ29yZGVyZWQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3AuYXR0cmlidXRlcy5saXN0ID0gJ2J1bGxldCc7XG4gICAgICAgIGRlbGV0ZSBvcC5hdHRyaWJ1dGVzLmJ1bGxldDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgdGV4dCA9IG9wLmluc2VydC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxuJyk7XG4gICAgICByZXR1cm4gZGVsdGEuaW5zZXJ0KHRleHQsIG9wLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsdGEucHVzaChvcCk7XG4gIH0sIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gRWRpdG9yO1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLlJhbmdlID0gdW5kZWZpbmVkO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9jbG9uZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG52YXIgX2Nsb25lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb25lKTtcblxudmFyIF9kZWVwRXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9kZWVwRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVlcEVxdWFsKTtcblxudmFyIF9lbWl0dGVyMyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBfZW1pdHRlcjQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbWl0dGVyMyk7XG5cbnZhciBfbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ2dlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgZGVidWcgPSAoMCwgX2xvZ2dlcjIuZGVmYXVsdCkoJ3F1aWxsOnNlbGVjdGlvbicpO1xuXG52YXIgUmFuZ2UgPSBmdW5jdGlvbiBSYW5nZShpbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYW5nZSk7XG5cbiAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbn07XG5cbnZhciBTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNlbGVjdGlvbihzY3JvbGwsIGVtaXR0ZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdGlvbik7XG5cbiAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgIHRoaXMuc2Nyb2xsID0gc2Nyb2xsO1xuICAgIHRoaXMuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICB0aGlzLnJvb3QgPSB0aGlzLnNjcm9sbC5kb21Ob2RlO1xuICAgIHRoaXMuY3Vyc29yID0gX3BhcmNobWVudDIuZGVmYXVsdC5jcmVhdGUoJ2N1cnNvcicsIHRoaXMpO1xuICAgIC8vIHNhdmVkUmFuZ2UgaXMgbGFzdCBub24tbnVsbCByYW5nZVxuICAgIHRoaXMubGFzdFJhbmdlID0gdGhpcy5zYXZlZFJhbmdlID0gbmV3IFJhbmdlKDAsIDApO1xuICAgIHRoaXMuaGFuZGxlQ29tcG9zaXRpb24oKTtcbiAgICB0aGlzLmhhbmRsZURyYWdnaW5nKCk7XG4gICAgdGhpcy5lbWl0dGVyLmxpc3RlbkRPTSgnc2VsZWN0aW9uY2hhbmdlJywgZG9jdW1lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMubW91c2VEb3duKSB7XG4gICAgICAgIHNldFRpbWVvdXQoX3RoaXMudXBkYXRlLmJpbmQoX3RoaXMsIF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuVVNFUiksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdHRlci5vbihfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuRURJVE9SX0NIQU5HRSwgZnVuY3Rpb24gKHR5cGUsIGRlbHRhKSB7XG4gICAgICBpZiAodHlwZSA9PT0gX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzLlRFWFRfQ0hBTkdFICYmIGRlbHRhLmxlbmd0aCgpID4gMCkge1xuICAgICAgICBfdGhpcy51cGRhdGUoX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdHRlci5vbihfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuU0NST0xMX0JFRk9SRV9VUERBVEUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMuaGFzRm9jdXMoKSkgcmV0dXJuO1xuICAgICAgdmFyIG5hdGl2ZSA9IF90aGlzLmdldE5hdGl2ZVJhbmdlKCk7XG4gICAgICBpZiAobmF0aXZlID09IG51bGwpIHJldHVybjtcbiAgICAgIGlmIChuYXRpdmUuc3RhcnQubm9kZSA9PT0gX3RoaXMuY3Vyc29yLnRleHROb2RlKSByZXR1cm47IC8vIGN1cnNvci5yZXN0b3JlKCkgd2lsbCBoYW5kbGVcbiAgICAgIC8vIFRPRE8gdW5jbGVhciBpZiB0aGlzIGhhcyBuZWdhdGl2ZSBzaWRlIGVmZmVjdHNcbiAgICAgIF90aGlzLmVtaXR0ZXIub25jZShfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuU0NST0xMX1VQREFURSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF90aGlzLnNldE5hdGl2ZVJhbmdlKG5hdGl2ZS5zdGFydC5ub2RlLCBuYXRpdmUuc3RhcnQub2Zmc2V0LCBuYXRpdmUuZW5kLm5vZGUsIG5hdGl2ZS5lbmQub2Zmc2V0KTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge31cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuZW1pdHRlci5vbihfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuU0NST0xMX09QVElNSVpFLCBmdW5jdGlvbiAobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgICBpZiAoY29udGV4dC5yYW5nZSkge1xuICAgICAgICB2YXIgX2NvbnRleHQkcmFuZ2UgPSBjb250ZXh0LnJhbmdlLFxuICAgICAgICAgICAgc3RhcnROb2RlID0gX2NvbnRleHQkcmFuZ2Uuc3RhcnROb2RlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBfY29udGV4dCRyYW5nZS5zdGFydE9mZnNldCxcbiAgICAgICAgICAgIGVuZE5vZGUgPSBfY29udGV4dCRyYW5nZS5lbmROb2RlLFxuICAgICAgICAgICAgZW5kT2Zmc2V0ID0gX2NvbnRleHQkcmFuZ2UuZW5kT2Zmc2V0O1xuXG4gICAgICAgIF90aGlzLnNldE5hdGl2ZVJhbmdlKHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQsIGVuZE5vZGUsIGVuZE9mZnNldCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGUoX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNlbGVjdGlvbiwgW3tcbiAgICBrZXk6ICdoYW5kbGVDb21wb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNvbXBvc2l0aW9uKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMucm9vdC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuY29tcG9zaW5nID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChfdGhpczIuY3Vyc29yLnBhcmVudCkge1xuICAgICAgICAgIHZhciByYW5nZSA9IF90aGlzMi5jdXJzb3IucmVzdG9yZSgpO1xuICAgICAgICAgIGlmICghcmFuZ2UpIHJldHVybjtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5zZXROYXRpdmVSYW5nZShyYW5nZS5zdGFydE5vZGUsIHJhbmdlLnN0YXJ0T2Zmc2V0LCByYW5nZS5lbmROb2RlLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVEcmFnZ2luZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZURyYWdnaW5nKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZW1pdHRlci5saXN0ZW5ET00oJ21vdXNlZG93bicsIGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLm1vdXNlRG93biA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdHRlci5saXN0ZW5ET00oJ21vdXNldXAnLCBkb2N1bWVudC5ib2R5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgX3RoaXMzLnVwZGF0ZShfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9jdXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgIGlmICh0aGlzLmhhc0ZvY3VzKCkpIHJldHVybjtcbiAgICAgIHRoaXMucm9vdC5mb2N1cygpO1xuICAgICAgdGhpcy5zZXRSYW5nZSh0aGlzLnNhdmVkUmFuZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChfZm9ybWF0LCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuc2Nyb2xsLndoaXRlbGlzdCAhPSBudWxsICYmICF0aGlzLnNjcm9sbC53aGl0ZWxpc3RbX2Zvcm1hdF0pIHJldHVybjtcbiAgICAgIHRoaXMuc2Nyb2xsLnVwZGF0ZSgpO1xuICAgICAgdmFyIG5hdGl2ZVJhbmdlID0gdGhpcy5nZXROYXRpdmVSYW5nZSgpO1xuICAgICAgaWYgKG5hdGl2ZVJhbmdlID09IG51bGwgfHwgIW5hdGl2ZVJhbmdlLm5hdGl2ZS5jb2xsYXBzZWQgfHwgX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShfZm9ybWF0LCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLKSkgcmV0dXJuO1xuICAgICAgaWYgKG5hdGl2ZVJhbmdlLnN0YXJ0Lm5vZGUgIT09IHRoaXMuY3Vyc29yLnRleHROb2RlKSB7XG4gICAgICAgIHZhciBibG90ID0gX3BhcmNobWVudDIuZGVmYXVsdC5maW5kKG5hdGl2ZVJhbmdlLnN0YXJ0Lm5vZGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKGJsb3QgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAvLyBUT0RPIEdpdmUgYmxvdCBhYmlsaXR5IHRvIG5vdCBzcGxpdFxuICAgICAgICBpZiAoYmxvdCBpbnN0YW5jZW9mIF9wYXJjaG1lbnQyLmRlZmF1bHQuTGVhZikge1xuICAgICAgICAgIHZhciBhZnRlciA9IGJsb3Quc3BsaXQobmF0aXZlUmFuZ2Uuc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgICBibG90LnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5jdXJzb3IsIGFmdGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibG90Lmluc2VydEJlZm9yZSh0aGlzLmN1cnNvciwgbmF0aXZlUmFuZ2Uuc3RhcnQubm9kZSk7IC8vIFNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnNvci5hdHRhY2goKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3Vyc29yLmZvcm1hdChfZm9ybWF0LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNjcm9sbC5vcHRpbWl6ZSgpO1xuICAgICAgdGhpcy5zZXROYXRpdmVSYW5nZSh0aGlzLmN1cnNvci50ZXh0Tm9kZSwgdGhpcy5jdXJzb3IudGV4dE5vZGUuZGF0YS5sZW5ndGgpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRCb3VuZHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3VuZHMoaW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICAgIHZhciBzY3JvbGxMZW5ndGggPSB0aGlzLnNjcm9sbC5sZW5ndGgoKTtcbiAgICAgIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHNjcm9sbExlbmd0aCAtIDEpO1xuICAgICAgbGVuZ3RoID0gTWF0aC5taW4oaW5kZXggKyBsZW5ndGgsIHNjcm9sbExlbmd0aCAtIDEpIC0gaW5kZXg7XG4gICAgICB2YXIgbm9kZSA9IHZvaWQgMCxcbiAgICAgICAgICBfc2Nyb2xsJGxlYWYgPSB0aGlzLnNjcm9sbC5sZWFmKGluZGV4KSxcbiAgICAgICAgICBfc2Nyb2xsJGxlYWYyID0gX3NsaWNlZFRvQXJyYXkoX3Njcm9sbCRsZWFmLCAyKSxcbiAgICAgICAgICBsZWFmID0gX3Njcm9sbCRsZWFmMlswXSxcbiAgICAgICAgICBvZmZzZXQgPSBfc2Nyb2xsJGxlYWYyWzFdO1xuICAgICAgaWYgKGxlYWYgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIHZhciBfbGVhZiRwb3NpdGlvbiA9IGxlYWYucG9zaXRpb24ob2Zmc2V0LCB0cnVlKTtcblxuICAgICAgdmFyIF9sZWFmJHBvc2l0aW9uMiA9IF9zbGljZWRUb0FycmF5KF9sZWFmJHBvc2l0aW9uLCAyKTtcblxuICAgICAgbm9kZSA9IF9sZWFmJHBvc2l0aW9uMlswXTtcbiAgICAgIG9mZnNldCA9IF9sZWFmJHBvc2l0aW9uMlsxXTtcblxuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG5cbiAgICAgICAgdmFyIF9zY3JvbGwkbGVhZjMgPSB0aGlzLnNjcm9sbC5sZWFmKGluZGV4ICsgbGVuZ3RoKTtcblxuICAgICAgICB2YXIgX3Njcm9sbCRsZWFmNCA9IF9zbGljZWRUb0FycmF5KF9zY3JvbGwkbGVhZjMsIDIpO1xuXG4gICAgICAgIGxlYWYgPSBfc2Nyb2xsJGxlYWY0WzBdO1xuICAgICAgICBvZmZzZXQgPSBfc2Nyb2xsJGxlYWY0WzFdO1xuXG4gICAgICAgIGlmIChsZWFmID09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciBfbGVhZiRwb3NpdGlvbjMgPSBsZWFmLnBvc2l0aW9uKG9mZnNldCwgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIF9sZWFmJHBvc2l0aW9uNCA9IF9zbGljZWRUb0FycmF5KF9sZWFmJHBvc2l0aW9uMywgMik7XG5cbiAgICAgICAgbm9kZSA9IF9sZWFmJHBvc2l0aW9uNFswXTtcbiAgICAgICAgb2Zmc2V0ID0gX2xlYWYkcG9zaXRpb240WzFdO1xuXG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2lkZSA9ICdsZWZ0JztcbiAgICAgICAgdmFyIHJlY3QgPSB2b2lkIDA7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgIGlmIChvZmZzZXQgPCBub2RlLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQgLSAxKTtcbiAgICAgICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgc2lkZSA9ICdyaWdodCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlY3QgPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN0ID0gbGVhZi5kb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGlmIChvZmZzZXQgPiAwKSBzaWRlID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJvdHRvbTogcmVjdC50b3AgKyByZWN0LmhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgICAgICAgIGxlZnQ6IHJlY3Rbc2lkZV0sXG4gICAgICAgICAgcmlnaHQ6IHJlY3Rbc2lkZV0sXG4gICAgICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgICAgICB3aWR0aDogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldE5hdGl2ZVJhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmF0aXZlUmFuZ2UoKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoc2VsZWN0aW9uID09IG51bGwgfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPD0gMCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgbmF0aXZlUmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgIGlmIChuYXRpdmVSYW5nZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMubm9ybWFsaXplTmF0aXZlKG5hdGl2ZVJhbmdlKTtcbiAgICAgIGRlYnVnLmluZm8oJ2dldE5hdGl2ZVJhbmdlJywgcmFuZ2UpO1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFJhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2UoKSB7XG4gICAgICB2YXIgbm9ybWFsaXplZCA9IHRoaXMuZ2V0TmF0aXZlUmFuZ2UoKTtcbiAgICAgIGlmIChub3JtYWxpemVkID09IG51bGwpIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLm5vcm1hbGl6ZWRUb1JhbmdlKG5vcm1hbGl6ZWQpO1xuICAgICAgcmV0dXJuIFtyYW5nZSwgbm9ybWFsaXplZF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFzRm9jdXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNGb2N1cygpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLnJvb3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbm9ybWFsaXplZFRvUmFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemVkVG9SYW5nZShyYW5nZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBwb3NpdGlvbnMgPSBbW3JhbmdlLnN0YXJ0Lm5vZGUsIHJhbmdlLnN0YXJ0Lm9mZnNldF1dO1xuICAgICAgaWYgKCFyYW5nZS5uYXRpdmUuY29sbGFwc2VkKSB7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKFtyYW5nZS5lbmQubm9kZSwgcmFuZ2UuZW5kLm9mZnNldF0pO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ZXMgPSBwb3NpdGlvbnMubWFwKGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3Bvc2l0aW9uID0gX3NsaWNlZFRvQXJyYXkocG9zaXRpb24sIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9wb3NpdGlvblswXSxcbiAgICAgICAgICAgIG9mZnNldCA9IF9wb3NpdGlvblsxXTtcblxuICAgICAgICB2YXIgYmxvdCA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuZmluZChub2RlLCB0cnVlKTtcbiAgICAgICAgdmFyIGluZGV4ID0gYmxvdC5vZmZzZXQoX3RoaXM0LnNjcm9sbCk7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH0gZWxzZSBpZiAoYmxvdCBpbnN0YW5jZW9mIF9wYXJjaG1lbnQyLmRlZmF1bHQuQ29udGFpbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ICsgYmxvdC5sZW5ndGgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXggKyBibG90LmluZGV4KG5vZGUsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGVuZCA9IE1hdGgubWluKE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShpbmRleGVzKSksIHRoaXMuc2Nyb2xsLmxlbmd0aCgpIC0gMSk7XG4gICAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBbZW5kXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGluZGV4ZXMpKSk7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbm9ybWFsaXplTmF0aXZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplTmF0aXZlKG5hdGl2ZVJhbmdlKSB7XG4gICAgICBpZiAoIWNvbnRhaW5zKHRoaXMucm9vdCwgbmF0aXZlUmFuZ2Uuc3RhcnRDb250YWluZXIpIHx8ICFuYXRpdmVSYW5nZS5jb2xsYXBzZWQgJiYgIWNvbnRhaW5zKHRoaXMucm9vdCwgbmF0aXZlUmFuZ2UuZW5kQ29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciByYW5nZSA9IHtcbiAgICAgICAgc3RhcnQ6IHsgbm9kZTogbmF0aXZlUmFuZ2Uuc3RhcnRDb250YWluZXIsIG9mZnNldDogbmF0aXZlUmFuZ2Uuc3RhcnRPZmZzZXQgfSxcbiAgICAgICAgZW5kOiB7IG5vZGU6IG5hdGl2ZVJhbmdlLmVuZENvbnRhaW5lciwgb2Zmc2V0OiBuYXRpdmVSYW5nZS5lbmRPZmZzZXQgfSxcbiAgICAgICAgbmF0aXZlOiBuYXRpdmVSYW5nZVxuICAgICAgfTtcbiAgICAgIFtyYW5nZS5zdGFydCwgcmFuZ2UuZW5kXS5mb3JFYWNoKGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgbm9kZSA9IHBvc2l0aW9uLm5vZGUsXG4gICAgICAgICAgICBvZmZzZXQgPSBwb3NpdGlvbi5vZmZzZXQ7XG4gICAgICAgIHdoaWxlICghKG5vZGUgaW5zdGFuY2VvZiBUZXh0KSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBvZmZzZXQgPSBub2RlIGluc3RhbmNlb2YgVGV4dCA/IG5vZGUuZGF0YS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uLm5vZGUgPSBub2RlLCBwb3NpdGlvbi5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyYW5nZVRvTmF0aXZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmFuZ2VUb05hdGl2ZShyYW5nZSkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBpbmRleGVzID0gcmFuZ2UuY29sbGFwc2VkID8gW3JhbmdlLmluZGV4XSA6IFtyYW5nZS5pbmRleCwgcmFuZ2UuaW5kZXggKyByYW5nZS5sZW5ndGhdO1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIHZhciBzY3JvbGxMZW5ndGggPSB0aGlzLnNjcm9sbC5sZW5ndGgoKTtcbiAgICAgIGluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgsIGkpIHtcbiAgICAgICAgaW5kZXggPSBNYXRoLm1pbihzY3JvbGxMZW5ndGggLSAxLCBpbmRleCk7XG4gICAgICAgIHZhciBub2RlID0gdm9pZCAwLFxuICAgICAgICAgICAgX3Njcm9sbCRsZWFmNSA9IF90aGlzNS5zY3JvbGwubGVhZihpbmRleCksXG4gICAgICAgICAgICBfc2Nyb2xsJGxlYWY2ID0gX3NsaWNlZFRvQXJyYXkoX3Njcm9sbCRsZWFmNSwgMiksXG4gICAgICAgICAgICBsZWFmID0gX3Njcm9sbCRsZWFmNlswXSxcbiAgICAgICAgICAgIG9mZnNldCA9IF9zY3JvbGwkbGVhZjZbMV07XG4gICAgICAgIHZhciBfbGVhZiRwb3NpdGlvbjUgPSBsZWFmLnBvc2l0aW9uKG9mZnNldCwgaSAhPT0gMCk7XG5cbiAgICAgICAgdmFyIF9sZWFmJHBvc2l0aW9uNiA9IF9zbGljZWRUb0FycmF5KF9sZWFmJHBvc2l0aW9uNSwgMik7XG5cbiAgICAgICAgbm9kZSA9IF9sZWFmJHBvc2l0aW9uNlswXTtcbiAgICAgICAgb2Zmc2V0ID0gX2xlYWYkcG9zaXRpb242WzFdO1xuXG4gICAgICAgIGFyZ3MucHVzaChub2RlLCBvZmZzZXQpO1xuICAgICAgfSk7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Njcm9sbEludG9WaWV3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoc2Nyb2xsaW5nQ29udGFpbmVyKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmxhc3RSYW5nZTtcbiAgICAgIGlmIChyYW5nZSA9PSBudWxsKSByZXR1cm47XG4gICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMocmFuZ2UuaW5kZXgsIHJhbmdlLmxlbmd0aCk7XG4gICAgICBpZiAoYm91bmRzID09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciBsaW1pdCA9IHRoaXMuc2Nyb2xsLmxlbmd0aCgpIC0gMTtcblxuICAgICAgdmFyIF9zY3JvbGwkbGluZSA9IHRoaXMuc2Nyb2xsLmxpbmUoTWF0aC5taW4ocmFuZ2UuaW5kZXgsIGxpbWl0KSksXG4gICAgICAgICAgX3Njcm9sbCRsaW5lMiA9IF9zbGljZWRUb0FycmF5KF9zY3JvbGwkbGluZSwgMSksXG4gICAgICAgICAgZmlyc3QgPSBfc2Nyb2xsJGxpbmUyWzBdO1xuXG4gICAgICB2YXIgbGFzdCA9IGZpcnN0O1xuICAgICAgaWYgKHJhbmdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIF9zY3JvbGwkbGluZTMgPSB0aGlzLnNjcm9sbC5saW5lKE1hdGgubWluKHJhbmdlLmluZGV4ICsgcmFuZ2UubGVuZ3RoLCBsaW1pdCkpO1xuXG4gICAgICAgIHZhciBfc2Nyb2xsJGxpbmU0ID0gX3NsaWNlZFRvQXJyYXkoX3Njcm9sbCRsaW5lMywgMSk7XG5cbiAgICAgICAgbGFzdCA9IF9zY3JvbGwkbGluZTRbMF07XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3QgPT0gbnVsbCB8fCBsYXN0ID09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciBzY3JvbGxCb3VuZHMgPSBzY3JvbGxpbmdDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoYm91bmRzLnRvcCA8IHNjcm9sbEJvdW5kcy50b3ApIHtcbiAgICAgICAgc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcCAtPSBzY3JvbGxCb3VuZHMudG9wIC0gYm91bmRzLnRvcDtcbiAgICAgIH0gZWxzZSBpZiAoYm91bmRzLmJvdHRvbSA+IHNjcm9sbEJvdW5kcy5ib3R0b20pIHtcbiAgICAgICAgc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcCArPSBib3VuZHMuYm90dG9tIC0gc2Nyb2xsQm91bmRzLmJvdHRvbTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXROYXRpdmVSYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE5hdGl2ZVJhbmdlKHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpIHtcbiAgICAgIHZhciBlbmROb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBzdGFydE5vZGU7XG4gICAgICB2YXIgZW5kT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBzdGFydE9mZnNldDtcbiAgICAgIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgICAgIGRlYnVnLmluZm8oJ3NldE5hdGl2ZVJhbmdlJywgc3RhcnROb2RlLCBzdGFydE9mZnNldCwgZW5kTm9kZSwgZW5kT2Zmc2V0KTtcbiAgICAgIGlmIChzdGFydE5vZGUgIT0gbnVsbCAmJiAodGhpcy5yb290LnBhcmVudE5vZGUgPT0gbnVsbCB8fCBzdGFydE5vZGUucGFyZW50Tm9kZSA9PSBudWxsIHx8IGVuZE5vZGUucGFyZW50Tm9kZSA9PSBudWxsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHJldHVybjtcbiAgICAgIGlmIChzdGFydE5vZGUgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRm9jdXMoKSkgdGhpcy5yb290LmZvY3VzKCk7XG4gICAgICAgIHZhciBuYXRpdmUgPSAodGhpcy5nZXROYXRpdmVSYW5nZSgpIHx8IHt9KS5uYXRpdmU7XG4gICAgICAgIGlmIChuYXRpdmUgPT0gbnVsbCB8fCBmb3JjZSB8fCBzdGFydE5vZGUgIT09IG5hdGl2ZS5zdGFydENvbnRhaW5lciB8fCBzdGFydE9mZnNldCAhPT0gbmF0aXZlLnN0YXJ0T2Zmc2V0IHx8IGVuZE5vZGUgIT09IG5hdGl2ZS5lbmRDb250YWluZXIgfHwgZW5kT2Zmc2V0ICE9PSBuYXRpdmUuZW5kT2Zmc2V0KSB7XG5cbiAgICAgICAgICBpZiAoc3RhcnROb2RlLnRhZ05hbWUgPT0gXCJCUlwiKSB7XG4gICAgICAgICAgICBzdGFydE9mZnNldCA9IFtdLmluZGV4T2YuY2FsbChzdGFydE5vZGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzLCBzdGFydE5vZGUpO1xuICAgICAgICAgICAgc3RhcnROb2RlID0gc3RhcnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmROb2RlLnRhZ05hbWUgPT0gXCJCUlwiKSB7XG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBbXS5pbmRleE9mLmNhbGwoZW5kTm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMsIGVuZE5vZGUpO1xuICAgICAgICAgICAgZW5kTm9kZSA9IGVuZE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICByYW5nZS5zZXRTdGFydChzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICByYW5nZS5zZXRFbmQoZW5kTm9kZSwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICB0aGlzLnJvb3QuYmx1cigpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7IC8vIHJvb3QuYmx1cigpIG5vdCBlbm91Z2ggb24gSUUxMStUcmF2aXMrU2F1Y2VMYWJzIChidXQgbm90IGxvY2FsIFZNcylcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRSYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFJhbmdlKHJhbmdlKSB7XG4gICAgICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5BUEk7XG5cbiAgICAgIGlmICh0eXBlb2YgZm9yY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNvdXJjZSA9IGZvcmNlO1xuICAgICAgICBmb3JjZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZGVidWcuaW5mbygnc2V0UmFuZ2UnLCByYW5nZSk7XG4gICAgICBpZiAocmFuZ2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMucmFuZ2VUb05hdGl2ZShyYW5nZSk7XG4gICAgICAgIHRoaXMuc2V0TmF0aXZlUmFuZ2UuYXBwbHkodGhpcywgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpLmNvbmNhdChbZm9yY2VdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldE5hdGl2ZVJhbmdlKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGUoc291cmNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlVTRVI7XG5cbiAgICAgIHZhciBvbGRSYW5nZSA9IHRoaXMubGFzdFJhbmdlO1xuXG4gICAgICB2YXIgX2dldFJhbmdlID0gdGhpcy5nZXRSYW5nZSgpLFxuICAgICAgICAgIF9nZXRSYW5nZTIgPSBfc2xpY2VkVG9BcnJheShfZ2V0UmFuZ2UsIDIpLFxuICAgICAgICAgIGxhc3RSYW5nZSA9IF9nZXRSYW5nZTJbMF0sXG4gICAgICAgICAgbmF0aXZlUmFuZ2UgPSBfZ2V0UmFuZ2UyWzFdO1xuXG4gICAgICB0aGlzLmxhc3RSYW5nZSA9IGxhc3RSYW5nZTtcbiAgICAgIGlmICh0aGlzLmxhc3RSYW5nZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2F2ZWRSYW5nZSA9IHRoaXMubGFzdFJhbmdlO1xuICAgICAgfVxuICAgICAgaWYgKCEoMCwgX2RlZXBFcXVhbDIuZGVmYXVsdCkob2xkUmFuZ2UsIHRoaXMubGFzdFJhbmdlKSkge1xuICAgICAgICB2YXIgX2VtaXR0ZXI7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNvbXBvc2luZyAmJiBuYXRpdmVSYW5nZSAhPSBudWxsICYmIG5hdGl2ZVJhbmdlLm5hdGl2ZS5jb2xsYXBzZWQgJiYgbmF0aXZlUmFuZ2Uuc3RhcnQubm9kZSAhPT0gdGhpcy5jdXJzb3IudGV4dE5vZGUpIHtcbiAgICAgICAgICB0aGlzLmN1cnNvci5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ3MgPSBbX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzLlNFTEVDVElPTl9DSEFOR0UsICgwLCBfY2xvbmUyLmRlZmF1bHQpKHRoaXMubGFzdFJhbmdlKSwgKDAsIF9jbG9uZTIuZGVmYXVsdCkob2xkUmFuZ2UpLCBzb3VyY2VdO1xuICAgICAgICAoX2VtaXR0ZXIgPSB0aGlzLmVtaXR0ZXIpLmVtaXQuYXBwbHkoX2VtaXR0ZXIsIFtfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuRURJVE9SX0NIQU5HRV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5TSUxFTlQpIHtcbiAgICAgICAgICB2YXIgX2VtaXR0ZXIyO1xuXG4gICAgICAgICAgKF9lbWl0dGVyMiA9IHRoaXMuZW1pdHRlcikuZW1pdC5hcHBseShfZW1pdHRlcjIsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNlbGVjdGlvbjtcbn0oKTtcblxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBkZXNjZW5kYW50KSB7XG4gIHRyeSB7XG4gICAgLy8gRmlyZWZveCBpbnNlcnRzIGluYWNjZXNzaWJsZSBub2RlcyBhcm91bmQgdmlkZW8gZWxlbWVudHNcbiAgICBkZXNjZW5kYW50LnBhcmVudE5vZGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gSUUxMSBoYXMgYnVnIHdpdGggVGV4dCBub2Rlc1xuICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzc4MDg3NC9ub2RlLWNvbnRhaW5zLWlzLWluY29ycmVjdFxuICBpZiAoZGVzY2VuZGFudCBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICBkZXNjZW5kYW50ID0gZGVzY2VuZGFudC5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBwYXJlbnQuY29udGFpbnMoZGVzY2VuZGFudCk7XG59XG5cbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNlbGVjdGlvbjtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQnJlYWsgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRFbWJlZCkge1xuICBfaW5oZXJpdHMoQnJlYWssIF9QYXJjaG1lbnQkRW1iZWQpO1xuXG4gIGZ1bmN0aW9uIEJyZWFrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCcmVhayk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJyZWFrLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnJlYWspKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCcmVhaywgW3tcbiAgICBrZXk6ICdpbnNlcnRJbnRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0SW50byhwYXJlbnQsIHJlZikge1xuICAgICAgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgX2dldChCcmVhay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCcmVhay5wcm90b3R5cGUpLCAnaW5zZXJ0SW50bycsIHRoaXMpLmNhbGwodGhpcywgcGFyZW50LCByZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsZW5ndGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJyZWFrO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkKTtcblxuQnJlYWsuYmxvdE5hbWUgPSAnYnJlYWsnO1xuQnJlYWsudGFnTmFtZSA9ICdCUic7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJyZWFrO1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsaW5rZWRfbGlzdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG52YXIgc2hhZG93XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgQ29udGFpbmVyQmxvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udGFpbmVyQmxvdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250YWluZXJCbG90KGRvbU5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9tTm9kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYnVpbGQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShvdGhlcik7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYXR0YWNoLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLmF0dGFjaCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IGxpbmtlZF9saXN0XzEuZGVmYXVsdCgpO1xuICAgICAgICAvLyBOZWVkIHRvIGJlIHJldmVyc2VkIGZvciBpZiBET00gbm9kZXMgYWxyZWFkeSBpbiBvcmRlclxuICAgICAgICBbXS5zbGljZVxuICAgICAgICAgICAgLmNhbGwodGhpcy5kb21Ob2RlLmNoaWxkTm9kZXMpXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBtYWtlQmxvdChub2RlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbnNlcnRCZWZvcmUoY2hpbGQsIF90aGlzLmNoaWxkcmVuLmhlYWQgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUmVnaXN0cnkuUGFyY2htZW50RXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5kZWxldGVBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiBsZW5ndGggPT09IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaEF0KGluZGV4LCBsZW5ndGgsIGZ1bmN0aW9uIChjaGlsZCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoaWxkLmRlbGV0ZUF0KG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5kZXNjZW5kYW50ID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBpbmRleCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNoaWxkcmVuLmZpbmQoaW5kZXgpLCBjaGlsZCA9IF9hWzBdLCBvZmZzZXQgPSBfYVsxXTtcbiAgICAgICAgaWYgKChjcml0ZXJpYS5ibG90TmFtZSA9PSBudWxsICYmIGNyaXRlcmlhKGNoaWxkKSkgfHxcbiAgICAgICAgICAgIChjcml0ZXJpYS5ibG90TmFtZSAhPSBudWxsICYmIGNoaWxkIGluc3RhbmNlb2YgY3JpdGVyaWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NoaWxkLCBvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgQ29udGFpbmVyQmxvdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRlc2NlbmRhbnQoY3JpdGVyaWEsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIC0xXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuZGVzY2VuZGFudHMgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAwOyB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkgeyBsZW5ndGggPSBOdW1iZXIuTUFYX1ZBTFVFOyB9XG4gICAgICAgIHZhciBkZXNjZW5kYW50cyA9IFtdO1xuICAgICAgICB2YXIgbGVuZ3RoTGVmdCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoQXQoaW5kZXgsIGxlbmd0aCwgZnVuY3Rpb24gKGNoaWxkLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoKGNyaXRlcmlhLmJsb3ROYW1lID09IG51bGwgJiYgY3JpdGVyaWEoY2hpbGQpKSB8fFxuICAgICAgICAgICAgICAgIChjcml0ZXJpYS5ibG90TmFtZSAhPSBudWxsICYmIGNoaWxkIGluc3RhbmNlb2YgY3JpdGVyaWEpKSB7XG4gICAgICAgICAgICAgICAgZGVzY2VuZGFudHMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBDb250YWluZXJCbG90KSB7XG4gICAgICAgICAgICAgICAgZGVzY2VuZGFudHMgPSBkZXNjZW5kYW50cy5jb25jYXQoY2hpbGQuZGVzY2VuZGFudHMoY3JpdGVyaWEsIGluZGV4LCBsZW5ndGhMZWZ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZW5ndGhMZWZ0IC09IGxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZXNjZW5kYW50cztcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQuZGV0YWNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRldGFjaC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuZm9ybWF0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoQXQoaW5kZXgsIGxlbmd0aCwgZnVuY3Rpb24gKGNoaWxkLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgY2hpbGQuZm9ybWF0QXQob2Zmc2V0LCBsZW5ndGgsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5pbnNlcnRBdCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNoaWxkcmVuLmZpbmQoaW5kZXgpLCBjaGlsZCA9IF9hWzBdLCBvZmZzZXQgPSBfYVsxXTtcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5pbnNlcnRBdChvZmZzZXQsIHZhbHVlLCBkZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJsb3QgPSBkZWYgPT0gbnVsbCA/IFJlZ2lzdHJ5LmNyZWF0ZSgndGV4dCcsIHZhbHVlKSA6IFJlZ2lzdHJ5LmNyZWF0ZSh2YWx1ZSwgZGVmKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoYmxvdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChjaGlsZEJsb3QsIHJlZkJsb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGljcy5hbGxvd2VkQ2hpbGRyZW4gIT0gbnVsbCAmJlxuICAgICAgICAgICAgIXRoaXMuc3RhdGljcy5hbGxvd2VkQ2hpbGRyZW4uc29tZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRCbG90IGluc3RhbmNlb2YgY2hpbGQ7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZ2lzdHJ5LlBhcmNobWVudEVycm9yKFwiQ2Fubm90IGluc2VydCBcIiArIGNoaWxkQmxvdC5zdGF0aWNzLmJsb3ROYW1lICsgXCIgaW50byBcIiArIHRoaXMuc3RhdGljcy5ibG90TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRCbG90Lmluc2VydEludG8odGhpcywgcmVmQmxvdCk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAobWVtbywgY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZW1vICsgY2hpbGQubGVuZ3RoKCk7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUubW92ZUNoaWxkcmVuID0gZnVuY3Rpb24gKHRhcmdldFBhcmVudCwgcmVmTm9kZSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICB0YXJnZXRQYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCByZWZOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5vcHRpbWl6ZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub3B0aW1pemUuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0aWNzLmRlZmF1bHRDaGlsZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gUmVnaXN0cnkuY3JlYXRlKHRoaXMuc3RhdGljcy5kZWZhdWx0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGNoaWxkLm9wdGltaXplKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIChpbmRleCwgaW5jbHVzaXZlKSB7XG4gICAgICAgIGlmIChpbmNsdXNpdmUgPT09IHZvaWQgMCkgeyBpbmNsdXNpdmUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLmNoaWxkcmVuLmZpbmQoaW5kZXgsIGluY2x1c2l2ZSksIGNoaWxkID0gX2FbMF0sIG9mZnNldCA9IF9hWzFdO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBbW3RoaXMsIGluZGV4XV07XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIENvbnRhaW5lckJsb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbi5jb25jYXQoY2hpbGQucGF0aChvZmZzZXQsIGluY2x1c2l2ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnB1c2goW2NoaWxkLCBvZmZzZXRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnJlbW92ZShjaGlsZCk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgQ29udGFpbmVyQmxvdCkge1xuICAgICAgICAgICAgdGFyZ2V0Lm1vdmVDaGlsZHJlbih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlcGxhY2UuY2FsbCh0aGlzLCB0YXJnZXQpO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoaW5kZXgsIGZvcmNlKSB7XG4gICAgICAgIGlmIChmb3JjZSA9PT0gdm9pZCAwKSB7IGZvcmNlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKCFmb3JjZSkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmxlbmd0aCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFmdGVyID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYWZ0ZXIsIHRoaXMubmV4dCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaEF0KGluZGV4LCB0aGlzLmxlbmd0aCgpLCBmdW5jdGlvbiAoY2hpbGQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLnNwbGl0KG9mZnNldCwgZm9yY2UpO1xuICAgICAgICAgICAgYWZ0ZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUudW53cmFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vdmVDaGlsZHJlbih0aGlzLnBhcmVudCwgdGhpcy5uZXh0KTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFkZGVkTm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIHJlbW92ZWROb2RlcyA9IFtdO1xuICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi50YXJnZXQgPT09IF90aGlzLmRvbU5vZGUgJiYgbXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgICBhZGRlZE5vZGVzLnB1c2guYXBwbHkoYWRkZWROb2RlcywgbXV0YXRpb24uYWRkZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZE5vZGVzLnB1c2guYXBwbHkocmVtb3ZlZE5vZGVzLCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVtb3ZlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIG5vZGUgaGFzIGFjdHVhbGx5IGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgLy8gT25lIGV4Y2VwdGlvbiBpcyBDaHJvbWUgZG9lcyBub3QgaW1tZWRpYXRlbHkgcmVtb3ZlIElGUkFNRXNcbiAgICAgICAgICAgIC8vIGZyb20gRE9NIGJ1dCBNdXRhdGlvblJlY29yZCBpcyBjb3JyZWN0IGluIGl0cyByZXBvcnRlZCByZW1vdmFsXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgbm9kZS50YWdOYW1lICE9PSAnSUZSQU1FJyAmJlxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBibG90ID0gUmVnaXN0cnkuZmluZChub2RlKTtcbiAgICAgICAgICAgIGlmIChibG90ID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGJsb3QuZG9tTm9kZS5wYXJlbnROb2RlID09IG51bGwgfHwgYmxvdC5kb21Ob2RlLnBhcmVudE5vZGUgPT09IF90aGlzLmRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICBibG90LmRldGFjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYWRkZWROb2Rlc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSA9PSBfdGhpcy5kb21Ob2RlO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhID09PSBiKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORykge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciByZWZCbG90ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWZCbG90ID0gUmVnaXN0cnkuZmluZChub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBibG90ID0gbWFrZUJsb3Qobm9kZSk7XG4gICAgICAgICAgICBpZiAoYmxvdC5uZXh0ICE9IHJlZkJsb3QgfHwgYmxvdC5uZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvdC5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBibG90LnBhcmVudC5yZW1vdmVDaGlsZChfdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmluc2VydEJlZm9yZShibG90LCByZWZCbG90IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRhaW5lckJsb3Q7XG59KHNoYWRvd18xLmRlZmF1bHQpKTtcbmZ1bmN0aW9uIG1ha2VCbG90KG5vZGUpIHtcbiAgICB2YXIgYmxvdCA9IFJlZ2lzdHJ5LmZpbmQobm9kZSk7XG4gICAgaWYgKGJsb3QgPT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmxvdCA9IFJlZ2lzdHJ5LmNyZWF0ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYmxvdCA9IFJlZ2lzdHJ5LmNyZWF0ZShSZWdpc3RyeS5TY29wZS5JTkxJTkUpO1xuICAgICAgICAgICAgW10uc2xpY2UuY2FsbChub2RlLmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGJsb3QuZG9tTm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJsb3QuZG9tTm9kZSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG90LmF0dGFjaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBibG90O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29udGFpbmVyQmxvdDtcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhdHRyaWJ1dG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBzdG9yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG52YXIgY29udGFpbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgRm9ybWF0QmxvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9ybWF0QmxvdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGb3JtYXRCbG90KGRvbU5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9tTm9kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYXR0cmlidXRlcyA9IG5ldyBzdG9yZV8xLmRlZmF1bHQoX3RoaXMuZG9tTm9kZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRm9ybWF0QmxvdC5mb3JtYXRzID0gZnVuY3Rpb24gKGRvbU5vZGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRhZ05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMudGFnTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkb21Ob2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgRm9ybWF0QmxvdC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSBSZWdpc3RyeS5xdWVyeShuYW1lKTtcbiAgICAgICAgaWYgKGZvcm1hdCBpbnN0YW5jZW9mIGF0dHJpYnV0b3JfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuYXR0cmlidXRlKGZvcm1hdCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ICE9IG51bGwgJiYgKG5hbWUgIT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSB8fCB0aGlzLmZvcm1hdHMoKVtuYW1lXSAhPT0gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZvcm1hdEJsb3QucHJvdG90eXBlLmZvcm1hdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmb3JtYXRzID0gdGhpcy5hdHRyaWJ1dGVzLnZhbHVlcygpO1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5zdGF0aWNzLmZvcm1hdHModGhpcy5kb21Ob2RlKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXRzW3RoaXMuc3RhdGljcy5ibG90TmFtZV0gPSBmb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgfTtcbiAgICBGb3JtYXRCbG90LnByb3RvdHlwZS5yZXBsYWNlV2l0aCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBfc3VwZXIucHJvdG90eXBlLnJlcGxhY2VXaXRoLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuY29weShyZXBsYWNlbWVudCk7XG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgICB9O1xuICAgIEZvcm1hdEJsb3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCBtdXRhdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICBpZiAobXV0YXRpb25zLnNvbWUoZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbXV0YXRpb24udGFyZ2V0ID09PSBfdGhpcy5kb21Ob2RlICYmIG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJztcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5idWlsZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGb3JtYXRCbG90LnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gX3N1cGVyLnByb3RvdHlwZS53cmFwLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAod3JhcHBlciBpbnN0YW5jZW9mIEZvcm1hdEJsb3QgJiYgd3JhcHBlci5zdGF0aWNzLnNjb3BlID09PSB0aGlzLnN0YXRpY3Muc2NvcGUpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5tb3ZlKHdyYXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcm1hdEJsb3Q7XG59KGNvbnRhaW5lcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEZvcm1hdEJsb3Q7XG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZG93XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgTGVhZkJsb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExlYWZCbG90LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExlYWZCbG90KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIExlYWZCbG90LnZhbHVlID0gZnVuY3Rpb24gKGRvbU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBMZWFmQmxvdC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbiAobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmRvbU5vZGUgPT09IG5vZGUgfHxcbiAgICAgICAgICAgIHRoaXMuZG9tTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4ob2Zmc2V0LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBMZWFmQmxvdC5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoaW5kZXgsIGluY2x1c2l2ZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gW10uaW5kZXhPZi5jYWxsKHRoaXMucGFyZW50LmRvbU5vZGUuY2hpbGROb2RlcywgdGhpcy5kb21Ob2RlKTtcbiAgICAgICAgaWYgKGluZGV4ID4gMClcbiAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICByZXR1cm4gW3RoaXMucGFyZW50LmRvbU5vZGUsIG9mZnNldF07XG4gICAgfTtcbiAgICBMZWFmQmxvdC5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9hID0ge30sIF9hW3RoaXMuc3RhdGljcy5ibG90TmFtZV0gPSB0aGlzLnN0YXRpY3MudmFsdWUodGhpcy5kb21Ob2RlKSB8fCB0cnVlLCBfYTtcbiAgICB9O1xuICAgIExlYWZCbG90LnNjb3BlID0gUmVnaXN0cnkuU2NvcGUuSU5MSU5FX0JMT1Q7XG4gICAgcmV0dXJuIExlYWZCbG90O1xufShzaGFkb3dfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBMZWFmQmxvdDtcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBlcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIGV4dGVuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblxudmFyIGxpYiA9IHtcbiAgYXR0cmlidXRlczoge1xuICAgIGNvbXBvc2U6IGZ1bmN0aW9uIChhLCBiLCBrZWVwTnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBhICE9PSAnb2JqZWN0JykgYSA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBiICE9PSAnb2JqZWN0JykgYiA9IHt9O1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBleHRlbmQodHJ1ZSwge30sIGIpO1xuICAgICAgaWYgKCFrZWVwTnVsbCkge1xuICAgICAgICBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykucmVkdWNlKGZ1bmN0aW9uIChjb3B5LCBrZXkpIHtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlc1trZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgIGlmIChhW2tleV0gIT09IHVuZGVmaW5lZCAmJiBiW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGFba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDAgPyBhdHRyaWJ1dGVzIDogdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICBkaWZmOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT09ICdvYmplY3QnKSBhID0ge307XG4gICAgICBpZiAodHlwZW9mIGIgIT09ICdvYmplY3QnKSBiID0ge307XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGEpLmNvbmNhdChPYmplY3Qua2V5cyhiKSkucmVkdWNlKGZ1bmN0aW9uIChhdHRyaWJ1dGVzLCBrZXkpIHtcbiAgICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSBiW2tleV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBiW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICB9LCB7fSk7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCA/IGF0dHJpYnV0ZXMgOiB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKGEsIGIsIHByaW9yaXR5KSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT09ICdvYmplY3QnKSByZXR1cm4gYjtcbiAgICAgIGlmICh0eXBlb2YgYiAhPT0gJ29iamVjdCcpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICBpZiAoIXByaW9yaXR5KSByZXR1cm4gYjsgIC8vIGIgc2ltcGx5IG92ZXJ3cml0ZXMgdXMgd2l0aG91dCBwcmlvcml0eVxuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhiKS5yZWR1Y2UoZnVuY3Rpb24gKGF0dHJpYnV0ZXMsIGtleSkge1xuICAgICAgICBpZiAoYVtrZXldID09PSB1bmRlZmluZWQpIGF0dHJpYnV0ZXNba2V5XSA9IGJba2V5XTsgIC8vIG51bGwgaXMgYSB2YWxpZCB2YWx1ZVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgIH0sIHt9KTtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwID8gYXR0cmlidXRlcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG5cbiAgaXRlcmF0b3I6IGZ1bmN0aW9uIChvcHMpIHtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKG9wcyk7XG4gIH0sXG5cbiAgbGVuZ3RoOiBmdW5jdGlvbiAob3ApIHtcbiAgICBpZiAodHlwZW9mIG9wWydkZWxldGUnXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBvcFsnZGVsZXRlJ107XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3AucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIG9wLnJldGFpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnID8gb3AuaW5zZXJ0Lmxlbmd0aCA6IDE7XG4gICAgfVxuICB9XG59O1xuXG5cbmZ1bmN0aW9uIEl0ZXJhdG9yKG9wcykge1xuICB0aGlzLm9wcyA9IG9wcztcbiAgdGhpcy5pbmRleCA9IDA7XG4gIHRoaXMub2Zmc2V0ID0gMDtcbn07XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wZWVrTGVuZ3RoKCkgPCBJbmZpbml0eTtcbn07XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICBpZiAoIWxlbmd0aCkgbGVuZ3RoID0gSW5maW5pdHk7XG4gIHZhciBuZXh0T3AgPSB0aGlzLm9wc1t0aGlzLmluZGV4XTtcbiAgaWYgKG5leHRPcCkge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICB2YXIgb3BMZW5ndGggPSBsaWIubGVuZ3RoKG5leHRPcClcbiAgICBpZiAobGVuZ3RoID49IG9wTGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgICBsZW5ndGggPSBvcExlbmd0aCAtIG9mZnNldDtcbiAgICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5leHRPcFsnZGVsZXRlJ10gPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4geyAnZGVsZXRlJzogbGVuZ3RoIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXRPcCA9IHt9O1xuICAgICAgaWYgKG5leHRPcC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldE9wLmF0dHJpYnV0ZXMgPSBuZXh0T3AuYXR0cmlidXRlcztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbmV4dE9wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0T3AucmV0YWluID0gbGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dE9wLmluc2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0T3AuaW5zZXJ0ID0gbmV4dE9wLmluc2VydC5zdWJzdHIob2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb2Zmc2V0IHNob3VsZCA9PT0gMCwgbGVuZ3RoIHNob3VsZCA9PT0gMVxuICAgICAgICByZXRPcC5pbnNlcnQgPSBuZXh0T3AuaW5zZXJ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldE9wO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyByZXRhaW46IEluZmluaXR5IH07XG4gIH1cbn07XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5vcHNbdGhpcy5pbmRleF07XG59O1xuXG5JdGVyYXRvci5wcm90b3R5cGUucGVla0xlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMub3BzW3RoaXMuaW5kZXhdKSB7XG4gICAgLy8gU2hvdWxkIG5ldmVyIHJldHVybiAwIGlmIG91ciBpbmRleCBpcyBiZWluZyBtYW5hZ2VkIGNvcnJlY3RseVxuICAgIHJldHVybiBsaWIubGVuZ3RoKHRoaXMub3BzW3RoaXMuaW5kZXhdKSAtIHRoaXMub2Zmc2V0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxufTtcblxuSXRlcmF0b3IucHJvdG90eXBlLnBlZWtUeXBlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5vcHNbdGhpcy5pbmRleF0pIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3BzW3RoaXMuaW5kZXhdWydkZWxldGUnXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnZGVsZXRlJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm9wc1t0aGlzLmluZGV4XS5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJ3JldGFpbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnaW5zZXJ0JztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICdyZXRhaW4nO1xufTtcblxuSXRlcmF0b3IucHJvdG90eXBlLnJlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oYXNOZXh0KCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gZWxzZSBpZiAodGhpcy5vZmZzZXQgPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5vcHMuc2xpY2UodGhpcy5pbmRleCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgdmFyIG5leHQgPSB0aGlzLm5leHQoKTtcbiAgICB2YXIgcmVzdCA9IHRoaXMub3BzLnNsaWNlKHRoaXMuaW5kZXgpO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICByZXR1cm4gW25leHRdLmNvbmNhdChyZXN0KTtcbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpYjtcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBjbG9uZSA9IChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2luc3RhbmNlb2Yob2JqLCB0eXBlKSB7XG4gIHJldHVybiB0eXBlICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgdHlwZTtcbn1cblxudmFyIG5hdGl2ZU1hcDtcbnRyeSB7XG4gIG5hdGl2ZU1hcCA9IE1hcDtcbn0gY2F0Y2goXykge1xuICAvLyBtYXliZSBhIHJlZmVyZW5jZSBlcnJvciBiZWNhdXNlIG5vIGBNYXBgLiBHaXZlIGl0IGEgZHVtbXkgdmFsdWUgdGhhdCBub1xuICAvLyB2YWx1ZSB3aWxsIGV2ZXIgYmUgYW4gaW5zdGFuY2VvZi5cbiAgbmF0aXZlTWFwID0gZnVuY3Rpb24oKSB7fTtcbn1cblxudmFyIG5hdGl2ZVNldDtcbnRyeSB7XG4gIG5hdGl2ZVNldCA9IFNldDtcbn0gY2F0Y2goXykge1xuICBuYXRpdmVTZXQgPSBmdW5jdGlvbigpIHt9O1xufVxuXG52YXIgbmF0aXZlUHJvbWlzZTtcbnRyeSB7XG4gIG5hdGl2ZVByb21pc2UgPSBQcm9taXNlO1xufSBjYXRjaChfKSB7XG4gIG5hdGl2ZVByb21pc2UgPSBmdW5jdGlvbigpIHt9O1xufVxuXG4vKipcbiAqIENsb25lcyAoY29waWVzKSBhbiBPYmplY3QgdXNpbmcgZGVlcCBjb3B5aW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSBkZWZhdWx0LCBidXQgaWYgeW91IGFyZSBjZXJ0YWluXG4gKiB0aGVyZSBhcmUgbm8gY2lyY3VsYXIgcmVmZXJlbmNlcyBpbiB5b3VyIG9iamVjdCwgeW91IGNhbiBzYXZlIHNvbWUgQ1BVIHRpbWVcbiAqIGJ5IGNhbGxpbmcgY2xvbmUob2JqLCBmYWxzZSkuXG4gKlxuICogQ2F1dGlvbjogaWYgYGNpcmN1bGFyYCBpcyBmYWxzZSBhbmQgYHBhcmVudGAgY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlcyxcbiAqIHlvdXIgcHJvZ3JhbSBtYXkgZW50ZXIgYW4gaW5maW5pdGUgbG9vcCBhbmQgY3Jhc2guXG4gKlxuICogQHBhcmFtIGBwYXJlbnRgIC0gdGhlIG9iamVjdCB0byBiZSBjbG9uZWRcbiAqIEBwYXJhbSBgY2lyY3VsYXJgIC0gc2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdCB0byBiZSBjbG9uZWQgbWF5IGNvbnRhaW5cbiAqICAgIGNpcmN1bGFyIHJlZmVyZW5jZXMuIChvcHRpb25hbCAtIHRydWUgYnkgZGVmYXVsdClcbiAqIEBwYXJhbSBgZGVwdGhgIC0gc2V0IHRvIGEgbnVtYmVyIGlmIHRoZSBvYmplY3QgaXMgb25seSB0byBiZSBjbG9uZWQgdG9cbiAqICAgIGEgcGFydGljdWxhciBkZXB0aC4gKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gSW5maW5pdHkpXG4gKiBAcGFyYW0gYHByb3RvdHlwZWAgLSBzZXRzIHRoZSBwcm90b3R5cGUgdG8gYmUgdXNlZCB3aGVuIGNsb25pbmcgYW4gb2JqZWN0LlxuICogICAgKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gcGFyZW50IHByb3RvdHlwZSkuXG4gKiBAcGFyYW0gYGluY2x1ZGVOb25FbnVtZXJhYmxlYCAtIHNldCB0byB0cnVlIGlmIHRoZSBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gKiAgICBzaG91bGQgYmUgY2xvbmVkIGFzIHdlbGwuIE5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgb24gdGhlIHByb3RvdHlwZVxuICogICAgY2hhaW4gd2lsbCBiZSBpZ25vcmVkLiAob3B0aW9uYWwgLSBmYWxzZSBieSBkZWZhdWx0KVxuKi9cbmZ1bmN0aW9uIGNsb25lKHBhcmVudCwgY2lyY3VsYXIsIGRlcHRoLCBwcm90b3R5cGUsIGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT09ICdvYmplY3QnKSB7XG4gICAgZGVwdGggPSBjaXJjdWxhci5kZXB0aDtcbiAgICBwcm90b3R5cGUgPSBjaXJjdWxhci5wcm90b3R5cGU7XG4gICAgaW5jbHVkZU5vbkVudW1lcmFibGUgPSBjaXJjdWxhci5pbmNsdWRlTm9uRW51bWVyYWJsZTtcbiAgICBjaXJjdWxhciA9IGNpcmN1bGFyLmNpcmN1bGFyO1xuICB9XG4gIC8vIG1haW50YWluIHR3byBhcnJheXMgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHdoZXJlIGNvcnJlc3BvbmRpbmcgcGFyZW50c1xuICAvLyBhbmQgY2hpbGRyZW4gaGF2ZSB0aGUgc2FtZSBpbmRleFxuICB2YXIgYWxsUGFyZW50cyA9IFtdO1xuICB2YXIgYWxsQ2hpbGRyZW4gPSBbXTtcblxuICB2YXIgdXNlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPSAndW5kZWZpbmVkJztcblxuICBpZiAodHlwZW9mIGNpcmN1bGFyID09ICd1bmRlZmluZWQnKVxuICAgIGNpcmN1bGFyID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGRlcHRoID09ICd1bmRlZmluZWQnKVxuICAgIGRlcHRoID0gSW5maW5pdHk7XG5cbiAgLy8gcmVjdXJzZSB0aGlzIGZ1bmN0aW9uIHNvIHdlIGRvbid0IHJlc2V0IGFsbFBhcmVudHMgYW5kIGFsbENoaWxkcmVuXG4gIGZ1bmN0aW9uIF9jbG9uZShwYXJlbnQsIGRlcHRoKSB7XG4gICAgLy8gY2xvbmluZyBudWxsIGFsd2F5cyByZXR1cm5zIG51bGxcbiAgICBpZiAocGFyZW50ID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoZGVwdGggPT09IDApXG4gICAgICByZXR1cm4gcGFyZW50O1xuXG4gICAgdmFyIGNoaWxkO1xuICAgIHZhciBwcm90bztcbiAgICBpZiAodHlwZW9mIHBhcmVudCAhPSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVNYXApKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVNYXAoKTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlU2V0KSkge1xuICAgICAgY2hpbGQgPSBuZXcgbmF0aXZlU2V0KCk7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVByb21pc2UpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcGFyZW50LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlKF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJlamVjdChfY2xvbmUoZXJyLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IFtdO1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc1JlZ0V4cChwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBSZWdFeHAocGFyZW50LnNvdXJjZSwgX19nZXRSZWdFeHBGbGFncyhwYXJlbnQpKTtcbiAgICAgIGlmIChwYXJlbnQubGFzdEluZGV4KSBjaGlsZC5sYXN0SW5kZXggPSBwYXJlbnQubGFzdEluZGV4O1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc0RhdGUocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBuZXcgRGF0ZShwYXJlbnQuZ2V0VGltZSgpKTtcbiAgICB9IGVsc2UgaWYgKHVzZUJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIocGFyZW50KSkge1xuICAgICAgaWYgKEJ1ZmZlci5hbGxvY1Vuc2FmZSkge1xuICAgICAgICAvLyBOb2RlLmpzID49IDQuNS4wXG4gICAgICAgIGNoaWxkID0gQnVmZmVyLmFsbG9jVW5zYWZlKHBhcmVudC5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT2xkZXIgTm9kZS5qcyB2ZXJzaW9uc1xuICAgICAgICBjaGlsZCA9IG5ldyBCdWZmZXIocGFyZW50Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBwYXJlbnQuY29weShjaGlsZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIEVycm9yKSkge1xuICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmVudCk7XG4gICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICAgIHByb3RvID0gcHJvdG90eXBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaXJjdWxhcikge1xuICAgICAgdmFyIGluZGV4ID0gYWxsUGFyZW50cy5pbmRleE9mKHBhcmVudCk7XG5cbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICByZXR1cm4gYWxsQ2hpbGRyZW5baW5kZXhdO1xuICAgICAgfVxuICAgICAgYWxsUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICBhbGxDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVNYXApKSB7XG4gICAgICBwYXJlbnQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBrZXlDaGlsZCA9IF9jbG9uZShrZXksIGRlcHRoIC0gMSk7XG4gICAgICAgIHZhciB2YWx1ZUNoaWxkID0gX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpO1xuICAgICAgICBjaGlsZC5zZXQoa2V5Q2hpbGQsIHZhbHVlQ2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVNldCkpIHtcbiAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBlbnRyeUNoaWxkID0gX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpO1xuICAgICAgICBjaGlsZC5hZGQoZW50cnlDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpIGluIHBhcmVudCkge1xuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKHByb3RvKSB7XG4gICAgICAgIGF0dHJzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRycyAmJiBhdHRycy5zZXQgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkW2ldID0gX2Nsb25lKHBhcmVudFtpXSwgZGVwdGggLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHBhcmVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBjbG9uaW5nIGEgc3ltYm9sIGJlY2F1c2UgaXQgaXMgYSBwcmltaXRpdmUsXG4gICAgICAgIC8vIGxpa2UgYSBudW1iZXIgb3Igc3RyaW5nLlxuICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc1tpXTtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgc3ltYm9sKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZW51bWVyYWJsZSAmJiAhaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZFtzeW1ib2xdID0gX2Nsb25lKHBhcmVudFtzeW1ib2xdLCBkZXB0aCAtIDEpO1xuICAgICAgICBpZiAoIWRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgc3ltYm9sLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gICAgICB2YXIgYWxsUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhcmVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbFByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IGFsbFByb3BlcnR5TmFtZXNbaV07XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkW3Byb3BlcnR5TmFtZV0gPSBfY2xvbmUocGFyZW50W3Byb3BlcnR5TmFtZV0sIGRlcHRoIC0gMSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIF9jbG9uZShwYXJlbnQsIGRlcHRoKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgZmxhdCBjbG9uZSB1c2luZyBwcm90b3R5cGUsIGFjY2VwdHMgb25seSBvYmplY3RzLCB1c2VmdWxsIGZvciBwcm9wZXJ0eVxuICogb3ZlcnJpZGUgb24gRkxBVCBjb25maWd1cmF0aW9uIG9iamVjdCAobm8gbmVzdGVkIHByb3BzKS5cbiAqXG4gKiBVU0UgV0lUSCBDQVVUSU9OISBUaGlzIG1heSBub3QgYmVoYXZlIGFzIHlvdSB3aXNoIGlmIHlvdSBkbyBub3Qga25vdyBob3cgdGhpc1xuICogd29ya3MuXG4gKi9cbmNsb25lLmNsb25lUHJvdG90eXBlID0gZnVuY3Rpb24gY2xvbmVQcm90b3R5cGUocGFyZW50KSB7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgYy5wcm90b3R5cGUgPSBwYXJlbnQ7XG4gIHJldHVybiBuZXcgYygpO1xufTtcblxuLy8gcHJpdmF0ZSB1dGlsaXR5IGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBfX29ialRvU3RyKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbmNsb25lLl9fb2JqVG9TdHIgPSBfX29ialRvU3RyO1xuXG5mdW5jdGlvbiBfX2lzRGF0ZShvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuY2xvbmUuX19pc0RhdGUgPSBfX2lzRGF0ZTtcblxuZnVuY3Rpb24gX19pc0FycmF5KG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuY2xvbmUuX19pc0FycmF5ID0gX19pc0FycmF5O1xuXG5mdW5jdGlvbiBfX2lzUmVnRXhwKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmNsb25lLl9faXNSZWdFeHAgPSBfX2lzUmVnRXhwO1xuXG5mdW5jdGlvbiBfX2dldFJlZ0V4cEZsYWdzKHJlKSB7XG4gIHZhciBmbGFncyA9ICcnO1xuICBpZiAocmUuZ2xvYmFsKSBmbGFncyArPSAnZyc7XG4gIGlmIChyZS5pZ25vcmVDYXNlKSBmbGFncyArPSAnaSc7XG4gIGlmIChyZS5tdWx0aWxpbmUpIGZsYWdzICs9ICdtJztcbiAgcmV0dXJuIGZsYWdzO1xufVxuY2xvbmUuX19nZXRSZWdFeHBGbGFncyA9IF9fZ2V0UmVnRXhwRmxhZ3M7XG5cbnJldHVybiBjbG9uZTtcbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xufVxuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9lbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9lbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VtaXR0ZXIpO1xuXG52YXIgX2Jsb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9ibG9jazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ibG9jayk7XG5cbnZhciBfYnJlYWsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9icmVhazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icmVhayk7XG5cbnZhciBfY29kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX2NvZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29kZSk7XG5cbnZhciBfY29udGFpbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbnZhciBfY29udGFpbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRhaW5lcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gaXNMaW5lKGJsb3QpIHtcbiAgcmV0dXJuIGJsb3QgaW5zdGFuY2VvZiBfYmxvY2syLmRlZmF1bHQgfHwgYmxvdCBpbnN0YW5jZW9mIF9ibG9jay5CbG9ja0VtYmVkO1xufVxuXG52YXIgU2Nyb2xsID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkU2Nyb2xsKSB7XG4gIF9pbmhlcml0cyhTY3JvbGwsIF9QYXJjaG1lbnQkU2Nyb2xsKTtcblxuICBmdW5jdGlvbiBTY3JvbGwoZG9tTm9kZSwgY29uZmlnKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNjcm9sbCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2Nyb2xsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2Nyb2xsKSkuY2FsbCh0aGlzLCBkb21Ob2RlKSk7XG5cbiAgICBfdGhpcy5lbWl0dGVyID0gY29uZmlnLmVtaXR0ZXI7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLndoaXRlbGlzdCkpIHtcbiAgICAgIF90aGlzLndoaXRlbGlzdCA9IGNvbmZpZy53aGl0ZWxpc3QucmVkdWNlKGZ1bmN0aW9uICh3aGl0ZWxpc3QsIGZvcm1hdCkge1xuICAgICAgICB3aGl0ZWxpc3RbZm9ybWF0XSA9IHRydWU7XG4gICAgICAgIHJldHVybiB3aGl0ZWxpc3Q7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8vIFNvbWUgcmVhc29uIGZpeGVzIGNvbXBvc2l0aW9uIGlzc3VlcyB3aXRoIGNoYXJhY3RlciBsYW5ndWFnZXMgaW4gV2luZG93cy9DaHJvbWUsIFNhZmFyaVxuICAgIF90aGlzLmRvbU5vZGUuYWRkRXZlbnRMaXN0ZW5lcignRE9NTm9kZUluc2VydGVkJywgZnVuY3Rpb24gKCkge30pO1xuICAgIF90aGlzLm9wdGltaXplKCk7XG4gICAgX3RoaXMuZW5hYmxlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNjcm9sbCwgW3tcbiAgICBrZXk6ICdiYXRjaFN0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmF0Y2hTdGFydCgpIHtcbiAgICAgIHRoaXMuYmF0Y2ggPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2JhdGNoRW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmF0Y2hFbmQoKSB7XG4gICAgICB0aGlzLmJhdGNoID0gZmFsc2U7XG4gICAgICB0aGlzLm9wdGltaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlQXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVBdChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgX2xpbmUgPSB0aGlzLmxpbmUoaW5kZXgpLFxuICAgICAgICAgIF9saW5lMiA9IF9zbGljZWRUb0FycmF5KF9saW5lLCAyKSxcbiAgICAgICAgICBmaXJzdCA9IF9saW5lMlswXSxcbiAgICAgICAgICBvZmZzZXQgPSBfbGluZTJbMV07XG5cbiAgICAgIHZhciBfbGluZTMgPSB0aGlzLmxpbmUoaW5kZXggKyBsZW5ndGgpLFxuICAgICAgICAgIF9saW5lNCA9IF9zbGljZWRUb0FycmF5KF9saW5lMywgMSksXG4gICAgICAgICAgbGFzdCA9IF9saW5lNFswXTtcblxuICAgICAgX2dldChTY3JvbGwucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2Nyb2xsLnByb3RvdHlwZSksICdkZWxldGVBdCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICBpZiAobGFzdCAhPSBudWxsICYmIGZpcnN0ICE9PSBsYXN0ICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgX2Jsb2NrLkJsb2NrRW1iZWQgfHwgbGFzdCBpbnN0YW5jZW9mIF9ibG9jay5CbG9ja0VtYmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpbWl6ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBfY29kZTIuZGVmYXVsdCkge1xuICAgICAgICAgIHZhciBuZXdsaW5lSW5kZXggPSBmaXJzdC5uZXdsaW5lSW5kZXgoZmlyc3QubGVuZ3RoKCksIHRydWUpO1xuICAgICAgICAgIGlmIChuZXdsaW5lSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgZmlyc3QgPSBmaXJzdC5zcGxpdChuZXdsaW5lSW5kZXggKyAxKTtcbiAgICAgICAgICAgIGlmIChmaXJzdCA9PT0gbGFzdCkge1xuICAgICAgICAgICAgICB0aGlzLm9wdGltaXplKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdCBpbnN0YW5jZW9mIF9jb2RlMi5kZWZhdWx0KSB7XG4gICAgICAgICAgdmFyIF9uZXdsaW5lSW5kZXggPSBsYXN0Lm5ld2xpbmVJbmRleCgwKTtcbiAgICAgICAgICBpZiAoX25ld2xpbmVJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBsYXN0LnNwbGl0KF9uZXdsaW5lSW5kZXggKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZiA9IGxhc3QuY2hpbGRyZW4uaGVhZCBpbnN0YW5jZW9mIF9icmVhazIuZGVmYXVsdCA/IG51bGwgOiBsYXN0LmNoaWxkcmVuLmhlYWQ7XG4gICAgICAgIGZpcnN0Lm1vdmVDaGlsZHJlbihsYXN0LCByZWYpO1xuICAgICAgICBmaXJzdC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW1pemUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB2YXIgZW5hYmxlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcblxuICAgICAgdGhpcy5kb21Ob2RlLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgZW5hYmxlZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0QXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBmb3JtYXQsIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy53aGl0ZWxpc3QgIT0gbnVsbCAmJiAhdGhpcy53aGl0ZWxpc3RbZm9ybWF0XSkgcmV0dXJuO1xuICAgICAgX2dldChTY3JvbGwucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2Nyb2xsLnByb3RvdHlwZSksICdmb3JtYXRBdCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCwgZm9ybWF0LCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGltaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0QXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRBdChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgICAgaWYgKGRlZiAhPSBudWxsICYmIHRoaXMud2hpdGVsaXN0ICE9IG51bGwgJiYgIXRoaXMud2hpdGVsaXN0W3ZhbHVlXSkgcmV0dXJuO1xuICAgICAgaWYgKGluZGV4ID49IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgaWYgKGRlZiA9PSBudWxsIHx8IF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkodmFsdWUsIF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0spID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgYmxvdCA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKHRoaXMuc3RhdGljcy5kZWZhdWx0Q2hpbGQpO1xuICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoYmxvdCk7XG4gICAgICAgICAgaWYgKGRlZiA9PSBudWxsICYmIHZhbHVlLmVuZHNXaXRoKCdcXG4nKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJsb3QuaW5zZXJ0QXQoMCwgdmFsdWUsIGRlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVtYmVkID0gX3BhcmNobWVudDIuZGVmYXVsdC5jcmVhdGUodmFsdWUsIGRlZik7XG4gICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbWJlZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoU2Nyb2xsLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbC5wcm90b3R5cGUpLCAnaW5zZXJ0QXQnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCB2YWx1ZSwgZGVmKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW1pemUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRCZWZvcmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoYmxvdCwgcmVmKSB7XG4gICAgICBpZiAoYmxvdC5zdGF0aWNzLnNjb3BlID09PSBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLklOTElORV9CTE9UKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gX3BhcmNobWVudDIuZGVmYXVsdC5jcmVhdGUodGhpcy5zdGF0aWNzLmRlZmF1bHRDaGlsZCk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoYmxvdCk7XG4gICAgICAgIGJsb3QgPSB3cmFwcGVyO1xuICAgICAgfVxuICAgICAgX2dldChTY3JvbGwucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2Nyb2xsLnByb3RvdHlwZSksICdpbnNlcnRCZWZvcmUnLCB0aGlzKS5jYWxsKHRoaXMsIGJsb3QsIHJlZik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGVhZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlYWYoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGgoaW5kZXgpLnBvcCgpIHx8IFtudWxsLCAtMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGluZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmUoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lKGluZGV4IC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5kZXNjZW5kYW50KGlzTGluZSwgaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xpbmVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGluZXMoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICB2YXIgZ2V0TGluZXMgPSBmdW5jdGlvbiBnZXRMaW5lcyhibG90LCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IFtdLFxuICAgICAgICAgICAgbGVuZ3RoTGVmdCA9IGxlbmd0aDtcbiAgICAgICAgYmxvdC5jaGlsZHJlbi5mb3JFYWNoQXQoaW5kZXgsIGxlbmd0aCwgZnVuY3Rpb24gKGNoaWxkLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGlzTGluZShjaGlsZCkpIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goY2hpbGQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LkNvbnRhaW5lcikge1xuICAgICAgICAgICAgbGluZXMgPSBsaW5lcy5jb25jYXQoZ2V0TGluZXMoY2hpbGQsIGluZGV4LCBsZW5ndGhMZWZ0KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aExlZnQgLT0gbGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBnZXRMaW5lcyh0aGlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvcHRpbWl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKCkge1xuICAgICAgdmFyIG11dGF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGlmICh0aGlzLmJhdGNoID09PSB0cnVlKSByZXR1cm47XG4gICAgICBfZ2V0KFNjcm9sbC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY3JvbGwucHJvdG90eXBlKSwgJ29wdGltaXplJywgdGhpcykuY2FsbCh0aGlzLCBtdXRhdGlvbnMsIGNvbnRleHQpO1xuICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KF9lbWl0dGVyMi5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfT1BUSU1JWkUsIG11dGF0aW9ucywgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncGF0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGgoaW5kZXgpIHtcbiAgICAgIHJldHVybiBfZ2V0KFNjcm9sbC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY3JvbGwucHJvdG90eXBlKSwgJ3BhdGgnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4KS5zbGljZSgxKTsgLy8gRXhjbHVkZSBzZWxmXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKG11dGF0aW9ucykge1xuICAgICAgaWYgKHRoaXMuYmF0Y2ggPT09IHRydWUpIHJldHVybjtcbiAgICAgIHZhciBzb3VyY2UgPSBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlVTRVI7XG4gICAgICBpZiAodHlwZW9mIG11dGF0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc291cmNlID0gbXV0YXRpb25zO1xuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG11dGF0aW9ucykpIHtcbiAgICAgICAgbXV0YXRpb25zID0gdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgfVxuICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KF9lbWl0dGVyMi5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfQkVGT1JFX1VQREFURSwgc291cmNlLCBtdXRhdGlvbnMpO1xuICAgICAgfVxuICAgICAgX2dldChTY3JvbGwucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2Nyb2xsLnByb3RvdHlwZSksICd1cGRhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIG11dGF0aW9ucy5jb25jYXQoW10pKTsgLy8gcGFzcyBjb3B5XG4gICAgICBpZiAobXV0YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoX2VtaXR0ZXIyLmRlZmF1bHQuZXZlbnRzLlNDUk9MTF9VUERBVEUsIHNvdXJjZSwgbXV0YXRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2Nyb2xsO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LlNjcm9sbCk7XG5cblNjcm9sbC5ibG90TmFtZSA9ICdzY3JvbGwnO1xuU2Nyb2xsLmNsYXNzTmFtZSA9ICdxbC1lZGl0b3InO1xuU2Nyb2xsLnRhZ05hbWUgPSAnRElWJztcblNjcm9sbC5kZWZhdWx0Q2hpbGQgPSAnYmxvY2snO1xuU2Nyb2xsLmFsbG93ZWRDaGlsZHJlbiA9IFtfYmxvY2syLmRlZmF1bHQsIF9ibG9jay5CbG9ja0VtYmVkLCBfY29udGFpbmVyMi5kZWZhdWx0XTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU2Nyb2xsO1xuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlNIT1JUS0VZID0gZXhwb3J0cy5kZWZhdWx0ID0gdW5kZWZpbmVkO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jbG9uZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG52YXIgX2Nsb25lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb25lKTtcblxudmFyIF9kZWVwRXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9kZWVwRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVlcEVxdWFsKTtcblxudmFyIF9leHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2V4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmQpO1xuXG52YXIgX3F1aWxsRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3F1aWxsRGVsdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGxEZWx0YSk7XG5cbnZhciBfb3AgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxudmFyIF9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vcCk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9xdWlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfcXVpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGwpO1xuXG52YXIgX2xvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG52YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRlYnVnID0gKDAsIF9sb2dnZXIyLmRlZmF1bHQpKCdxdWlsbDprZXlib2FyZCcpO1xuXG52YXIgU0hPUlRLRVkgPSAvTWFjL2kudGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pID8gJ21ldGFLZXknIDogJ2N0cmxLZXknO1xuXG52YXIgS2V5Ym9hcmQgPSBmdW5jdGlvbiAoX01vZHVsZSkge1xuICBfaW5oZXJpdHMoS2V5Ym9hcmQsIF9Nb2R1bGUpO1xuXG4gIF9jcmVhdGVDbGFzcyhLZXlib2FyZCwgbnVsbCwgW3tcbiAgICBrZXk6ICdtYXRjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKGV2dCwgYmluZGluZykge1xuICAgICAgYmluZGluZyA9IG5vcm1hbGl6ZShiaW5kaW5nKTtcbiAgICAgIGlmIChbJ2FsdEtleScsICdjdHJsS2V5JywgJ21ldGFLZXknLCAnc2hpZnRLZXknXS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhYmluZGluZ1trZXldICE9PSBldnRba2V5XSAmJiBiaW5kaW5nW2tleV0gIT09IG51bGw7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmluZGluZy5rZXkgPT09IChldnQud2hpY2ggfHwgZXZ0LmtleUNvZGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIEtleWJvYXJkKHF1aWxsLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtleWJvYXJkKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChLZXlib2FyZC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEtleWJvYXJkKSkuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuYmluZGluZ3MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfdGhpcy5vcHRpb25zLmJpbmRpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAobmFtZSA9PT0gJ2xpc3QgYXV0b2ZpbGwnICYmIHF1aWxsLnNjcm9sbC53aGl0ZWxpc3QgIT0gbnVsbCAmJiAhcXVpbGwuc2Nyb2xsLndoaXRlbGlzdFsnbGlzdCddKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLmJpbmRpbmdzW25hbWVdKSB7XG4gICAgICAgIF90aGlzLmFkZEJpbmRpbmcoX3RoaXMub3B0aW9ucy5iaW5kaW5nc1tuYW1lXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RoaXMuYWRkQmluZGluZyh7IGtleTogS2V5Ym9hcmQua2V5cy5FTlRFUiwgc2hpZnRLZXk6IG51bGwgfSwgaGFuZGxlRW50ZXIpO1xuICAgIF90aGlzLmFkZEJpbmRpbmcoeyBrZXk6IEtleWJvYXJkLmtleXMuRU5URVIsIG1ldGFLZXk6IG51bGwsIGN0cmxLZXk6IG51bGwsIGFsdEtleTogbnVsbCB9LCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgaWYgKC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgLy8gTmVlZCB0byBoYW5kbGUgZGVsZXRlIGFuZCBiYWNrc3BhY2UgZm9yIEZpcmVmb3ggaW4gdGhlIGdlbmVyYWwgY2FzZSAjMTE3MVxuICAgICAgX3RoaXMuYWRkQmluZGluZyh7IGtleTogS2V5Ym9hcmQua2V5cy5CQUNLU1BBQ0UgfSwgeyBjb2xsYXBzZWQ6IHRydWUgfSwgaGFuZGxlQmFja3NwYWNlKTtcbiAgICAgIF90aGlzLmFkZEJpbmRpbmcoeyBrZXk6IEtleWJvYXJkLmtleXMuREVMRVRFIH0sIHsgY29sbGFwc2VkOiB0cnVlIH0sIGhhbmRsZURlbGV0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmFkZEJpbmRpbmcoeyBrZXk6IEtleWJvYXJkLmtleXMuQkFDS1NQQUNFIH0sIHsgY29sbGFwc2VkOiB0cnVlLCBwcmVmaXg6IC9eLj8kLyB9LCBoYW5kbGVCYWNrc3BhY2UpO1xuICAgICAgX3RoaXMuYWRkQmluZGluZyh7IGtleTogS2V5Ym9hcmQua2V5cy5ERUxFVEUgfSwgeyBjb2xsYXBzZWQ6IHRydWUsIHN1ZmZpeDogL14uPyQvIH0sIGhhbmRsZURlbGV0ZSk7XG4gICAgfVxuICAgIF90aGlzLmFkZEJpbmRpbmcoeyBrZXk6IEtleWJvYXJkLmtleXMuQkFDS1NQQUNFIH0sIHsgY29sbGFwc2VkOiBmYWxzZSB9LCBoYW5kbGVEZWxldGVSYW5nZSk7XG4gICAgX3RoaXMuYWRkQmluZGluZyh7IGtleTogS2V5Ym9hcmQua2V5cy5ERUxFVEUgfSwgeyBjb2xsYXBzZWQ6IGZhbHNlIH0sIGhhbmRsZURlbGV0ZVJhbmdlKTtcbiAgICBfdGhpcy5hZGRCaW5kaW5nKHsga2V5OiBLZXlib2FyZC5rZXlzLkJBQ0tTUEFDRSwgYWx0S2V5OiBudWxsLCBjdHJsS2V5OiBudWxsLCBtZXRhS2V5OiBudWxsLCBzaGlmdEtleTogbnVsbCB9LCB7IGNvbGxhcHNlZDogdHJ1ZSwgb2Zmc2V0OiAwIH0sIGhhbmRsZUJhY2tzcGFjZSk7XG4gICAgX3RoaXMubGlzdGVuKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEtleWJvYXJkLCBbe1xuICAgIGtleTogJ2FkZEJpbmRpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRCaW5kaW5nKGtleSkge1xuICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGhhbmRsZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICB2YXIgYmluZGluZyA9IG5vcm1hbGl6ZShrZXkpO1xuICAgICAgaWYgKGJpbmRpbmcgPT0gbnVsbCB8fCBiaW5kaW5nLmtleSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWJ1Zy53YXJuKCdBdHRlbXB0ZWQgdG8gYWRkIGludmFsaWQga2V5Ym9hcmQgYmluZGluZycsIGJpbmRpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnRleHQgPSB7IGhhbmRsZXI6IGNvbnRleHQgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoYW5kbGVyID0geyBoYW5kbGVyOiBoYW5kbGVyIH07XG4gICAgICB9XG4gICAgICBiaW5kaW5nID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKGJpbmRpbmcsIGNvbnRleHQsIGhhbmRsZXIpO1xuICAgICAgdGhpcy5iaW5kaW5nc1tiaW5kaW5nLmtleV0gPSB0aGlzLmJpbmRpbmdzW2JpbmRpbmcua2V5XSB8fCBbXTtcbiAgICAgIHRoaXMuYmluZGluZ3NbYmluZGluZy5rZXldLnB1c2goYmluZGluZyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGlzdGVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMucXVpbGwucm9vdC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBpZiAoZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgICAgdmFyIHdoaWNoID0gZXZ0LndoaWNoIHx8IGV2dC5rZXlDb2RlO1xuICAgICAgICB2YXIgYmluZGluZ3MgPSAoX3RoaXMyLmJpbmRpbmdzW3doaWNoXSB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIEtleWJvYXJkLm1hdGNoKGV2dCwgYmluZGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYmluZGluZ3MubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHZhciByYW5nZSA9IF90aGlzMi5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHJhbmdlID09IG51bGwgfHwgIV90aGlzMi5xdWlsbC5oYXNGb2N1cygpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIF9xdWlsbCRnZXRMaW5lID0gX3RoaXMyLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgICAgX3F1aWxsJGdldExpbmUyID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmUsIDIpLFxuICAgICAgICAgICAgbGluZSA9IF9xdWlsbCRnZXRMaW5lMlswXSxcbiAgICAgICAgICAgIG9mZnNldCA9IF9xdWlsbCRnZXRMaW5lMlsxXTtcblxuICAgICAgICB2YXIgX3F1aWxsJGdldExlYWYgPSBfdGhpczIucXVpbGwuZ2V0TGVhZihyYW5nZS5pbmRleCksXG4gICAgICAgICAgICBfcXVpbGwkZ2V0TGVhZjIgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkZ2V0TGVhZiwgMiksXG4gICAgICAgICAgICBsZWFmU3RhcnQgPSBfcXVpbGwkZ2V0TGVhZjJbMF0sXG4gICAgICAgICAgICBvZmZzZXRTdGFydCA9IF9xdWlsbCRnZXRMZWFmMlsxXTtcblxuICAgICAgICB2YXIgX3JlZiA9IHJhbmdlLmxlbmd0aCA9PT0gMCA/IFtsZWFmU3RhcnQsIG9mZnNldFN0YXJ0XSA6IF90aGlzMi5xdWlsbC5nZXRMZWFmKHJhbmdlLmluZGV4ICsgcmFuZ2UubGVuZ3RoKSxcbiAgICAgICAgICAgIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICBsZWFmRW5kID0gX3JlZjJbMF0sXG4gICAgICAgICAgICBvZmZzZXRFbmQgPSBfcmVmMlsxXTtcblxuICAgICAgICB2YXIgcHJlZml4VGV4dCA9IGxlYWZTdGFydCBpbnN0YW5jZW9mIF9wYXJjaG1lbnQyLmRlZmF1bHQuVGV4dCA/IGxlYWZTdGFydC52YWx1ZSgpLnNsaWNlKDAsIG9mZnNldFN0YXJ0KSA6ICcnO1xuICAgICAgICB2YXIgc3VmZml4VGV4dCA9IGxlYWZFbmQgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LlRleHQgPyBsZWFmRW5kLnZhbHVlKCkuc2xpY2Uob2Zmc2V0RW5kKSA6ICcnO1xuICAgICAgICB2YXIgY3VyQ29udGV4dCA9IHtcbiAgICAgICAgICBjb2xsYXBzZWQ6IHJhbmdlLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgICBlbXB0eTogcmFuZ2UubGVuZ3RoID09PSAwICYmIGxpbmUubGVuZ3RoKCkgPD0gMSxcbiAgICAgICAgICBmb3JtYXQ6IF90aGlzMi5xdWlsbC5nZXRGb3JtYXQocmFuZ2UpLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgIHByZWZpeDogcHJlZml4VGV4dCxcbiAgICAgICAgICBzdWZmaXg6IHN1ZmZpeFRleHRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHByZXZlbnRlZCA9IGJpbmRpbmdzLnNvbWUoZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICBpZiAoYmluZGluZy5jb2xsYXBzZWQgIT0gbnVsbCAmJiBiaW5kaW5nLmNvbGxhcHNlZCAhPT0gY3VyQ29udGV4dC5jb2xsYXBzZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAoYmluZGluZy5lbXB0eSAhPSBudWxsICYmIGJpbmRpbmcuZW1wdHkgIT09IGN1ckNvbnRleHQuZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAoYmluZGluZy5vZmZzZXQgIT0gbnVsbCAmJiBiaW5kaW5nLm9mZnNldCAhPT0gY3VyQ29udGV4dC5vZmZzZXQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIC8vIGFueSBmb3JtYXQgaXMgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGJpbmRpbmcuZm9ybWF0LmV2ZXJ5KGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjdXJDb250ZXh0LmZvcm1hdFtuYW1lXSA9PSBudWxsO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihiaW5kaW5nLmZvcm1hdCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBhbGwgZm9ybWF0cyBtdXN0IG1hdGNoXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGJpbmRpbmcuZm9ybWF0KS5ldmVyeShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICBpZiAoYmluZGluZy5mb3JtYXRbbmFtZV0gPT09IHRydWUpIHJldHVybiBjdXJDb250ZXh0LmZvcm1hdFtuYW1lXSAhPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoYmluZGluZy5mb3JtYXRbbmFtZV0gPT09IGZhbHNlKSByZXR1cm4gY3VyQ29udGV4dC5mb3JtYXRbbmFtZV0gPT0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBfZGVlcEVxdWFsMi5kZWZhdWx0KShiaW5kaW5nLmZvcm1hdFtuYW1lXSwgY3VyQ29udGV4dC5mb3JtYXRbbmFtZV0pO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmluZGluZy5wcmVmaXggIT0gbnVsbCAmJiAhYmluZGluZy5wcmVmaXgudGVzdChjdXJDb250ZXh0LnByZWZpeCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAoYmluZGluZy5zdWZmaXggIT0gbnVsbCAmJiAhYmluZGluZy5zdWZmaXgudGVzdChjdXJDb250ZXh0LnN1ZmZpeCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gYmluZGluZy5oYW5kbGVyLmNhbGwoX3RoaXMyLCByYW5nZSwgY3VyQ29udGV4dCkgIT09IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJldmVudGVkKSB7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBLZXlib2FyZDtcbn0oX21vZHVsZTIuZGVmYXVsdCk7XG5cbktleWJvYXJkLmtleXMgPSB7XG4gIEJBQ0tTUEFDRTogOCxcbiAgVEFCOiA5LFxuICBFTlRFUjogMTMsXG4gIEVTQ0FQRTogMjcsXG4gIExFRlQ6IDM3LFxuICBVUDogMzgsXG4gIFJJR0hUOiAzOSxcbiAgRE9XTjogNDAsXG4gIERFTEVURTogNDZcbn07XG5cbktleWJvYXJkLkRFRkFVTFRTID0ge1xuICBiaW5kaW5nczoge1xuICAgICdib2xkJzogbWFrZUZvcm1hdEhhbmRsZXIoJ2JvbGQnKSxcbiAgICAnaXRhbGljJzogbWFrZUZvcm1hdEhhbmRsZXIoJ2l0YWxpYycpLFxuICAgICd1bmRlcmxpbmUnOiBtYWtlRm9ybWF0SGFuZGxlcigndW5kZXJsaW5lJyksXG4gICAgJ2luZGVudCc6IHtcbiAgICAgIC8vIGhpZ2hsaWdodCB0YWIgb3IgdGFiIGF0IGJlZ2lubmluZyBvZiBsaXN0LCBpbmRlbnQgb3IgYmxvY2txdW90ZVxuICAgICAga2V5OiBLZXlib2FyZC5rZXlzLlRBQixcbiAgICAgIGZvcm1hdDogWydibG9ja3F1b3RlJywgJ2luZGVudCcsICdsaXN0J10sXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNvbGxhcHNlZCAmJiBjb250ZXh0Lm9mZnNldCAhPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdpbmRlbnQnLCAnKzEnLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdvdXRkZW50Jzoge1xuICAgICAga2V5OiBLZXlib2FyZC5rZXlzLlRBQixcbiAgICAgIHNoaWZ0S2V5OiB0cnVlLFxuICAgICAgZm9ybWF0OiBbJ2Jsb2NrcXVvdGUnLCAnaW5kZW50JywgJ2xpc3QnXSxcbiAgICAgIC8vIGhpZ2hsaWdodCB0YWIgb3IgdGFiIGF0IGJlZ2lubmluZyBvZiBsaXN0LCBpbmRlbnQgb3IgYmxvY2txdW90ZVxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5jb2xsYXBzZWQgJiYgY29udGV4dC5vZmZzZXQgIT09IDApIHJldHVybiB0cnVlO1xuICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnaW5kZW50JywgJy0xJywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfSxcbiAgICAnb3V0ZGVudCBiYWNrc3BhY2UnOiB7XG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuQkFDS1NQQUNFLFxuICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgc2hpZnRLZXk6IG51bGwsXG4gICAgICBtZXRhS2V5OiBudWxsLFxuICAgICAgY3RybEtleTogbnVsbCxcbiAgICAgIGFsdEtleTogbnVsbCxcbiAgICAgIGZvcm1hdDogWydpbmRlbnQnLCAnbGlzdCddLFxuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5mb3JtYXQuaW5kZW50ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnaW5kZW50JywgJy0xJywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5mb3JtYXQubGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2xpc3QnLCBmYWxzZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdpbmRlbnQgY29kZS1ibG9jayc6IG1ha2VDb2RlQmxvY2tIYW5kbGVyKHRydWUpLFxuICAgICdvdXRkZW50IGNvZGUtYmxvY2snOiBtYWtlQ29kZUJsb2NrSGFuZGxlcihmYWxzZSksXG4gICAgJ3JlbW92ZSB0YWInOiB7XG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuVEFCLFxuICAgICAgc2hpZnRLZXk6IHRydWUsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBwcmVmaXg6IC9cXHQkLyxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5kZWxldGVUZXh0KHJhbmdlLmluZGV4IC0gMSwgMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfSxcbiAgICAndGFiJzoge1xuICAgICAga2V5OiBLZXlib2FyZC5rZXlzLlRBQixcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5oaXN0b3J5LmN1dG9mZigpO1xuICAgICAgICB2YXIgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpLmRlbGV0ZShyYW5nZS5sZW5ndGgpLmluc2VydCgnXFx0Jyk7XG4gICAgICAgIHRoaXMucXVpbGwudXBkYXRlQ29udGVudHMoZGVsdGEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB0aGlzLnF1aWxsLmhpc3RvcnkuY3V0b2ZmKCk7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdsaXN0IGVtcHR5IGVudGVyJzoge1xuICAgICAga2V5OiBLZXlib2FyZC5rZXlzLkVOVEVSLFxuICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgZm9ybWF0OiBbJ2xpc3QnXSxcbiAgICAgIGVtcHR5OiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGlzdCcsIGZhbHNlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgaWYgKGNvbnRleHQuZm9ybWF0LmluZGVudCkge1xuICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdpbmRlbnQnLCBmYWxzZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdjaGVja2xpc3QgZW50ZXInOiB7XG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuRU5URVIsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBmb3JtYXQ6IHsgbGlzdDogJ2NoZWNrZWQnIH0sXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlKSB7XG4gICAgICAgIHZhciBfcXVpbGwkZ2V0TGluZTMgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgICAgX3F1aWxsJGdldExpbmU0ID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmUzLCAyKSxcbiAgICAgICAgICAgIGxpbmUgPSBfcXVpbGwkZ2V0TGluZTRbMF0sXG4gICAgICAgICAgICBvZmZzZXQgPSBfcXVpbGwkZ2V0TGluZTRbMV07XG5cbiAgICAgICAgdmFyIGZvcm1hdHMgPSAoMCwgX2V4dGVuZDIuZGVmYXVsdCkoe30sIGxpbmUuZm9ybWF0cygpLCB7IGxpc3Q6ICdjaGVja2VkJyB9KTtcbiAgICAgICAgdmFyIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKHJhbmdlLmluZGV4KS5pbnNlcnQoJ1xcbicsIGZvcm1hdHMpLnJldGFpbihsaW5lLmxlbmd0aCgpIC0gb2Zmc2V0IC0gMSkucmV0YWluKDEsIHsgbGlzdDogJ3VuY2hlY2tlZCcgfSk7XG4gICAgICAgIHRoaXMucXVpbGwudXBkYXRlQ29udGVudHMoZGVsdGEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCArIDEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICAgIHRoaXMucXVpbGwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdoZWFkZXIgZW50ZXInOiB7XG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuRU5URVIsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBmb3JtYXQ6IFsnaGVhZGVyJ10sXG4gICAgICBzdWZmaXg6IC9eJC8sXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfcXVpbGwkZ2V0TGluZTUgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgICAgX3F1aWxsJGdldExpbmU2ID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmU1LCAyKSxcbiAgICAgICAgICAgIGxpbmUgPSBfcXVpbGwkZ2V0TGluZTZbMF0sXG4gICAgICAgICAgICBvZmZzZXQgPSBfcXVpbGwkZ2V0TGluZTZbMV07XG5cbiAgICAgICAgdmFyIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKHJhbmdlLmluZGV4KS5pbnNlcnQoJ1xcbicsIGNvbnRleHQuZm9ybWF0KS5yZXRhaW4obGluZS5sZW5ndGgoKSAtIG9mZnNldCAtIDEpLnJldGFpbigxLCB7IGhlYWRlcjogbnVsbCB9KTtcbiAgICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgICAgdGhpcy5xdWlsbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2xpc3QgYXV0b2ZpbGwnOiB7XG4gICAgICBrZXk6ICcgJyxcbiAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICAgIGZvcm1hdDogeyBsaXN0OiBmYWxzZSB9LFxuICAgICAgcHJlZml4OiAvXlxccyo/KFxcZCtcXC58LXxcXCp8XFxbID9cXF18XFxbeFxcXSkkLyxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbnRleHQucHJlZml4Lmxlbmd0aDtcblxuICAgICAgICB2YXIgX3F1aWxsJGdldExpbmU3ID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgIF9xdWlsbCRnZXRMaW5lOCA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMaW5lNywgMiksXG4gICAgICAgICAgICBsaW5lID0gX3F1aWxsJGdldExpbmU4WzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3F1aWxsJGdldExpbmU4WzFdO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPiBsZW5ndGgpIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIHN3aXRjaCAoY29udGV4dC5wcmVmaXgudHJpbSgpKSB7XG4gICAgICAgICAgY2FzZSAnW10nOmNhc2UgJ1sgXSc6XG4gICAgICAgICAgICB2YWx1ZSA9ICd1bmNoZWNrZWQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnW3hdJzpcbiAgICAgICAgICAgIHZhbHVlID0gJ2NoZWNrZWQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnLSc6Y2FzZSAnKic6XG4gICAgICAgICAgICB2YWx1ZSA9ICdidWxsZXQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhbHVlID0gJ29yZGVyZWQnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVpbGwuaW5zZXJ0VGV4dChyYW5nZS5pbmRleCwgJyAnLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgdGhpcy5xdWlsbC5oaXN0b3J5LmN1dG9mZigpO1xuICAgICAgICB2YXIgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4ocmFuZ2UuaW5kZXggLSBvZmZzZXQpLmRlbGV0ZShsZW5ndGggKyAxKS5yZXRhaW4obGluZS5sZW5ndGgoKSAtIDIgLSBvZmZzZXQpLnJldGFpbigxLCB7IGxpc3Q6IHZhbHVlIH0pO1xuICAgICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgdGhpcy5xdWlsbC5oaXN0b3J5LmN1dG9mZigpO1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCAtIGxlbmd0aCwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdjb2RlIGV4aXQnOiB7XG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuRU5URVIsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBmb3JtYXQ6IFsnY29kZS1ibG9jayddLFxuICAgICAgcHJlZml4OiAvXFxuXFxuJC8sXG4gICAgICBzdWZmaXg6IC9eXFxzKyQvLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSkge1xuICAgICAgICB2YXIgX3F1aWxsJGdldExpbmU5ID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgIF9xdWlsbCRnZXRMaW5lMTAgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkZ2V0TGluZTksIDIpLFxuICAgICAgICAgICAgbGluZSA9IF9xdWlsbCRnZXRMaW5lMTBbMF0sXG4gICAgICAgICAgICBvZmZzZXQgPSBfcXVpbGwkZ2V0TGluZTEwWzFdO1xuXG4gICAgICAgIHZhciBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihyYW5nZS5pbmRleCArIGxpbmUubGVuZ3RoKCkgLSBvZmZzZXQgLSAyKS5yZXRhaW4oMSwgeyAnY29kZS1ibG9jayc6IG51bGwgfSkuZGVsZXRlKDEpO1xuICAgICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdlbWJlZCBsZWZ0JzogbWFrZUVtYmVkQXJyb3dIYW5kbGVyKEtleWJvYXJkLmtleXMuTEVGVCwgZmFsc2UpLFxuICAgICdlbWJlZCBsZWZ0IHNoaWZ0JzogbWFrZUVtYmVkQXJyb3dIYW5kbGVyKEtleWJvYXJkLmtleXMuTEVGVCwgdHJ1ZSksXG4gICAgJ2VtYmVkIHJpZ2h0JzogbWFrZUVtYmVkQXJyb3dIYW5kbGVyKEtleWJvYXJkLmtleXMuUklHSFQsIGZhbHNlKSxcbiAgICAnZW1iZWQgcmlnaHQgc2hpZnQnOiBtYWtlRW1iZWRBcnJvd0hhbmRsZXIoS2V5Ym9hcmQua2V5cy5SSUdIVCwgdHJ1ZSlcbiAgfVxufTtcblxuZnVuY3Rpb24gbWFrZUVtYmVkQXJyb3dIYW5kbGVyKGtleSwgc2hpZnRLZXkpIHtcbiAgdmFyIF9yZWYzO1xuXG4gIHZhciB3aGVyZSA9IGtleSA9PT0gS2V5Ym9hcmQua2V5cy5MRUZUID8gJ3ByZWZpeCcgOiAnc3VmZml4JztcbiAgcmV0dXJuIF9yZWYzID0ge1xuICAgIGtleToga2V5LFxuICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICBhbHRLZXk6IG51bGxcbiAgfSwgX2RlZmluZVByb3BlcnR5KF9yZWYzLCB3aGVyZSwgL14kLyksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMywgJ2hhbmRsZXInLCBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlKSB7XG4gICAgdmFyIGluZGV4ID0gcmFuZ2UuaW5kZXg7XG4gICAgaWYgKGtleSA9PT0gS2V5Ym9hcmQua2V5cy5SSUdIVCkge1xuICAgICAgaW5kZXggKz0gcmFuZ2UubGVuZ3RoICsgMTtcbiAgICB9XG5cbiAgICB2YXIgX3F1aWxsJGdldExlYWYzID0gdGhpcy5xdWlsbC5nZXRMZWFmKGluZGV4KSxcbiAgICAgICAgX3F1aWxsJGdldExlYWY0ID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExlYWYzLCAxKSxcbiAgICAgICAgbGVhZiA9IF9xdWlsbCRnZXRMZWFmNFswXTtcblxuICAgIGlmICghKGxlYWYgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGtleSA9PT0gS2V5Ym9hcmQua2V5cy5MRUZUKSB7XG4gICAgICBpZiAoc2hpZnRLZXkpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggLSAxLCByYW5nZS5sZW5ndGggKyAxLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4IC0gMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzaGlmdEtleSkge1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCwgcmFuZ2UubGVuZ3RoICsgMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCArIHJhbmdlLmxlbmd0aCArIDEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pLCBfcmVmMztcbn1cblxuZnVuY3Rpb24gaGFuZGxlQmFja3NwYWNlKHJhbmdlLCBjb250ZXh0KSB7XG4gIGlmIChyYW5nZS5pbmRleCA9PT0gMCB8fCB0aGlzLnF1aWxsLmdldExlbmd0aCgpIDw9IDEpIHJldHVybjtcblxuICB2YXIgX3F1aWxsJGdldExpbmUxMSA9IHRoaXMucXVpbGwuZ2V0TGluZShyYW5nZS5pbmRleCksXG4gICAgICBfcXVpbGwkZ2V0TGluZTEyID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmUxMSwgMSksXG4gICAgICBsaW5lID0gX3F1aWxsJGdldExpbmUxMlswXTtcblxuICB2YXIgZm9ybWF0cyA9IHt9O1xuICBpZiAoY29udGV4dC5vZmZzZXQgPT09IDApIHtcbiAgICB2YXIgX3F1aWxsJGdldExpbmUxMyA9IHRoaXMucXVpbGwuZ2V0TGluZShyYW5nZS5pbmRleCAtIDEpLFxuICAgICAgICBfcXVpbGwkZ2V0TGluZTE0ID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmUxMywgMSksXG4gICAgICAgIHByZXYgPSBfcXVpbGwkZ2V0TGluZTE0WzBdO1xuXG4gICAgaWYgKHByZXYgIT0gbnVsbCAmJiBwcmV2Lmxlbmd0aCgpID4gMSkge1xuICAgICAgdmFyIGN1ckZvcm1hdHMgPSBsaW5lLmZvcm1hdHMoKTtcbiAgICAgIHZhciBwcmV2Rm9ybWF0cyA9IHRoaXMucXVpbGwuZ2V0Rm9ybWF0KHJhbmdlLmluZGV4IC0gMSwgMSk7XG4gICAgICBmb3JtYXRzID0gX29wMi5kZWZhdWx0LmF0dHJpYnV0ZXMuZGlmZihjdXJGb3JtYXRzLCBwcmV2Rm9ybWF0cykgfHwge307XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBhc3RyYWwgc3ltYm9sc1xuICB2YXIgbGVuZ3RoID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0kLy50ZXN0KGNvbnRleHQucHJlZml4KSA/IDIgOiAxO1xuICB0aGlzLnF1aWxsLmRlbGV0ZVRleHQocmFuZ2UuaW5kZXggLSBsZW5ndGgsIGxlbmd0aCwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gIGlmIChPYmplY3Qua2V5cyhmb3JtYXRzKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5xdWlsbC5mb3JtYXRMaW5lKHJhbmdlLmluZGV4IC0gbGVuZ3RoLCBsZW5ndGgsIGZvcm1hdHMsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICB9XG4gIHRoaXMucXVpbGwuZm9jdXMoKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRGVsZXRlKHJhbmdlLCBjb250ZXh0KSB7XG4gIC8vIENoZWNrIGZvciBhc3RyYWwgc3ltYm9sc1xuICB2YXIgbGVuZ3RoID0gL15bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdLy50ZXN0KGNvbnRleHQuc3VmZml4KSA/IDIgOiAxO1xuICBpZiAocmFuZ2UuaW5kZXggPj0gdGhpcy5xdWlsbC5nZXRMZW5ndGgoKSAtIGxlbmd0aCkgcmV0dXJuO1xuICB2YXIgZm9ybWF0cyA9IHt9LFxuICAgICAgbmV4dExlbmd0aCA9IDA7XG5cbiAgdmFyIF9xdWlsbCRnZXRMaW5lMTUgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgX3F1aWxsJGdldExpbmUxNiA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMaW5lMTUsIDEpLFxuICAgICAgbGluZSA9IF9xdWlsbCRnZXRMaW5lMTZbMF07XG5cbiAgaWYgKGNvbnRleHQub2Zmc2V0ID49IGxpbmUubGVuZ3RoKCkgLSAxKSB7XG4gICAgdmFyIF9xdWlsbCRnZXRMaW5lMTcgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXggKyAxKSxcbiAgICAgICAgX3F1aWxsJGdldExpbmUxOCA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMaW5lMTcsIDEpLFxuICAgICAgICBuZXh0ID0gX3F1aWxsJGdldExpbmUxOFswXTtcblxuICAgIGlmIChuZXh0KSB7XG4gICAgICB2YXIgY3VyRm9ybWF0cyA9IGxpbmUuZm9ybWF0cygpO1xuICAgICAgdmFyIG5leHRGb3JtYXRzID0gdGhpcy5xdWlsbC5nZXRGb3JtYXQocmFuZ2UuaW5kZXgsIDEpO1xuICAgICAgZm9ybWF0cyA9IF9vcDIuZGVmYXVsdC5hdHRyaWJ1dGVzLmRpZmYoY3VyRm9ybWF0cywgbmV4dEZvcm1hdHMpIHx8IHt9O1xuICAgICAgbmV4dExlbmd0aCA9IG5leHQubGVuZ3RoKCk7XG4gICAgfVxuICB9XG4gIHRoaXMucXVpbGwuZGVsZXRlVGV4dChyYW5nZS5pbmRleCwgbGVuZ3RoLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgaWYgKE9iamVjdC5rZXlzKGZvcm1hdHMpLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLnF1aWxsLmZvcm1hdExpbmUocmFuZ2UuaW5kZXggKyBuZXh0TGVuZ3RoIC0gMSwgbGVuZ3RoLCBmb3JtYXRzLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVEZWxldGVSYW5nZShyYW5nZSkge1xuICB2YXIgbGluZXMgPSB0aGlzLnF1aWxsLmdldExpbmVzKHJhbmdlKTtcbiAgdmFyIGZvcm1hdHMgPSB7fTtcbiAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgZmlyc3RGb3JtYXRzID0gbGluZXNbMF0uZm9ybWF0cygpO1xuICAgIHZhciBsYXN0Rm9ybWF0cyA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmZvcm1hdHMoKTtcbiAgICBmb3JtYXRzID0gX29wMi5kZWZhdWx0LmF0dHJpYnV0ZXMuZGlmZihsYXN0Rm9ybWF0cywgZmlyc3RGb3JtYXRzKSB8fCB7fTtcbiAgfVxuICB0aGlzLnF1aWxsLmRlbGV0ZVRleHQocmFuZ2UsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICBpZiAoT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID4gMCkge1xuICAgIHRoaXMucXVpbGwuZm9ybWF0TGluZShyYW5nZS5pbmRleCwgMSwgZm9ybWF0cywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gIH1cbiAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXgsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gIHRoaXMucXVpbGwuZm9jdXMoKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRW50ZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgaWYgKHJhbmdlLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLnF1aWxsLnNjcm9sbC5kZWxldGVBdChyYW5nZS5pbmRleCwgcmFuZ2UubGVuZ3RoKTsgLy8gU28gd2UgZG8gbm90IHRyaWdnZXIgdGV4dC1jaGFuZ2VcbiAgfVxuICB2YXIgbGluZUZvcm1hdHMgPSBPYmplY3Qua2V5cyhjb250ZXh0LmZvcm1hdCkucmVkdWNlKGZ1bmN0aW9uIChsaW5lRm9ybWF0cywgZm9ybWF0KSB7XG4gICAgaWYgKF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkoZm9ybWF0LCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLKSAmJiAhQXJyYXkuaXNBcnJheShjb250ZXh0LmZvcm1hdFtmb3JtYXRdKSkge1xuICAgICAgbGluZUZvcm1hdHNbZm9ybWF0XSA9IGNvbnRleHQuZm9ybWF0W2Zvcm1hdF07XG4gICAgfVxuICAgIHJldHVybiBsaW5lRm9ybWF0cztcbiAgfSwge30pO1xuICB0aGlzLnF1aWxsLmluc2VydFRleHQocmFuZ2UuaW5kZXgsICdcXG4nLCBsaW5lRm9ybWF0cywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gIC8vIEVhcmxpZXIgc2Nyb2xsLmRlbGV0ZUF0IG1pZ2h0IGhhdmUgbWVzc2VkIHVwIG91ciBzZWxlY3Rpb24sXG4gIC8vIHNvIGluc2VydFRleHQncyBidWlsdCBpbiBzZWxlY3Rpb24gcHJlc2VydmF0aW9uIGlzIG5vdCByZWxpYWJsZVxuICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCArIDEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gIHRoaXMucXVpbGwuZm9jdXMoKTtcbiAgT2JqZWN0LmtleXMoY29udGV4dC5mb3JtYXQpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobGluZUZvcm1hdHNbbmFtZV0gIT0gbnVsbCkgcmV0dXJuO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRleHQuZm9ybWF0W25hbWVdKSkgcmV0dXJuO1xuICAgIGlmIChuYW1lID09PSAnbGluaycpIHJldHVybjtcbiAgICBfdGhpczMucXVpbGwuZm9ybWF0KG5hbWUsIGNvbnRleHQuZm9ybWF0W25hbWVdLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VDb2RlQmxvY2tIYW5kbGVyKGluZGVudCkge1xuICByZXR1cm4ge1xuICAgIGtleTogS2V5Ym9hcmQua2V5cy5UQUIsXG4gICAgc2hpZnRLZXk6ICFpbmRlbnQsXG4gICAgZm9ybWF0OiB7ICdjb2RlLWJsb2NrJzogdHJ1ZSB9LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UpIHtcbiAgICAgIHZhciBDb2RlQmxvY2sgPSBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KCdjb2RlLWJsb2NrJyk7XG4gICAgICB2YXIgaW5kZXggPSByYW5nZS5pbmRleCxcbiAgICAgICAgICBsZW5ndGggPSByYW5nZS5sZW5ndGg7XG5cbiAgICAgIHZhciBfcXVpbGwkc2Nyb2xsJGRlc2NlbmQgPSB0aGlzLnF1aWxsLnNjcm9sbC5kZXNjZW5kYW50KENvZGVCbG9jaywgaW5kZXgpLFxuICAgICAgICAgIF9xdWlsbCRzY3JvbGwkZGVzY2VuZDIgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkc2Nyb2xsJGRlc2NlbmQsIDIpLFxuICAgICAgICAgIGJsb2NrID0gX3F1aWxsJHNjcm9sbCRkZXNjZW5kMlswXSxcbiAgICAgICAgICBvZmZzZXQgPSBfcXVpbGwkc2Nyb2xsJGRlc2NlbmQyWzFdO1xuXG4gICAgICBpZiAoYmxvY2sgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIHNjcm9sbEluZGV4ID0gdGhpcy5xdWlsbC5nZXRJbmRleChibG9jayk7XG4gICAgICB2YXIgc3RhcnQgPSBibG9jay5uZXdsaW5lSW5kZXgob2Zmc2V0LCB0cnVlKSArIDE7XG4gICAgICB2YXIgZW5kID0gYmxvY2submV3bGluZUluZGV4KHNjcm9sbEluZGV4ICsgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgIHZhciBsaW5lcyA9IGJsb2NrLmRvbU5vZGUudGV4dENvbnRlbnQuc2xpY2Uoc3RhcnQsIGVuZCkuc3BsaXQoJ1xcbicpO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICAgICAgaWYgKGluZGVudCkge1xuICAgICAgICAgIGJsb2NrLmluc2VydEF0KHN0YXJ0ICsgb2Zmc2V0LCBDb2RlQmxvY2suVEFCKTtcbiAgICAgICAgICBvZmZzZXQgKz0gQ29kZUJsb2NrLlRBQi5sZW5ndGg7XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGluZGV4ICs9IENvZGVCbG9jay5UQUIubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gQ29kZUJsb2NrLlRBQi5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChDb2RlQmxvY2suVEFCKSkge1xuICAgICAgICAgIGJsb2NrLmRlbGV0ZUF0KHN0YXJ0ICsgb2Zmc2V0LCBDb2RlQmxvY2suVEFCLmxlbmd0aCk7XG4gICAgICAgICAgb2Zmc2V0IC09IENvZGVCbG9jay5UQUIubGVuZ3RoO1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBpbmRleCAtPSBDb2RlQmxvY2suVEFCLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoIC09IENvZGVCbG9jay5UQUIubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gbGluZS5sZW5ndGggKyAxO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZShfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKGluZGV4LCBsZW5ndGgsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlRm9ybWF0SGFuZGxlcihmb3JtYXQpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGZvcm1hdFswXS50b1VwcGVyQ2FzZSgpLFxuICAgIHNob3J0S2V5OiB0cnVlLFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgIHRoaXMucXVpbGwuZm9ybWF0KGZvcm1hdCwgIWNvbnRleHQuZm9ybWF0W2Zvcm1hdF0sIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKGJpbmRpbmcpIHtcbiAgaWYgKHR5cGVvZiBiaW5kaW5nID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYmluZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplKHsga2V5OiBiaW5kaW5nIH0pO1xuICB9XG4gIGlmICgodHlwZW9mIGJpbmRpbmcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGJpbmRpbmcpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBiaW5kaW5nID0gKDAsIF9jbG9uZTIuZGVmYXVsdCkoYmluZGluZywgZmFsc2UpO1xuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZy5rZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKEtleWJvYXJkLmtleXNbYmluZGluZy5rZXkudG9VcHBlckNhc2UoKV0gIT0gbnVsbCkge1xuICAgICAgYmluZGluZy5rZXkgPSBLZXlib2FyZC5rZXlzW2JpbmRpbmcua2V5LnRvVXBwZXJDYXNlKCldO1xuICAgIH0gZWxzZSBpZiAoYmluZGluZy5rZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICBiaW5kaW5nLmtleSA9IGJpbmRpbmcua2V5LnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChiaW5kaW5nLnNob3J0S2V5KSB7XG4gICAgYmluZGluZ1tTSE9SVEtFWV0gPSBiaW5kaW5nLnNob3J0S2V5O1xuICAgIGRlbGV0ZSBiaW5kaW5nLnNob3J0S2V5O1xuICB9XG4gIHJldHVybiBiaW5kaW5nO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBLZXlib2FyZDtcbmV4cG9ydHMuU0hPUlRLRVkgPSBTSE9SVEtFWTtcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX3RleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3RleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEN1cnNvciA9IGZ1bmN0aW9uIChfUGFyY2htZW50JEVtYmVkKSB7XG4gIF9pbmhlcml0cyhDdXJzb3IsIF9QYXJjaG1lbnQkRW1iZWQpO1xuXG4gIF9jcmVhdGVDbGFzcyhDdXJzb3IsIG51bGwsIFt7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gQ3Vyc29yKGRvbU5vZGUsIHNlbGVjdGlvbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXJzb3IpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEN1cnNvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEN1cnNvcikpLmNhbGwodGhpcywgZG9tTm9kZSkpO1xuXG4gICAgX3RoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgIF90aGlzLnRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoQ3Vyc29yLkNPTlRFTlRTKTtcbiAgICBfdGhpcy5kb21Ob2RlLmFwcGVuZENoaWxkKF90aGlzLnRleHROb2RlKTtcbiAgICBfdGhpcy5fbGVuZ3RoID0gMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ3Vyc29yLCBbe1xuICAgIGtleTogJ2RldGFjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgIC8vIHN1cGVyLmRldGFjaCgpIHdpbGwgYWxzbyBjbGVhciBkb21Ob2RlLl9fYmxvdFxuICAgICAgaWYgKHRoaXMucGFyZW50ICE9IG51bGwpIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gX2dldChDdXJzb3IucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3Vyc29yLnByb3RvdHlwZSksICdmb3JtYXQnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLFxuICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgIHdoaWxlICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQuc3RhdGljcy5zY29wZSAhPT0gX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DS19CTE9UKSB7XG4gICAgICAgIGluZGV4ICs9IHRhcmdldC5vZmZzZXQodGFyZ2V0LnBhcmVudCk7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gQ3Vyc29yLkNPTlRFTlRTLmxlbmd0aDtcbiAgICAgICAgdGFyZ2V0Lm9wdGltaXplKCk7XG4gICAgICAgIHRhcmdldC5mb3JtYXRBdChpbmRleCwgQ3Vyc29yLkNPTlRFTlRTLmxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luZGV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXgobm9kZSwgb2Zmc2V0KSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy50ZXh0Tm9kZSkgcmV0dXJuIDA7XG4gICAgICByZXR1cm4gX2dldChDdXJzb3IucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3Vyc29yLnByb3RvdHlwZSksICdpbmRleCcsIHRoaXMpLmNhbGwodGhpcywgbm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsZW5ndGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Bvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gW3RoaXMudGV4dE5vZGUsIHRoaXMudGV4dE5vZGUuZGF0YS5sZW5ndGhdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIF9nZXQoQ3Vyc29yLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEN1cnNvci5wcm90b3R5cGUpLCAncmVtb3ZlJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXN0b3JlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdG9yZSgpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5jb21wb3NpbmcgfHwgdGhpcy5wYXJlbnQgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIHRleHROb2RlID0gdGhpcy50ZXh0Tm9kZTtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsZWN0aW9uLmdldE5hdGl2ZVJhbmdlKCk7XG4gICAgICB2YXIgcmVzdG9yZVRleHQgPSB2b2lkIDAsXG4gICAgICAgICAgc3RhcnQgPSB2b2lkIDAsXG4gICAgICAgICAgZW5kID0gdm9pZCAwO1xuICAgICAgaWYgKHJhbmdlICE9IG51bGwgJiYgcmFuZ2Uuc3RhcnQubm9kZSA9PT0gdGV4dE5vZGUgJiYgcmFuZ2UuZW5kLm5vZGUgPT09IHRleHROb2RlKSB7XG4gICAgICAgIHZhciBfcmVmID0gW3RleHROb2RlLCByYW5nZS5zdGFydC5vZmZzZXQsIHJhbmdlLmVuZC5vZmZzZXRdO1xuICAgICAgICByZXN0b3JlVGV4dCA9IF9yZWZbMF07XG4gICAgICAgIHN0YXJ0ID0gX3JlZlsxXTtcbiAgICAgICAgZW5kID0gX3JlZlsyXTtcbiAgICAgIH1cbiAgICAgIC8vIExpbmsgZm9ybWF0IHdpbGwgaW5zZXJ0IHRleHQgb3V0c2lkZSBvZiBhbmNob3IgdGFnXG4gICAgICB3aGlsZSAodGhpcy5kb21Ob2RlLmxhc3RDaGlsZCAhPSBudWxsICYmIHRoaXMuZG9tTm9kZS5sYXN0Q2hpbGQgIT09IHRoaXMudGV4dE5vZGUpIHtcbiAgICAgICAgdGhpcy5kb21Ob2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuZG9tTm9kZS5sYXN0Q2hpbGQsIHRoaXMuZG9tTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0Tm9kZS5kYXRhICE9PSBDdXJzb3IuQ09OVEVOVFMpIHtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLnRleHROb2RlLmRhdGEuc3BsaXQoQ3Vyc29yLkNPTlRFTlRTKS5qb2luKCcnKTtcbiAgICAgICAgaWYgKHRoaXMubmV4dCBpbnN0YW5jZW9mIF90ZXh0Mi5kZWZhdWx0KSB7XG4gICAgICAgICAgcmVzdG9yZVRleHQgPSB0aGlzLm5leHQuZG9tTm9kZTtcbiAgICAgICAgICB0aGlzLm5leHQuaW5zZXJ0QXQoMCwgdGV4dCk7XG4gICAgICAgICAgdGhpcy50ZXh0Tm9kZS5kYXRhID0gQ3Vyc29yLkNPTlRFTlRTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudGV4dE5vZGUuZGF0YSA9IHRleHQ7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKHRoaXMudGV4dE5vZGUpLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLnRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoQ3Vyc29yLkNPTlRFTlRTKTtcbiAgICAgICAgICB0aGlzLmRvbU5vZGUuYXBwZW5kQ2hpbGQodGhpcy50ZXh0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgX21hcCA9IFtzdGFydCwgZW5kXS5tYXAoZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihyZXN0b3JlVGV4dC5kYXRhLmxlbmd0aCwgb2Zmc2V0IC0gMSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgX21hcDIgPSBfc2xpY2VkVG9BcnJheShfbWFwLCAyKTtcblxuICAgICAgICBzdGFydCA9IF9tYXAyWzBdO1xuICAgICAgICBlbmQgPSBfbWFwMlsxXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXJ0Tm9kZTogcmVzdG9yZVRleHQsXG4gICAgICAgICAgc3RhcnRPZmZzZXQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZE5vZGU6IHJlc3RvcmVUZXh0LFxuICAgICAgICAgIGVuZE9mZnNldDogZW5kXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChtdXRhdGlvbnMuc29tZShmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiBtdXRhdGlvbi50YXJnZXQgPT09IF90aGlzMi50ZXh0Tm9kZTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMucmVzdG9yZSgpO1xuICAgICAgICBpZiAocmFuZ2UpIGNvbnRleHQucmFuZ2UgPSByYW5nZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDdXJzb3I7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuRW1iZWQpO1xuXG5DdXJzb3IuYmxvdE5hbWUgPSAnY3Vyc29yJztcbkN1cnNvci5jbGFzc05hbWUgPSAncWwtY3Vyc29yJztcbkN1cnNvci50YWdOYW1lID0gJ3NwYW4nO1xuQ3Vyc29yLkNPTlRFTlRTID0gJ1xcdUZFRkYnOyAvLyBaZXJvIHdpZHRoIG5vIGJyZWFrIHNwYWNlXG5cblxuZXhwb3J0cy5kZWZhdWx0ID0gQ3Vyc29yO1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9ibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfYmxvY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmxvY2spO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDb250YWluZXIgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRDb250YWluZXIpIHtcbiAgX2luaGVyaXRzKENvbnRhaW5lciwgX1BhcmNobWVudCRDb250YWluZXIpO1xuXG4gIGZ1bmN0aW9uIENvbnRhaW5lcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udGFpbmVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ29udGFpbmVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29udGFpbmVyKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gQ29udGFpbmVyO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LkNvbnRhaW5lcik7XG5cbkNvbnRhaW5lci5hbGxvd2VkQ2hpbGRyZW4gPSBbX2Jsb2NrMi5kZWZhdWx0LCBfYmxvY2suQmxvY2tFbWJlZCwgQ29udGFpbmVyXTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ29udGFpbmVyO1xuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNvbG9yU3R5bGUgPSBleHBvcnRzLkNvbG9yQ2xhc3MgPSBleHBvcnRzLkNvbG9yQXR0cmlidXRvciA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENvbG9yQXR0cmlidXRvciA9IGZ1bmN0aW9uIChfUGFyY2htZW50JEF0dHJpYnV0b3IpIHtcbiAgX2luaGVyaXRzKENvbG9yQXR0cmlidXRvciwgX1BhcmNobWVudCRBdHRyaWJ1dG9yKTtcblxuICBmdW5jdGlvbiBDb2xvckF0dHJpYnV0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yQXR0cmlidXRvcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvbG9yQXR0cmlidXRvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbG9yQXR0cmlidXRvcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbG9yQXR0cmlidXRvciwgW3tcbiAgICBrZXk6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGRvbU5vZGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9nZXQoQ29sb3JBdHRyaWJ1dG9yLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbG9yQXR0cmlidXRvci5wcm90b3R5cGUpLCAndmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIGRvbU5vZGUpO1xuICAgICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKCdyZ2IoJykpIHJldHVybiB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXlteXFxkXSsvLCAnJykucmVwbGFjZSgvW15cXGRdKyQvLCAnJyk7XG4gICAgICByZXR1cm4gJyMnICsgdmFsdWUuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gKCcwMCcgKyBwYXJzZUludChjb21wb25lbnQpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgICAgfSkuam9pbignJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbG9yQXR0cmlidXRvcjtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLlN0eWxlKTtcblxudmFyIENvbG9yQ2xhc3MgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkNsYXNzKCdjb2xvcicsICdxbC1jb2xvcicsIHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuSU5MSU5FXG59KTtcbnZhciBDb2xvclN0eWxlID0gbmV3IENvbG9yQXR0cmlidXRvcignY29sb3InLCAnY29sb3InLCB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLklOTElORVxufSk7XG5cbmV4cG9ydHMuQ29sb3JBdHRyaWJ1dG9yID0gQ29sb3JBdHRyaWJ1dG9yO1xuZXhwb3J0cy5Db2xvckNsYXNzID0gQ29sb3JDbGFzcztcbmV4cG9ydHMuQ29sb3JTdHlsZSA9IENvbG9yU3R5bGU7XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2FuaXRpemUgPSBleHBvcnRzLmRlZmF1bHQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9pbmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX2lubGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmxpbmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBMaW5rID0gZnVuY3Rpb24gKF9JbmxpbmUpIHtcbiAgX2luaGVyaXRzKExpbmssIF9JbmxpbmUpO1xuXG4gIGZ1bmN0aW9uIExpbmsoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmspO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChMaW5rLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGluaykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpbmssIFt7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobmFtZSAhPT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lIHx8ICF2YWx1ZSkgcmV0dXJuIF9nZXQoTGluay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaW5rLnByb3RvdHlwZSksICdmb3JtYXQnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5zYW5pdGl6ZSh2YWx1ZSk7XG4gICAgICB0aGlzLmRvbU5vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgdmFsdWUpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZSA9IF9nZXQoTGluay5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpbmspLCAnY3JlYXRlJywgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICB2YWx1ZSA9IHRoaXMuc2FuaXRpemUodmFsdWUpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB2YWx1ZSk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgncmVsJywgJ25vb3BlbmVyIG5vcmVmZXJyZXInKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd0YXJnZXQnLCAnX2JsYW5rJyk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cyhkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzYW5pdGl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhbml0aXplKHVybCkge1xuICAgICAgcmV0dXJuIF9zYW5pdGl6ZSh1cmwsIHRoaXMuUFJPVE9DT0xfV0hJVEVMSVNUKSA/IHVybCA6IHRoaXMuU0FOSVRJWkVEX1VSTDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGluaztcbn0oX2lubGluZTIuZGVmYXVsdCk7XG5cbkxpbmsuYmxvdE5hbWUgPSAnbGluayc7XG5MaW5rLnRhZ05hbWUgPSAnQSc7XG5MaW5rLlNBTklUSVpFRF9VUkwgPSAnYWJvdXQ6YmxhbmsnO1xuTGluay5QUk9UT0NPTF9XSElURUxJU1QgPSBbJ2h0dHAnLCAnaHR0cHMnLCAnbWFpbHRvJywgJ3RlbCddO1xuXG5mdW5jdGlvbiBfc2FuaXRpemUodXJsLCBwcm90b2NvbHMpIHtcbiAgdmFyIGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgYW5jaG9yLmhyZWYgPSB1cmw7XG4gIHZhciBwcm90b2NvbCA9IGFuY2hvci5ocmVmLnNsaWNlKDAsIGFuY2hvci5ocmVmLmluZGV4T2YoJzonKSk7XG4gIHJldHVybiBwcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPiAtMTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gTGluaztcbmV4cG9ydHMuc2FuaXRpemUgPSBfc2FuaXRpemU7XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2tleWJvYXJkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBfa2V5Ym9hcmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5Ym9hcmQpO1xuXG52YXIgX2Ryb3Bkb3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDcpO1xuXG52YXIgX2Ryb3Bkb3duMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Ryb3Bkb3duKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIG9wdGlvbnNDb3VudGVyID0gMDtcblxuZnVuY3Rpb24gdG9nZ2xlQXJpYUF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCAhKGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgPT09ICd0cnVlJykpO1xufVxuXG52YXIgUGlja2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQaWNrZXIoc2VsZWN0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQaWNrZXIpO1xuXG4gICAgdGhpcy5zZWxlY3QgPSBzZWxlY3Q7XG4gICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdGhpcy5idWlsZFBpY2tlcigpO1xuICAgIHRoaXMuc2VsZWN0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5zZWxlY3QucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5jb250YWluZXIsIHRoaXMuc2VsZWN0KTtcblxuICAgIHRoaXMubGFiZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMudG9nZ2xlUGlja2VyKCk7XG4gICAgfSk7XG4gICAgdGhpcy5sYWJlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgLy8gQWxsb3dzIHRoZSBcIkVudGVyXCIga2V5IHRvIG9wZW4gdGhlIHBpY2tlclxuICAgICAgICBjYXNlIF9rZXlib2FyZDIuZGVmYXVsdC5rZXlzLkVOVEVSOlxuICAgICAgICAgIF90aGlzLnRvZ2dsZVBpY2tlcigpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIEFsbG93cyB0aGUgXCJFc2NhcGVcIiBrZXkgdG8gY2xvc2UgdGhlIHBpY2tlclxuICAgICAgICBjYXNlIF9rZXlib2FyZDIuZGVmYXVsdC5rZXlzLkVTQ0FQRTpcbiAgICAgICAgICBfdGhpcy5lc2NhcGUoKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBpY2tlciwgW3tcbiAgICBrZXk6ICd0b2dnbGVQaWNrZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVQaWNrZXIoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QudG9nZ2xlKCdxbC1leHBhbmRlZCcpO1xuICAgICAgLy8gVG9nZ2xlIGFyaWEtZXhwYW5kZWQgYW5kIGFyaWEtaGlkZGVuIHRvIG1ha2UgdGhlIHBpY2tlciBhY2Nlc3NpYmxlXG4gICAgICB0b2dnbGVBcmlhQXR0cmlidXRlKHRoaXMubGFiZWwsICdhcmlhLWV4cGFuZGVkJyk7XG4gICAgICB0b2dnbGVBcmlhQXR0cmlidXRlKHRoaXMub3B0aW9ucywgJ2FyaWEtaGlkZGVuJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGRJdGVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRJdGVtKG9wdGlvbikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgaXRlbS50YWJJbmRleCA9ICcwJztcbiAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xuXG4gICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3FsLXBpY2tlci1pdGVtJyk7XG4gICAgICBpZiAob3B0aW9uLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkge1xuICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScsIG9wdGlvbi5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbi50ZXh0Q29udGVudCkge1xuICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnZGF0YS1sYWJlbCcsIG9wdGlvbi50ZXh0Q29udGVudCk7XG4gICAgICB9XG4gICAgICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2VsZWN0SXRlbShpdGVtLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgaXRlbS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgIC8vIEFsbG93cyB0aGUgXCJFbnRlclwiIGtleSB0byBzZWxlY3QgYW4gaXRlbVxuICAgICAgICAgIGNhc2UgX2tleWJvYXJkMi5kZWZhdWx0LmtleXMuRU5URVI6XG4gICAgICAgICAgICBfdGhpczIuc2VsZWN0SXRlbShpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIEFsbG93cyB0aGUgXCJFc2NhcGVcIiBrZXkgdG8gY2xvc2UgdGhlIHBpY2tlclxuICAgICAgICAgIGNhc2UgX2tleWJvYXJkMi5kZWZhdWx0LmtleXMuRVNDQVBFOlxuICAgICAgICAgICAgX3RoaXMyLmVzY2FwZSgpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdidWlsZExhYmVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRMYWJlbCgpIHtcbiAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ3FsLXBpY2tlci1sYWJlbCcpO1xuICAgICAgbGFiZWwuaW5uZXJIVE1MID0gX2Ryb3Bkb3duMi5kZWZhdWx0O1xuICAgICAgbGFiZWwudGFiSW5kZXggPSAnMCc7XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdidWlsZE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZE9wdGlvbnMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBvcHRpb25zLmNsYXNzTGlzdC5hZGQoJ3FsLXBpY2tlci1vcHRpb25zJyk7XG5cbiAgICAgIC8vIERvbid0IHdhbnQgc2NyZWVuIHJlYWRlcnMgdG8gcmVhZCB0aGlzIHVudGlsIG9wdGlvbnMgYXJlIHZpc2libGVcbiAgICAgIG9wdGlvbnMuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICBvcHRpb25zLnRhYkluZGV4ID0gJy0xJztcblxuICAgICAgLy8gTmVlZCBhIHVuaXF1ZSBpZCBmb3IgYXJpYS1jb250cm9sc1xuICAgICAgb3B0aW9ucy5pZCA9ICdxbC1waWNrZXItb3B0aW9ucy0nICsgb3B0aW9uc0NvdW50ZXI7XG4gICAgICBvcHRpb25zQ291bnRlciArPSAxO1xuICAgICAgdGhpcy5sYWJlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnLCBvcHRpb25zLmlkKTtcblxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgW10uc2xpY2UuY2FsbCh0aGlzLnNlbGVjdC5vcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfdGhpczMuYnVpbGRJdGVtKG9wdGlvbik7XG4gICAgICAgIG9wdGlvbnMuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBfdGhpczMuc2VsZWN0SXRlbShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdidWlsZFBpY2tlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkUGlja2VyKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIFtdLnNsaWNlLmNhbGwodGhpcy5zZWxlY3QuYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBfdGhpczQuY29udGFpbmVyLnNldEF0dHJpYnV0ZShpdGVtLm5hbWUsIGl0ZW0udmFsdWUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdxbC1waWNrZXInKTtcbiAgICAgIHRoaXMubGFiZWwgPSB0aGlzLmJ1aWxkTGFiZWwoKTtcbiAgICAgIHRoaXMuYnVpbGRPcHRpb25zKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXNjYXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXNjYXBlKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIC8vIENsb3NlIG1lbnUgYW5kIHJldHVybiBmb2N1cyB0byB0cmlnZ2VyIGxhYmVsXG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAvLyBOZWVkIHNldFRpbWVvdXQgZm9yIGFjY2Vzc2liaWxpdHkgdG8gZW5zdXJlIHRoYXQgdGhlIGJyb3dzZXIgZXhlY3V0ZXNcbiAgICAgIC8vIGZvY3VzIG9uIHRoZSBuZXh0IHByb2Nlc3MgdGhyZWFkIGFuZCBhZnRlciBhbnkgRE9NIGNvbnRlbnQgY2hhbmdlc1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczUubGFiZWwuZm9jdXMoKTtcbiAgICAgIH0sIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Nsb3NlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdxbC1leHBhbmRlZCcpO1xuICAgICAgdGhpcy5sYWJlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgIHRoaXMub3B0aW9ucy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZWxlY3RJdGVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0SXRlbShpdGVtKSB7XG4gICAgICB2YXIgdHJpZ2dlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5xbC1zZWxlY3RlZCcpO1xuICAgICAgaWYgKGl0ZW0gPT09IHNlbGVjdGVkKSByZXR1cm47XG4gICAgICBpZiAoc2VsZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgICBzZWxlY3RlZC5jbGFzc0xpc3QucmVtb3ZlKCdxbC1zZWxlY3RlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdxbC1zZWxlY3RlZCcpO1xuICAgICAgdGhpcy5zZWxlY3Quc2VsZWN0ZWRJbmRleCA9IFtdLmluZGV4T2YuY2FsbChpdGVtLnBhcmVudE5vZGUuY2hpbGRyZW4sIGl0ZW0pO1xuICAgICAgaWYgKGl0ZW0uaGFzQXR0cmlidXRlKCdkYXRhLXZhbHVlJykpIHtcbiAgICAgICAgdGhpcy5sYWJlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnLCBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFiZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXZhbHVlJyk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbS5oYXNBdHRyaWJ1dGUoJ2RhdGEtbGFiZWwnKSkge1xuICAgICAgICB0aGlzLmxhYmVsLnNldEF0dHJpYnV0ZSgnZGF0YS1sYWJlbCcsIGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWxhYmVsJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYWJlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbGFiZWwnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgRXZlbnQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKEV2ZW50KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLy8gSUUxMVxuICAgICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgIGV2ZW50LmluaXRFdmVudCgnY2hhbmdlJywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5zZWxlY3QuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBvcHRpb24gPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5zZWxlY3Quc2VsZWN0ZWRJbmRleCA+IC0xKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcignLnFsLXBpY2tlci1vcHRpb25zJykuY2hpbGRyZW5bdGhpcy5zZWxlY3Quc2VsZWN0ZWRJbmRleF07XG4gICAgICAgIG9wdGlvbiA9IHRoaXMuc2VsZWN0Lm9wdGlvbnNbdGhpcy5zZWxlY3Quc2VsZWN0ZWRJbmRleF07XG4gICAgICAgIHRoaXMuc2VsZWN0SXRlbShpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0SXRlbShudWxsKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FjdGl2ZSA9IG9wdGlvbiAhPSBudWxsICYmIG9wdGlvbiAhPT0gdGhpcy5zZWxlY3QucXVlcnlTZWxlY3Rvcignb3B0aW9uW3NlbGVjdGVkXScpO1xuICAgICAgdGhpcy5sYWJlbC5jbGFzc0xpc3QudG9nZ2xlKCdxbC1hY3RpdmUnLCBpc0FjdGl2ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBpY2tlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUGlja2VyO1xuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9xdWlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfcXVpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGwpO1xuXG52YXIgX2Jsb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9ibG9jazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ibG9jayk7XG5cbnZhciBfYnJlYWsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9icmVhazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icmVhayk7XG5cbnZhciBfY29udGFpbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbnZhciBfY29udGFpbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRhaW5lcik7XG5cbnZhciBfY3Vyc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbnZhciBfY3Vyc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2N1cnNvcik7XG5cbnZhciBfZW1iZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcblxudmFyIF9lbWJlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbWJlZCk7XG5cbnZhciBfaW5saW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9pbmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5saW5lKTtcblxudmFyIF9zY3JvbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblxudmFyIF9zY3JvbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2Nyb2xsKTtcblxudmFyIF90ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RleHQpO1xuXG52YXIgX2NsaXBib2FyZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xuXG52YXIgX2NsaXBib2FyZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGlwYm9hcmQpO1xuXG52YXIgX2hpc3RvcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcblxudmFyIF9oaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hpc3RvcnkpO1xuXG52YXIgX2tleWJvYXJkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBfa2V5Ym9hcmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5Ym9hcmQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5fcXVpbGwyLmRlZmF1bHQucmVnaXN0ZXIoe1xuICAnYmxvdHMvYmxvY2snOiBfYmxvY2syLmRlZmF1bHQsXG4gICdibG90cy9ibG9jay9lbWJlZCc6IF9ibG9jay5CbG9ja0VtYmVkLFxuICAnYmxvdHMvYnJlYWsnOiBfYnJlYWsyLmRlZmF1bHQsXG4gICdibG90cy9jb250YWluZXInOiBfY29udGFpbmVyMi5kZWZhdWx0LFxuICAnYmxvdHMvY3Vyc29yJzogX2N1cnNvcjIuZGVmYXVsdCxcbiAgJ2Jsb3RzL2VtYmVkJzogX2VtYmVkMi5kZWZhdWx0LFxuICAnYmxvdHMvaW5saW5lJzogX2lubGluZTIuZGVmYXVsdCxcbiAgJ2Jsb3RzL3Njcm9sbCc6IF9zY3JvbGwyLmRlZmF1bHQsXG4gICdibG90cy90ZXh0JzogX3RleHQyLmRlZmF1bHQsXG5cbiAgJ21vZHVsZXMvY2xpcGJvYXJkJzogX2NsaXBib2FyZDIuZGVmYXVsdCxcbiAgJ21vZHVsZXMvaGlzdG9yeSc6IF9oaXN0b3J5Mi5kZWZhdWx0LFxuICAnbW9kdWxlcy9rZXlib2FyZCc6IF9rZXlib2FyZDIuZGVmYXVsdFxufSk7XG5cbl9wYXJjaG1lbnQyLmRlZmF1bHQucmVnaXN0ZXIoX2Jsb2NrMi5kZWZhdWx0LCBfYnJlYWsyLmRlZmF1bHQsIF9jdXJzb3IyLmRlZmF1bHQsIF9pbmxpbmUyLmRlZmF1bHQsIF9zY3JvbGwyLmRlZmF1bHQsIF90ZXh0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX3F1aWxsMi5kZWZhdWx0O1xuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIFNoYWRvd0Jsb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2hhZG93QmxvdChkb21Ob2RlKSB7XG4gICAgICAgIHRoaXMuZG9tTm9kZSA9IGRvbU5vZGU7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXSA9IHsgYmxvdDogdGhpcyB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hhZG93QmxvdC5wcm90b3R5cGUsIFwic3RhdGljc1wiLCB7XG4gICAgICAgIC8vIEhhY2sgZm9yIGFjY2Vzc2luZyBpbmhlcml0ZWQgc3RhdGljIG1ldGhvZHNcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU2hhZG93QmxvdC5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudGFnTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVnaXN0cnkuUGFyY2htZW50RXJyb3IoJ0Jsb3QgZGVmaW5pdGlvbiBtaXNzaW5nIHRhZ05hbWUnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy50YWdOYW1lKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KHZhbHVlKS50b1N0cmluZygpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnTmFtZVt2YWx1ZSAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudGFnTmFtZS5pbmRleE9mKHZhbHVlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy50YWdOYW1lWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGwgPSB0aGlzLnBhcmVudC5zY3JvbGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IHRoaXMuZG9tTm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICByZXR1cm4gUmVnaXN0cnkuY3JlYXRlKGRvbU5vZGUpO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRlbGV0ZSB0aGlzLmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUuZGVsZXRlQXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICB2YXIgYmxvdCA9IHRoaXMuaXNvbGF0ZShpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgYmxvdC5yZW1vdmUoKTtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLmZvcm1hdEF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBibG90ID0gdGhpcy5pc29sYXRlKGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBpZiAoUmVnaXN0cnkucXVlcnkobmFtZSwgUmVnaXN0cnkuU2NvcGUuQkxPVCkgIT0gbnVsbCAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgYmxvdC53cmFwKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChSZWdpc3RyeS5xdWVyeShuYW1lLCBSZWdpc3RyeS5TY29wZS5BVFRSSUJVVEUpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBSZWdpc3RyeS5jcmVhdGUodGhpcy5zdGF0aWNzLnNjb3BlKTtcbiAgICAgICAgICAgIGJsb3Qud3JhcChwYXJlbnQpO1xuICAgICAgICAgICAgcGFyZW50LmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLmluc2VydEF0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICAgIHZhciBibG90ID0gZGVmID09IG51bGwgPyBSZWdpc3RyeS5jcmVhdGUoJ3RleHQnLCB2YWx1ZSkgOiBSZWdpc3RyeS5jcmVhdGUodmFsdWUsIGRlZik7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLnNwbGl0KGluZGV4KTtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJsb3QsIHJlZik7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5pbnNlcnRJbnRvID0gZnVuY3Rpb24gKHBhcmVudEJsb3QsIHJlZkJsb3QpIHtcbiAgICAgICAgaWYgKHJlZkJsb3QgPT09IHZvaWQgMCkgeyByZWZCbG90ID0gbnVsbDsgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4ucmVtb3ZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWZEb21Ob2RlID0gbnVsbDtcbiAgICAgICAgcGFyZW50QmxvdC5jaGlsZHJlbi5pbnNlcnRCZWZvcmUodGhpcywgcmVmQmxvdCk7XG4gICAgICAgIGlmIChyZWZCbG90ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlZkRvbU5vZGUgPSByZWZCbG90LmRvbU5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG9tTm9kZS5wYXJlbnROb2RlICE9IHBhcmVudEJsb3QuZG9tTm9kZSB8fFxuICAgICAgICAgICAgdGhpcy5kb21Ob2RlLm5leHRTaWJsaW5nICE9IHJlZkRvbU5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudEJsb3QuZG9tTm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb21Ob2RlLCByZWZEb21Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudEJsb3Q7XG4gICAgICAgIHRoaXMuYXR0YWNoKCk7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5pc29sYXRlID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuc3BsaXQoaW5kZXgpO1xuICAgICAgICB0YXJnZXQuc3BsaXQobGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICBpZiAocm9vdCA9PT0gdm9pZCAwKSB7IHJvb3QgPSB0aGlzLnBhcmVudDsgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgPT0gbnVsbCB8fCB0aGlzID09IHJvb3QpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkcmVuLm9mZnNldCh0aGlzKSArIHRoaXMucGFyZW50Lm9mZnNldChyb290KTtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLm9wdGltaXplID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgLy8gVE9ETyBjbGVhbiB1cCBvbmNlIHdlIHVzZSBXZWFrTWFwXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKHRoaXMuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0ubXV0YXRpb25zO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbU5vZGUucGFyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRvbU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0LnBhcmVudCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0YXJnZXQucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCB0YXJnZXQubmV4dCk7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciByZXBsYWNlbWVudCA9IHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyA/IFJlZ2lzdHJ5LmNyZWF0ZShuYW1lLCB2YWx1ZSkgOiBuYW1lO1xuICAgICAgICByZXBsYWNlbWVudC5yZXBsYWNlKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChpbmRleCwgZm9yY2UpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSAwID8gdGhpcyA6IHRoaXMubmV4dDtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBkbyBieSBkZWZhdWx0XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnID8gUmVnaXN0cnkuY3JlYXRlKG5hbWUsIHZhbHVlKSA6IG5hbWU7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUod3JhcHBlciwgdGhpcy5uZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMpO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QuYmxvdE5hbWUgPSAnYWJzdHJhY3QnO1xuICAgIHJldHVybiBTaGFkb3dCbG90O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNoYWRvd0Jsb3Q7XG5cblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGF0dHJpYnV0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIGNsYXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBzdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIEF0dHJpYnV0b3JTdG9yZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdHRyaWJ1dG9yU3RvcmUoZG9tTm9kZSkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5kb21Ob2RlID0gZG9tTm9kZTtcbiAgICAgICAgdGhpcy5idWlsZCgpO1xuICAgIH1cbiAgICBBdHRyaWJ1dG9yU3RvcmUucHJvdG90eXBlLmF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICAgIC8vIHZlcmJcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLmFkZCh0aGlzLmRvbU5vZGUsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUodGhpcy5kb21Ob2RlKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGUuYXR0ck5hbWVdID0gYXR0cmlidXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGUuYXR0ck5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZS5yZW1vdmUodGhpcy5kb21Ob2RlKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlLmF0dHJOYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXR0cmlidXRvclN0b3JlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gYXR0cmlidXRvcl8xLmRlZmF1bHQua2V5cyh0aGlzLmRvbU5vZGUpO1xuICAgICAgICB2YXIgY2xhc3NlcyA9IGNsYXNzXzEuZGVmYXVsdC5rZXlzKHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIHZhciBzdHlsZXMgPSBzdHlsZV8xLmRlZmF1bHQua2V5cyh0aGlzLmRvbU5vZGUpO1xuICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAuY29uY2F0KGNsYXNzZXMpXG4gICAgICAgICAgICAuY29uY2F0KHN0eWxlcylcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IFJlZ2lzdHJ5LnF1ZXJ5KG5hbWUsIFJlZ2lzdHJ5LlNjb3BlLkFUVFJJQlVURSk7XG4gICAgICAgICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIGF0dHJpYnV0b3JfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cmlidXRlc1thdHRyLmF0dHJOYW1lXSA9IGF0dHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXR0cmlidXRvclN0b3JlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMuYXR0cmlidXRlc1trZXldLnZhbHVlKF90aGlzLmRvbU5vZGUpO1xuICAgICAgICAgICAgdGFyZ2V0LmZvcm1hdChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdHRyaWJ1dG9yU3RvcmUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29weSh0YXJnZXQpO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgX3RoaXMuYXR0cmlidXRlc1trZXldLnJlbW92ZShfdGhpcy5kb21Ob2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIH07XG4gICAgQXR0cmlidXRvclN0b3JlLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmF0dHJpYnV0ZXMpLnJlZHVjZShmdW5jdGlvbiAoYXR0cmlidXRlcywgbmFtZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlc1tuYW1lXSA9IF90aGlzLmF0dHJpYnV0ZXNbbmFtZV0udmFsdWUoX3RoaXMuZG9tTm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgcmV0dXJuIEF0dHJpYnV0b3JTdG9yZTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBdHRyaWJ1dG9yU3RvcmU7XG5cblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXR0cmlidXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5mdW5jdGlvbiBtYXRjaChub2RlLCBwcmVmaXgpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gICAgcmV0dXJuIGNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS5pbmRleE9mKHByZWZpeCArIFwiLVwiKSA9PT0gMDtcbiAgICB9KTtcbn1cbnZhciBDbGFzc0F0dHJpYnV0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsYXNzQXR0cmlidXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDbGFzc0F0dHJpYnV0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ2xhc3NBdHRyaWJ1dG9yLmtleXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gKG5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVcbiAgICAgICAgICAgICAgICAuc3BsaXQoJy0nKVxuICAgICAgICAgICAgICAgIC5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgICAgICAuam9pbignLScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENsYXNzQXR0cmlidXRvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5BZGQobm9kZSwgdmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnJlbW92ZShub2RlKTtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKHRoaXMua2V5TmFtZSArIFwiLVwiICsgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIENsYXNzQXR0cmlidXRvci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBtYXRjaChub2RlLCB0aGlzLmtleU5hbWUpO1xuICAgICAgICBtYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChub2RlLmNsYXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbGFzc0F0dHJpYnV0b3IucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1hdGNoKG5vZGUsIHRoaXMua2V5TmFtZSlbMF0gfHwgJyc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC5zbGljZSh0aGlzLmtleU5hbWUubGVuZ3RoICsgMSk7IC8vICsxIGZvciBoeXBoZW5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSA/IHZhbHVlIDogJyc7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xhc3NBdHRyaWJ1dG9yO1xufShhdHRyaWJ1dG9yXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2xhc3NBdHRyaWJ1dG9yO1xuXG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGF0dHJpYnV0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuZnVuY3Rpb24gY2FtZWxpemUobmFtZSkge1xuICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy0nKTtcbiAgICB2YXIgcmVzdCA9IHBhcnRzXG4gICAgICAgIC5zbGljZSgxKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIHJldHVybiBwYXJ0WzBdLnRvVXBwZXJDYXNlKCkgKyBwYXJ0LnNsaWNlKDEpO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcnKTtcbiAgICByZXR1cm4gcGFydHNbMF0gKyByZXN0O1xufVxudmFyIFN0eWxlQXR0cmlidXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3R5bGVBdHRyaWJ1dG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0eWxlQXR0cmlidXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTdHlsZUF0dHJpYnV0b3Iua2V5cyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgJycpLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGFyciA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICByZXR1cm4gYXJyWzBdLnRyaW0oKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdHlsZUF0dHJpYnV0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBub2RlLnN0eWxlW2NhbWVsaXplKHRoaXMua2V5TmFtZSldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgU3R5bGVBdHRyaWJ1dG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG5vZGUuc3R5bGVbY2FtZWxpemUodGhpcy5rZXlOYW1lKV0gPSAnJztcbiAgICAgICAgaWYgKCFub2RlLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0eWxlQXR0cmlidXRvci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuc3R5bGVbY2FtZWxpemUodGhpcy5rZXlOYW1lKV07XG4gICAgICAgIHJldHVybiB0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkgPyB2YWx1ZSA6ICcnO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlQXR0cmlidXRvcjtcbn0oYXR0cmlidXRvcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0eWxlQXR0cmlidXRvcjtcblxuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBUaGVtZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGhlbWUocXVpbGwsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGhlbWUpO1xuXG4gICAgdGhpcy5xdWlsbCA9IHF1aWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5tb2R1bGVzID0ge307XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGhlbWUsIFt7XG4gICAga2V5OiAnaW5pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoX3RoaXMubW9kdWxlc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgX3RoaXMuYWRkTW9kdWxlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRNb2R1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNb2R1bGUobmFtZSkge1xuICAgICAgdmFyIG1vZHVsZUNsYXNzID0gdGhpcy5xdWlsbC5jb25zdHJ1Y3Rvci5pbXBvcnQoJ21vZHVsZXMvJyArIG5hbWUpO1xuICAgICAgdGhpcy5tb2R1bGVzW25hbWVdID0gbmV3IG1vZHVsZUNsYXNzKHRoaXMucXVpbGwsIHRoaXMub3B0aW9ucy5tb2R1bGVzW25hbWVdIHx8IHt9KTtcbiAgICAgIHJldHVybiB0aGlzLm1vZHVsZXNbbmFtZV07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRoZW1lO1xufSgpO1xuXG5UaGVtZS5ERUZBVUxUUyA9IHtcbiAgbW9kdWxlczoge31cbn07XG5UaGVtZS50aGVtZXMgPSB7XG4gICdkZWZhdWx0JzogVGhlbWVcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRoZW1lO1xuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX3RleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3RleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEdVQVJEX1RFWFQgPSAnXFx1RkVGRic7XG5cbnZhciBFbWJlZCA9IGZ1bmN0aW9uIChfUGFyY2htZW50JEVtYmVkKSB7XG4gIF9pbmhlcml0cyhFbWJlZCwgX1BhcmNobWVudCRFbWJlZCk7XG5cbiAgZnVuY3Rpb24gRW1iZWQobm9kZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWJlZCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRW1iZWQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFbWJlZCkpLmNhbGwodGhpcywgbm9kZSkpO1xuXG4gICAgX3RoaXMuY29udGVudE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgX3RoaXMuY29udGVudE5vZGUuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCBmYWxzZSk7XG4gICAgW10uc2xpY2UuY2FsbChfdGhpcy5kb21Ob2RlLmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgX3RoaXMuY29udGVudE5vZGUuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcbiAgICB9KTtcbiAgICBfdGhpcy5sZWZ0R3VhcmQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShHVUFSRF9URVhUKTtcbiAgICBfdGhpcy5yaWdodEd1YXJkID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoR1VBUkRfVEVYVCk7XG4gICAgX3RoaXMuZG9tTm9kZS5hcHBlbmRDaGlsZChfdGhpcy5sZWZ0R3VhcmQpO1xuICAgIF90aGlzLmRvbU5vZGUuYXBwZW5kQ2hpbGQoX3RoaXMuY29udGVudE5vZGUpO1xuICAgIF90aGlzLmRvbU5vZGUuYXBwZW5kQ2hpbGQoX3RoaXMucmlnaHRHdWFyZCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVtYmVkLCBbe1xuICAgIGtleTogJ2luZGV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXgobm9kZSwgb2Zmc2V0KSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy5sZWZ0R3VhcmQpIHJldHVybiAwO1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMucmlnaHRHdWFyZCkgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gX2dldChFbWJlZC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFbWJlZC5wcm90b3R5cGUpLCAnaW5kZXgnLCB0aGlzKS5jYWxsKHRoaXMsIG5vZGUsIG9mZnNldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzdG9yZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3RvcmUobm9kZSkge1xuICAgICAgdmFyIHJhbmdlID0gdm9pZCAwLFxuICAgICAgICAgIHRleHROb2RlID0gdm9pZCAwO1xuICAgICAgdmFyIHRleHQgPSBub2RlLmRhdGEuc3BsaXQoR1VBUkRfVEVYVCkuam9pbignJyk7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy5sZWZ0R3VhcmQpIHtcbiAgICAgICAgaWYgKHRoaXMucHJldiBpbnN0YW5jZW9mIF90ZXh0Mi5kZWZhdWx0KSB7XG4gICAgICAgICAgdmFyIHByZXZMZW5ndGggPSB0aGlzLnByZXYubGVuZ3RoKCk7XG4gICAgICAgICAgdGhpcy5wcmV2Lmluc2VydEF0KHByZXZMZW5ndGgsIHRleHQpO1xuICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnROb2RlOiB0aGlzLnByZXYuZG9tTm9kZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBwcmV2TGVuZ3RoICsgdGV4dC5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKHRleHROb2RlKSwgdGhpcyk7XG4gICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydE5vZGU6IHRleHROb2RlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHRleHQubGVuZ3RoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlID09PSB0aGlzLnJpZ2h0R3VhcmQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCBpbnN0YW5jZW9mIF90ZXh0Mi5kZWZhdWx0KSB7XG4gICAgICAgICAgdGhpcy5uZXh0Lmluc2VydEF0KDAsIHRleHQpO1xuICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnROb2RlOiB0aGlzLm5leHQuZG9tTm9kZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiB0ZXh0Lmxlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoX3BhcmNobWVudDIuZGVmYXVsdC5jcmVhdGUodGV4dE5vZGUpLCB0aGlzLm5leHQpO1xuICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnROb2RlOiB0ZXh0Tm9kZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiB0ZXh0Lmxlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuZGF0YSA9IEdVQVJEX1RFWFQ7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIG11dGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnICYmIChtdXRhdGlvbi50YXJnZXQgPT09IF90aGlzMi5sZWZ0R3VhcmQgfHwgbXV0YXRpb24udGFyZ2V0ID09PSBfdGhpczIucmlnaHRHdWFyZCkpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBfdGhpczIucmVzdG9yZShtdXRhdGlvbi50YXJnZXQpO1xuICAgICAgICAgIGlmIChyYW5nZSkgY29udGV4dC5yYW5nZSA9IHJhbmdlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRW1iZWQ7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuRW1iZWQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFbWJlZDtcblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5BbGlnblN0eWxlID0gZXhwb3J0cy5BbGlnbkNsYXNzID0gZXhwb3J0cy5BbGlnbkF0dHJpYnV0ZSA9IHVuZGVmaW5lZDtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY29uZmlnID0ge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DSyxcbiAgd2hpdGVsaXN0OiBbJ3JpZ2h0JywgJ2NlbnRlcicsICdqdXN0aWZ5J11cbn07XG5cbnZhciBBbGlnbkF0dHJpYnV0ZSA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQXR0cmlidXRlKCdhbGlnbicsICdhbGlnbicsIGNvbmZpZyk7XG52YXIgQWxpZ25DbGFzcyA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQ2xhc3MoJ2FsaWduJywgJ3FsLWFsaWduJywgY29uZmlnKTtcbnZhciBBbGlnblN0eWxlID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5TdHlsZSgnYWxpZ24nLCAndGV4dC1hbGlnbicsIGNvbmZpZyk7XG5cbmV4cG9ydHMuQWxpZ25BdHRyaWJ1dGUgPSBBbGlnbkF0dHJpYnV0ZTtcbmV4cG9ydHMuQWxpZ25DbGFzcyA9IEFsaWduQ2xhc3M7XG5leHBvcnRzLkFsaWduU3R5bGUgPSBBbGlnblN0eWxlO1xuXG4vKioqLyB9KSxcbi8qIDM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkJhY2tncm91bmRTdHlsZSA9IGV4cG9ydHMuQmFja2dyb3VuZENsYXNzID0gdW5kZWZpbmVkO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfY29sb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIEJhY2tncm91bmRDbGFzcyA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQ2xhc3MoJ2JhY2tncm91bmQnLCAncWwtYmcnLCB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLklOTElORVxufSk7XG52YXIgQmFja2dyb3VuZFN0eWxlID0gbmV3IF9jb2xvci5Db2xvckF0dHJpYnV0b3IoJ2JhY2tncm91bmQnLCAnYmFja2dyb3VuZC1jb2xvcicsIHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuSU5MSU5FXG59KTtcblxuZXhwb3J0cy5CYWNrZ3JvdW5kQ2xhc3MgPSBCYWNrZ3JvdW5kQ2xhc3M7XG5leHBvcnRzLkJhY2tncm91bmRTdHlsZSA9IEJhY2tncm91bmRTdHlsZTtcblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5EaXJlY3Rpb25TdHlsZSA9IGV4cG9ydHMuRGlyZWN0aW9uQ2xhc3MgPSBleHBvcnRzLkRpcmVjdGlvbkF0dHJpYnV0ZSA9IHVuZGVmaW5lZDtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY29uZmlnID0ge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DSyxcbiAgd2hpdGVsaXN0OiBbJ3J0bCddXG59O1xuXG52YXIgRGlyZWN0aW9uQXR0cmlidXRlID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5BdHRyaWJ1dGUoJ2RpcmVjdGlvbicsICdkaXInLCBjb25maWcpO1xudmFyIERpcmVjdGlvbkNsYXNzID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5DbGFzcygnZGlyZWN0aW9uJywgJ3FsLWRpcmVjdGlvbicsIGNvbmZpZyk7XG52YXIgRGlyZWN0aW9uU3R5bGUgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLlN0eWxlKCdkaXJlY3Rpb24nLCAnZGlyZWN0aW9uJywgY29uZmlnKTtcblxuZXhwb3J0cy5EaXJlY3Rpb25BdHRyaWJ1dGUgPSBEaXJlY3Rpb25BdHRyaWJ1dGU7XG5leHBvcnRzLkRpcmVjdGlvbkNsYXNzID0gRGlyZWN0aW9uQ2xhc3M7XG5leHBvcnRzLkRpcmVjdGlvblN0eWxlID0gRGlyZWN0aW9uU3R5bGU7XG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRm9udENsYXNzID0gZXhwb3J0cy5Gb250U3R5bGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBjb25maWcgPSB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLklOTElORSxcbiAgd2hpdGVsaXN0OiBbJ3NlcmlmJywgJ21vbm9zcGFjZSddXG59O1xuXG52YXIgRm9udENsYXNzID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5DbGFzcygnZm9udCcsICdxbC1mb250JywgY29uZmlnKTtcblxudmFyIEZvbnRTdHlsZUF0dHJpYnV0b3IgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRBdHRyaWJ1dG9yKSB7XG4gIF9pbmhlcml0cyhGb250U3R5bGVBdHRyaWJ1dG9yLCBfUGFyY2htZW50JEF0dHJpYnV0b3IpO1xuXG4gIGZ1bmN0aW9uIEZvbnRTdHlsZUF0dHJpYnV0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvbnRTdHlsZUF0dHJpYnV0b3IpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGb250U3R5bGVBdHRyaWJ1dG9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9udFN0eWxlQXR0cmlidXRvcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZvbnRTdHlsZUF0dHJpYnV0b3IsIFt7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShub2RlKSB7XG4gICAgICByZXR1cm4gX2dldChGb250U3R5bGVBdHRyaWJ1dG9yLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvbnRTdHlsZUF0dHJpYnV0b3IucHJvdG90eXBlKSwgJ3ZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCBub2RlKS5yZXBsYWNlKC9bXCInXS9nLCAnJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvbnRTdHlsZUF0dHJpYnV0b3I7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5TdHlsZSk7XG5cbnZhciBGb250U3R5bGUgPSBuZXcgRm9udFN0eWxlQXR0cmlidXRvcignZm9udCcsICdmb250LWZhbWlseScsIGNvbmZpZyk7XG5cbmV4cG9ydHMuRm9udFN0eWxlID0gRm9udFN0eWxlO1xuZXhwb3J0cy5Gb250Q2xhc3MgPSBGb250Q2xhc3M7XG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU2l6ZVN0eWxlID0gZXhwb3J0cy5TaXplQ2xhc3MgPSB1bmRlZmluZWQ7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFNpemVDbGFzcyA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQ2xhc3MoJ3NpemUnLCAncWwtc2l6ZScsIHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuSU5MSU5FLFxuICB3aGl0ZWxpc3Q6IFsnc21hbGwnLCAnbGFyZ2UnLCAnaHVnZSddXG59KTtcbnZhciBTaXplU3R5bGUgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLlN0eWxlKCdzaXplJywgJ2ZvbnQtc2l6ZScsIHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuSU5MSU5FLFxuICB3aGl0ZWxpc3Q6IFsnMTBweCcsICcxOHB4JywgJzMycHgnXVxufSk7XG5cbmV4cG9ydHMuU2l6ZUNsYXNzID0gU2l6ZUNsYXNzO1xuZXhwb3J0cy5TaXplU3R5bGUgPSBTaXplU3R5bGU7XG5cbi8qKiovIH0pLFxuLyogNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICdhbGlnbic6IHtcbiAgICAnJzogX193ZWJwYWNrX3JlcXVpcmVfXyg3NiksXG4gICAgJ2NlbnRlcic6IF9fd2VicGFja19yZXF1aXJlX18oNzcpLFxuICAgICdyaWdodCc6IF9fd2VicGFja19yZXF1aXJlX18oNzgpLFxuICAgICdqdXN0aWZ5JzogX193ZWJwYWNrX3JlcXVpcmVfXyg3OSlcbiAgfSxcbiAgJ2JhY2tncm91bmQnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwKSxcbiAgJ2Jsb2NrcXVvdGUnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKSxcbiAgJ2JvbGQnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyKSxcbiAgJ2NsZWFuJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4MyksXG4gICdjb2RlJzogX193ZWJwYWNrX3JlcXVpcmVfXyg1OCksXG4gICdjb2RlLWJsb2NrJzogX193ZWJwYWNrX3JlcXVpcmVfXyg1OCksXG4gICdjb2xvcic6IF9fd2VicGFja19yZXF1aXJlX18oODQpLFxuICAnZGlyZWN0aW9uJzoge1xuICAgICcnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1KSxcbiAgICAncnRsJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4NilcbiAgfSxcbiAgJ2Zsb2F0Jzoge1xuICAgICdjZW50ZXInOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3KSxcbiAgICAnZnVsbCc6IF9fd2VicGFja19yZXF1aXJlX18oODgpLFxuICAgICdsZWZ0JzogX193ZWJwYWNrX3JlcXVpcmVfXyg4OSksXG4gICAgJ3JpZ2h0JzogX193ZWJwYWNrX3JlcXVpcmVfXyg5MClcbiAgfSxcbiAgJ2Zvcm11bGEnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxKSxcbiAgJ2hlYWRlcic6IHtcbiAgICAnMSc6IF9fd2VicGFja19yZXF1aXJlX18oOTIpLFxuICAgICcyJzogX193ZWJwYWNrX3JlcXVpcmVfXyg5MylcbiAgfSxcbiAgJ2l0YWxpYyc6IF9fd2VicGFja19yZXF1aXJlX18oOTQpLFxuICAnaW1hZ2UnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KSxcbiAgJ2luZGVudCc6IHtcbiAgICAnKzEnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2KSxcbiAgICAnLTEnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KVxuICB9LFxuICAnbGluayc6IF9fd2VicGFja19yZXF1aXJlX18oOTgpLFxuICAnbGlzdCc6IHtcbiAgICAnb3JkZXJlZCc6IF9fd2VicGFja19yZXF1aXJlX18oOTkpLFxuICAgICdidWxsZXQnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMCksXG4gICAgJ2NoZWNrJzogX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpXG4gIH0sXG4gICdzY3JpcHQnOiB7XG4gICAgJ3N1Yic6IF9fd2VicGFja19yZXF1aXJlX18oMTAyKSxcbiAgICAnc3VwZXInOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMylcbiAgfSxcbiAgJ3N0cmlrZSc6IF9fd2VicGFja19yZXF1aXJlX18oMTA0KSxcbiAgJ3VuZGVybGluZSc6IF9fd2VicGFja19yZXF1aXJlX18oMTA1KSxcbiAgJ3ZpZGVvJzogX193ZWJwYWNrX3JlcXVpcmVfXygxMDYpXG59O1xuXG4vKioqLyB9KSxcbi8qIDQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldExhc3RDaGFuZ2VJbmRleCA9IGV4cG9ydHMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX3F1aWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9xdWlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbCk7XG5cbnZhciBfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9tb2R1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSGlzdG9yeSA9IGZ1bmN0aW9uIChfTW9kdWxlKSB7XG4gIF9pbmhlcml0cyhIaXN0b3J5LCBfTW9kdWxlKTtcblxuICBmdW5jdGlvbiBIaXN0b3J5KHF1aWxsLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhpc3RvcnkpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEhpc3RvcnkuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihIaXN0b3J5KSkuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMubGFzdFJlY29yZGVkID0gMDtcbiAgICBfdGhpcy5pZ25vcmVDaGFuZ2UgPSBmYWxzZTtcbiAgICBfdGhpcy5jbGVhcigpO1xuICAgIF90aGlzLnF1aWxsLm9uKF9xdWlsbDIuZGVmYXVsdC5ldmVudHMuRURJVE9SX0NIQU5HRSwgZnVuY3Rpb24gKGV2ZW50TmFtZSwgZGVsdGEsIG9sZERlbHRhLCBzb3VyY2UpIHtcbiAgICAgIGlmIChldmVudE5hbWUgIT09IF9xdWlsbDIuZGVmYXVsdC5ldmVudHMuVEVYVF9DSEFOR0UgfHwgX3RoaXMuaWdub3JlQ2hhbmdlKSByZXR1cm47XG4gICAgICBpZiAoIV90aGlzLm9wdGlvbnMudXNlck9ubHkgfHwgc291cmNlID09PSBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKSB7XG4gICAgICAgIF90aGlzLnJlY29yZChkZWx0YSwgb2xkRGVsdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMudHJhbnNmb3JtKGRlbHRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpcy5xdWlsbC5rZXlib2FyZC5hZGRCaW5kaW5nKHsga2V5OiAnWicsIHNob3J0S2V5OiB0cnVlIH0sIF90aGlzLnVuZG8uYmluZChfdGhpcykpO1xuICAgIF90aGlzLnF1aWxsLmtleWJvYXJkLmFkZEJpbmRpbmcoeyBrZXk6ICdaJywgc2hvcnRLZXk6IHRydWUsIHNoaWZ0S2V5OiB0cnVlIH0sIF90aGlzLnJlZG8uYmluZChfdGhpcykpO1xuICAgIGlmICgvV2luL2kudGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pKSB7XG4gICAgICBfdGhpcy5xdWlsbC5rZXlib2FyZC5hZGRCaW5kaW5nKHsga2V5OiAnWScsIHNob3J0S2V5OiB0cnVlIH0sIF90aGlzLnJlZG8uYmluZChfdGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSGlzdG9yeSwgW3tcbiAgICBrZXk6ICdjaGFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2Uoc291cmNlLCBkZXN0KSB7XG4gICAgICBpZiAodGhpcy5zdGFja1tzb3VyY2VdLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIGRlbHRhID0gdGhpcy5zdGFja1tzb3VyY2VdLnBvcCgpO1xuICAgICAgdGhpcy5zdGFja1tkZXN0XS5wdXNoKGRlbHRhKTtcbiAgICAgIHRoaXMubGFzdFJlY29yZGVkID0gMDtcbiAgICAgIHRoaXMuaWdub3JlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIHRoaXMucXVpbGwudXBkYXRlQ29udGVudHMoZGVsdGFbc291cmNlXSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB0aGlzLmlnbm9yZUNoYW5nZSA9IGZhbHNlO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0TGFzdENoYW5nZUluZGV4KGRlbHRhW3NvdXJjZV0pO1xuICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NsZWFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLnN0YWNrID0geyB1bmRvOiBbXSwgcmVkbzogW10gfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjdXRvZmYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXRvZmYoKSB7XG4gICAgICB0aGlzLmxhc3RSZWNvcmRlZCA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVjb3JkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb3JkKGNoYW5nZURlbHRhLCBvbGREZWx0YSkge1xuICAgICAgaWYgKGNoYW5nZURlbHRhLm9wcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHRoaXMuc3RhY2sucmVkbyA9IFtdO1xuICAgICAgdmFyIHVuZG9EZWx0YSA9IHRoaXMucXVpbGwuZ2V0Q29udGVudHMoKS5kaWZmKG9sZERlbHRhKTtcbiAgICAgIHZhciB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKHRoaXMubGFzdFJlY29yZGVkICsgdGhpcy5vcHRpb25zLmRlbGF5ID4gdGltZXN0YW1wICYmIHRoaXMuc3RhY2sudW5kby5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IHRoaXMuc3RhY2sudW5kby5wb3AoKTtcbiAgICAgICAgdW5kb0RlbHRhID0gdW5kb0RlbHRhLmNvbXBvc2UoZGVsdGEudW5kbyk7XG4gICAgICAgIGNoYW5nZURlbHRhID0gZGVsdGEucmVkby5jb21wb3NlKGNoYW5nZURlbHRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdFJlY29yZGVkID0gdGltZXN0YW1wO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGFjay51bmRvLnB1c2goe1xuICAgICAgICByZWRvOiBjaGFuZ2VEZWx0YSxcbiAgICAgICAgdW5kbzogdW5kb0RlbHRhXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnN0YWNrLnVuZG8ubGVuZ3RoID4gdGhpcy5vcHRpb25zLm1heFN0YWNrKSB7XG4gICAgICAgIHRoaXMuc3RhY2sudW5kby5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlZG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWRvKCkge1xuICAgICAgdGhpcy5jaGFuZ2UoJ3JlZG8nLCAndW5kbycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RyYW5zZm9ybScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybShkZWx0YSkge1xuICAgICAgdGhpcy5zdGFjay51bmRvLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICBjaGFuZ2UudW5kbyA9IGRlbHRhLnRyYW5zZm9ybShjaGFuZ2UudW5kbywgdHJ1ZSk7XG4gICAgICAgIGNoYW5nZS5yZWRvID0gZGVsdGEudHJhbnNmb3JtKGNoYW5nZS5yZWRvLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdGFjay5yZWRvLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICBjaGFuZ2UudW5kbyA9IGRlbHRhLnRyYW5zZm9ybShjaGFuZ2UudW5kbywgdHJ1ZSk7XG4gICAgICAgIGNoYW5nZS5yZWRvID0gZGVsdGEudHJhbnNmb3JtKGNoYW5nZS5yZWRvLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VuZG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmRvKCkge1xuICAgICAgdGhpcy5jaGFuZ2UoJ3VuZG8nLCAncmVkbycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIaXN0b3J5O1xufShfbW9kdWxlMi5kZWZhdWx0KTtcblxuSGlzdG9yeS5ERUZBVUxUUyA9IHtcbiAgZGVsYXk6IDEwMDAsXG4gIG1heFN0YWNrOiAxMDAsXG4gIHVzZXJPbmx5OiBmYWxzZVxufTtcblxuZnVuY3Rpb24gZW5kc1dpdGhOZXdsaW5lQ2hhbmdlKGRlbHRhKSB7XG4gIHZhciBsYXN0T3AgPSBkZWx0YS5vcHNbZGVsdGEub3BzLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdE9wID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKGxhc3RPcC5pbnNlcnQgIT0gbnVsbCkge1xuICAgIHJldHVybiB0eXBlb2YgbGFzdE9wLmluc2VydCA9PT0gJ3N0cmluZycgJiYgbGFzdE9wLmluc2VydC5lbmRzV2l0aCgnXFxuJyk7XG4gIH1cbiAgaWYgKGxhc3RPcC5hdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobGFzdE9wLmF0dHJpYnV0ZXMpLnNvbWUoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHJldHVybiBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KGF0dHIsIF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0spICE9IG51bGw7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRMYXN0Q2hhbmdlSW5kZXgoZGVsdGEpIHtcbiAgdmFyIGRlbGV0ZUxlbmd0aCA9IGRlbHRhLnJlZHVjZShmdW5jdGlvbiAobGVuZ3RoLCBvcCkge1xuICAgIGxlbmd0aCArPSBvcC5kZWxldGUgfHwgMDtcbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9LCAwKTtcbiAgdmFyIGNoYW5nZUluZGV4ID0gZGVsdGEubGVuZ3RoKCkgLSBkZWxldGVMZW5ndGg7XG4gIGlmIChlbmRzV2l0aE5ld2xpbmVDaGFuZ2UoZGVsdGEpKSB7XG4gICAgY2hhbmdlSW5kZXggLT0gMTtcbiAgfVxuICByZXR1cm4gY2hhbmdlSW5kZXg7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEhpc3Rvcnk7XG5leHBvcnRzLmdldExhc3RDaGFuZ2VJbmRleCA9IGdldExhc3RDaGFuZ2VJbmRleDtcblxuLyoqKi8gfSksXG4vKiA0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5CYXNlVG9vbHRpcCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2V4dGVuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZXh0ZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZCk7XG5cbnZhciBfcXVpbGxEZWx0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfcXVpbGxEZWx0YTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbERlbHRhKTtcblxudmFyIF9lbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9lbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VtaXR0ZXIpO1xuXG52YXIgX2tleWJvYXJkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBfa2V5Ym9hcmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5Ym9hcmQpO1xuXG52YXIgX3RoZW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cbnZhciBfdGhlbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGhlbWUpO1xuXG52YXIgX2NvbG9yUGlja2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XG5cbnZhciBfY29sb3JQaWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29sb3JQaWNrZXIpO1xuXG52YXIgX2ljb25QaWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcblxudmFyIF9pY29uUGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ljb25QaWNrZXIpO1xuXG52YXIgX3BpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG52YXIgX3BpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9waWNrZXIpO1xuXG52YXIgX3Rvb2x0aXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcblxudmFyIF90b29sdGlwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Rvb2x0aXApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBBTElHTlMgPSBbZmFsc2UsICdjZW50ZXInLCAncmlnaHQnLCAnanVzdGlmeSddO1xuXG52YXIgQ09MT1JTID0gW1wiIzAwMDAwMFwiLCBcIiNlNjAwMDBcIiwgXCIjZmY5OTAwXCIsIFwiI2ZmZmYwMFwiLCBcIiMwMDhhMDBcIiwgXCIjMDA2NmNjXCIsIFwiIzk5MzNmZlwiLCBcIiNmZmZmZmZcIiwgXCIjZmFjY2NjXCIsIFwiI2ZmZWJjY1wiLCBcIiNmZmZmY2NcIiwgXCIjY2NlOGNjXCIsIFwiI2NjZTBmNVwiLCBcIiNlYmQ2ZmZcIiwgXCIjYmJiYmJiXCIsIFwiI2YwNjY2NlwiLCBcIiNmZmMyNjZcIiwgXCIjZmZmZjY2XCIsIFwiIzY2Yjk2NlwiLCBcIiM2NmEzZTBcIiwgXCIjYzI4NWZmXCIsIFwiIzg4ODg4OFwiLCBcIiNhMTAwMDBcIiwgXCIjYjI2YjAwXCIsIFwiI2IyYjIwMFwiLCBcIiMwMDYxMDBcIiwgXCIjMDA0N2IyXCIsIFwiIzZiMjRiMlwiLCBcIiM0NDQ0NDRcIiwgXCIjNWMwMDAwXCIsIFwiIzY2M2QwMFwiLCBcIiM2NjY2MDBcIiwgXCIjMDAzNzAwXCIsIFwiIzAwMjk2NlwiLCBcIiMzZDE0NjZcIl07XG5cbnZhciBGT05UUyA9IFtmYWxzZSwgJ3NlcmlmJywgJ21vbm9zcGFjZSddO1xuXG52YXIgSEVBREVSUyA9IFsnMScsICcyJywgJzMnLCBmYWxzZV07XG5cbnZhciBTSVpFUyA9IFsnc21hbGwnLCBmYWxzZSwgJ2xhcmdlJywgJ2h1Z2UnXTtcblxudmFyIEJhc2VUaGVtZSA9IGZ1bmN0aW9uIChfVGhlbWUpIHtcbiAgX2luaGVyaXRzKEJhc2VUaGVtZSwgX1RoZW1lKTtcblxuICBmdW5jdGlvbiBCYXNlVGhlbWUocXVpbGwsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZVRoZW1lKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCYXNlVGhlbWUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXNlVGhlbWUpKS5jYWxsKHRoaXMsIHF1aWxsLCBvcHRpb25zKSk7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcihlKSB7XG4gICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMocXVpbGwucm9vdCkpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMudG9vbHRpcCAhPSBudWxsICYmICFfdGhpcy50b29sdGlwLnJvb3QuY29udGFpbnMoZS50YXJnZXQpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IF90aGlzLnRvb2x0aXAudGV4dGJveCAmJiAhX3RoaXMucXVpbGwuaGFzRm9jdXMoKSkge1xuICAgICAgICBfdGhpcy50b29sdGlwLmhpZGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5waWNrZXJzICE9IG51bGwpIHtcbiAgICAgICAgX3RoaXMucGlja2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChwaWNrZXIpIHtcbiAgICAgICAgICBpZiAoIXBpY2tlci5jb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICBwaWNrZXIuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgcXVpbGwuZW1pdHRlci5saXN0ZW5ET00oJ2NsaWNrJywgZG9jdW1lbnQuYm9keSwgbGlzdGVuZXIpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlVGhlbWUsIFt7XG4gICAga2V5OiAnYWRkTW9kdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTW9kdWxlKG5hbWUpIHtcbiAgICAgIHZhciBtb2R1bGUgPSBfZ2V0KEJhc2VUaGVtZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXNlVGhlbWUucHJvdG90eXBlKSwgJ2FkZE1vZHVsZScsIHRoaXMpLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICBpZiAobmFtZSA9PT0gJ3Rvb2xiYXInKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5kVG9vbGJhcihtb2R1bGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdidWlsZEJ1dHRvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZEJ1dHRvbnMoYnV0dG9ucywgaWNvbnMpIHtcbiAgICAgIGJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbiAoYnV0dG9uKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBidXR0b24uZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICAgICAgICBjbGFzc05hbWUuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgaWYgKCFuYW1lLnN0YXJ0c1dpdGgoJ3FsLScpKSByZXR1cm47XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoJ3FsLScubGVuZ3RoKTtcbiAgICAgICAgICBpZiAoaWNvbnNbbmFtZV0gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgIGlmIChuYW1lID09PSAnZGlyZWN0aW9uJykge1xuICAgICAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9IGljb25zW25hbWVdWycnXSArIGljb25zW25hbWVdWydydGwnXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpY29uc1tuYW1lXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSBpY29uc1tuYW1lXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYnV0dG9uLnZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgaWNvbnNbbmFtZV1bdmFsdWVdKSB7XG4gICAgICAgICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSBpY29uc1tuYW1lXVt2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkUGlja2VycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkUGlja2VycyhzZWxlY3RzLCBpY29ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMucGlja2VycyA9IHNlbGVjdHMubWFwKGZ1bmN0aW9uIChzZWxlY3QpIHtcbiAgICAgICAgaWYgKHNlbGVjdC5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWFsaWduJykpIHtcbiAgICAgICAgICBpZiAoc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvbicpID09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbGxTZWxlY3Qoc2VsZWN0LCBBTElHTlMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IF9pY29uUGlja2VyMi5kZWZhdWx0KHNlbGVjdCwgaWNvbnMuYWxpZ24pO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdC5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWJhY2tncm91bmQnKSB8fCBzZWxlY3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1jb2xvcicpKSB7XG4gICAgICAgICAgdmFyIGZvcm1hdCA9IHNlbGVjdC5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWJhY2tncm91bmQnKSA/ICdiYWNrZ3JvdW5kJyA6ICdjb2xvcic7XG4gICAgICAgICAgaWYgKHNlbGVjdC5xdWVyeVNlbGVjdG9yKCdvcHRpb24nKSA9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWxsU2VsZWN0KHNlbGVjdCwgQ09MT1JTLCBmb3JtYXQgPT09ICdiYWNrZ3JvdW5kJyA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgX2NvbG9yUGlja2VyMi5kZWZhdWx0KHNlbGVjdCwgaWNvbnNbZm9ybWF0XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNlbGVjdC5xdWVyeVNlbGVjdG9yKCdvcHRpb24nKSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0LmNsYXNzTGlzdC5jb250YWlucygncWwtZm9udCcpKSB7XG4gICAgICAgICAgICAgIGZpbGxTZWxlY3Qoc2VsZWN0LCBGT05UUyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdC5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWhlYWRlcicpKSB7XG4gICAgICAgICAgICAgIGZpbGxTZWxlY3Qoc2VsZWN0LCBIRUFERVJTKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0LmNsYXNzTGlzdC5jb250YWlucygncWwtc2l6ZScpKSB7XG4gICAgICAgICAgICAgIGZpbGxTZWxlY3Qoc2VsZWN0LCBTSVpFUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgX3BpY2tlcjIuZGVmYXVsdChzZWxlY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgIF90aGlzMi5waWNrZXJzLmZvckVhY2goZnVuY3Rpb24gKHBpY2tlcikge1xuICAgICAgICAgIHBpY2tlci51cGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5xdWlsbC5vbihfZW1pdHRlcjIuZGVmYXVsdC5ldmVudHMuRURJVE9SX0NIQU5HRSwgdXBkYXRlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZVRoZW1lO1xufShfdGhlbWUyLmRlZmF1bHQpO1xuXG5CYXNlVGhlbWUuREVGQVVMVFMgPSAoMCwgX2V4dGVuZDIuZGVmYXVsdCkodHJ1ZSwge30sIF90aGVtZTIuZGVmYXVsdC5ERUZBVUxUUywge1xuICBtb2R1bGVzOiB7XG4gICAgdG9vbGJhcjoge1xuICAgICAgaGFuZGxlcnM6IHtcbiAgICAgICAgZm9ybXVsYTogZnVuY3Rpb24gZm9ybXVsYSgpIHtcbiAgICAgICAgICB0aGlzLnF1aWxsLnRoZW1lLnRvb2x0aXAuZWRpdCgnZm9ybXVsYScpO1xuICAgICAgICB9LFxuICAgICAgICBpbWFnZTogZnVuY3Rpb24gaW1hZ2UoKSB7XG4gICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICB2YXIgZmlsZUlucHV0ID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcignaW5wdXQucWwtaW1hZ2VbdHlwZT1maWxlXScpO1xuICAgICAgICAgIGlmIChmaWxlSW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZmlsZUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgIGZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnZmlsZScpO1xuICAgICAgICAgICAgZmlsZUlucHV0LnNldEF0dHJpYnV0ZSgnYWNjZXB0JywgJ2ltYWdlL3BuZywgaW1hZ2UvZ2lmLCBpbWFnZS9qcGVnLCBpbWFnZS9ibXAsIGltYWdlL3gtaWNvbicpO1xuICAgICAgICAgICAgZmlsZUlucHV0LmNsYXNzTGlzdC5hZGQoJ3FsLWltYWdlJyk7XG4gICAgICAgICAgICBmaWxlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoZmlsZUlucHV0LmZpbGVzICE9IG51bGwgJiYgZmlsZUlucHV0LmZpbGVzWzBdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IF90aGlzMy5xdWlsbC5nZXRTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICBfdGhpczMucXVpbGwudXBkYXRlQ29udGVudHMobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKHJhbmdlLmluZGV4KS5kZWxldGUocmFuZ2UubGVuZ3RoKS5pbnNlcnQoeyBpbWFnZTogZS50YXJnZXQucmVzdWx0IH0pLCBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICAgICAgICAgICAgX3RoaXMzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCArIDEsIF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgICAgICAgICAgICAgIGZpbGVJbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlSW5wdXQuZmlsZXNbMF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGVJbnB1dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbGVJbnB1dC5jbGljaygpO1xuICAgICAgICB9LFxuICAgICAgICB2aWRlbzogZnVuY3Rpb24gdmlkZW8oKSB7XG4gICAgICAgICAgdGhpcy5xdWlsbC50aGVtZS50b29sdGlwLmVkaXQoJ3ZpZGVvJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgQmFzZVRvb2x0aXAgPSBmdW5jdGlvbiAoX1Rvb2x0aXApIHtcbiAgX2luaGVyaXRzKEJhc2VUb29sdGlwLCBfVG9vbHRpcCk7XG5cbiAgZnVuY3Rpb24gQmFzZVRvb2x0aXAocXVpbGwsIGJvdW5kc0NvbnRhaW5lcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlVG9vbHRpcCk7XG5cbiAgICB2YXIgX3RoaXM0ID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJhc2VUb29sdGlwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmFzZVRvb2x0aXApKS5jYWxsKHRoaXMsIHF1aWxsLCBib3VuZHNDb250YWluZXIpKTtcblxuICAgIF90aGlzNC50ZXh0Ym94ID0gX3RoaXM0LnJvb3QucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cInRleHRcIl0nKTtcbiAgICBfdGhpczQubGlzdGVuKCk7XG4gICAgcmV0dXJuIF90aGlzNDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlVG9vbHRpcCwgW3tcbiAgICBrZXk6ICdsaXN0ZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW4oKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdGhpcy50ZXh0Ym94LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKF9rZXlib2FyZDIuZGVmYXVsdC5tYXRjaChldmVudCwgJ2VudGVyJykpIHtcbiAgICAgICAgICBfdGhpczUuc2F2ZSgpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2tleWJvYXJkMi5kZWZhdWx0Lm1hdGNoKGV2ZW50LCAnZXNjYXBlJykpIHtcbiAgICAgICAgICBfdGhpczUuY2FuY2VsKCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FuY2VsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZWRpdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXQoKSB7XG4gICAgICB2YXIgbW9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2xpbmsnO1xuICAgICAgdmFyIHByZXZpZXcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgIHRoaXMucm9vdC5jbGFzc0xpc3QucmVtb3ZlKCdxbC1oaWRkZW4nKTtcbiAgICAgIHRoaXMucm9vdC5jbGFzc0xpc3QuYWRkKCdxbC1lZGl0aW5nJyk7XG4gICAgICBpZiAocHJldmlldyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudGV4dGJveC52YWx1ZSA9IHByZXZpZXc7XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgIT09IHRoaXMucm9vdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kZScpKSB7XG4gICAgICAgIHRoaXMudGV4dGJveC52YWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgdGhpcy5wb3NpdGlvbih0aGlzLnF1aWxsLmdldEJvdW5kcyh0aGlzLnF1aWxsLnNlbGVjdGlvbi5zYXZlZFJhbmdlKSk7XG4gICAgICB0aGlzLnRleHRib3guc2VsZWN0KCk7XG4gICAgICB0aGlzLnRleHRib3guc2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsIHRoaXMudGV4dGJveC5nZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIG1vZGUpIHx8ICcnKTtcbiAgICAgIHRoaXMucm9vdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kZScsIG1vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc3RvcmVGb2N1cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3RvcmVGb2N1cygpIHtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLnF1aWxsLnNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3A7XG4gICAgICB0aGlzLnF1aWxsLmZvY3VzKCk7XG4gICAgICB0aGlzLnF1aWxsLnNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2F2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnRleHRib3gudmFsdWU7XG4gICAgICBzd2l0Y2ggKHRoaXMucm9vdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kZScpKSB7XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLnF1aWxsLnJvb3Quc2Nyb2xsVG9wO1xuICAgICAgICAgICAgaWYgKHRoaXMubGlua1JhbmdlKSB7XG4gICAgICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0VGV4dCh0aGlzLmxpbmtSYW5nZSwgJ2xpbmsnLCB2YWx1ZSwgX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMubGlua1JhbmdlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlRm9jdXMoKTtcbiAgICAgICAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2xpbmsnLCB2YWx1ZSwgX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucXVpbGwucm9vdC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YWx1ZSA9IGV4dHJhY3RWaWRlb1VybCh2YWx1ZSk7XG4gICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSAnZm9ybXVsYSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkgYnJlYWs7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnF1aWxsLmdldFNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgICAgIGlmIChyYW5nZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IHJhbmdlLmluZGV4ICsgcmFuZ2UubGVuZ3RoO1xuICAgICAgICAgICAgICB0aGlzLnF1aWxsLmluc2VydEVtYmVkKGluZGV4LCB0aGlzLnJvb3QuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGUnKSwgdmFsdWUsIF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnJvb3QuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGUnKSA9PT0gJ2Zvcm11bGEnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWlsbC5pbnNlcnRUZXh0KGluZGV4ICsgMSwgJyAnLCBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKGluZGV4ICsgMiwgX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dGJveC52YWx1ZSA9ICcnO1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VUb29sdGlwO1xufShfdG9vbHRpcDIuZGVmYXVsdCk7XG5cbmZ1bmN0aW9uIGV4dHJhY3RWaWRlb1VybCh1cmwpIHtcbiAgdmFyIG1hdGNoID0gdXJsLm1hdGNoKC9eKD86KGh0dHBzPyk6XFwvXFwvKT8oPzooPzp3d3d8bSlcXC4pP3lvdXR1YmVcXC5jb21cXC93YXRjaC4qdj0oW2EtekEtWjAtOV8tXSspLykgfHwgdXJsLm1hdGNoKC9eKD86KGh0dHBzPyk6XFwvXFwvKT8oPzooPzp3d3d8bSlcXC4pP3lvdXR1XFwuYmVcXC8oW2EtekEtWjAtOV8tXSspLyk7XG4gIGlmIChtYXRjaCkge1xuICAgIHJldHVybiAobWF0Y2hbMV0gfHwgJ2h0dHBzJykgKyAnOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkLycgKyBtYXRjaFsyXSArICc/c2hvd2luZm89MCc7XG4gIH1cbiAgaWYgKG1hdGNoID0gdXJsLm1hdGNoKC9eKD86KGh0dHBzPyk6XFwvXFwvKT8oPzp3d3dcXC4pP3ZpbWVvXFwuY29tXFwvKFxcZCspLykpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgcmV0dXJuIChtYXRjaFsxXSB8fCAnaHR0cHMnKSArICc6Ly9wbGF5ZXIudmltZW8uY29tL3ZpZGVvLycgKyBtYXRjaFsyXSArICcvJztcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG5mdW5jdGlvbiBmaWxsU2VsZWN0KHNlbGVjdCwgdmFsdWVzKSB7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBpZiAodmFsdWUgPT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgb3B0aW9uLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnc2VsZWN0ZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9uLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gICAgfVxuICAgIHNlbGVjdC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5CYXNlVG9vbHRpcCA9IEJhc2VUb29sdGlwO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZVRoZW1lO1xuXG4vKioqLyB9KSxcbi8qIDQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTGlua2VkTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5rZWRMaXN0KCkge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBub2Rlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG5vZGVzWzBdLCBudWxsKTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kLmFwcGx5KHRoaXMsIG5vZGVzLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgY3VyLCBuZXh0ID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICB3aGlsZSAoKGN1ciA9IG5leHQoKSkpIHtcbiAgICAgICAgICAgIGlmIChjdXIgPT09IG5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKG5vZGUsIHJlZk5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBub2RlLm5leHQgPSByZWZOb2RlO1xuICAgICAgICBpZiAocmVmTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLnByZXYgPSByZWZOb2RlLnByZXY7XG4gICAgICAgICAgICBpZiAocmVmTm9kZS5wcmV2ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWZOb2RlLnByZXYubmV4dCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWZOb2RlLnByZXYgPSBub2RlO1xuICAgICAgICAgICAgaWYgKHJlZk5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50YWlsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUucHJldiA9IHRoaXMudGFpbDtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLnByZXYgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSAxO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB2YXIgaW5kZXggPSAwLCBjdXIgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlIChjdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN1ciA9PT0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIGluZGV4ICs9IGN1ci5sZW5ndGgoKTtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWlucyhub2RlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG5vZGUucHJldiAhPSBudWxsKVxuICAgICAgICAgICAgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgIGlmIChub2RlLm5leHQgIT0gbnVsbClcbiAgICAgICAgICAgIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2O1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKVxuICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZS5uZXh0O1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKVxuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZS5wcmV2O1xuICAgICAgICB0aGlzLmxlbmd0aCAtPSAxO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiAoY3VyTm9kZSkge1xuICAgICAgICBpZiAoY3VyTm9kZSA9PT0gdm9pZCAwKSB7IGN1ck5vZGUgPSB0aGlzLmhlYWQ7IH1cbiAgICAgICAgLy8gVE9ETyB1c2UgeWllbGQgd2hlbiB3ZSBjYW5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBjdXJOb2RlO1xuICAgICAgICAgICAgaWYgKGN1ck5vZGUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBjdXJOb2RlID0gY3VyTm9kZS5uZXh0O1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoaW5kZXgsIGluY2x1c2l2ZSkge1xuICAgICAgICBpZiAoaW5jbHVzaXZlID09PSB2b2lkIDApIHsgaW5jbHVzaXZlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGN1ciwgbmV4dCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgd2hpbGUgKChjdXIgPSBuZXh0KCkpKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gY3VyLmxlbmd0aCgpO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgKGluY2x1c2l2ZSAmJiBpbmRleCA9PT0gbGVuZ3RoICYmIChjdXIubmV4dCA9PSBudWxsIHx8IGN1ci5uZXh0Lmxlbmd0aCgpICE9PSAwKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2N1ciwgaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggLT0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbnVsbCwgMF07XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjdXIsIG5leHQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIHdoaWxlICgoY3VyID0gbmV4dCgpKSkge1xuICAgICAgICAgICAgY2FsbGJhY2soY3VyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZm9yRWFjaEF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChsZW5ndGggPD0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5maW5kKGluZGV4KSwgc3RhcnROb2RlID0gX2FbMF0sIG9mZnNldCA9IF9hWzFdO1xuICAgICAgICB2YXIgY3VyLCBjdXJJbmRleCA9IGluZGV4IC0gb2Zmc2V0LCBuZXh0ID0gdGhpcy5pdGVyYXRvcihzdGFydE5vZGUpO1xuICAgICAgICB3aGlsZSAoKGN1ciA9IG5leHQoKSkgJiYgY3VySW5kZXggPCBpbmRleCArIGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGN1ckxlbmd0aCA9IGN1ci5sZW5ndGgoKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IGN1ckluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY3VyLCBpbmRleCAtIGN1ckluZGV4LCBNYXRoLm1pbihsZW5ndGgsIGN1ckluZGV4ICsgY3VyTGVuZ3RoIC0gaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGN1ciwgMCwgTWF0aC5taW4oY3VyTGVuZ3RoLCBpbmRleCArIGxlbmd0aCAtIGN1ckluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJJbmRleCArPSBjdXJMZW5ndGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGN1cikge1xuICAgICAgICAgICAgbWVtby5wdXNoKGNhbGxiYWNrKGN1cikpO1xuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH0sIFtdKTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgbWVtbykge1xuICAgICAgICB2YXIgY3VyLCBuZXh0ID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICB3aGlsZSAoKGN1ciA9IG5leHQoKSkpIHtcbiAgICAgICAgICAgIG1lbW8gPSBjYWxsYmFjayhtZW1vLCBjdXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gICAgcmV0dXJuIExpbmtlZExpc3Q7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTGlua2VkTGlzdDtcblxuXG4vKioqLyB9KSxcbi8qIDQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250YWluZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBPQlNFUlZFUl9DT05GSUcgPSB7XG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbn07XG52YXIgTUFYX09QVElNSVpFX0lURVJBVElPTlMgPSAxMDA7XG52YXIgU2Nyb2xsQmxvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2Nyb2xsQmxvdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY3JvbGxCbG90KG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbm9kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2Nyb2xsID0gX3RoaXM7XG4gICAgICAgIF90aGlzLm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlKG11dGF0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vYnNlcnZlci5vYnNlcnZlKF90aGlzLmRvbU5vZGUsIE9CU0VSVkVSX0NPTkZJRyk7XG4gICAgICAgIF90aGlzLmF0dGFjaCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNjcm9sbEJsb3QucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXRhY2guY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgICBTY3JvbGxCbG90LnByb3RvdHlwZS5kZWxldGVBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiBsZW5ndGggPT09IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZWxldGVBdC5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY3JvbGxCbG90LnByb3RvdHlwZS5mb3JtYXRBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmZvcm1hdEF0LmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgIH07XG4gICAgU2Nyb2xsQmxvdC5wcm90b3R5cGUuaW5zZXJ0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnNlcnRBdC5jYWxsKHRoaXMsIGluZGV4LCB2YWx1ZSwgZGVmKTtcbiAgICB9O1xuICAgIFNjcm9sbEJsb3QucHJvdG90eXBlLm9wdGltaXplID0gZnVuY3Rpb24gKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobXV0YXRpb25zID09PSB2b2lkIDApIHsgbXV0YXRpb25zID0gW107IH1cbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vcHRpbWl6ZS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAvLyBXZSBtdXN0IG1vZGlmeSBtdXRhdGlvbnMgZGlyZWN0bHksIGNhbm5vdCBtYWtlIGNvcHkgYW5kIHRoZW4gbW9kaWZ5XG4gICAgICAgIHZhciByZWNvcmRzID0gW10uc2xpY2UuY2FsbCh0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgICAgICAvLyBBcnJheS5wdXNoIGN1cnJlbnRseSBzZWVtcyB0byBiZSBpbXBsZW1lbnRlZCBieSBhIG5vbi10YWlsIHJlY3Vyc2l2ZSBmdW5jdGlvblxuICAgICAgICAvLyBzbyB3ZSBjYW5ub3QganVzdCBtdXRhdGlvbnMucHVzaC5hcHBseShtdXRhdGlvbnMsIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgICAgIHdoaWxlIChyZWNvcmRzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBtdXRhdGlvbnMucHVzaChyZWNvcmRzLnBvcCgpKTtcbiAgICAgICAgLy8gVE9ETyB1c2UgV2Vha01hcFxuICAgICAgICB2YXIgbWFyayA9IGZ1bmN0aW9uIChibG90LCBtYXJrUGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobWFya1BhcmVudCA9PT0gdm9pZCAwKSB7IG1hcmtQYXJlbnQgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAoYmxvdCA9PSBudWxsIHx8IGJsb3QgPT09IF90aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChibG90LmRvbU5vZGUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGJsb3QuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0ubXV0YXRpb25zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFya1BhcmVudClcbiAgICAgICAgICAgICAgICBtYXJrKGJsb3QucGFyZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9wdGltaXplID0gZnVuY3Rpb24gKGJsb3QpIHtcbiAgICAgICAgICAgIC8vIFBvc3Qtb3JkZXIgdHJhdmVyc2FsXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgYmxvdC5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXS5tdXRhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG90IGluc3RhbmNlb2YgY29udGFpbmVyXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGJsb3QuY2hpbGRyZW4uZm9yRWFjaChvcHRpbWl6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG90Lm9wdGltaXplKGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gbXV0YXRpb25zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgcmVtYWluaW5nLmxlbmd0aCA+IDA7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGkgPj0gTUFYX09QVElNSVpFX0lURVJBVElPTlMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tQYXJjaG1lbnRdIE1heGltdW0gb3B0aW1pemUgaXRlcmF0aW9ucyByZWFjaGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1haW5pbmcuZm9yRWFjaChmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvdCA9IFJlZ2lzdHJ5LmZpbmQobXV0YXRpb24udGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvdCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGJsb3QuZG9tTm9kZSA9PT0gbXV0YXRpb24udGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFyayhSZWdpc3RyeS5maW5kKG11dGF0aW9uLnByZXZpb3VzU2libGluZywgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdLmZvckVhY2guY2FsbChtdXRhdGlvbi5hZGRlZE5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IFJlZ2lzdHJ5LmZpbmQobm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmsoY2hpbGQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBjb250YWluZXJfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGdyYW5kQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmsoZ3JhbmRDaGlsZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtdXRhdGlvbi50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmsoYmxvdC5wcmV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXJrKGJsb3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2gob3B0aW1pemUpO1xuICAgICAgICAgICAgcmVtYWluaW5nID0gW10uc2xpY2UuY2FsbCh0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgICAgICAgICAgcmVjb3JkcyA9IHJlbWFpbmluZy5zbGljZSgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlY29yZHMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICBtdXRhdGlvbnMucHVzaChyZWNvcmRzLnBvcCgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsQmxvdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSB7fTsgfVxuICAgICAgICBtdXRhdGlvbnMgPSBtdXRhdGlvbnMgfHwgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAvLyBUT0RPIHVzZSBXZWFrTWFwXG4gICAgICAgIG11dGF0aW9uc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBibG90ID0gUmVnaXN0cnkuZmluZChtdXRhdGlvbi50YXJnZXQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGJsb3QgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGJsb3QuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0ubXV0YXRpb25zID0gW211dGF0aW9uXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucy5wdXNoKG11dGF0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChibG90KSB7XG4gICAgICAgICAgICBpZiAoYmxvdCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgYmxvdCA9PT0gX3RoaXMgfHxcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgYmxvdC51cGRhdGUoYmxvdC5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXS5tdXRhdGlvbnMgfHwgW10sIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAodGhpcy5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXS5tdXRhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCB0aGlzLmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpbWl6ZShtdXRhdGlvbnMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgU2Nyb2xsQmxvdC5ibG90TmFtZSA9ICdzY3JvbGwnO1xuICAgIFNjcm9sbEJsb3QuZGVmYXVsdENoaWxkID0gJ2Jsb2NrJztcbiAgICBTY3JvbGxCbG90LnNjb3BlID0gUmVnaXN0cnkuU2NvcGUuQkxPQ0tfQkxPVDtcbiAgICBTY3JvbGxCbG90LnRhZ05hbWUgPSAnRElWJztcbiAgICByZXR1cm4gU2Nyb2xsQmxvdDtcbn0oY29udGFpbmVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU2Nyb2xsQmxvdDtcblxuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBmb3JtYXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8vIFNoYWxsb3cgb2JqZWN0IGNvbXBhcmlzb25cbmZ1bmN0aW9uIGlzRXF1YWwob2JqMSwgb2JqMikge1xuICAgIGlmIChPYmplY3Qua2V5cyhvYmoxKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iajIpLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iajEpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAob2JqMVtwcm9wXSAhPT0gb2JqMltwcm9wXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG52YXIgSW5saW5lQmxvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5saW5lQmxvdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmxpbmVCbG90KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIElubGluZUJsb3QuZm9ybWF0cyA9IGZ1bmN0aW9uIChkb21Ob2RlKSB7XG4gICAgICAgIGlmIChkb21Ob2RlLnRhZ05hbWUgPT09IElubGluZUJsb3QudGFnTmFtZSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBfc3VwZXIuZm9ybWF0cy5jYWxsKHRoaXMsIGRvbU5vZGUpO1xuICAgIH07XG4gICAgSW5saW5lQmxvdC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChuYW1lID09PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBmb3JtYXRfMS5kZWZhdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLndyYXAoSW5saW5lQmxvdC5ibG90TmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZXMuY29weShjaGlsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudW53cmFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmZvcm1hdC5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5saW5lQmxvdC5wcm90b3R5cGUuZm9ybWF0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0cygpW25hbWVdICE9IG51bGwgfHwgUmVnaXN0cnkucXVlcnkobmFtZSwgUmVnaXN0cnkuU2NvcGUuQVRUUklCVVRFKSkge1xuICAgICAgICAgICAgdmFyIGJsb3QgPSB0aGlzLmlzb2xhdGUoaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgICAgICBibG90LmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmZvcm1hdEF0LmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmxpbmVCbG90LnByb3RvdHlwZS5vcHRpbWl6ZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub3B0aW1pemUuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIGZvcm1hdHMgPSB0aGlzLmZvcm1hdHMoKTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGZvcm1hdHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW53cmFwKCk7IC8vIHVuZm9ybWF0dGVkIHNwYW5cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dDtcbiAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBJbmxpbmVCbG90ICYmIG5leHQucHJldiA9PT0gdGhpcyAmJiBpc0VxdWFsKGZvcm1hdHMsIG5leHQuZm9ybWF0cygpKSkge1xuICAgICAgICAgICAgbmV4dC5tb3ZlQ2hpbGRyZW4odGhpcyk7XG4gICAgICAgICAgICBuZXh0LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmxpbmVCbG90LmJsb3ROYW1lID0gJ2lubGluZSc7XG4gICAgSW5saW5lQmxvdC5zY29wZSA9IFJlZ2lzdHJ5LlNjb3BlLklOTElORV9CTE9UO1xuICAgIElubGluZUJsb3QudGFnTmFtZSA9ICdTUEFOJztcbiAgICByZXR1cm4gSW5saW5lQmxvdDtcbn0oZm9ybWF0XzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSW5saW5lQmxvdDtcblxuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBmb3JtYXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBCbG9ja0Jsb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrQmxvdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja0Jsb3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQmxvY2tCbG90LmZvcm1hdHMgPSBmdW5jdGlvbiAoZG9tTm9kZSkge1xuICAgICAgICB2YXIgdGFnTmFtZSA9IFJlZ2lzdHJ5LnF1ZXJ5KEJsb2NrQmxvdC5ibG90TmFtZSkudGFnTmFtZTtcbiAgICAgICAgaWYgKGRvbU5vZGUudGFnTmFtZSA9PT0gdGFnTmFtZSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBfc3VwZXIuZm9ybWF0cy5jYWxsKHRoaXMsIGRvbU5vZGUpO1xuICAgIH07XG4gICAgQmxvY2tCbG90LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKFJlZ2lzdHJ5LnF1ZXJ5KG5hbWUsIFJlZ2lzdHJ5LlNjb3BlLkJMT0NLKSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aChCbG9ja0Jsb3QuYmxvdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5mb3JtYXQuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJsb2NrQmxvdC5wcm90b3R5cGUuZm9ybWF0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKFJlZ2lzdHJ5LnF1ZXJ5KG5hbWUsIFJlZ2lzdHJ5LlNjb3BlLkJMT0NLKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmZvcm1hdEF0LmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCbG9ja0Jsb3QucHJvdG90eXBlLmluc2VydEF0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICAgIGlmIChkZWYgPT0gbnVsbCB8fCBSZWdpc3RyeS5xdWVyeSh2YWx1ZSwgUmVnaXN0cnkuU2NvcGUuSU5MSU5FKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgdGV4dCBvciBpbmxpbmVcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5zZXJ0QXQuY2FsbCh0aGlzLCBpbmRleCwgdmFsdWUsIGRlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLnNwbGl0KGluZGV4KTtcbiAgICAgICAgICAgIHZhciBibG90ID0gUmVnaXN0cnkuY3JlYXRlKHZhbHVlLCBkZWYpO1xuICAgICAgICAgICAgYWZ0ZXIucGFyZW50Lmluc2VydEJlZm9yZShibG90LCBhZnRlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJsb2NrQmxvdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVHJpZGVudC8pKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIG11dGF0aW9ucywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJsb2NrQmxvdC5ibG90TmFtZSA9ICdibG9jayc7XG4gICAgQmxvY2tCbG90LnNjb3BlID0gUmVnaXN0cnkuU2NvcGUuQkxPQ0tfQkxPVDtcbiAgICBCbG9ja0Jsb3QudGFnTmFtZSA9ICdQJztcbiAgICByZXR1cm4gQmxvY2tCbG90O1xufShmb3JtYXRfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCbG9ja0Jsb3Q7XG5cblxuLyoqKi8gfSksXG4vKiA0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGVhZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG52YXIgRW1iZWRCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbWJlZEJsb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1iZWRCbG90KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEVtYmVkQmxvdC5mb3JtYXRzID0gZnVuY3Rpb24gKGRvbU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEVtYmVkQmxvdC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIC8vIHN1cGVyLmZvcm1hdEF0IHdyYXBzLCB3aGljaCBpcyB3aGF0IHdlIHdhbnQgaW4gZ2VuZXJhbCxcbiAgICAgICAgLy8gYnV0IHRoaXMgYWxsb3dzIHN1YmNsYXNzZXMgdG8gb3ZlcndyaXRlIGZvciBmb3JtYXRzXG4gICAgICAgIC8vIHRoYXQganVzdCBhcHBseSB0byBwYXJ0aWN1bGFyIGVtYmVkc1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmZvcm1hdEF0LmNhbGwodGhpcywgMCwgdGhpcy5sZW5ndGgoKSwgbmFtZSwgdmFsdWUpO1xuICAgIH07XG4gICAgRW1iZWRCbG90LnByb3RvdHlwZS5mb3JtYXRBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgbGVuZ3RoID09PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmZvcm1hdEF0LmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbWJlZEJsb3QucHJvdG90eXBlLmZvcm1hdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRpY3MuZm9ybWF0cyh0aGlzLmRvbU5vZGUpO1xuICAgIH07XG4gICAgcmV0dXJuIEVtYmVkQmxvdDtcbn0obGVhZl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVtYmVkQmxvdDtcblxuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsZWFmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgVGV4dEJsb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRleHRCbG90LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRleHRCbG90KG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbm9kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGV4dCA9IF90aGlzLnN0YXRpY3MudmFsdWUoX3RoaXMuZG9tTm9kZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGV4dEJsb3QuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gICAgfTtcbiAgICBUZXh0QmxvdC52YWx1ZSA9IGZ1bmN0aW9uIChkb21Ob2RlKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZG9tTm9kZS5kYXRhO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh0ZXh0Wydub3JtYWxpemUnXSlcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0Wydub3JtYWxpemUnXSgpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIFRleHRCbG90LnByb3RvdHlwZS5kZWxldGVBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZG9tTm9kZS5kYXRhID0gdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGluZGV4KSArIHRoaXMudGV4dC5zbGljZShpbmRleCArIGxlbmd0aCk7XG4gICAgfTtcbiAgICBUZXh0QmxvdC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbiAobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmRvbU5vZGUgPT09IG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgVGV4dEJsb3QucHJvdG90eXBlLmluc2VydEF0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICAgIGlmIChkZWYgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGluZGV4KSArIHZhbHVlICsgdGhpcy50ZXh0LnNsaWNlKGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuZG9tTm9kZS5kYXRhID0gdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnNlcnRBdC5jYWxsKHRoaXMsIGluZGV4LCB2YWx1ZSwgZGVmKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEJsb3QucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7XG4gICAgfTtcbiAgICBUZXh0QmxvdC5wcm90b3R5cGUub3B0aW1pemUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9wdGltaXplLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMuc3RhdGljcy52YWx1ZSh0aGlzLmRvbU5vZGUpO1xuICAgICAgICBpZiAodGhpcy50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQgaW5zdGFuY2VvZiBUZXh0QmxvdCAmJiB0aGlzLm5leHQucHJldiA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRBdCh0aGlzLmxlbmd0aCgpLCB0aGlzLm5leHQudmFsdWUoKSk7XG4gICAgICAgICAgICB0aGlzLm5leHQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRCbG90LnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uIChpbmRleCwgaW5jbHVzaXZlKSB7XG4gICAgICAgIGlmIChpbmNsdXNpdmUgPT09IHZvaWQgMCkgeyBpbmNsdXNpdmUgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gW3RoaXMuZG9tTm9kZSwgaW5kZXhdO1xuICAgIH07XG4gICAgVGV4dEJsb3QucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKGluZGV4LCBmb3JjZSkge1xuICAgICAgICBpZiAoZm9yY2UgPT09IHZvaWQgMCkgeyBmb3JjZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmICghZm9yY2UpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5sZW5ndGgoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZnRlciA9IFJlZ2lzdHJ5LmNyZWF0ZSh0aGlzLmRvbU5vZGUuc3BsaXRUZXh0KGluZGV4KSk7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShhZnRlciwgdGhpcy5uZXh0KTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5zdGF0aWNzLnZhbHVlKHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIHJldHVybiBhZnRlcjtcbiAgICB9O1xuICAgIFRleHRCbG90LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChtdXRhdGlvbnMuc29tZShmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgbXV0YXRpb24udGFyZ2V0ID09PSBfdGhpcy5kb21Ob2RlO1xuICAgICAgICB9KSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5zdGF0aWNzLnZhbHVlKHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRCbG90LnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9O1xuICAgIFRleHRCbG90LmJsb3ROYW1lID0gJ3RleHQnO1xuICAgIFRleHRCbG90LnNjb3BlID0gUmVnaXN0cnkuU2NvcGUuSU5MSU5FX0JMT1Q7XG4gICAgcmV0dXJuIFRleHRCbG90O1xufShsZWFmXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVGV4dEJsb3Q7XG5cblxuLyoqKi8gfSksXG4vKiA1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuZWxlbS5jbGFzc0xpc3QudG9nZ2xlKCd0ZXN0LWNsYXNzJywgZmFsc2UpO1xuaWYgKGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZXN0LWNsYXNzJykpIHtcbiAgdmFyIF90b2dnbGUgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZTtcbiAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAodG9rZW4sIGZvcmNlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmICF0aGlzLmNvbnRhaW5zKHRva2VuKSA9PT0gIWZvcmNlKSB7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfdG9nZ2xlLmNhbGwodGhpcywgdG9rZW4pO1xuICAgIH1cbiAgfTtcbn1cblxuaWYgKCFTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgpIHtcbiAgU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID0gZnVuY3Rpb24gKHNlYXJjaFN0cmluZywgcG9zaXRpb24pIHtcbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIHx8IDA7XG4gICAgcmV0dXJuIHRoaXMuc3Vic3RyKHBvc2l0aW9uLCBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xuICB9O1xufVxuXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpIHtcbiAgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgdmFyIHN1YmplY3RTdHJpbmcgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicgfHwgIWlzRmluaXRlKHBvc2l0aW9uKSB8fCBNYXRoLmZsb29yKHBvc2l0aW9uKSAhPT0gcG9zaXRpb24gfHwgcG9zaXRpb24gPiBzdWJqZWN0U3RyaW5nLmxlbmd0aCkge1xuICAgICAgcG9zaXRpb24gPSBzdWJqZWN0U3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgcG9zaXRpb24gLT0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcbiAgICB2YXIgbGFzdEluZGV4ID0gc3ViamVjdFN0cmluZy5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICAgIHJldHVybiBsYXN0SW5kZXggIT09IC0xICYmIGxhc3RJbmRleCA9PT0gcG9zaXRpb247XG4gIH07XG59XG5cbmlmICghQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgXCJmaW5kXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocHJlZGljYXRlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHZhciBsaXN0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoID4+PiAwO1xuICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgdmFsdWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBsaXN0W2ldO1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgdmFsdWUsIGksIGxpc3QpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSk7XG59XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgLy8gRGlzYWJsZSByZXNpemluZyBpbiBGaXJlZm94XG4gIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiZW5hYmxlT2JqZWN0UmVzaXppbmdcIiwgZmFsc2UsIGZhbHNlKTtcbiAgLy8gRGlzYWJsZSBhdXRvbWF0aWMgbGlua2lmeWluZyBpbiBJRTExXG4gIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiYXV0b1VybERldGVjdFwiLCBmYWxzZSwgZmFsc2UpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGlzIGxpYnJhcnkgbW9kaWZpZXMgdGhlIGRpZmYtcGF0Y2gtbWF0Y2ggbGlicmFyeSBieSBOZWlsIEZyYXNlclxuICogYnkgcmVtb3ZpbmcgdGhlIHBhdGNoIGFuZCBtYXRjaCBmdW5jdGlvbmFsaXR5IGFuZCBjZXJ0YWluIGFkdmFuY2VkXG4gKiBvcHRpb25zIGluIHRoZSBkaWZmIGZ1bmN0aW9uLiBUaGUgb3JpZ2luYWwgbGljZW5zZSBpcyBhcyBmb2xsb3dzOlxuICpcbiAqID09PVxuICpcbiAqIERpZmYgTWF0Y2ggYW5kIFBhdGNoXG4gKlxuICogQ29weXJpZ2h0IDIwMDYgR29vZ2xlIEluYy5cbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC9cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuLyoqXG4gKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgZGlmZiBpcyBhbiBhcnJheSBvZiB0dXBsZXM6XG4gKiBbW0RJRkZfREVMRVRFLCAnSGVsbG8nXSwgW0RJRkZfSU5TRVJULCAnR29vZGJ5ZSddLCBbRElGRl9FUVVBTCwgJyB3b3JsZC4nXV1cbiAqIHdoaWNoIG1lYW5zOiBkZWxldGUgJ0hlbGxvJywgYWRkICdHb29kYnllJyBhbmQga2VlcCAnIHdvcmxkLidcbiAqL1xudmFyIERJRkZfREVMRVRFID0gLTE7XG52YXIgRElGRl9JTlNFUlQgPSAxO1xudmFyIERJRkZfRVFVQUwgPSAwO1xuXG5cbi8qKlxuICogRmluZCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGV4dHMuICBTaW1wbGlmaWVzIHRoZSBwcm9ibGVtIGJ5IHN0cmlwcGluZ1xuICogYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4IG9mZiB0aGUgdGV4dHMgYmVmb3JlIGRpZmZpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge0ludH0gY3Vyc29yX3BvcyBFeHBlY3RlZCBlZGl0IHBvc2l0aW9uIGluIHRleHQxIChvcHRpb25hbClcbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZnVuY3Rpb24gZGlmZl9tYWluKHRleHQxLCB0ZXh0MiwgY3Vyc29yX3Bvcykge1xuICAvLyBDaGVjayBmb3IgZXF1YWxpdHkgKHNwZWVkdXApLlxuICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcbiAgICBpZiAodGV4dDEpIHtcbiAgICAgIHJldHVybiBbW0RJRkZfRVFVQUwsIHRleHQxXV07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIENoZWNrIGN1cnNvcl9wb3Mgd2l0aGluIGJvdW5kc1xuICBpZiAoY3Vyc29yX3BvcyA8IDAgfHwgdGV4dDEubGVuZ3RoIDwgY3Vyc29yX3Bvcykge1xuICAgIGN1cnNvcl9wb3MgPSBudWxsO1xuICB9XG5cbiAgLy8gVHJpbSBvZmYgY29tbW9uIHByZWZpeCAoc3BlZWR1cCkuXG4gIHZhciBjb21tb25sZW5ndGggPSBkaWZmX2NvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpO1xuICB2YXIgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG5cbiAgLy8gVHJpbSBvZmYgY29tbW9uIHN1ZmZpeCAoc3BlZWR1cCkuXG4gIGNvbW1vbmxlbmd0aCA9IGRpZmZfY29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mik7XG4gIHZhciBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcblxuICAvLyBDb21wdXRlIHRoZSBkaWZmIG9uIHRoZSBtaWRkbGUgYmxvY2suXG4gIHZhciBkaWZmcyA9IGRpZmZfY29tcHV0ZV8odGV4dDEsIHRleHQyKTtcblxuICAvLyBSZXN0b3JlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgaWYgKGNvbW1vbnByZWZpeCkge1xuICAgIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIGNvbW1vbnByZWZpeF0pO1xuICB9XG4gIGlmIChjb21tb25zdWZmaXgpIHtcbiAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBjb21tb25zdWZmaXhdKTtcbiAgfVxuICBkaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIGlmIChjdXJzb3JfcG9zICE9IG51bGwpIHtcbiAgICBkaWZmcyA9IGZpeF9jdXJzb3IoZGlmZnMsIGN1cnNvcl9wb3MpO1xuICB9XG4gIGRpZmZzID0gZml4X2Vtb2ppKGRpZmZzKTtcbiAgcmV0dXJuIGRpZmZzO1xufTtcblxuXG4vKipcbiAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgQXNzdW1lcyB0aGF0IHRoZSB0ZXh0cyBkbyBub3RcbiAqIGhhdmUgYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICovXG5mdW5jdGlvbiBkaWZmX2NvbXB1dGVfKHRleHQxLCB0ZXh0Mikge1xuICB2YXIgZGlmZnM7XG5cbiAgaWYgKCF0ZXh0MSkge1xuICAgIC8vIEp1c3QgYWRkIHNvbWUgdGV4dCAoc3BlZWR1cCkuXG4gICAgcmV0dXJuIFtbRElGRl9JTlNFUlQsIHRleHQyXV07XG4gIH1cblxuICBpZiAoIXRleHQyKSB7XG4gICAgLy8gSnVzdCBkZWxldGUgc29tZSB0ZXh0IChzcGVlZHVwKS5cbiAgICByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdXTtcbiAgfVxuXG4gIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICB2YXIgaSA9IGxvbmd0ZXh0LmluZGV4T2Yoc2hvcnR0ZXh0KTtcbiAgaWYgKGkgIT0gLTEpIHtcbiAgICAvLyBTaG9ydGVyIHRleHQgaXMgaW5zaWRlIHRoZSBsb25nZXIgdGV4dCAoc3BlZWR1cCkuXG4gICAgZGlmZnMgPSBbW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSldLFxuICAgICAgICAgICAgIFtESUZGX0VRVUFMLCBzaG9ydHRleHRdLFxuICAgICAgICAgICAgIFtESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBzaG9ydHRleHQubGVuZ3RoKV1dO1xuICAgIC8vIFN3YXAgaW5zZXJ0aW9ucyBmb3IgZGVsZXRpb25zIGlmIGRpZmYgaXMgcmV2ZXJzZWQuXG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgICAgZGlmZnNbMF1bMF0gPSBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZnM7XG4gIH1cblxuICBpZiAoc2hvcnR0ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgLy8gU2luZ2xlIGNoYXJhY3RlciBzdHJpbmcuXG4gICAgLy8gQWZ0ZXIgdGhlIHByZXZpb3VzIHNwZWVkdXAsIHRoZSBjaGFyYWN0ZXIgY2FuJ3QgYmUgYW4gZXF1YWxpdHkuXG4gICAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICB9XG5cbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBwcm9ibGVtIGNhbiBiZSBzcGxpdCBpbiB0d28uXG4gIHZhciBobSA9IGRpZmZfaGFsZk1hdGNoXyh0ZXh0MSwgdGV4dDIpO1xuICBpZiAoaG0pIHtcbiAgICAvLyBBIGhhbGYtbWF0Y2ggd2FzIGZvdW5kLCBzb3J0IG91dCB0aGUgcmV0dXJuIGRhdGEuXG4gICAgdmFyIHRleHQxX2EgPSBobVswXTtcbiAgICB2YXIgdGV4dDFfYiA9IGhtWzFdO1xuICAgIHZhciB0ZXh0Ml9hID0gaG1bMl07XG4gICAgdmFyIHRleHQyX2IgPSBobVszXTtcbiAgICB2YXIgbWlkX2NvbW1vbiA9IGhtWzRdO1xuICAgIC8vIFNlbmQgYm90aCBwYWlycyBvZmYgZm9yIHNlcGFyYXRlIHByb2Nlc3NpbmcuXG4gICAgdmFyIGRpZmZzX2EgPSBkaWZmX21haW4odGV4dDFfYSwgdGV4dDJfYSk7XG4gICAgdmFyIGRpZmZzX2IgPSBkaWZmX21haW4odGV4dDFfYiwgdGV4dDJfYik7XG4gICAgLy8gTWVyZ2UgdGhlIHJlc3VsdHMuXG4gICAgcmV0dXJuIGRpZmZzX2EuY29uY2F0KFtbRElGRl9FUVVBTCwgbWlkX2NvbW1vbl1dLCBkaWZmc19iKTtcbiAgfVxuXG4gIHJldHVybiBkaWZmX2Jpc2VjdF8odGV4dDEsIHRleHQyKTtcbn07XG5cblxuLyoqXG4gKiBGaW5kIHRoZSAnbWlkZGxlIHNuYWtlJyBvZiBhIGRpZmYsIHNwbGl0IHRoZSBwcm9ibGVtIGluIHR3b1xuICogYW5kIHJldHVybiB0aGUgcmVjdXJzaXZlbHkgY29uc3RydWN0ZWQgZGlmZi5cbiAqIFNlZSBNeWVycyAxOTg2IHBhcGVyOiBBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgSXRzIFZhcmlhdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkaWZmX2Jpc2VjdF8odGV4dDEsIHRleHQyKSB7XG4gIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cbiAgdmFyIHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgdmFyIHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgdmFyIG1heF9kID0gTWF0aC5jZWlsKCh0ZXh0MV9sZW5ndGggKyB0ZXh0Ml9sZW5ndGgpIC8gMik7XG4gIHZhciB2X29mZnNldCA9IG1heF9kO1xuICB2YXIgdl9sZW5ndGggPSAyICogbWF4X2Q7XG4gIHZhciB2MSA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gIHZhciB2MiA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gIC8vIFNldHRpbmcgYWxsIGVsZW1lbnRzIHRvIC0xIGlzIGZhc3RlciBpbiBDaHJvbWUgJiBGaXJlZm94IHRoYW4gbWl4aW5nXG4gIC8vIGludGVnZXJzIGFuZCB1bmRlZmluZWQuXG4gIGZvciAodmFyIHggPSAwOyB4IDwgdl9sZW5ndGg7IHgrKykge1xuICAgIHYxW3hdID0gLTE7XG4gICAgdjJbeF0gPSAtMTtcbiAgfVxuICB2MVt2X29mZnNldCArIDFdID0gMDtcbiAgdjJbdl9vZmZzZXQgKyAxXSA9IDA7XG4gIHZhciBkZWx0YSA9IHRleHQxX2xlbmd0aCAtIHRleHQyX2xlbmd0aDtcbiAgLy8gSWYgdGhlIHRvdGFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIGlzIG9kZCwgdGhlbiB0aGUgZnJvbnQgcGF0aCB3aWxsIGNvbGxpZGVcbiAgLy8gd2l0aCB0aGUgcmV2ZXJzZSBwYXRoLlxuICB2YXIgZnJvbnQgPSAoZGVsdGEgJSAyICE9IDApO1xuICAvLyBPZmZzZXRzIGZvciBzdGFydCBhbmQgZW5kIG9mIGsgbG9vcC5cbiAgLy8gUHJldmVudHMgbWFwcGluZyBvZiBzcGFjZSBiZXlvbmQgdGhlIGdyaWQuXG4gIHZhciBrMXN0YXJ0ID0gMDtcbiAgdmFyIGsxZW5kID0gMDtcbiAgdmFyIGsyc3RhcnQgPSAwO1xuICB2YXIgazJlbmQgPSAwO1xuICBmb3IgKHZhciBkID0gMDsgZCA8IG1heF9kOyBkKyspIHtcbiAgICAvLyBXYWxrIHRoZSBmcm9udCBwYXRoIG9uZSBzdGVwLlxuICAgIGZvciAodmFyIGsxID0gLWQgKyBrMXN0YXJ0OyBrMSA8PSBkIC0gazFlbmQ7IGsxICs9IDIpIHtcbiAgICAgIHZhciBrMV9vZmZzZXQgPSB2X29mZnNldCArIGsxO1xuICAgICAgdmFyIHgxO1xuICAgICAgaWYgKGsxID09IC1kIHx8IChrMSAhPSBkICYmIHYxW2sxX29mZnNldCAtIDFdIDwgdjFbazFfb2Zmc2V0ICsgMV0pKSB7XG4gICAgICAgIHgxID0gdjFbazFfb2Zmc2V0ICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MSA9IHYxW2sxX29mZnNldCAtIDFdICsgMTtcbiAgICAgIH1cbiAgICAgIHZhciB5MSA9IHgxIC0gazE7XG4gICAgICB3aGlsZSAoeDEgPCB0ZXh0MV9sZW5ndGggJiYgeTEgPCB0ZXh0Ml9sZW5ndGggJiZcbiAgICAgICAgICAgICB0ZXh0MS5jaGFyQXQoeDEpID09IHRleHQyLmNoYXJBdCh5MSkpIHtcbiAgICAgICAgeDErKztcbiAgICAgICAgeTErKztcbiAgICAgIH1cbiAgICAgIHYxW2sxX29mZnNldF0gPSB4MTtcbiAgICAgIGlmICh4MSA+IHRleHQxX2xlbmd0aCkge1xuICAgICAgICAvLyBSYW4gb2ZmIHRoZSByaWdodCBvZiB0aGUgZ3JhcGguXG4gICAgICAgIGsxZW5kICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKHkxID4gdGV4dDJfbGVuZ3RoKSB7XG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIGJvdHRvbSBvZiB0aGUgZ3JhcGguXG4gICAgICAgIGsxc3RhcnQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbnQpIHtcbiAgICAgICAgdmFyIGsyX29mZnNldCA9IHZfb2Zmc2V0ICsgZGVsdGEgLSBrMTtcbiAgICAgICAgaWYgKGsyX29mZnNldCA+PSAwICYmIGsyX29mZnNldCA8IHZfbGVuZ3RoICYmIHYyW2syX29mZnNldF0gIT0gLTEpIHtcbiAgICAgICAgICAvLyBNaXJyb3IgeDIgb250byB0b3AtbGVmdCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgICAgICB2YXIgeDIgPSB0ZXh0MV9sZW5ndGggLSB2MltrMl9vZmZzZXRdO1xuICAgICAgICAgIGlmICh4MSA+PSB4Mikge1xuICAgICAgICAgICAgLy8gT3ZlcmxhcCBkZXRlY3RlZC5cbiAgICAgICAgICAgIHJldHVybiBkaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgxLCB5MSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2FsayB0aGUgcmV2ZXJzZSBwYXRoIG9uZSBzdGVwLlxuICAgIGZvciAodmFyIGsyID0gLWQgKyBrMnN0YXJ0OyBrMiA8PSBkIC0gazJlbmQ7IGsyICs9IDIpIHtcbiAgICAgIHZhciBrMl9vZmZzZXQgPSB2X29mZnNldCArIGsyO1xuICAgICAgdmFyIHgyO1xuICAgICAgaWYgKGsyID09IC1kIHx8IChrMiAhPSBkICYmIHYyW2syX29mZnNldCAtIDFdIDwgdjJbazJfb2Zmc2V0ICsgMV0pKSB7XG4gICAgICAgIHgyID0gdjJbazJfb2Zmc2V0ICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHYyW2syX29mZnNldCAtIDFdICsgMTtcbiAgICAgIH1cbiAgICAgIHZhciB5MiA9IHgyIC0gazI7XG4gICAgICB3aGlsZSAoeDIgPCB0ZXh0MV9sZW5ndGggJiYgeTIgPCB0ZXh0Ml9sZW5ndGggJiZcbiAgICAgICAgICAgICB0ZXh0MS5jaGFyQXQodGV4dDFfbGVuZ3RoIC0geDIgLSAxKSA9PVxuICAgICAgICAgICAgIHRleHQyLmNoYXJBdCh0ZXh0Ml9sZW5ndGggLSB5MiAtIDEpKSB7XG4gICAgICAgIHgyKys7XG4gICAgICAgIHkyKys7XG4gICAgICB9XG4gICAgICB2MltrMl9vZmZzZXRdID0geDI7XG4gICAgICBpZiAoeDIgPiB0ZXh0MV9sZW5ndGgpIHtcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgbGVmdCBvZiB0aGUgZ3JhcGguXG4gICAgICAgIGsyZW5kICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKHkyID4gdGV4dDJfbGVuZ3RoKSB7XG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIHRvcCBvZiB0aGUgZ3JhcGguXG4gICAgICAgIGsyc3RhcnQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoIWZyb250KSB7XG4gICAgICAgIHZhciBrMV9vZmZzZXQgPSB2X29mZnNldCArIGRlbHRhIC0gazI7XG4gICAgICAgIGlmIChrMV9vZmZzZXQgPj0gMCAmJiBrMV9vZmZzZXQgPCB2X2xlbmd0aCAmJiB2MVtrMV9vZmZzZXRdICE9IC0xKSB7XG4gICAgICAgICAgdmFyIHgxID0gdjFbazFfb2Zmc2V0XTtcbiAgICAgICAgICB2YXIgeTEgPSB2X29mZnNldCArIHgxIC0gazFfb2Zmc2V0O1xuICAgICAgICAgIC8vIE1pcnJvciB4MiBvbnRvIHRvcC1sZWZ0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAgICAgIHgyID0gdGV4dDFfbGVuZ3RoIC0geDI7XG4gICAgICAgICAgaWYgKHgxID49IHgyKSB7XG4gICAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLlxuICAgICAgICAgICAgcmV0dXJuIGRpZmZfYmlzZWN0U3BsaXRfKHRleHQxLCB0ZXh0MiwgeDEsIHkxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRGlmZiB0b29rIHRvbyBsb25nIGFuZCBoaXQgdGhlIGRlYWRsaW5lIG9yXG4gIC8vIG51bWJlciBvZiBkaWZmcyBlcXVhbHMgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIG5vIGNvbW1vbmFsaXR5IGF0IGFsbC5cbiAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xufTtcblxuXG4vKipcbiAqIEdpdmVuIHRoZSBsb2NhdGlvbiBvZiB0aGUgJ21pZGRsZSBzbmFrZScsIHNwbGl0IHRoZSBkaWZmIGluIHR3byBwYXJ0c1xuICogYW5kIHJlY3Vyc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBJbmRleCBvZiBzcGxpdCBwb2ludCBpbiB0ZXh0MS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IEluZGV4IG9mIHNwbGl0IHBvaW50IGluIHRleHQyLlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICovXG5mdW5jdGlvbiBkaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgsIHkpIHtcbiAgdmFyIHRleHQxYSA9IHRleHQxLnN1YnN0cmluZygwLCB4KTtcbiAgdmFyIHRleHQyYSA9IHRleHQyLnN1YnN0cmluZygwLCB5KTtcbiAgdmFyIHRleHQxYiA9IHRleHQxLnN1YnN0cmluZyh4KTtcbiAgdmFyIHRleHQyYiA9IHRleHQyLnN1YnN0cmluZyh5KTtcblxuICAvLyBDb21wdXRlIGJvdGggZGlmZnMgc2VyaWFsbHkuXG4gIHZhciBkaWZmcyA9IGRpZmZfbWFpbih0ZXh0MWEsIHRleHQyYSk7XG4gIHZhciBkaWZmc2IgPSBkaWZmX21haW4odGV4dDFiLCB0ZXh0MmIpO1xuXG4gIHJldHVybiBkaWZmcy5jb25jYXQoZGlmZnNiKTtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBwcmVmaXggb2YgdHdvIHN0cmluZ3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIHN0YXJ0IG9mIGVhY2hcbiAqICAgICBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGRpZmZfY29tbW9uUHJlZml4KHRleHQxLCB0ZXh0Mikge1xuICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxLmNoYXJBdCgwKSAhPSB0ZXh0Mi5jaGFyQXQoMCkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAvLyBCaW5hcnkgc2VhcmNoLlxuICAvLyBQZXJmb3JtYW5jZSBhbmFseXNpczogaHR0cDovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xuICB2YXIgcG9pbnRlcm1pbiA9IDA7XG4gIHZhciBwb2ludGVybWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xuICB2YXIgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XG4gIHZhciBwb2ludGVyc3RhcnQgPSAwO1xuICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcbiAgICBpZiAodGV4dDEuc3Vic3RyaW5nKHBvaW50ZXJzdGFydCwgcG9pbnRlcm1pZCkgPT1cbiAgICAgICAgdGV4dDIuc3Vic3RyaW5nKHBvaW50ZXJzdGFydCwgcG9pbnRlcm1pZCkpIHtcbiAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xuICAgICAgcG9pbnRlcnN0YXJ0ID0gcG9pbnRlcm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlcm1heCA9IHBvaW50ZXJtaWQ7XG4gICAgfVxuICAgIHBvaW50ZXJtaWQgPSBNYXRoLmZsb29yKChwb2ludGVybWF4IC0gcG9pbnRlcm1pbikgLyAyICsgcG9pbnRlcm1pbik7XG4gIH1cbiAgcmV0dXJuIHBvaW50ZXJtaWQ7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBjb21tb24gc3VmZml4IG9mIHR3byBzdHJpbmdzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBlbmQgb2YgZWFjaCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGRpZmZfY29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mikge1xuICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8XG4gICAgICB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0gMSkgIT0gdGV4dDIuY2hhckF0KHRleHQyLmxlbmd0aCAtIDEpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gQmluYXJ5IHNlYXJjaC5cbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAwNy8xMC8wOS9cbiAgdmFyIHBvaW50ZXJtaW4gPSAwO1xuICB2YXIgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcbiAgdmFyIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuICB2YXIgcG9pbnRlcmVuZCA9IDA7XG4gIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xuICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDEubGVuZ3RoIC0gcG9pbnRlcmVuZCkgPT1cbiAgICAgICAgdGV4dDIuc3Vic3RyaW5nKHRleHQyLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQyLmxlbmd0aCAtIHBvaW50ZXJlbmQpKSB7XG4gICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcbiAgICAgIHBvaW50ZXJlbmQgPSBwb2ludGVybWluO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICB9XG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcbiAgfVxuICByZXR1cm4gcG9pbnRlcm1pZDtcbn07XG5cblxuLyoqXG4gKiBEbyB0aGUgdHdvIHRleHRzIHNoYXJlIGEgc3Vic3RyaW5nIHdoaWNoIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGxlbmd0aCBvZiB0aGVcbiAqIGxvbmdlciB0ZXh0P1xuICogVGhpcyBzcGVlZHVwIGNhbiBwcm9kdWNlIG5vbi1taW5pbWFsIGRpZmZzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXG4gKiAgICAgdGV4dDEsIHRoZSBzdWZmaXggb2YgdGV4dDEsIHRoZSBwcmVmaXggb2YgdGV4dDIsIHRoZSBzdWZmaXggb2ZcbiAqICAgICB0ZXh0MiBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuICBPciBudWxsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gZGlmZl9oYWxmTWF0Y2hfKHRleHQxLCB0ZXh0Mikge1xuICB2YXIgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xuICB2YXIgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcbiAgaWYgKGxvbmd0ZXh0Lmxlbmd0aCA8IDQgfHwgc2hvcnR0ZXh0Lmxlbmd0aCAqIDIgPCBsb25ndGV4dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDsgIC8vIFBvaW50bGVzcy5cbiAgfVxuXG4gIC8qKlxuICAgKiBEb2VzIGEgc3Vic3RyaW5nIG9mIHNob3J0dGV4dCBleGlzdCB3aXRoaW4gbG9uZ3RleHQgc3VjaCB0aGF0IHRoZSBzdWJzdHJpbmdcbiAgICogaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIGxvbmd0ZXh0P1xuICAgKiBDbG9zdXJlLCBidXQgZG9lcyBub3QgcmVmZXJlbmNlIGFueSBleHRlcm5hbCB2YXJpYWJsZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb25ndGV4dCBMb25nZXIgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnR0ZXh0IFNob3J0ZXIgc3RyaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBTdGFydCBpbmRleCBvZiBxdWFydGVyIGxlbmd0aCBzdWJzdHJpbmcgd2l0aGluIGxvbmd0ZXh0LlxuICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2ZcbiAgICogICAgIGxvbmd0ZXh0LCB0aGUgc3VmZml4IG9mIGxvbmd0ZXh0LCB0aGUgcHJlZml4IG9mIHNob3J0dGV4dCwgdGhlIHN1ZmZpeFxuICAgKiAgICAgb2Ygc2hvcnR0ZXh0IGFuZCB0aGUgY29tbW9uIG1pZGRsZS4gIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LCBpKSB7XG4gICAgLy8gU3RhcnQgd2l0aCBhIDEvNCBsZW5ndGggc3Vic3RyaW5nIGF0IHBvc2l0aW9uIGkgYXMgYSBzZWVkLlxuICAgIHZhciBzZWVkID0gbG9uZ3RleHQuc3Vic3RyaW5nKGksIGkgKyBNYXRoLmZsb29yKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpKTtcbiAgICB2YXIgaiA9IC0xO1xuICAgIHZhciBiZXN0X2NvbW1vbiA9ICcnO1xuICAgIHZhciBiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYiwgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYjtcbiAgICB3aGlsZSAoKGogPSBzaG9ydHRleHQuaW5kZXhPZihzZWVkLCBqICsgMSkpICE9IC0xKSB7XG4gICAgICB2YXIgcHJlZml4TGVuZ3RoID0gZGlmZl9jb21tb25QcmVmaXgobG9uZ3RleHQuc3Vic3RyaW5nKGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoaikpO1xuICAgICAgdmFyIHN1ZmZpeExlbmd0aCA9IGRpZmZfY29tbW9uU3VmZml4KGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGopKTtcbiAgICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggPCBzdWZmaXhMZW5ndGggKyBwcmVmaXhMZW5ndGgpIHtcbiAgICAgICAgYmVzdF9jb21tb24gPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogLSBzdWZmaXhMZW5ndGgsIGopICtcbiAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoaiwgaiArIHByZWZpeExlbmd0aCk7XG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYSA9IGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9sb25ndGV4dF9iID0gbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X3Nob3J0dGV4dF9hID0gc2hvcnR0ZXh0LnN1YnN0cmluZygwLCBqIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYiA9IHNob3J0dGV4dC5zdWJzdHJpbmcoaiArIHByZWZpeExlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggKiAyID49IGxvbmd0ZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYixcbiAgICAgICAgICAgICAgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYiwgYmVzdF9jb21tb25dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgc2Vjb25kIHF1YXJ0ZXIgaXMgdGhlIHNlZWQgZm9yIGEgaGFsZi1tYXRjaC5cbiAgdmFyIGhtMSA9IGRpZmZfaGFsZk1hdGNoSV8obG9uZ3RleHQsIHNob3J0dGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpKTtcbiAgLy8gQ2hlY2sgYWdhaW4gYmFzZWQgb24gdGhlIHRoaXJkIHF1YXJ0ZXIuXG4gIHZhciBobTIgPSBkaWZmX2hhbGZNYXRjaElfKGxvbmd0ZXh0LCBzaG9ydHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyAyKSk7XG4gIHZhciBobTtcbiAgaWYgKCFobTEgJiYgIWhtMikge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKCFobTIpIHtcbiAgICBobSA9IGhtMTtcbiAgfSBlbHNlIGlmICghaG0xKSB7XG4gICAgaG0gPSBobTI7XG4gIH0gZWxzZSB7XG4gICAgLy8gQm90aCBtYXRjaGVkLiAgU2VsZWN0IHRoZSBsb25nZXN0LlxuICAgIGhtID0gaG0xWzRdLmxlbmd0aCA+IGhtMls0XS5sZW5ndGggPyBobTEgOiBobTI7XG4gIH1cblxuICAvLyBBIGhhbGYtbWF0Y2ggd2FzIGZvdW5kLCBzb3J0IG91dCB0aGUgcmV0dXJuIGRhdGEuXG4gIHZhciB0ZXh0MV9hLCB0ZXh0MV9iLCB0ZXh0Ml9hLCB0ZXh0Ml9iO1xuICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKSB7XG4gICAgdGV4dDFfYSA9IGhtWzBdO1xuICAgIHRleHQxX2IgPSBobVsxXTtcbiAgICB0ZXh0Ml9hID0gaG1bMl07XG4gICAgdGV4dDJfYiA9IGhtWzNdO1xuICB9IGVsc2Uge1xuICAgIHRleHQyX2EgPSBobVswXTtcbiAgICB0ZXh0Ml9iID0gaG1bMV07XG4gICAgdGV4dDFfYSA9IGhtWzJdO1xuICAgIHRleHQxX2IgPSBobVszXTtcbiAgfVxuICB2YXIgbWlkX2NvbW1vbiA9IGhtWzRdO1xuICByZXR1cm4gW3RleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2IsIG1pZF9jb21tb25dO1xufTtcblxuXG4vKipcbiAqIFJlb3JkZXIgYW5kIG1lcmdlIGxpa2UgZWRpdCBzZWN0aW9ucy4gIE1lcmdlIGVxdWFsaXRpZXMuXG4gKiBBbnkgZWRpdCBzZWN0aW9uIGNhbiBtb3ZlIGFzIGxvbmcgYXMgaXQgZG9lc24ndCBjcm9zcyBhbiBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICovXG5mdW5jdGlvbiBkaWZmX2NsZWFudXBNZXJnZShkaWZmcykge1xuICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCAnJ10pOyAgLy8gQWRkIGEgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cbiAgdmFyIHBvaW50ZXIgPSAwO1xuICB2YXIgY291bnRfZGVsZXRlID0gMDtcbiAgdmFyIGNvdW50X2luc2VydCA9IDA7XG4gIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xuICB2YXIgdGV4dF9pbnNlcnQgPSAnJztcbiAgdmFyIGNvbW1vbmxlbmd0aDtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudF9pbnNlcnQrKztcbiAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIC8vIFVwb24gcmVhY2hpbmcgYW4gZXF1YWxpdHksIGNoZWNrIGZvciBwcmlvciByZWR1bmRhbmNpZXMuXG4gICAgICAgIGlmIChjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQgPiAxKSB7XG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSAhPT0gMCAmJiBjb3VudF9pbnNlcnQgIT09IDApIHtcbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBwcmVmaXhpZXMuXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSBkaWZmX2NvbW1vblByZWZpeCh0ZXh0X2luc2VydCwgdGV4dF9kZWxldGUpO1xuICAgICAgICAgICAgaWYgKGNvbW1vbmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBpZiAoKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQpID4gMCAmJlxuICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzBdID09XG4gICAgICAgICAgICAgICAgICBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzFdICs9XG4gICAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZSgwLCAwLCBbRElGRl9FUVVBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpXSk7XG4gICAgICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGYWN0b3Igb3V0IGFueSBjb21tb24gc3VmZml4aWVzLlxuICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gZGlmZl9jb21tb25TdWZmaXgodGV4dF9pbnNlcnQsIHRleHRfZGVsZXRlKTtcbiAgICAgICAgICAgIGlmIChjb21tb25sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcodGV4dF9pbnNlcnQubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCkgKyBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgdGV4dF9pbnNlcnQubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKDAsIHRleHRfZGVsZXRlLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgPT09IDApIHtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfSU5TRVJULCB0ZXh0X2luc2VydF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY291bnRfaW5zZXJ0ID09PSAwKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSxcbiAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0RFTEVURSwgdGV4dF9kZWxldGVdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQsXG4gICAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlXSxcbiAgICAgICAgICAgICAgICBbRElGRl9JTlNFUlQsIHRleHRfaW5zZXJ0XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0ICtcbiAgICAgICAgICAgICAgICAgICAgKGNvdW50X2RlbGV0ZSA/IDEgOiAwKSArIChjb3VudF9pbnNlcnQgPyAxIDogMCkgKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXIgIT09IDAgJiYgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAvLyBNZXJnZSB0aGlzIGVxdWFsaXR5IHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICBjb3VudF9kZWxldGUgPSAwO1xuICAgICAgICB0ZXh0X2RlbGV0ZSA9ICcnO1xuICAgICAgICB0ZXh0X2luc2VydCA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdID09PSAnJykge1xuICAgIGRpZmZzLnBvcCgpOyAgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICB9XG5cbiAgLy8gU2Vjb25kIHBhc3M6IGxvb2sgZm9yIHNpbmdsZSBlZGl0cyBzdXJyb3VuZGVkIG9uIGJvdGggc2lkZXMgYnkgZXF1YWxpdGllc1xuICAvLyB3aGljaCBjYW4gYmUgc2hpZnRlZCBzaWRld2F5cyB0byBlbGltaW5hdGUgYW4gZXF1YWxpdHkuXG4gIC8vIGUuZzogQTxpbnM+QkE8L2lucz5DIC0+IDxpbnM+QUI8L2lucz5BQ1xuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICBwb2ludGVyID0gMTtcbiAgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnQgKGRvbid0IG5lZWQgY2hlY2tpbmcpLlxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDEpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwgJiZcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID09IERJRkZfRVFVQUwpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgZWRpdCBzdXJyb3VuZGVkIGJ5IGVxdWFsaXRpZXMuXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCkgPT0gZGlmZnNbcG9pbnRlciAtIDFdWzFdKSB7XG4gICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKTtcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpID09XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdKSB7XG4gICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIG5leHQgZXF1YWxpdHkuXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID1cbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSArXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgLy8gSWYgc2hpZnRzIHdlcmUgbWFkZSwgdGhlIGRpZmYgbmVlZHMgcmVvcmRlcmluZyBhbmQgYW5vdGhlciBzaGlmdCBzd2VlcC5cbiAgaWYgKGNoYW5nZXMpIHtcbiAgICBkaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIH1cbn07XG5cblxudmFyIGRpZmYgPSBkaWZmX21haW47XG5kaWZmLklOU0VSVCA9IERJRkZfSU5TRVJUO1xuZGlmZi5ERUxFVEUgPSBESUZGX0RFTEVURTtcbmRpZmYuRVFVQUwgPSBESUZGX0VRVUFMO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmY7XG5cbi8qXG4gKiBNb2RpZnkgYSBkaWZmIHN1Y2ggdGhhdCB0aGUgY3Vyc29yIHBvc2l0aW9uIHBvaW50cyB0byB0aGUgc3RhcnQgb2YgYSBjaGFuZ2U6XG4gKiBFLmcuXG4gKiAgIGN1cnNvcl9ub3JtYWxpemVfZGlmZihbW0RJRkZfRVFVQUwsICdhYmMnXV0sIDEpXG4gKiAgICAgPT4gWzEsIFtbRElGRl9FUVVBTCwgJ2EnXSwgW0RJRkZfRVFVQUwsICdiYyddXV1cbiAqICAgY3Vyc29yX25vcm1hbGl6ZV9kaWZmKFtbRElGRl9JTlNFUlQsICduZXcnXSwgW0RJRkZfREVMRVRFLCAneHl6J11dLCAyKVxuICogICAgID0+IFsyLCBbW0RJRkZfSU5TRVJULCAnbmV3J10sIFtESUZGX0RFTEVURSwgJ3h5J10sIFtESUZGX0RFTEVURSwgJ3onXV1dXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqIEBwYXJhbSB7SW50fSBjdXJzb3JfcG9zIFN1Z2dlc3RlZCBlZGl0IHBvc2l0aW9uLiBNdXN0IG5vdCBiZSBvdXQgb2YgYm91bmRzIVxuICogQHJldHVybiB7QXJyYXl9IEEgdHVwbGUgW2N1cnNvciBsb2NhdGlvbiBpbiB0aGUgbW9kaWZpZWQgZGlmZiwgbW9kaWZpZWQgZGlmZl1cbiAqL1xuZnVuY3Rpb24gY3Vyc29yX25vcm1hbGl6ZV9kaWZmIChkaWZmcywgY3Vyc29yX3Bvcykge1xuICBpZiAoY3Vyc29yX3BvcyA9PT0gMCkge1xuICAgIHJldHVybiBbRElGRl9FUVVBTCwgZGlmZnNdO1xuICB9XG4gIGZvciAodmFyIGN1cnJlbnRfcG9zID0gMCwgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkID0gZGlmZnNbaV07XG4gICAgaWYgKGRbMF0gPT09IERJRkZfREVMRVRFIHx8IGRbMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgIHZhciBuZXh0X3BvcyA9IGN1cnJlbnRfcG9zICsgZFsxXS5sZW5ndGg7XG4gICAgICBpZiAoY3Vyc29yX3BvcyA9PT0gbmV4dF9wb3MpIHtcbiAgICAgICAgcmV0dXJuIFtpICsgMSwgZGlmZnNdO1xuICAgICAgfSBlbHNlIGlmIChjdXJzb3JfcG9zIDwgbmV4dF9wb3MpIHtcbiAgICAgICAgLy8gY29weSB0byBwcmV2ZW50IHNpZGUgZWZmZWN0c1xuICAgICAgICBkaWZmcyA9IGRpZmZzLnNsaWNlKCk7XG4gICAgICAgIC8vIHNwbGl0IGQgaW50byB0d28gZGlmZiBjaGFuZ2VzXG4gICAgICAgIHZhciBzcGxpdF9wb3MgPSBjdXJzb3JfcG9zIC0gY3VycmVudF9wb3M7XG4gICAgICAgIHZhciBkX2xlZnQgPSBbZFswXSwgZFsxXS5zbGljZSgwLCBzcGxpdF9wb3MpXTtcbiAgICAgICAgdmFyIGRfcmlnaHQgPSBbZFswXSwgZFsxXS5zbGljZShzcGxpdF9wb3MpXTtcbiAgICAgICAgZGlmZnMuc3BsaWNlKGksIDEsIGRfbGVmdCwgZF9yaWdodCk7XG4gICAgICAgIHJldHVybiBbaSArIDEsIGRpZmZzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRfcG9zID0gbmV4dF9wb3M7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcignY3Vyc29yX3BvcyBpcyBvdXQgb2YgYm91bmRzIScpXG59XG5cbi8qXG4gKiBNb2RpZnkgYSBkaWZmIHN1Y2ggdGhhdCB0aGUgZWRpdCBwb3NpdGlvbiBpcyBcInNoaWZ0ZWRcIiB0byB0aGUgcHJvcG9zZWQgZWRpdCBsb2NhdGlvbiAoY3Vyc29yX3Bvc2l0aW9uKS5cbiAqXG4gKiBDYXNlIDEpXG4gKiAgIENoZWNrIGlmIGEgbmFpdmUgc2hpZnQgaXMgcG9zc2libGU6XG4gKiAgICAgWzAsIFhdLCBbIDEsIFldIC0+IFsgMSwgWV0sIFswLCBYXSAgICAoaWYgWCArIFkgPT09IFkgKyBYKVxuICogICAgIFswLCBYXSwgWy0xLCBZXSAtPiBbLTEsIFldLCBbMCwgWF0gICAgKGlmIFggKyBZID09PSBZICsgWCkgLSBob2xkcyBzYW1lIHJlc3VsdFxuICogQ2FzZSAyKVxuICogICBDaGVjayBpZiB0aGUgZm9sbG93aW5nIHNoaWZ0cyBhcmUgcG9zc2libGU6XG4gKiAgICAgWzAsICdwcmUnXSwgWyAxLCAncHJlZml4J10gLT4gWyAxLCAncHJlJ10sIFswLCAncHJlJ10sIFsgMSwgJ2ZpeCddXG4gKiAgICAgWzAsICdwcmUnXSwgWy0xLCAncHJlZml4J10gLT4gWy0xLCAncHJlJ10sIFswLCAncHJlJ10sIFstMSwgJ2ZpeCddXG4gKiAgICAgICAgIF4gICAgICAgICAgICBeXG4gKiAgICAgICAgIGQgICAgICAgICAgZF9uZXh0XG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqIEBwYXJhbSB7SW50fSBjdXJzb3JfcG9zIFN1Z2dlc3RlZCBlZGl0IHBvc2l0aW9uLiBNdXN0IG5vdCBiZSBvdXQgb2YgYm91bmRzIVxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKi9cbmZ1bmN0aW9uIGZpeF9jdXJzb3IgKGRpZmZzLCBjdXJzb3JfcG9zKSB7XG4gIHZhciBub3JtID0gY3Vyc29yX25vcm1hbGl6ZV9kaWZmKGRpZmZzLCBjdXJzb3JfcG9zKTtcbiAgdmFyIG5kaWZmcyA9IG5vcm1bMV07XG4gIHZhciBjdXJzb3JfcG9pbnRlciA9IG5vcm1bMF07XG4gIHZhciBkID0gbmRpZmZzW2N1cnNvcl9wb2ludGVyXTtcbiAgdmFyIGRfbmV4dCA9IG5kaWZmc1tjdXJzb3JfcG9pbnRlciArIDFdO1xuXG4gIGlmIChkID09IG51bGwpIHtcbiAgICAvLyBUZXh0IHdhcyBkZWxldGVkIGZyb20gZW5kIG9mIG9yaWdpbmFsIHN0cmluZyxcbiAgICAvLyBjdXJzb3IgaXMgbm93IG91dCBvZiBib3VuZHMgaW4gbmV3IHN0cmluZ1xuICAgIHJldHVybiBkaWZmcztcbiAgfSBlbHNlIGlmIChkWzBdICE9PSBESUZGX0VRVUFMKSB7XG4gICAgLy8gQSBtb2RpZmljYXRpb24gaGFwcGVuZWQgYXQgdGhlIGN1cnNvciBsb2NhdGlvbi5cbiAgICAvLyBUaGlzIGlzIHRoZSBleHBlY3RlZCBvdXRjb21lLCBzbyB3ZSBjYW4gcmV0dXJuIHRoZSBvcmlnaW5hbCBkaWZmLlxuICAgIHJldHVybiBkaWZmcztcbiAgfSBlbHNlIHtcbiAgICBpZiAoZF9uZXh0ICE9IG51bGwgJiYgZFsxXSArIGRfbmV4dFsxXSA9PT0gZF9uZXh0WzFdICsgZFsxXSkge1xuICAgICAgLy8gQ2FzZSAxKVxuICAgICAgLy8gSXQgaXMgcG9zc2libGUgdG8gcGVyZm9ybSBhIG5haXZlIHNoaWZ0XG4gICAgICBuZGlmZnMuc3BsaWNlKGN1cnNvcl9wb2ludGVyLCAyLCBkX25leHQsIGQpXG4gICAgICByZXR1cm4gbWVyZ2VfdHVwbGVzKG5kaWZmcywgY3Vyc29yX3BvaW50ZXIsIDIpXG4gICAgfSBlbHNlIGlmIChkX25leHQgIT0gbnVsbCAmJiBkX25leHRbMV0uaW5kZXhPZihkWzFdKSA9PT0gMCkge1xuICAgICAgLy8gQ2FzZSAyKVxuICAgICAgLy8gZFsxXSBpcyBhIHByZWZpeCBvZiBkX25leHRbMV1cbiAgICAgIC8vIFdlIGNhbiBhc3N1bWUgdGhhdCBkX25leHRbMF0gIT09IDAsIHNpbmNlIGRbMF0gPT09IDBcbiAgICAgIC8vIFNoaWZ0IGVkaXQgbG9jYXRpb25zLi5cbiAgICAgIG5kaWZmcy5zcGxpY2UoY3Vyc29yX3BvaW50ZXIsIDIsIFtkX25leHRbMF0sIGRbMV1dLCBbMCwgZFsxXV0pO1xuICAgICAgdmFyIHN1ZmZpeCA9IGRfbmV4dFsxXS5zbGljZShkWzFdLmxlbmd0aCk7XG4gICAgICBpZiAoc3VmZml4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgbmRpZmZzLnNwbGljZShjdXJzb3JfcG9pbnRlciArIDIsIDAsIFtkX25leHRbMF0sIHN1ZmZpeF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlX3R1cGxlcyhuZGlmZnMsIGN1cnNvcl9wb2ludGVyLCAzKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb3QgcG9zc2libGUgdG8gcGVyZm9ybSBhbnkgbW9kaWZpY2F0aW9uXG4gICAgICByZXR1cm4gZGlmZnM7XG4gICAgfVxuICB9XG59XG5cbi8qXG4gKiBDaGVjayBkaWZmIGRpZCBub3Qgc3BsaXQgc3Vycm9nYXRlIHBhaXJzLlxuICogRXguIFswLCAnXFx1RDgzRCddLCBbLTEsICdcXHVEQzM2J10sIFsxLCAnXFx1REMyRiddIC0+IFstMSwgJ1xcdUQ4M0RcXHVEQzM2J10sIFsxLCAnXFx1RDgzRFxcdURDMkYnXVxuICogICAgICdcXHVEODNEXFx1REMzNicgPT09ICfwn5C2JywgJ1xcdUQ4M0RcXHVEQzJGJyA9PT0gJ/CfkK8nXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICovXG5mdW5jdGlvbiBmaXhfZW1vamkgKGRpZmZzKSB7XG4gIHZhciBjb21wYWN0ID0gZmFsc2U7XG4gIHZhciBzdGFydHNfd2l0aF9wYWlyX2VuZCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckNvZGVBdCgwKSA+PSAweERDMDAgJiYgc3RyLmNoYXJDb2RlQXQoMCkgPD0gMHhERkZGO1xuICB9XG4gIHZhciBlbmRzX3dpdGhfcGFpcl9zdGFydCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckNvZGVBdChzdHIubGVuZ3RoLTEpID49IDB4RDgwMCAmJiBzdHIuY2hhckNvZGVBdChzdHIubGVuZ3RoLTEpIDw9IDB4REJGRjtcbiAgfVxuICBmb3IgKHZhciBpID0gMjsgaSA8IGRpZmZzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGRpZmZzW2ktMl1bMF0gPT09IERJRkZfRVFVQUwgJiYgZW5kc193aXRoX3BhaXJfc3RhcnQoZGlmZnNbaS0yXVsxXSkgJiZcbiAgICAgICAgZGlmZnNbaS0xXVswXSA9PT0gRElGRl9ERUxFVEUgJiYgc3RhcnRzX3dpdGhfcGFpcl9lbmQoZGlmZnNbaS0xXVsxXSkgJiZcbiAgICAgICAgZGlmZnNbaV1bMF0gPT09IERJRkZfSU5TRVJUICYmIHN0YXJ0c193aXRoX3BhaXJfZW5kKGRpZmZzW2ldWzFdKSkge1xuICAgICAgY29tcGFjdCA9IHRydWU7XG5cbiAgICAgIGRpZmZzW2ktMV1bMV0gPSBkaWZmc1tpLTJdWzFdLnNsaWNlKC0xKSArIGRpZmZzW2ktMV1bMV07XG4gICAgICBkaWZmc1tpXVsxXSA9IGRpZmZzW2ktMl1bMV0uc2xpY2UoLTEpICsgZGlmZnNbaV1bMV07XG5cbiAgICAgIGRpZmZzW2ktMl1bMV0gPSBkaWZmc1tpLTJdWzFdLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFjb21wYWN0KSB7XG4gICAgcmV0dXJuIGRpZmZzO1xuICB9XG4gIHZhciBmaXhlZF9kaWZmcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmZzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGRpZmZzW2ldWzFdLmxlbmd0aCA+IDApIHtcbiAgICAgIGZpeGVkX2RpZmZzLnB1c2goZGlmZnNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZml4ZWRfZGlmZnM7XG59XG5cbi8qXG4gKiBUcnkgdG8gbWVyZ2UgdHVwbGVzIHdpdGggdGhlaXIgbmVpZ2JvcnMgaW4gYSBnaXZlbiByYW5nZS5cbiAqIEUuZy4gWzAsICdhJ10sIFswLCAnYiddIC0+IFswLCAnYWInXVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHBhcmFtIHtJbnR9IHN0YXJ0IFBvc2l0aW9uIG9mIHRoZSBmaXJzdCBlbGVtZW50IHRvIG1lcmdlIChkaWZmc1tzdGFydF0gaXMgYWxzbyBtZXJnZWQgd2l0aCBkaWZmc1tzdGFydCAtIDFdKS5cbiAqIEBwYXJhbSB7SW50fSBsZW5ndGggTnVtYmVyIG9mIGNvbnNlY3V0aXZlIGVsZW1lbnRzIHRvIGNoZWNrLlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIG1lcmdlZCBkaWZmIHR1cGxlcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VfdHVwbGVzIChkaWZmcywgc3RhcnQsIGxlbmd0aCkge1xuICAvLyBDaGVjayBmcm9tIChzdGFydC0xKSB0byAoc3RhcnQrbGVuZ3RoKS5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgbGVuZ3RoIC0gMTsgaSA+PSAwICYmIGkgPj0gc3RhcnQgLSAxOyBpLS0pIHtcbiAgICBpZiAoaSArIDEgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICAgIHZhciBsZWZ0X2QgPSBkaWZmc1tpXTtcbiAgICAgIHZhciByaWdodF9kID0gZGlmZnNbaSsxXTtcbiAgICAgIGlmIChsZWZ0X2RbMF0gPT09IHJpZ2h0X2RbMV0pIHtcbiAgICAgICAgZGlmZnMuc3BsaWNlKGksIDIsIFtsZWZ0X2RbMF0sIGxlZnRfZFsxXSArIHJpZ2h0X2RbMV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufVxuXG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gID8gT2JqZWN0LmtleXMgOiBzaGltO1xuXG5leHBvcnRzLnNoaW0gPSBzaGltO1xuZnVuY3Rpb24gc2hpbSAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cblxuXG4vKioqLyB9KSxcbi8qIDUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZXhpc3RzIE9ubHkgY2hlY2sgaWYgdGhlcmUgYXJlIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtBcnJheXxCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQsIGV4aXN0cykge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgYXZhaWxhYmxlID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGV4aXN0cykgcmV0dXJuICEhYXZhaWxhYmxlO1xuICBpZiAoIWF2YWlsYWJsZSkgcmV0dXJuIFtdO1xuICBpZiAoYXZhaWxhYmxlLmZuKSByZXR1cm4gW2F2YWlsYWJsZS5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdmFpbGFibGUubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gYXZhaWxhYmxlW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCB0aGlzKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCB0aGlzLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghdGhpcy5fZXZlbnRzW2V2dF0uZm4pIHRoaXMuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIHRoaXMuX2V2ZW50c1tldnRdID0gW3RoaXMuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgdGhpcywgdHJ1ZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgdGhpcy5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgdGhpcy5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIXRoaXMuX2V2ZW50c1tldnRdLmZuKSB0aGlzLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSB0aGlzLl9ldmVudHNbZXZ0XSA9IFt0aGlzLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIGVsc2UgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuXG4gICAgICAmJiAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpXG4gICAgICAmJiAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgICAgZWxzZSBkZWxldGUgdGhpcy5fZXZlbnRzW2V2dF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm5cbiAgICAgICAgfHwgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKVxuICAgICAgICB8fCAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgZWxzZSBkZWxldGUgdGhpcy5fZXZlbnRzW2V2dF07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkge1xuICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICAgIGVsc2UgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gZG9lc24ndCBhcHBseSBhbnltb3JlLlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG5cblxuLyoqKi8gfSksXG4vKiA1NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYXRjaFRleHQgPSBleHBvcnRzLm1hdGNoU3BhY2luZyA9IGV4cG9ydHMubWF0Y2hOZXdsaW5lID0gZXhwb3J0cy5tYXRjaEJsb3QgPSBleHBvcnRzLm1hdGNoQXR0cmlidXRvciA9IGV4cG9ydHMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXh0ZW5kMiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZXh0ZW5kMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZDIpO1xuXG52YXIgX3F1aWxsRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3F1aWxsRGVsdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGxEZWx0YSk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9xdWlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfcXVpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGwpO1xuXG52YXIgX2xvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG52YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cbnZhciBfYWxpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxudmFyIF9iYWNrZ3JvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cbnZhciBfY29kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX2NvZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29kZSk7XG5cbnZhciBfY29sb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxudmFyIF9kaXJlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblxudmFyIF9mb250ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cbnZhciBfc2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBkZWJ1ZyA9ICgwLCBfbG9nZ2VyMi5kZWZhdWx0KSgncXVpbGw6Y2xpcGJvYXJkJyk7XG5cbnZhciBET01fS0VZID0gJ19fcWwtbWF0Y2hlcic7XG5cbnZhciBDTElQQk9BUkRfQ09ORklHID0gW1tOb2RlLlRFWFRfTk9ERSwgbWF0Y2hUZXh0XSwgW05vZGUuVEVYVF9OT0RFLCBtYXRjaE5ld2xpbmVdLCBbJ2JyJywgbWF0Y2hCcmVha10sIFtOb2RlLkVMRU1FTlRfTk9ERSwgbWF0Y2hOZXdsaW5lXSwgW05vZGUuRUxFTUVOVF9OT0RFLCBtYXRjaEJsb3RdLCBbTm9kZS5FTEVNRU5UX05PREUsIG1hdGNoU3BhY2luZ10sIFtOb2RlLkVMRU1FTlRfTk9ERSwgbWF0Y2hBdHRyaWJ1dG9yXSwgW05vZGUuRUxFTUVOVF9OT0RFLCBtYXRjaFN0eWxlc10sIFsnbGknLCBtYXRjaEluZGVudF0sIFsnYicsIG1hdGNoQWxpYXMuYmluZChtYXRjaEFsaWFzLCAnYm9sZCcpXSwgWydpJywgbWF0Y2hBbGlhcy5iaW5kKG1hdGNoQWxpYXMsICdpdGFsaWMnKV0sIFsnc3R5bGUnLCBtYXRjaElnbm9yZV1dO1xuXG52YXIgQVRUUklCVVRFX0FUVFJJQlVUT1JTID0gW19hbGlnbi5BbGlnbkF0dHJpYnV0ZSwgX2RpcmVjdGlvbi5EaXJlY3Rpb25BdHRyaWJ1dGVdLnJlZHVjZShmdW5jdGlvbiAobWVtbywgYXR0cikge1xuICBtZW1vW2F0dHIua2V5TmFtZV0gPSBhdHRyO1xuICByZXR1cm4gbWVtbztcbn0sIHt9KTtcblxudmFyIFNUWUxFX0FUVFJJQlVUT1JTID0gW19hbGlnbi5BbGlnblN0eWxlLCBfYmFja2dyb3VuZC5CYWNrZ3JvdW5kU3R5bGUsIF9jb2xvci5Db2xvclN0eWxlLCBfZGlyZWN0aW9uLkRpcmVjdGlvblN0eWxlLCBfZm9udC5Gb250U3R5bGUsIF9zaXplLlNpemVTdHlsZV0ucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBhdHRyKSB7XG4gIG1lbW9bYXR0ci5rZXlOYW1lXSA9IGF0dHI7XG4gIHJldHVybiBtZW1vO1xufSwge30pO1xuXG52YXIgQ2xpcGJvYXJkID0gZnVuY3Rpb24gKF9Nb2R1bGUpIHtcbiAgX2luaGVyaXRzKENsaXBib2FyZCwgX01vZHVsZSk7XG5cbiAgZnVuY3Rpb24gQ2xpcGJvYXJkKHF1aWxsLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaXBib2FyZCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ2xpcGJvYXJkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2xpcGJvYXJkKSkuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMucXVpbGwucm9vdC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIF90aGlzLm9uUGFzdGUuYmluZChfdGhpcykpO1xuICAgIF90aGlzLmNvbnRhaW5lciA9IF90aGlzLnF1aWxsLmFkZENvbnRhaW5lcigncWwtY2xpcGJvYXJkJyk7XG4gICAgX3RoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgdHJ1ZSk7XG4gICAgX3RoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSk7XG4gICAgX3RoaXMubWF0Y2hlcnMgPSBbXTtcbiAgICBDTElQQk9BUkRfQ09ORklHLmNvbmNhdChfdGhpcy5vcHRpb25zLm1hdGNoZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICBzZWxlY3RvciA9IF9yZWYyWzBdLFxuICAgICAgICAgIG1hdGNoZXIgPSBfcmVmMlsxXTtcblxuICAgICAgaWYgKCFvcHRpb25zLm1hdGNoVmlzdWFsICYmIG1hdGNoZXIgPT09IG1hdGNoU3BhY2luZykgcmV0dXJuO1xuICAgICAgX3RoaXMuYWRkTWF0Y2hlcihzZWxlY3RvciwgbWF0Y2hlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENsaXBib2FyZCwgW3tcbiAgICBrZXk6ICdhZGRNYXRjaGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTWF0Y2hlcihzZWxlY3RvciwgbWF0Y2hlcikge1xuICAgICAgdGhpcy5tYXRjaGVycy5wdXNoKFtzZWxlY3RvciwgbWF0Y2hlcl0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbnZlcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0KGh0bWwpIHtcbiAgICAgIGlmICh0eXBlb2YgaHRtbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gaHRtbC5yZXBsYWNlKC9cXD5cXHI/XFxuICtcXDwvZywgJz48Jyk7IC8vIFJlbW92ZSBzcGFjZXMgYmV0d2VlbiB0YWdzXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBmb3JtYXRzID0gdGhpcy5xdWlsbC5nZXRGb3JtYXQodGhpcy5xdWlsbC5zZWxlY3Rpb24uc2F2ZWRSYW5nZS5pbmRleCk7XG4gICAgICBpZiAoZm9ybWF0c1tfY29kZTIuZGVmYXVsdC5ibG90TmFtZV0pIHtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmNvbnRhaW5lci5pbm5lclRleHQ7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICByZXR1cm4gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkuaW5zZXJ0KHRleHQsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgX2NvZGUyLmRlZmF1bHQuYmxvdE5hbWUsIGZvcm1hdHNbX2NvZGUyLmRlZmF1bHQuYmxvdE5hbWVdKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJlcGFyZU1hdGNoaW5nID0gdGhpcy5wcmVwYXJlTWF0Y2hpbmcoKSxcbiAgICAgICAgICBfcHJlcGFyZU1hdGNoaW5nMiA9IF9zbGljZWRUb0FycmF5KF9wcmVwYXJlTWF0Y2hpbmcsIDIpLFxuICAgICAgICAgIGVsZW1lbnRNYXRjaGVycyA9IF9wcmVwYXJlTWF0Y2hpbmcyWzBdLFxuICAgICAgICAgIHRleHRNYXRjaGVycyA9IF9wcmVwYXJlTWF0Y2hpbmcyWzFdO1xuXG4gICAgICB2YXIgZGVsdGEgPSB0cmF2ZXJzZSh0aGlzLmNvbnRhaW5lciwgZWxlbWVudE1hdGNoZXJzLCB0ZXh0TWF0Y2hlcnMpO1xuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIG5ld2xpbmVcbiAgICAgIGlmIChkZWx0YUVuZHNXaXRoKGRlbHRhLCAnXFxuJykgJiYgZGVsdGEub3BzW2RlbHRhLm9wcy5sZW5ndGggLSAxXS5hdHRyaWJ1dGVzID09IG51bGwpIHtcbiAgICAgICAgZGVsdGEgPSBkZWx0YS5jb21wb3NlKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihkZWx0YS5sZW5ndGgoKSAtIDEpLmRlbGV0ZSgxKSk7XG4gICAgICB9XG4gICAgICBkZWJ1Zy5sb2coJ2NvbnZlcnQnLCB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwsIGRlbHRhKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rhbmdlcm91c2x5UGFzdGVIVE1MJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGFuZ2Vyb3VzbHlQYXN0ZUhUTUwoaW5kZXgsIGh0bWwpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLkFQSTtcblxuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRDb250ZW50cyh0aGlzLmNvbnZlcnQoaW5kZXgpLCBodG1sKTtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oMCwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXN0ZSA9IHRoaXMuY29udmVydChodG1sKTtcbiAgICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4oaW5kZXgpLmNvbmNhdChwYXN0ZSksIHNvdXJjZSk7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKGluZGV4ICsgcGFzdGUubGVuZ3RoKCksIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25QYXN0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGFzdGUoZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgIXRoaXMucXVpbGwuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB2YXIgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpO1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMucXVpbGwuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmZvY3VzKCk7XG4gICAgICB0aGlzLnF1aWxsLnNlbGVjdGlvbi51cGRhdGUoX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWx0YSA9IGRlbHRhLmNvbmNhdChfdGhpczIuY29udmVydCgpKS5kZWxldGUocmFuZ2UubGVuZ3RoKTtcbiAgICAgICAgX3RoaXMyLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgLy8gcmFuZ2UubGVuZ3RoIGNvbnRyaWJ1dGVzIHRvIGRlbHRhLmxlbmd0aCgpXG4gICAgICAgIF90aGlzMi5xdWlsbC5zZXRTZWxlY3Rpb24oZGVsdGEubGVuZ3RoKCkgLSByYW5nZS5sZW5ndGgsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICAgIF90aGlzMi5xdWlsbC5zY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICBfdGhpczIucXVpbGwuZm9jdXMoKTtcbiAgICAgIH0sIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ByZXBhcmVNYXRjaGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmVNYXRjaGluZygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgZWxlbWVudE1hdGNoZXJzID0gW10sXG4gICAgICAgICAgdGV4dE1hdGNoZXJzID0gW107XG4gICAgICB0aGlzLm1hdGNoZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgdmFyIF9wYWlyID0gX3NsaWNlZFRvQXJyYXkocGFpciwgMiksXG4gICAgICAgICAgICBzZWxlY3RvciA9IF9wYWlyWzBdLFxuICAgICAgICAgICAgbWF0Y2hlciA9IF9wYWlyWzFdO1xuXG4gICAgICAgIHN3aXRjaCAoc2VsZWN0b3IpIHtcbiAgICAgICAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOlxuICAgICAgICAgICAgdGV4dE1hdGNoZXJzLnB1c2gobWF0Y2hlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzLnB1c2gobWF0Y2hlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKF90aGlzMy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE8gdXNlIHdlYWttYXBcbiAgICAgICAgICAgICAgbm9kZVtET01fS0VZXSA9IG5vZGVbRE9NX0tFWV0gfHwgW107XG4gICAgICAgICAgICAgIG5vZGVbRE9NX0tFWV0ucHVzaChtYXRjaGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtlbGVtZW50TWF0Y2hlcnMsIHRleHRNYXRjaGVyc107XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENsaXBib2FyZDtcbn0oX21vZHVsZTIuZGVmYXVsdCk7XG5cbkNsaXBib2FyZC5ERUZBVUxUUyA9IHtcbiAgbWF0Y2hlcnM6IFtdLFxuICBtYXRjaFZpc3VhbDogdHJ1ZVxufTtcblxuZnVuY3Rpb24gYXBwbHlGb3JtYXQoZGVsdGEsIGZvcm1hdCwgdmFsdWUpIHtcbiAgaWYgKCh0eXBlb2YgZm9ybWF0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihmb3JtYXQpKSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZm9ybWF0KS5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBrZXkpIHtcbiAgICAgIHJldHVybiBhcHBseUZvcm1hdChkZWx0YSwga2V5LCBmb3JtYXRba2V5XSk7XG4gICAgfSwgZGVsdGEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZWx0YS5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBvcCkge1xuICAgICAgaWYgKG9wLmF0dHJpYnV0ZXMgJiYgb3AuYXR0cmlidXRlc1tmb3JtYXRdKSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5wdXNoKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5pbnNlcnQob3AuaW5zZXJ0LCAoMCwgX2V4dGVuZDMuZGVmYXVsdCkoe30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgZm9ybWF0LCB2YWx1ZSksIG9wLmF0dHJpYnV0ZXMpKTtcbiAgICAgIH1cbiAgICB9LCBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKG5vZGUpIHtcbiAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSByZXR1cm4ge307XG4gIHZhciBET01fS0VZID0gJ19fcWwtY29tcHV0ZWQtc3R5bGUnO1xuICByZXR1cm4gbm9kZVtET01fS0VZXSB8fCAobm9kZVtET01fS0VZXSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpKTtcbn1cblxuZnVuY3Rpb24gZGVsdGFFbmRzV2l0aChkZWx0YSwgdGV4dCkge1xuICB2YXIgZW5kVGV4dCA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSBkZWx0YS5vcHMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIGVuZFRleHQubGVuZ3RoIDwgdGV4dC5sZW5ndGg7IC0taSkge1xuICAgIHZhciBvcCA9IGRlbHRhLm9wc1tpXTtcbiAgICBpZiAodHlwZW9mIG9wLmluc2VydCAhPT0gJ3N0cmluZycpIGJyZWFrO1xuICAgIGVuZFRleHQgPSBvcC5pbnNlcnQgKyBlbmRUZXh0O1xuICB9XG4gIHJldHVybiBlbmRUZXh0LnNsaWNlKC0xICogdGV4dC5sZW5ndGgpID09PSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBpc0xpbmUobm9kZSkge1xuICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlOyAvLyBFeGNsdWRlIGVtYmVkIGJsb2Nrc1xuICB2YXIgc3R5bGUgPSBjb21wdXRlU3R5bGUobm9kZSk7XG4gIHJldHVybiBbJ2Jsb2NrJywgJ2xpc3QtaXRlbSddLmluZGV4T2Yoc3R5bGUuZGlzcGxheSkgPiAtMTtcbn1cblxuZnVuY3Rpb24gdHJhdmVyc2Uobm9kZSwgZWxlbWVudE1hdGNoZXJzLCB0ZXh0TWF0Y2hlcnMpIHtcbiAgLy8gUG9zdC1vcmRlclxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5URVhUX05PREUpIHtcbiAgICByZXR1cm4gdGV4dE1hdGNoZXJzLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIG1hdGNoZXIpIHtcbiAgICAgIHJldHVybiBtYXRjaGVyKG5vZGUsIGRlbHRhKTtcbiAgICB9LCBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKSk7XG4gIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICByZXR1cm4gW10ucmVkdWNlLmNhbGwobm9kZS5jaGlsZE5vZGVzIHx8IFtdLCBmdW5jdGlvbiAoZGVsdGEsIGNoaWxkTm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuRGVsdGEgPSB0cmF2ZXJzZShjaGlsZE5vZGUsIGVsZW1lbnRNYXRjaGVycywgdGV4dE1hdGNoZXJzKTtcbiAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGNoaWxkcmVuRGVsdGEgPSBlbGVtZW50TWF0Y2hlcnMucmVkdWNlKGZ1bmN0aW9uIChjaGlsZHJlbkRlbHRhLCBtYXRjaGVyKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoZXIoY2hpbGROb2RlLCBjaGlsZHJlbkRlbHRhKTtcbiAgICAgICAgfSwgY2hpbGRyZW5EZWx0YSk7XG4gICAgICAgIGNoaWxkcmVuRGVsdGEgPSAoY2hpbGROb2RlW0RPTV9LRVldIHx8IFtdKS5yZWR1Y2UoZnVuY3Rpb24gKGNoaWxkcmVuRGVsdGEsIG1hdGNoZXIpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hlcihjaGlsZE5vZGUsIGNoaWxkcmVuRGVsdGEpO1xuICAgICAgICB9LCBjaGlsZHJlbkRlbHRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWx0YS5jb25jYXQoY2hpbGRyZW5EZWx0YSk7XG4gICAgfSwgbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaEFsaWFzKGZvcm1hdCwgbm9kZSwgZGVsdGEpIHtcbiAgcmV0dXJuIGFwcGx5Rm9ybWF0KGRlbHRhLCBmb3JtYXQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBtYXRjaEF0dHJpYnV0b3Iobm9kZSwgZGVsdGEpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQXR0cmlidXRlLmtleXMobm9kZSk7XG4gIHZhciBjbGFzc2VzID0gX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkNsYXNzLmtleXMobm9kZSk7XG4gIHZhciBzdHlsZXMgPSBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuU3R5bGUua2V5cyhub2RlKTtcbiAgdmFyIGZvcm1hdHMgPSB7fTtcbiAgYXR0cmlidXRlcy5jb25jYXQoY2xhc3NlcykuY29uY2F0KHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBhdHRyID0gX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShuYW1lLCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkFUVFJJQlVURSk7XG4gICAgaWYgKGF0dHIgIT0gbnVsbCkge1xuICAgICAgZm9ybWF0c1thdHRyLmF0dHJOYW1lXSA9IGF0dHIudmFsdWUobm9kZSk7XG4gICAgICBpZiAoZm9ybWF0c1thdHRyLmF0dHJOYW1lXSkgcmV0dXJuO1xuICAgIH1cbiAgICBhdHRyID0gQVRUUklCVVRFX0FUVFJJQlVUT1JTW25hbWVdO1xuICAgIGlmIChhdHRyICE9IG51bGwgJiYgKGF0dHIuYXR0ck5hbWUgPT09IG5hbWUgfHwgYXR0ci5rZXlOYW1lID09PSBuYW1lKSkge1xuICAgICAgZm9ybWF0c1thdHRyLmF0dHJOYW1lXSA9IGF0dHIudmFsdWUobm9kZSkgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhdHRyID0gU1RZTEVfQVRUUklCVVRPUlNbbmFtZV07XG4gICAgaWYgKGF0dHIgIT0gbnVsbCAmJiAoYXR0ci5hdHRyTmFtZSA9PT0gbmFtZSB8fCBhdHRyLmtleU5hbWUgPT09IG5hbWUpKSB7XG4gICAgICBhdHRyID0gU1RZTEVfQVRUUklCVVRPUlNbbmFtZV07XG4gICAgICBmb3JtYXRzW2F0dHIuYXR0ck5hbWVdID0gYXR0ci52YWx1ZShub2RlKSB8fCB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcbiAgaWYgKE9iamVjdC5rZXlzKGZvcm1hdHMpLmxlbmd0aCA+IDApIHtcbiAgICBkZWx0YSA9IGFwcGx5Rm9ybWF0KGRlbHRhLCBmb3JtYXRzKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIG1hdGNoQmxvdChub2RlLCBkZWx0YSkge1xuICB2YXIgbWF0Y2ggPSBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KG5vZGUpO1xuICBpZiAobWF0Y2ggPT0gbnVsbCkgcmV0dXJuIGRlbHRhO1xuICBpZiAobWF0Y2gucHJvdG90eXBlIGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCkge1xuICAgIHZhciBlbWJlZCA9IHt9O1xuICAgIHZhciB2YWx1ZSA9IG1hdGNoLnZhbHVlKG5vZGUpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBlbWJlZFttYXRjaC5ibG90TmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkuaW5zZXJ0KGVtYmVkLCBtYXRjaC5mb3JtYXRzKG5vZGUpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1hdGNoLmZvcm1hdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkZWx0YSA9IGFwcGx5Rm9ybWF0KGRlbHRhLCBtYXRjaC5ibG90TmFtZSwgbWF0Y2guZm9ybWF0cyhub2RlKSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBtYXRjaEJyZWFrKG5vZGUsIGRlbHRhKSB7XG4gIGlmICghZGVsdGFFbmRzV2l0aChkZWx0YSwgJ1xcbicpKSB7XG4gICAgZGVsdGEuaW5zZXJ0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIG1hdGNoSWdub3JlKCkge1xuICByZXR1cm4gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoSW5kZW50KG5vZGUsIGRlbHRhKSB7XG4gIHZhciBtYXRjaCA9IF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobm9kZSk7XG4gIGlmIChtYXRjaCA9PSBudWxsIHx8IG1hdGNoLmJsb3ROYW1lICE9PSAnbGlzdC1pdGVtJyB8fCAhZGVsdGFFbmRzV2l0aChkZWx0YSwgJ1xcbicpKSB7XG4gICAgcmV0dXJuIGRlbHRhO1xuICB9XG4gIHZhciBpbmRlbnQgPSAtMSxcbiAgICAgIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgd2hpbGUgKCFwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1jbGlwYm9hcmQnKSkge1xuICAgIGlmICgoX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShwYXJlbnQpIHx8IHt9KS5ibG90TmFtZSA9PT0gJ2xpc3QnKSB7XG4gICAgICBpbmRlbnQgKz0gMTtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgaWYgKGluZGVudCA8PSAwKSByZXR1cm4gZGVsdGE7XG4gIHJldHVybiBkZWx0YS5jb21wb3NlKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihkZWx0YS5sZW5ndGgoKSAtIDEpLnJldGFpbigxLCB7IGluZGVudDogaW5kZW50IH0pKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hOZXdsaW5lKG5vZGUsIGRlbHRhKSB7XG4gIGlmICghZGVsdGFFbmRzV2l0aChkZWx0YSwgJ1xcbicpKSB7XG4gICAgaWYgKGlzTGluZShub2RlKSB8fCBkZWx0YS5sZW5ndGgoKSA+IDAgJiYgbm9kZS5uZXh0U2libGluZyAmJiBpc0xpbmUobm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgIGRlbHRhLmluc2VydCgnXFxuJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hTcGFjaW5nKG5vZGUsIGRlbHRhKSB7XG4gIGlmIChpc0xpbmUobm9kZSkgJiYgbm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgIT0gbnVsbCAmJiAhZGVsdGFFbmRzV2l0aChkZWx0YSwgJ1xcblxcbicpKSB7XG4gICAgdmFyIG5vZGVIZWlnaHQgPSBub2RlLm9mZnNldEhlaWdodCArIHBhcnNlRmxvYXQoY29tcHV0ZVN0eWxlKG5vZGUpLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KGNvbXB1dGVTdHlsZShub2RlKS5tYXJnaW5Cb3R0b20pO1xuICAgIGlmIChub2RlLm5leHRFbGVtZW50U2libGluZy5vZmZzZXRUb3AgPiBub2RlLm9mZnNldFRvcCArIG5vZGVIZWlnaHQgKiAxLjUpIHtcbiAgICAgIGRlbHRhLmluc2VydCgnXFxuJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hTdHlsZXMobm9kZSwgZGVsdGEpIHtcbiAgdmFyIGZvcm1hdHMgPSB7fTtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZSB8fCB7fTtcbiAgaWYgKHN0eWxlLmZvbnRTdHlsZSAmJiBjb21wdXRlU3R5bGUobm9kZSkuZm9udFN0eWxlID09PSAnaXRhbGljJykge1xuICAgIGZvcm1hdHMuaXRhbGljID0gdHJ1ZTtcbiAgfVxuICBpZiAoc3R5bGUuZm9udFdlaWdodCAmJiAoY29tcHV0ZVN0eWxlKG5vZGUpLmZvbnRXZWlnaHQuc3RhcnRzV2l0aCgnYm9sZCcpIHx8IHBhcnNlSW50KGNvbXB1dGVTdHlsZShub2RlKS5mb250V2VpZ2h0KSA+PSA3MDApKSB7XG4gICAgZm9ybWF0cy5ib2xkID0gdHJ1ZTtcbiAgfVxuICBpZiAoT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID4gMCkge1xuICAgIGRlbHRhID0gYXBwbHlGb3JtYXQoZGVsdGEsIGZvcm1hdHMpO1xuICB9XG4gIGlmIChwYXJzZUZsb2F0KHN0eWxlLnRleHRJbmRlbnQgfHwgMCkgPiAwKSB7XG4gICAgLy8gQ291bGQgYmUgMC41aW5cbiAgICBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLmluc2VydCgnXFx0JykuY29uY2F0KGRlbHRhKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIG1hdGNoVGV4dChub2RlLCBkZWx0YSkge1xuICB2YXIgdGV4dCA9IG5vZGUuZGF0YTtcbiAgLy8gV29yZCByZXByZXNlbnRzIGVtcHR5IGxpbmUgd2l0aCA8bzpwPiZuYnNwOzwvbzpwPlxuICBpZiAobm9kZS5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdPOlAnKSB7XG4gICAgcmV0dXJuIGRlbHRhLmluc2VydCh0ZXh0LnRyaW0oKSk7XG4gIH1cbiAgaWYgKHRleHQudHJpbSgpLmxlbmd0aCA9PT0gMCAmJiBub2RlLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1jbGlwYm9hcmQnKSkge1xuICAgIHJldHVybiBkZWx0YTtcbiAgfVxuICBpZiAoIWNvbXB1dGVTdHlsZShub2RlLnBhcmVudE5vZGUpLndoaXRlU3BhY2Uuc3RhcnRzV2l0aCgncHJlJykpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1zdHlsZVxuICAgIHZhciByZXBsYWNlciA9IGZ1bmN0aW9uIHJlcGxhY2VyKGNvbGxhcHNlLCBtYXRjaCkge1xuICAgICAgbWF0Y2ggPSBtYXRjaC5yZXBsYWNlKC9bXlxcdTAwYTBdL2csICcnKTsgLy8gXFx1MDBhMCBpcyBuYnNwO1xuICAgICAgcmV0dXJuIG1hdGNoLmxlbmd0aCA8IDEgJiYgY29sbGFwc2UgPyAnICcgOiBtYXRjaDtcbiAgICB9O1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnICcpLnJlcGxhY2UoL1xcbi9nLCAnICcpO1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcc1xccysvZywgcmVwbGFjZXIuYmluZChyZXBsYWNlciwgdHJ1ZSkpOyAvLyBjb2xsYXBzZSB3aGl0ZXNwYWNlXG4gICAgaWYgKG5vZGUucHJldmlvdXNTaWJsaW5nID09IG51bGwgJiYgaXNMaW5lKG5vZGUucGFyZW50Tm9kZSkgfHwgbm9kZS5wcmV2aW91c1NpYmxpbmcgIT0gbnVsbCAmJiBpc0xpbmUobm9kZS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eXFxzKy8sIHJlcGxhY2VyLmJpbmQocmVwbGFjZXIsIGZhbHNlKSk7XG4gICAgfVxuICAgIGlmIChub2RlLm5leHRTaWJsaW5nID09IG51bGwgJiYgaXNMaW5lKG5vZGUucGFyZW50Tm9kZSkgfHwgbm9kZS5uZXh0U2libGluZyAhPSBudWxsICYmIGlzTGluZShub2RlLm5leHRTaWJsaW5nKSkge1xuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxzKyQvLCByZXBsYWNlci5iaW5kKHJlcGxhY2VyLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVsdGEuaW5zZXJ0KHRleHQpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBDbGlwYm9hcmQ7XG5leHBvcnRzLm1hdGNoQXR0cmlidXRvciA9IG1hdGNoQXR0cmlidXRvcjtcbmV4cG9ydHMubWF0Y2hCbG90ID0gbWF0Y2hCbG90O1xuZXhwb3J0cy5tYXRjaE5ld2xpbmUgPSBtYXRjaE5ld2xpbmU7XG5leHBvcnRzLm1hdGNoU3BhY2luZyA9IG1hdGNoU3BhY2luZztcbmV4cG9ydHMubWF0Y2hUZXh0ID0gbWF0Y2hUZXh0O1xuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9pbmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX2lubGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmxpbmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBCb2xkID0gZnVuY3Rpb24gKF9JbmxpbmUpIHtcbiAgX2luaGVyaXRzKEJvbGQsIF9JbmxpbmUpO1xuXG4gIGZ1bmN0aW9uIEJvbGQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJvbGQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCb2xkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9sZCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJvbGQsIFt7XG4gICAga2V5OiAnb3B0aW1pemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpbWl6ZShjb250ZXh0KSB7XG4gICAgICBfZ2V0KEJvbGQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9sZC5wcm90b3R5cGUpLCAnb3B0aW1pemUnLCB0aGlzKS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgaWYgKHRoaXMuZG9tTm9kZS50YWdOYW1lICE9PSB0aGlzLnN0YXRpY3MudGFnTmFtZVswXSkge1xuICAgICAgICB0aGlzLnJlcGxhY2VXaXRoKHRoaXMuc3RhdGljcy5ibG90TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdjcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4gX2dldChCb2xkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9sZCksICdjcmVhdGUnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJvbGQ7XG59KF9pbmxpbmUyLmRlZmF1bHQpO1xuXG5Cb2xkLmJsb3ROYW1lID0gJ2JvbGQnO1xuQm9sZC50YWdOYW1lID0gWydTVFJPTkcnLCAnQiddO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCb2xkO1xuXG4vKioqLyB9KSxcbi8qIDU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZENvbnRyb2xzID0gZXhwb3J0cy5kZWZhdWx0ID0gdW5kZWZpbmVkO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcXVpbGxEZWx0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfcXVpbGxEZWx0YTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbERlbHRhKTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX3F1aWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9xdWlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbCk7XG5cbnZhciBfbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ2dlcik7XG5cbnZhciBfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9tb2R1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgZGVidWcgPSAoMCwgX2xvZ2dlcjIuZGVmYXVsdCkoJ3F1aWxsOnRvb2xiYXInKTtcblxudmFyIFRvb2xiYXIgPSBmdW5jdGlvbiAoX01vZHVsZSkge1xuICBfaW5oZXJpdHMoVG9vbGJhciwgX01vZHVsZSk7XG5cbiAgZnVuY3Rpb24gVG9vbGJhcihxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sYmFyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUb29sYmFyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVG9vbGJhcikpLmNhbGwodGhpcywgcXVpbGwsIG9wdGlvbnMpKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KF90aGlzLm9wdGlvbnMuY29udGFpbmVyKSkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgYWRkQ29udHJvbHMoY29udGFpbmVyLCBfdGhpcy5vcHRpb25zLmNvbnRhaW5lcik7XG4gICAgICBxdWlsbC5jb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBxdWlsbC5jb250YWluZXIpO1xuICAgICAgX3RoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGlzLm9wdGlvbnMuY29udGFpbmVyID09PSAnc3RyaW5nJykge1xuICAgICAgX3RoaXMuY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5vcHRpb25zLmNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmNvbnRhaW5lciA9IF90aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgIH1cbiAgICBpZiAoIShfdGhpcy5jb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHZhciBfcmV0O1xuXG4gICAgICByZXR1cm4gX3JldCA9IGRlYnVnLmVycm9yKCdDb250YWluZXIgcmVxdWlyZWQgZm9yIHRvb2xiYXInLCBfdGhpcy5vcHRpb25zKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICAgIH1cbiAgICBfdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgncWwtdG9vbGJhcicpO1xuICAgIF90aGlzLmNvbnRyb2xzID0gW107XG4gICAgX3RoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfdGhpcy5vcHRpb25zLmhhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgIF90aGlzLmFkZEhhbmRsZXIoZm9ybWF0LCBfdGhpcy5vcHRpb25zLmhhbmRsZXJzW2Zvcm1hdF0pO1xuICAgIH0pO1xuICAgIFtdLmZvckVhY2guY2FsbChfdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uLCBzZWxlY3QnKSwgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBfdGhpcy5hdHRhY2goaW5wdXQpO1xuICAgIH0pO1xuICAgIF90aGlzLnF1aWxsLm9uKF9xdWlsbDIuZGVmYXVsdC5ldmVudHMuRURJVE9SX0NIQU5HRSwgZnVuY3Rpb24gKHR5cGUsIHJhbmdlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gX3F1aWxsMi5kZWZhdWx0LmV2ZW50cy5TRUxFQ1RJT05fQ0hBTkdFKSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZShyYW5nZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RoaXMucXVpbGwub24oX3F1aWxsMi5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfT1BUSU1JWkUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyRxdWlsbCRzZWxlY3Rpb24gPSBfdGhpcy5xdWlsbC5zZWxlY3Rpb24uZ2V0UmFuZ2UoKSxcbiAgICAgICAgICBfdGhpcyRxdWlsbCRzZWxlY3Rpb24yID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkcXVpbGwkc2VsZWN0aW9uLCAxKSxcbiAgICAgICAgICByYW5nZSA9IF90aGlzJHF1aWxsJHNlbGVjdGlvbjJbMF07IC8vIHF1aWxsLmdldFNlbGVjdGlvbiB0cmlnZ2VycyB1cGRhdGVcblxuXG4gICAgICBfdGhpcy51cGRhdGUocmFuZ2UpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUb29sYmFyLCBbe1xuICAgIGtleTogJ2FkZEhhbmRsZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRIYW5kbGVyKGZvcm1hdCwgaGFuZGxlcikge1xuICAgICAgdGhpcy5oYW5kbGVyc1tmb3JtYXRdID0gaGFuZGxlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhdHRhY2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2goaW5wdXQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZm9ybWF0ID0gW10uZmluZC5jYWxsKGlucHV0LmNsYXNzTGlzdCwgZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoJ3FsLScpID09PSAwO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWZvcm1hdCkgcmV0dXJuO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnNsaWNlKCdxbC0nLmxlbmd0aCk7XG4gICAgICBpZiAoaW5wdXQudGFnTmFtZSA9PT0gJ0JVVFRPTicpIHtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFuZGxlcnNbZm9ybWF0XSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLnF1aWxsLnNjcm9sbC53aGl0ZWxpc3QgIT0gbnVsbCAmJiB0aGlzLnF1aWxsLnNjcm9sbC53aGl0ZWxpc3RbZm9ybWF0XSA9PSBudWxsKSB7XG4gICAgICAgICAgZGVidWcud2FybignaWdub3JpbmcgYXR0YWNoaW5nIHRvIGRpc2FibGVkIGZvcm1hdCcsIGZvcm1hdCwgaW5wdXQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShmb3JtYXQpID09IG51bGwpIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKCdpZ25vcmluZyBhdHRhY2hpbmcgdG8gbm9uZXhpc3RlbnQgZm9ybWF0JywgZm9ybWF0LCBpbnB1dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXZlbnROYW1lID0gaW5wdXQudGFnTmFtZSA9PT0gJ1NFTEVDVCcgPyAnY2hhbmdlJyA6ICdjbGljayc7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgICBpZiAoaW5wdXQudGFnTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuc2VsZWN0ZWRJbmRleCA8IDApIHJldHVybjtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBpbnB1dC5vcHRpb25zW2lucHV0LnNlbGVjdGVkSW5kZXhdO1xuICAgICAgICAgIGlmIChzZWxlY3RlZC5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2VsZWN0ZWQudmFsdWUgfHwgZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpbnB1dC5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWFjdGl2ZScpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGlucHV0LnZhbHVlIHx8ICFpbnB1dC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczIucXVpbGwuZm9jdXMoKTtcblxuICAgICAgICB2YXIgX3F1aWxsJHNlbGVjdGlvbiRnZXRSID0gX3RoaXMyLnF1aWxsLnNlbGVjdGlvbi5nZXRSYW5nZSgpLFxuICAgICAgICAgICAgX3F1aWxsJHNlbGVjdGlvbiRnZXRSMiA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRzZWxlY3Rpb24kZ2V0UiwgMSksXG4gICAgICAgICAgICByYW5nZSA9IF9xdWlsbCRzZWxlY3Rpb24kZ2V0UjJbMF07XG5cbiAgICAgICAgaWYgKF90aGlzMi5oYW5kbGVyc1tmb3JtYXRdICE9IG51bGwpIHtcbiAgICAgICAgICBfdGhpczIuaGFuZGxlcnNbZm9ybWF0XS5jYWxsKF90aGlzMiwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkoZm9ybWF0KS5wcm90b3R5cGUgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9tcHQoJ0VudGVyICcgKyBmb3JtYXQpO1xuICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgICAgICBfdGhpczIucXVpbGwudXBkYXRlQ29udGVudHMobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKHJhbmdlLmluZGV4KS5kZWxldGUocmFuZ2UubGVuZ3RoKS5pbnNlcnQoX2RlZmluZVByb3BlcnR5KHt9LCBmb3JtYXQsIHZhbHVlKSksIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMi5xdWlsbC5mb3JtYXQoZm9ybWF0LCB2YWx1ZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMyLnVwZGF0ZShyYW5nZSk7XG4gICAgICB9KTtcbiAgICAgIC8vIFRPRE8gdXNlIHdlYWttYXBcbiAgICAgIHRoaXMuY29udHJvbHMucHVzaChbZm9ybWF0LCBpbnB1dF0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShyYW5nZSkge1xuICAgICAgdmFyIGZvcm1hdHMgPSByYW5nZSA9PSBudWxsID8ge30gOiB0aGlzLnF1aWxsLmdldEZvcm1hdChyYW5nZSk7XG4gICAgICB0aGlzLmNvbnRyb2xzLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgdmFyIF9wYWlyID0gX3NsaWNlZFRvQXJyYXkocGFpciwgMiksXG4gICAgICAgICAgICBmb3JtYXQgPSBfcGFpclswXSxcbiAgICAgICAgICAgIGlucHV0ID0gX3BhaXJbMV07XG5cbiAgICAgICAgaWYgKGlucHV0LnRhZ05hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAocmFuZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9uID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdHNbZm9ybWF0XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb24gPSBpbnB1dC5xdWVyeVNlbGVjdG9yKCdvcHRpb25bc2VsZWN0ZWRdJyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShmb3JtYXRzW2Zvcm1hdF0pKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBmb3JtYXRzW2Zvcm1hdF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXCIvZywgJ1xcXFxcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9uID0gaW5wdXQucXVlcnlTZWxlY3Rvcignb3B0aW9uW3ZhbHVlPVwiJyArIHZhbHVlICsgJ1wiXScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gJyc7IC8vIFRPRE8gbWFrZSBjb25maWd1cmFibGU/XG4gICAgICAgICAgICBpbnB1dC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCdxbC1hY3RpdmUnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkge1xuICAgICAgICAgICAgLy8gYm90aCBiZWluZyBudWxsIHNob3VsZCBtYXRjaCAoZGVmYXVsdCB2YWx1ZXMpXG4gICAgICAgICAgICAvLyAnMScgc2hvdWxkIG1hdGNoIHdpdGggMSAoaGVhZGVycylcbiAgICAgICAgICAgIHZhciBpc0FjdGl2ZSA9IGZvcm1hdHNbZm9ybWF0XSA9PT0gaW5wdXQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpIHx8IGZvcm1hdHNbZm9ybWF0XSAhPSBudWxsICYmIGZvcm1hdHNbZm9ybWF0XS50b1N0cmluZygpID09PSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgZm9ybWF0c1tmb3JtYXRdID09IG51bGwgJiYgIWlucHV0LmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC50b2dnbGUoJ3FsLWFjdGl2ZScsIGlzQWN0aXZlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LnRvZ2dsZSgncWwtYWN0aXZlJywgZm9ybWF0c1tmb3JtYXRdICE9IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRvb2xiYXI7XG59KF9tb2R1bGUyLmRlZmF1bHQpO1xuXG5Ub29sYmFyLkRFRkFVTFRTID0ge307XG5cbmZ1bmN0aW9uIGFkZEJ1dHRvbihjb250YWluZXIsIGZvcm1hdCwgdmFsdWUpIHtcbiAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gIGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgaW5wdXQuY2xhc3NMaXN0LmFkZCgncWwtJyArIGZvcm1hdCk7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBhZGRDb250cm9scyhjb250YWluZXIsIGdyb3Vwcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZ3JvdXBzWzBdKSkge1xuICAgIGdyb3VwcyA9IFtncm91cHNdO1xuICB9XG4gIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9scykge1xuICAgIHZhciBncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBncm91cC5jbGFzc0xpc3QuYWRkKCdxbC1mb3JtYXRzJyk7XG4gICAgY29udHJvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgaWYgKHR5cGVvZiBjb250cm9sID09PSAnc3RyaW5nJykge1xuICAgICAgICBhZGRCdXR0b24oZ3JvdXAsIGNvbnRyb2wpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IE9iamVjdC5rZXlzKGNvbnRyb2wpWzBdO1xuICAgICAgICB2YXIgdmFsdWUgPSBjb250cm9sW2Zvcm1hdF07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGFkZFNlbGVjdChncm91cCwgZm9ybWF0LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQnV0dG9uKGdyb3VwLCBmb3JtYXQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChncm91cCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTZWxlY3QoY29udGFpbmVyLCBmb3JtYXQsIHZhbHVlcykge1xuICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgaW5wdXQuY2xhc3NMaXN0LmFkZCgncWwtJyArIGZvcm1hdCk7XG4gIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBvcHRpb24uc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9uLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnc2VsZWN0ZWQnKTtcbiAgICB9XG4gICAgaW5wdXQuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgfSk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbnB1dCk7XG59XG5cblRvb2xiYXIuREVGQVVMVFMgPSB7XG4gIGNvbnRhaW5lcjogbnVsbCxcbiAgaGFuZGxlcnM6IHtcbiAgICBjbGVhbjogZnVuY3Rpb24gY2xlYW4oKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHJhbmdlID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChyYW5nZSA9PSBudWxsKSByZXR1cm47XG4gICAgICBpZiAocmFuZ2UubGVuZ3RoID09IDApIHtcbiAgICAgICAgdmFyIGZvcm1hdHMgPSB0aGlzLnF1aWxsLmdldEZvcm1hdCgpO1xuICAgICAgICBPYmplY3Qua2V5cyhmb3JtYXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgLy8gQ2xlYW4gZnVuY3Rpb25hbGl0eSBpbiBleGlzdGluZyBhcHBzIG9ubHkgY2xlYW4gaW5saW5lIGZvcm1hdHNcbiAgICAgICAgICBpZiAoX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShuYW1lLCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLklOTElORSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMzLnF1aWxsLmZvcm1hdChuYW1lLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVpbGwucmVtb3ZlRm9ybWF0KHJhbmdlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpcmVjdGlvbjogZnVuY3Rpb24gZGlyZWN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgYWxpZ24gPSB0aGlzLnF1aWxsLmdldEZvcm1hdCgpWydhbGlnbiddO1xuICAgICAgaWYgKHZhbHVlID09PSAncnRsJyAmJiBhbGlnbiA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdhbGlnbicsICdyaWdodCcsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfSBlbHNlIGlmICghdmFsdWUgJiYgYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2FsaWduJywgZmFsc2UsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfVxuICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2RpcmVjdGlvbicsIHZhbHVlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICB9LFxuICAgIGluZGVudDogZnVuY3Rpb24gaW5kZW50KHZhbHVlKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnF1aWxsLmdldFNlbGVjdGlvbigpO1xuICAgICAgdmFyIGZvcm1hdHMgPSB0aGlzLnF1aWxsLmdldEZvcm1hdChyYW5nZSk7XG4gICAgICB2YXIgaW5kZW50ID0gcGFyc2VJbnQoZm9ybWF0cy5pbmRlbnQgfHwgMCk7XG4gICAgICBpZiAodmFsdWUgPT09ICcrMScgfHwgdmFsdWUgPT09ICctMScpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVyID0gdmFsdWUgPT09ICcrMScgPyAxIDogLTE7XG4gICAgICAgIGlmIChmb3JtYXRzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIG1vZGlmaWVyICo9IC0xO1xuICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnaW5kZW50JywgaW5kZW50ICsgbW9kaWZpZXIsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24gbGluayh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHZhbHVlID0gcHJvbXB0KCdFbnRlciBsaW5rIFVSTDonKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdsaW5rJywgdmFsdWUsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgIH0sXG4gICAgbGlzdDogZnVuY3Rpb24gbGlzdCh2YWx1ZSkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHZhciBmb3JtYXRzID0gdGhpcy5xdWlsbC5nZXRGb3JtYXQocmFuZ2UpO1xuICAgICAgaWYgKHZhbHVlID09PSAnY2hlY2snKSB7XG4gICAgICAgIGlmIChmb3JtYXRzWydsaXN0J10gPT09ICdjaGVja2VkJyB8fCBmb3JtYXRzWydsaXN0J10gPT09ICd1bmNoZWNrZWQnKSB7XG4gICAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2xpc3QnLCBmYWxzZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2xpc3QnLCAndW5jaGVja2VkJywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdsaXN0JywgdmFsdWUsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVG9vbGJhcjtcbmV4cG9ydHMuYWRkQ29udHJvbHMgPSBhZGRDb250cm9scztcblxuLyoqKi8gfSksXG4vKiA1OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cG9seWxpbmUgY2xhc3M9XFxcInFsLWV2ZW4gcWwtc3Ryb2tlXFxcIiBwb2ludHM9XFxcIjUgNyAzIDkgNSAxMVxcXCI+PC9wb2x5bGluZT4gPHBvbHlsaW5lIGNsYXNzPVxcXCJxbC1ldmVuIHFsLXN0cm9rZVxcXCIgcG9pbnRzPVxcXCIxMyA3IDE1IDkgMTMgMTFcXFwiPjwvcG9seWxpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xMCB4Mj04IHkxPTUgeTI9MTM+PC9saW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA1OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcGlja2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbnZhciBfcGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpY2tlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENvbG9yUGlja2VyID0gZnVuY3Rpb24gKF9QaWNrZXIpIHtcbiAgX2luaGVyaXRzKENvbG9yUGlja2VyLCBfUGlja2VyKTtcblxuICBmdW5jdGlvbiBDb2xvclBpY2tlcihzZWxlY3QsIGxhYmVsKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yUGlja2VyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2xvclBpY2tlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbG9yUGlja2VyKSkuY2FsbCh0aGlzLCBzZWxlY3QpKTtcblxuICAgIF90aGlzLmxhYmVsLmlubmVySFRNTCA9IGxhYmVsO1xuICAgIF90aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdxbC1jb2xvci1waWNrZXInKTtcbiAgICBbXS5zbGljZS5jYWxsKF90aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcucWwtcGlja2VyLWl0ZW0nKSwgMCwgNykuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdxbC1wcmltYXJ5Jyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbG9yUGlja2VyLCBbe1xuICAgIGtleTogJ2J1aWxkSXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkSXRlbShvcHRpb24pIHtcbiAgICAgIHZhciBpdGVtID0gX2dldChDb2xvclBpY2tlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvclBpY2tlci5wcm90b3R5cGUpLCAnYnVpbGRJdGVtJywgdGhpcykuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgaXRlbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb24uZ2V0QXR0cmlidXRlKCd2YWx1ZScpIHx8ICcnO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0SXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEl0ZW0oaXRlbSwgdHJpZ2dlcikge1xuICAgICAgX2dldChDb2xvclBpY2tlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvclBpY2tlci5wcm90b3R5cGUpLCAnc2VsZWN0SXRlbScsIHRoaXMpLmNhbGwodGhpcywgaXRlbSwgdHJpZ2dlcik7XG4gICAgICB2YXIgY29sb3JMYWJlbCA9IHRoaXMubGFiZWwucXVlcnlTZWxlY3RvcignLnFsLWNvbG9yLWxhYmVsJyk7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtID8gaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSB8fCAnJyA6ICcnO1xuICAgICAgaWYgKGNvbG9yTGFiZWwpIHtcbiAgICAgICAgaWYgKGNvbG9yTGFiZWwudGFnTmFtZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgY29sb3JMYWJlbC5zdHlsZS5zdHJva2UgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xvckxhYmVsLnN0eWxlLmZpbGwgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2xvclBpY2tlcjtcbn0oX3BpY2tlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENvbG9yUGlja2VyO1xuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9waWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxudmFyIF9waWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGlja2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSWNvblBpY2tlciA9IGZ1bmN0aW9uIChfUGlja2VyKSB7XG4gIF9pbmhlcml0cyhJY29uUGlja2VyLCBfUGlja2VyKTtcblxuICBmdW5jdGlvbiBJY29uUGlja2VyKHNlbGVjdCwgaWNvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWNvblBpY2tlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSWNvblBpY2tlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEljb25QaWNrZXIpKS5jYWxsKHRoaXMsIHNlbGVjdCkpO1xuXG4gICAgX3RoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3FsLWljb24tcGlja2VyJyk7XG4gICAgW10uZm9yRWFjaC5jYWxsKF90aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcucWwtcGlja2VyLWl0ZW0nKSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGl0ZW0uaW5uZXJIVE1MID0gaWNvbnNbaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSB8fCAnJ107XG4gICAgfSk7XG4gICAgX3RoaXMuZGVmYXVsdEl0ZW0gPSBfdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcignLnFsLXNlbGVjdGVkJyk7XG4gICAgX3RoaXMuc2VsZWN0SXRlbShfdGhpcy5kZWZhdWx0SXRlbSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEljb25QaWNrZXIsIFt7XG4gICAga2V5OiAnc2VsZWN0SXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEl0ZW0oaXRlbSwgdHJpZ2dlcikge1xuICAgICAgX2dldChJY29uUGlja2VyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEljb25QaWNrZXIucHJvdG90eXBlKSwgJ3NlbGVjdEl0ZW0nLCB0aGlzKS5jYWxsKHRoaXMsIGl0ZW0sIHRyaWdnZXIpO1xuICAgICAgaXRlbSA9IGl0ZW0gfHwgdGhpcy5kZWZhdWx0SXRlbTtcbiAgICAgIHRoaXMubGFiZWwuaW5uZXJIVE1MID0gaXRlbS5pbm5lckhUTUw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEljb25QaWNrZXI7XG59KF9waWNrZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJY29uUGlja2VyO1xuXG4vKioqLyB9KSxcbi8qIDYxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb29sdGlwKHF1aWxsLCBib3VuZHNDb250YWluZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2x0aXApO1xuXG4gICAgdGhpcy5xdWlsbCA9IHF1aWxsO1xuICAgIHRoaXMuYm91bmRzQ29udGFpbmVyID0gYm91bmRzQ29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgdGhpcy5yb290ID0gcXVpbGwuYWRkQ29udGFpbmVyKCdxbC10b29sdGlwJyk7XG4gICAgdGhpcy5yb290LmlubmVySFRNTCA9IHRoaXMuY29uc3RydWN0b3IuVEVNUExBVEU7XG4gICAgaWYgKHRoaXMucXVpbGwucm9vdCA9PT0gdGhpcy5xdWlsbC5zY3JvbGxpbmdDb250YWluZXIpIHtcbiAgICAgIHRoaXMucXVpbGwucm9vdC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJvb3Quc3R5bGUubWFyZ2luVG9wID0gLTEgKiBfdGhpcy5xdWlsbC5yb290LnNjcm9sbFRvcCArICdweCc7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5oaWRlKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVG9vbHRpcCwgW3tcbiAgICBrZXk6ICdoaWRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHRoaXMucm9vdC5jbGFzc0xpc3QuYWRkKCdxbC1oaWRkZW4nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uKHJlZmVyZW5jZSkge1xuICAgICAgdmFyIGxlZnQgPSByZWZlcmVuY2UubGVmdCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSB0aGlzLnJvb3Qub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgLy8gcm9vdC5zY3JvbGxUb3Agc2hvdWxkIGJlIDAgaWYgc2Nyb2xsQ29udGFpbmVyICE9PSByb290XG4gICAgICB2YXIgdG9wID0gcmVmZXJlbmNlLmJvdHRvbSArIHRoaXMucXVpbGwucm9vdC5zY3JvbGxUb3A7XG4gICAgICB0aGlzLnJvb3Quc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgICAgdGhpcy5yb290LnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgICB0aGlzLnJvb3QuY2xhc3NMaXN0LnJlbW92ZSgncWwtZmxpcCcpO1xuICAgICAgdmFyIGNvbnRhaW5lckJvdW5kcyA9IHRoaXMuYm91bmRzQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHJvb3RCb3VuZHMgPSB0aGlzLnJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc2hpZnQgPSAwO1xuICAgICAgaWYgKHJvb3RCb3VuZHMucmlnaHQgPiBjb250YWluZXJCb3VuZHMucmlnaHQpIHtcbiAgICAgICAgc2hpZnQgPSBjb250YWluZXJCb3VuZHMucmlnaHQgLSByb290Qm91bmRzLnJpZ2h0O1xuICAgICAgICB0aGlzLnJvb3Quc3R5bGUubGVmdCA9IGxlZnQgKyBzaGlmdCArICdweCc7XG4gICAgICB9XG4gICAgICBpZiAocm9vdEJvdW5kcy5sZWZ0IDwgY29udGFpbmVyQm91bmRzLmxlZnQpIHtcbiAgICAgICAgc2hpZnQgPSBjb250YWluZXJCb3VuZHMubGVmdCAtIHJvb3RCb3VuZHMubGVmdDtcbiAgICAgICAgdGhpcy5yb290LnN0eWxlLmxlZnQgPSBsZWZ0ICsgc2hpZnQgKyAncHgnO1xuICAgICAgfVxuICAgICAgaWYgKHJvb3RCb3VuZHMuYm90dG9tID4gY29udGFpbmVyQm91bmRzLmJvdHRvbSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcm9vdEJvdW5kcy5ib3R0b20gLSByb290Qm91bmRzLnRvcDtcbiAgICAgICAgdmFyIHZlcnRpY2FsU2hpZnQgPSByZWZlcmVuY2UuYm90dG9tIC0gcmVmZXJlbmNlLnRvcCArIGhlaWdodDtcbiAgICAgICAgdGhpcy5yb290LnN0eWxlLnRvcCA9IHRvcCAtIHZlcnRpY2FsU2hpZnQgKyAncHgnO1xuICAgICAgICB0aGlzLnJvb3QuY2xhc3NMaXN0LmFkZCgncWwtZmxpcCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNoaWZ0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nob3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdGhpcy5yb290LmNsYXNzTGlzdC5yZW1vdmUoJ3FsLWVkaXRpbmcnKTtcbiAgICAgIHRoaXMucm9vdC5jbGFzc0xpc3QucmVtb3ZlKCdxbC1oaWRkZW4nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVG9vbHRpcDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVG9vbHRpcDtcblxuLyoqKi8gfSksXG4vKiA2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9leHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2V4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmQpO1xuXG52YXIgX2VtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX2VtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW1pdHRlcik7XG5cbnZhciBfYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXG52YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XG5cbnZhciBfbGluayA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG52YXIgX2xpbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGluayk7XG5cbnZhciBfc2VsZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfaWNvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblxudmFyIF9pY29uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pY29ucyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFRPT0xCQVJfQ09ORklHID0gW1t7IGhlYWRlcjogWycxJywgJzInLCAnMycsIGZhbHNlXSB9XSwgWydib2xkJywgJ2l0YWxpYycsICd1bmRlcmxpbmUnLCAnbGluayddLCBbeyBsaXN0OiAnb3JkZXJlZCcgfSwgeyBsaXN0OiAnYnVsbGV0JyB9XSwgWydjbGVhbiddXTtcblxudmFyIFNub3dUaGVtZSA9IGZ1bmN0aW9uIChfQmFzZVRoZW1lKSB7XG4gIF9pbmhlcml0cyhTbm93VGhlbWUsIF9CYXNlVGhlbWUpO1xuXG4gIGZ1bmN0aW9uIFNub3dUaGVtZShxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTbm93VGhlbWUpO1xuXG4gICAgaWYgKG9wdGlvbnMubW9kdWxlcy50b29sYmFyICE9IG51bGwgJiYgb3B0aW9ucy5tb2R1bGVzLnRvb2xiYXIuY29udGFpbmVyID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMubW9kdWxlcy50b29sYmFyLmNvbnRhaW5lciA9IFRPT0xCQVJfQ09ORklHO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTbm93VGhlbWUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTbm93VGhlbWUpKS5jYWxsKHRoaXMsIHF1aWxsLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5xdWlsbC5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgncWwtc25vdycpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTbm93VGhlbWUsIFt7XG4gICAga2V5OiAnZXh0ZW5kVG9vbGJhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZFRvb2xiYXIodG9vbGJhcikge1xuICAgICAgdG9vbGJhci5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgncWwtc25vdycpO1xuICAgICAgdGhpcy5idWlsZEJ1dHRvbnMoW10uc2xpY2UuY2FsbCh0b29sYmFyLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdidXR0b24nKSksIF9pY29uczIuZGVmYXVsdCk7XG4gICAgICB0aGlzLmJ1aWxkUGlja2VycyhbXS5zbGljZS5jYWxsKHRvb2xiYXIuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCcpKSwgX2ljb25zMi5kZWZhdWx0KTtcbiAgICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTbm93VG9vbHRpcCh0aGlzLnF1aWxsLCB0aGlzLm9wdGlvbnMuYm91bmRzKTtcbiAgICAgIGlmICh0b29sYmFyLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucWwtbGluaycpKSB7XG4gICAgICAgIHRoaXMucXVpbGwua2V5Ym9hcmQuYWRkQmluZGluZyh7IGtleTogJ0snLCBzaG9ydEtleTogdHJ1ZSB9LCBmdW5jdGlvbiAocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgICB0b29sYmFyLmhhbmRsZXJzWydsaW5rJ10uY2FsbCh0b29sYmFyLCAhY29udGV4dC5mb3JtYXQubGluayk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTbm93VGhlbWU7XG59KF9iYXNlMi5kZWZhdWx0KTtcblxuU25vd1RoZW1lLkRFRkFVTFRTID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKHRydWUsIHt9LCBfYmFzZTIuZGVmYXVsdC5ERUZBVUxUUywge1xuICBtb2R1bGVzOiB7XG4gICAgdG9vbGJhcjoge1xuICAgICAgaGFuZGxlcnM6IHtcbiAgICAgICAgbGluazogZnVuY3Rpb24gbGluayh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChyYW5nZSA9PSBudWxsIHx8IHJhbmdlLmxlbmd0aCA9PSAwKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgcHJldmlldyA9IHRoaXMucXVpbGwuZ2V0VGV4dChyYW5nZSk7XG4gICAgICAgICAgICBpZiAoL15cXFMrQFxcUytcXC5cXFMrJC8udGVzdChwcmV2aWV3KSAmJiBwcmV2aWV3LmluZGV4T2YoJ21haWx0bzonKSAhPT0gMCkge1xuICAgICAgICAgICAgICBwcmV2aWV3ID0gJ21haWx0bzonICsgcHJldmlldztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b29sdGlwID0gdGhpcy5xdWlsbC50aGVtZS50b29sdGlwO1xuICAgICAgICAgICAgdG9vbHRpcC5lZGl0KCdsaW5rJywgcHJldmlldyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdsaW5rJywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBTbm93VG9vbHRpcCA9IGZ1bmN0aW9uIChfQmFzZVRvb2x0aXApIHtcbiAgX2luaGVyaXRzKFNub3dUb29sdGlwLCBfQmFzZVRvb2x0aXApO1xuXG4gIGZ1bmN0aW9uIFNub3dUb29sdGlwKHF1aWxsLCBib3VuZHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU25vd1Rvb2x0aXApO1xuXG4gICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTbm93VG9vbHRpcC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNub3dUb29sdGlwKSkuY2FsbCh0aGlzLCBxdWlsbCwgYm91bmRzKSk7XG5cbiAgICBfdGhpczIucHJldmlldyA9IF90aGlzMi5yb290LnF1ZXJ5U2VsZWN0b3IoJ2EucWwtcHJldmlldycpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU25vd1Rvb2x0aXAsIFt7XG4gICAga2V5OiAnbGlzdGVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIF9nZXQoU25vd1Rvb2x0aXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU25vd1Rvb2x0aXAucHJvdG90eXBlKSwgJ2xpc3RlbicsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcignYS5xbC1hY3Rpb24nKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoX3RoaXMzLnJvb3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1lZGl0aW5nJykpIHtcbiAgICAgICAgICBfdGhpczMuc2F2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMy5lZGl0KCdsaW5rJywgX3RoaXMzLnByZXZpZXcudGV4dENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKCdhLnFsLXJlbW92ZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChfdGhpczMubGlua1JhbmdlICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBfdGhpczMubGlua1JhbmdlO1xuICAgICAgICAgIF90aGlzMy5yZXN0b3JlRm9jdXMoKTtcbiAgICAgICAgICBfdGhpczMucXVpbGwuZm9ybWF0VGV4dChyYW5nZSwgJ2xpbmsnLCBmYWxzZSwgX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgICBkZWxldGUgX3RoaXMzLmxpbmtSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBfdGhpczMuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnF1aWxsLm9uKF9lbWl0dGVyMi5kZWZhdWx0LmV2ZW50cy5TRUxFQ1RJT05fQ0hBTkdFLCBmdW5jdGlvbiAocmFuZ2UsIG9sZFJhbmdlLCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHJhbmdlID09IG51bGwpIHJldHVybjtcbiAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMCAmJiBzb3VyY2UgPT09IF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuVVNFUikge1xuICAgICAgICAgIHZhciBfcXVpbGwkc2Nyb2xsJGRlc2NlbmQgPSBfdGhpczMucXVpbGwuc2Nyb2xsLmRlc2NlbmRhbnQoX2xpbmsyLmRlZmF1bHQsIHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgICAgX3F1aWxsJHNjcm9sbCRkZXNjZW5kMiA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRzY3JvbGwkZGVzY2VuZCwgMiksXG4gICAgICAgICAgICAgIGxpbmsgPSBfcXVpbGwkc2Nyb2xsJGRlc2NlbmQyWzBdLFxuICAgICAgICAgICAgICBvZmZzZXQgPSBfcXVpbGwkc2Nyb2xsJGRlc2NlbmQyWzFdO1xuXG4gICAgICAgICAgaWYgKGxpbmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMzLmxpbmtSYW5nZSA9IG5ldyBfc2VsZWN0aW9uLlJhbmdlKHJhbmdlLmluZGV4IC0gb2Zmc2V0LCBsaW5rLmxlbmd0aCgpKTtcbiAgICAgICAgICAgIHZhciBwcmV2aWV3ID0gX2xpbmsyLmRlZmF1bHQuZm9ybWF0cyhsaW5rLmRvbU5vZGUpO1xuICAgICAgICAgICAgX3RoaXMzLnByZXZpZXcudGV4dENvbnRlbnQgPSBwcmV2aWV3O1xuICAgICAgICAgICAgX3RoaXMzLnByZXZpZXcuc2V0QXR0cmlidXRlKCdocmVmJywgcHJldmlldyk7XG4gICAgICAgICAgICBfdGhpczMuc2hvdygpO1xuICAgICAgICAgICAgX3RoaXMzLnBvc2l0aW9uKF90aGlzMy5xdWlsbC5nZXRCb3VuZHMoX3RoaXMzLmxpbmtSYW5nZSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgX3RoaXMzLmxpbmtSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczMuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2hvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICBfZ2V0KFNub3dUb29sdGlwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNub3dUb29sdGlwLnByb3RvdHlwZSksICdzaG93JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMucm9vdC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbW9kZScpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTbm93VG9vbHRpcDtcbn0oX2Jhc2UuQmFzZVRvb2x0aXApO1xuXG5Tbm93VG9vbHRpcC5URU1QTEFURSA9IFsnPGEgY2xhc3M9XCJxbC1wcmV2aWV3XCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCJhYm91dDpibGFua1wiPjwvYT4nLCAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS1mb3JtdWxhPVwiZT1tY14yXCIgZGF0YS1saW5rPVwiaHR0cHM6Ly9xdWlsbGpzLmNvbVwiIGRhdGEtdmlkZW89XCJFbWJlZCBVUkxcIj4nLCAnPGEgY2xhc3M9XCJxbC1hY3Rpb25cIj48L2E+JywgJzxhIGNsYXNzPVwicWwtcmVtb3ZlXCI+PC9hPiddLmpvaW4oJycpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTbm93VGhlbWU7XG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbnZhciBfY29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb3JlKTtcblxudmFyIF9hbGlnbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuXG52YXIgX2RpcmVjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXG52YXIgX2luZGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xuXG52YXIgX2Jsb2NrcXVvdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcblxudmFyIF9ibG9ja3F1b3RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrcXVvdGUpO1xuXG52YXIgX2hlYWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xuXG52YXIgX2hlYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWFkZXIpO1xuXG52YXIgX2xpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcblxudmFyIF9saXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpc3QpO1xuXG52YXIgX2JhY2tncm91bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxudmFyIF9jb2xvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG52YXIgX2ZvbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblxudmFyIF9zaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cbnZhciBfYm9sZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xuXG52YXIgX2JvbGQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYm9sZCk7XG5cbnZhciBfaXRhbGljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OCk7XG5cbnZhciBfaXRhbGljMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0YWxpYyk7XG5cbnZhciBfbGluayA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG52YXIgX2xpbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGluayk7XG5cbnZhciBfc2NyaXB0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG5cbnZhciBfc2NyaXB0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NjcmlwdCk7XG5cbnZhciBfc3RyaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG5cbnZhciBfc3RyaWtlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmlrZSk7XG5cbnZhciBfdW5kZXJsaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cbnZhciBfdW5kZXJsaW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VuZGVybGluZSk7XG5cbnZhciBfaW1hZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblxudmFyIF9pbWFnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbWFnZSk7XG5cbnZhciBfdmlkZW8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblxudmFyIF92aWRlbzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aWRlbyk7XG5cbnZhciBfY29kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX2NvZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29kZSk7XG5cbnZhciBfZm9ybXVsYSA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG52YXIgX2Zvcm11bGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9ybXVsYSk7XG5cbnZhciBfc3ludGF4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG5cbnZhciBfc3ludGF4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bnRheCk7XG5cbnZhciBfdG9vbGJhciA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xuXG52YXIgX3Rvb2xiYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9vbGJhcik7XG5cbnZhciBfaWNvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblxudmFyIF9pY29uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pY29ucyk7XG5cbnZhciBfcGlja2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbnZhciBfcGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpY2tlcik7XG5cbnZhciBfY29sb3JQaWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcblxudmFyIF9jb2xvclBpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2xvclBpY2tlcik7XG5cbnZhciBfaWNvblBpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xuXG52YXIgX2ljb25QaWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaWNvblBpY2tlcik7XG5cbnZhciBfdG9vbHRpcCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xuXG52YXIgX3Rvb2x0aXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9vbHRpcCk7XG5cbnZhciBfYnViYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDgpO1xuXG52YXIgX2J1YmJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9idWJibGUpO1xuXG52YXIgX3Nub3cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcblxudmFyIF9zbm93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Nub3cpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5fY29yZTIuZGVmYXVsdC5yZWdpc3Rlcih7XG4gICdhdHRyaWJ1dG9ycy9hdHRyaWJ1dGUvZGlyZWN0aW9uJzogX2RpcmVjdGlvbi5EaXJlY3Rpb25BdHRyaWJ1dGUsXG5cbiAgJ2F0dHJpYnV0b3JzL2NsYXNzL2FsaWduJzogX2FsaWduLkFsaWduQ2xhc3MsXG4gICdhdHRyaWJ1dG9ycy9jbGFzcy9iYWNrZ3JvdW5kJzogX2JhY2tncm91bmQuQmFja2dyb3VuZENsYXNzLFxuICAnYXR0cmlidXRvcnMvY2xhc3MvY29sb3InOiBfY29sb3IuQ29sb3JDbGFzcyxcbiAgJ2F0dHJpYnV0b3JzL2NsYXNzL2RpcmVjdGlvbic6IF9kaXJlY3Rpb24uRGlyZWN0aW9uQ2xhc3MsXG4gICdhdHRyaWJ1dG9ycy9jbGFzcy9mb250JzogX2ZvbnQuRm9udENsYXNzLFxuICAnYXR0cmlidXRvcnMvY2xhc3Mvc2l6ZSc6IF9zaXplLlNpemVDbGFzcyxcblxuICAnYXR0cmlidXRvcnMvc3R5bGUvYWxpZ24nOiBfYWxpZ24uQWxpZ25TdHlsZSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2JhY2tncm91bmQnOiBfYmFja2dyb3VuZC5CYWNrZ3JvdW5kU3R5bGUsXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS9jb2xvcic6IF9jb2xvci5Db2xvclN0eWxlLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvZGlyZWN0aW9uJzogX2RpcmVjdGlvbi5EaXJlY3Rpb25TdHlsZSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2ZvbnQnOiBfZm9udC5Gb250U3R5bGUsXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS9zaXplJzogX3NpemUuU2l6ZVN0eWxlXG59LCB0cnVlKTtcblxuX2NvcmUyLmRlZmF1bHQucmVnaXN0ZXIoe1xuICAnZm9ybWF0cy9hbGlnbic6IF9hbGlnbi5BbGlnbkNsYXNzLFxuICAnZm9ybWF0cy9kaXJlY3Rpb24nOiBfZGlyZWN0aW9uLkRpcmVjdGlvbkNsYXNzLFxuICAnZm9ybWF0cy9pbmRlbnQnOiBfaW5kZW50LkluZGVudENsYXNzLFxuXG4gICdmb3JtYXRzL2JhY2tncm91bmQnOiBfYmFja2dyb3VuZC5CYWNrZ3JvdW5kU3R5bGUsXG4gICdmb3JtYXRzL2NvbG9yJzogX2NvbG9yLkNvbG9yU3R5bGUsXG4gICdmb3JtYXRzL2ZvbnQnOiBfZm9udC5Gb250Q2xhc3MsXG4gICdmb3JtYXRzL3NpemUnOiBfc2l6ZS5TaXplQ2xhc3MsXG5cbiAgJ2Zvcm1hdHMvYmxvY2txdW90ZSc6IF9ibG9ja3F1b3RlMi5kZWZhdWx0LFxuICAnZm9ybWF0cy9jb2RlLWJsb2NrJzogX2NvZGUyLmRlZmF1bHQsXG4gICdmb3JtYXRzL2hlYWRlcic6IF9oZWFkZXIyLmRlZmF1bHQsXG4gICdmb3JtYXRzL2xpc3QnOiBfbGlzdDIuZGVmYXVsdCxcblxuICAnZm9ybWF0cy9ib2xkJzogX2JvbGQyLmRlZmF1bHQsXG4gICdmb3JtYXRzL2NvZGUnOiBfY29kZS5Db2RlLFxuICAnZm9ybWF0cy9pdGFsaWMnOiBfaXRhbGljMi5kZWZhdWx0LFxuICAnZm9ybWF0cy9saW5rJzogX2xpbmsyLmRlZmF1bHQsXG4gICdmb3JtYXRzL3NjcmlwdCc6IF9zY3JpcHQyLmRlZmF1bHQsXG4gICdmb3JtYXRzL3N0cmlrZSc6IF9zdHJpa2UyLmRlZmF1bHQsXG4gICdmb3JtYXRzL3VuZGVybGluZSc6IF91bmRlcmxpbmUyLmRlZmF1bHQsXG5cbiAgJ2Zvcm1hdHMvaW1hZ2UnOiBfaW1hZ2UyLmRlZmF1bHQsXG4gICdmb3JtYXRzL3ZpZGVvJzogX3ZpZGVvMi5kZWZhdWx0LFxuXG4gICdmb3JtYXRzL2xpc3QvaXRlbSc6IF9saXN0Lkxpc3RJdGVtLFxuXG4gICdtb2R1bGVzL2Zvcm11bGEnOiBfZm9ybXVsYTIuZGVmYXVsdCxcbiAgJ21vZHVsZXMvc3ludGF4JzogX3N5bnRheDIuZGVmYXVsdCxcbiAgJ21vZHVsZXMvdG9vbGJhcic6IF90b29sYmFyMi5kZWZhdWx0LFxuXG4gICd0aGVtZXMvYnViYmxlJzogX2J1YmJsZTIuZGVmYXVsdCxcbiAgJ3RoZW1lcy9zbm93JzogX3Nub3cyLmRlZmF1bHQsXG5cbiAgJ3VpL2ljb25zJzogX2ljb25zMi5kZWZhdWx0LFxuICAndWkvcGlja2VyJzogX3BpY2tlcjIuZGVmYXVsdCxcbiAgJ3VpL2ljb24tcGlja2VyJzogX2ljb25QaWNrZXIyLmRlZmF1bHQsXG4gICd1aS9jb2xvci1waWNrZXInOiBfY29sb3JQaWNrZXIyLmRlZmF1bHQsXG4gICd1aS90b29sdGlwJzogX3Rvb2x0aXAyLmRlZmF1bHRcbn0sIHRydWUpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfY29yZTIuZGVmYXVsdDtcblxuLyoqKi8gfSksXG4vKiA2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5JbmRlbnRDbGFzcyA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIElkZW50QXR0cmlidXRvciA9IGZ1bmN0aW9uIChfUGFyY2htZW50JEF0dHJpYnV0b3IpIHtcbiAgX2luaGVyaXRzKElkZW50QXR0cmlidXRvciwgX1BhcmNobWVudCRBdHRyaWJ1dG9yKTtcblxuICBmdW5jdGlvbiBJZGVudEF0dHJpYnV0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElkZW50QXR0cmlidXRvcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKElkZW50QXR0cmlidXRvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKElkZW50QXR0cmlidXRvcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKElkZW50QXR0cmlidXRvciwgW3tcbiAgICBrZXk6ICdhZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQobm9kZSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gJysxJyB8fCB2YWx1ZSA9PT0gJy0xJykge1xuICAgICAgICB2YXIgaW5kZW50ID0gdGhpcy52YWx1ZShub2RlKSB8fCAwO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSAnKzEnID8gaW5kZW50ICsgMSA6IGluZGVudCAtIDE7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgdGhpcy5yZW1vdmUobm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoSWRlbnRBdHRyaWJ1dG9yLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKElkZW50QXR0cmlidXRvci5wcm90b3R5cGUpLCAnYWRkJywgdGhpcykuY2FsbCh0aGlzLCBub2RlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FuQWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuQWRkKG5vZGUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gX2dldChJZGVudEF0dHJpYnV0b3IucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSWRlbnRBdHRyaWJ1dG9yLnByb3RvdHlwZSksICdjYW5BZGQnLCB0aGlzKS5jYWxsKHRoaXMsIG5vZGUsIHZhbHVlKSB8fCBfZ2V0KElkZW50QXR0cmlidXRvci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJZGVudEF0dHJpYnV0b3IucHJvdG90eXBlKSwgJ2NhbkFkZCcsIHRoaXMpLmNhbGwodGhpcywgbm9kZSwgcGFyc2VJbnQodmFsdWUpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG5vZGUpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChfZ2V0KElkZW50QXR0cmlidXRvci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJZGVudEF0dHJpYnV0b3IucHJvdG90eXBlKSwgJ3ZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCBub2RlKSkgfHwgdW5kZWZpbmVkOyAvLyBEb24ndCByZXR1cm4gTmFOXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIElkZW50QXR0cmlidXRvcjtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkNsYXNzKTtcblxudmFyIEluZGVudENsYXNzID0gbmV3IElkZW50QXR0cmlidXRvcignaW5kZW50JywgJ3FsLWluZGVudCcsIHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0ssXG4gIHdoaXRlbGlzdDogWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdXG59KTtcblxuZXhwb3J0cy5JbmRlbnRDbGFzcyA9IEluZGVudENsYXNzO1xuXG4vKioqLyB9KSxcbi8qIDY1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQmxvY2txdW90ZSA9IGZ1bmN0aW9uIChfQmxvY2spIHtcbiAgX2luaGVyaXRzKEJsb2NrcXVvdGUsIF9CbG9jayk7XG5cbiAgZnVuY3Rpb24gQmxvY2txdW90ZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmxvY2txdW90ZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJsb2NrcXVvdGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9ja3F1b3RlKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gQmxvY2txdW90ZTtcbn0oX2Jsb2NrMi5kZWZhdWx0KTtcblxuQmxvY2txdW90ZS5ibG90TmFtZSA9ICdibG9ja3F1b3RlJztcbkJsb2NrcXVvdGUudGFnTmFtZSA9ICdibG9ja3F1b3RlJztcblxuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2txdW90ZTtcblxuLyoqKi8gfSksXG4vKiA2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2Jsb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9ibG9jazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ibG9jayk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEhlYWRlciA9IGZ1bmN0aW9uIChfQmxvY2spIHtcbiAgX2luaGVyaXRzKEhlYWRlciwgX0Jsb2NrKTtcblxuICBmdW5jdGlvbiBIZWFkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlYWRlcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEhlYWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEhlYWRlcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEhlYWRlciwgbnVsbCwgW3tcbiAgICBrZXk6ICdmb3JtYXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cyhkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWdOYW1lLmluZGV4T2YoZG9tTm9kZS50YWdOYW1lKSArIDE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhlYWRlcjtcbn0oX2Jsb2NrMi5kZWZhdWx0KTtcblxuSGVhZGVyLmJsb3ROYW1lID0gJ2hlYWRlcic7XG5IZWFkZXIudGFnTmFtZSA9IFsnSDEnLCAnSDInLCAnSDMnLCAnSDQnLCAnSDUnLCAnSDYnXTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSGVhZGVyO1xuXG4vKioqLyB9KSxcbi8qIDY3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLkxpc3RJdGVtID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9ibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfYmxvY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmxvY2spO1xuXG52YXIgX2NvbnRhaW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG52YXIgX2NvbnRhaW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250YWluZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBMaXN0SXRlbSA9IGZ1bmN0aW9uIChfQmxvY2spIHtcbiAgX2luaGVyaXRzKExpc3RJdGVtLCBfQmxvY2spO1xuXG4gIGZ1bmN0aW9uIExpc3RJdGVtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaXN0SXRlbSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKExpc3RJdGVtLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdEl0ZW0pKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaXN0SXRlbSwgW3tcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChuYW1lID09PSBMaXN0LmJsb3ROYW1lICYmICF2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlcGxhY2VXaXRoKF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKHRoaXMuc3RhdGljcy5zY29wZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChMaXN0SXRlbS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0SXRlbS5wcm90b3R5cGUpLCAnZm9ybWF0JywgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgaWYgKHRoaXMucHJldiA9PSBudWxsICYmIHRoaXMubmV4dCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucGFyZW50LnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChMaXN0SXRlbS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0SXRlbS5wcm90b3R5cGUpLCAncmVtb3ZlJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXBsYWNlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VXaXRoKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnBhcmVudC5pc29sYXRlKHRoaXMub2Zmc2V0KHRoaXMucGFyZW50KSwgdGhpcy5sZW5ndGgoKSk7XG4gICAgICBpZiAobmFtZSA9PT0gdGhpcy5wYXJlbnQuc3RhdGljcy5ibG90TmFtZSkge1xuICAgICAgICB0aGlzLnBhcmVudC5yZXBsYWNlV2l0aChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJlbnQudW53cmFwKCk7XG4gICAgICAgIHJldHVybiBfZ2V0KExpc3RJdGVtLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpc3RJdGVtLnByb3RvdHlwZSksICdyZXBsYWNlV2l0aCcsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnZm9ybWF0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIGRvbU5vZGUudGFnTmFtZSA9PT0gdGhpcy50YWdOYW1lID8gdW5kZWZpbmVkIDogX2dldChMaXN0SXRlbS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpc3RJdGVtKSwgJ2Zvcm1hdHMnLCB0aGlzKS5jYWxsKHRoaXMsIGRvbU5vZGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaXN0SXRlbTtcbn0oX2Jsb2NrMi5kZWZhdWx0KTtcblxuTGlzdEl0ZW0uYmxvdE5hbWUgPSAnbGlzdC1pdGVtJztcbkxpc3RJdGVtLnRhZ05hbWUgPSAnTEknO1xuXG52YXIgTGlzdCA9IGZ1bmN0aW9uIChfQ29udGFpbmVyKSB7XG4gIF9pbmhlcml0cyhMaXN0LCBfQ29udGFpbmVyKTtcblxuICBfY3JlYXRlQ2xhc3MoTGlzdCwgbnVsbCwgW3tcbiAgICBrZXk6ICdjcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgIHZhciB0YWdOYW1lID0gdmFsdWUgPT09ICdvcmRlcmVkJyA/ICdPTCcgOiAnVUwnO1xuICAgICAgdmFyIG5vZGUgPSBfZ2V0KExpc3QuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0KSwgJ2NyZWF0ZScsIHRoaXMpLmNhbGwodGhpcywgdGFnTmFtZSk7XG4gICAgICBpZiAodmFsdWUgPT09ICdjaGVja2VkJyB8fCB2YWx1ZSA9PT0gJ3VuY2hlY2tlZCcpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtY2hlY2tlZCcsIHZhbHVlID09PSAnY2hlY2tlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgaWYgKGRvbU5vZGUudGFnTmFtZSA9PT0gJ09MJykgcmV0dXJuICdvcmRlcmVkJztcbiAgICAgIGlmIChkb21Ob2RlLnRhZ05hbWUgPT09ICdVTCcpIHtcbiAgICAgICAgaWYgKGRvbU5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLWNoZWNrZWQnKSkge1xuICAgICAgICAgIHJldHVybiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1jaGVja2VkJykgPT09ICd0cnVlJyA/ICdjaGVja2VkJyA6ICd1bmNoZWNrZWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnYnVsbGV0JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBMaXN0KGRvbU5vZGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGlzdCk7XG5cbiAgICB2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKExpc3QuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0KSkuY2FsbCh0aGlzLCBkb21Ob2RlKSk7XG5cbiAgICB2YXIgbGlzdEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIGxpc3RFdmVudEhhbmRsZXIoZSkge1xuICAgICAgaWYgKGUudGFyZ2V0LnBhcmVudE5vZGUgIT09IGRvbU5vZGUpIHJldHVybjtcbiAgICAgIHZhciBmb3JtYXQgPSBfdGhpczIuc3RhdGljcy5mb3JtYXRzKGRvbU5vZGUpO1xuICAgICAgdmFyIGJsb3QgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmZpbmQoZS50YXJnZXQpO1xuICAgICAgaWYgKGZvcm1hdCA9PT0gJ2NoZWNrZWQnKSB7XG4gICAgICAgIGJsb3QuZm9ybWF0KCdsaXN0JywgJ3VuY2hlY2tlZCcpO1xuICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICd1bmNoZWNrZWQnKSB7XG4gICAgICAgIGJsb3QuZm9ybWF0KCdsaXN0JywgJ2NoZWNrZWQnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZG9tTm9kZS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgbGlzdEV2ZW50SGFuZGxlcik7XG4gICAgZG9tTm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBsaXN0RXZlbnRIYW5kbGVyKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpc3QsIFt7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4udGFpbC5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKCkge1xuICAgICAgLy8gV2UgZG9uJ3QgaW5oZXJpdCBmcm9tIEZvcm1hdEJsb3RcbiAgICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sIHRoaXMuc3RhdGljcy5ibG90TmFtZSwgdGhpcy5zdGF0aWNzLmZvcm1hdHModGhpcy5kb21Ob2RlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0QmVmb3JlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKGJsb3QsIHJlZikge1xuICAgICAgaWYgKGJsb3QgaW5zdGFuY2VvZiBMaXN0SXRlbSkge1xuICAgICAgICBfZ2V0KExpc3QucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdC5wcm90b3R5cGUpLCAnaW5zZXJ0QmVmb3JlJywgdGhpcykuY2FsbCh0aGlzLCBibG90LCByZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVmID09IG51bGwgPyB0aGlzLmxlbmd0aCgpIDogcmVmLm9mZnNldCh0aGlzKTtcbiAgICAgICAgdmFyIGFmdGVyID0gdGhpcy5zcGxpdChpbmRleCk7XG4gICAgICAgIGFmdGVyLnBhcmVudC5pbnNlcnRCZWZvcmUoYmxvdCwgYWZ0ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29wdGltaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW1pemUoY29udGV4dCkge1xuICAgICAgX2dldChMaXN0LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpc3QucHJvdG90eXBlKSwgJ29wdGltaXplJywgdGhpcykuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgaWYgKG5leHQgIT0gbnVsbCAmJiBuZXh0LnByZXYgPT09IHRoaXMgJiYgbmV4dC5zdGF0aWNzLmJsb3ROYW1lID09PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUgJiYgbmV4dC5kb21Ob2RlLnRhZ05hbWUgPT09IHRoaXMuZG9tTm9kZS50YWdOYW1lICYmIG5leHQuZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2hlY2tlZCcpID09PSB0aGlzLmRvbU5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWNoZWNrZWQnKSkge1xuICAgICAgICBuZXh0Lm1vdmVDaGlsZHJlbih0aGlzKTtcbiAgICAgICAgbmV4dC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXBsYWNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZSh0YXJnZXQpIHtcbiAgICAgIGlmICh0YXJnZXQuc3RhdGljcy5ibG90TmFtZSAhPT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lKSB7XG4gICAgICAgIHZhciBpdGVtID0gX3BhcmNobWVudDIuZGVmYXVsdC5jcmVhdGUodGhpcy5zdGF0aWNzLmRlZmF1bHRDaGlsZCk7XG4gICAgICAgIHRhcmdldC5tb3ZlQ2hpbGRyZW4oaXRlbSk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgICB9XG4gICAgICBfZ2V0KExpc3QucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdC5wcm90b3R5cGUpLCAncmVwbGFjZScsIHRoaXMpLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGlzdDtcbn0oX2NvbnRhaW5lcjIuZGVmYXVsdCk7XG5cbkxpc3QuYmxvdE5hbWUgPSAnbGlzdCc7XG5MaXN0LnNjb3BlID0gX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DS19CTE9UO1xuTGlzdC50YWdOYW1lID0gWydPTCcsICdVTCddO1xuTGlzdC5kZWZhdWx0Q2hpbGQgPSAnbGlzdC1pdGVtJztcbkxpc3QuYWxsb3dlZENoaWxkcmVuID0gW0xpc3RJdGVtXTtcblxuZXhwb3J0cy5MaXN0SXRlbSA9IExpc3RJdGVtO1xuZXhwb3J0cy5kZWZhdWx0ID0gTGlzdDtcblxuLyoqKi8gfSksXG4vKiA2OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2JvbGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxudmFyIF9ib2xkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JvbGQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBJdGFsaWMgPSBmdW5jdGlvbiAoX0JvbGQpIHtcbiAgX2luaGVyaXRzKEl0YWxpYywgX0JvbGQpO1xuXG4gIGZ1bmN0aW9uIEl0YWxpYygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSXRhbGljKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSXRhbGljLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSXRhbGljKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gSXRhbGljO1xufShfYm9sZDIuZGVmYXVsdCk7XG5cbkl0YWxpYy5ibG90TmFtZSA9ICdpdGFsaWMnO1xuSXRhbGljLnRhZ05hbWUgPSBbJ0VNJywgJ0knXTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSXRhbGljO1xuXG4vKioqLyB9KSxcbi8qIDY5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9pbmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX2lubGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmxpbmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBTY3JpcHQgPSBmdW5jdGlvbiAoX0lubGluZSkge1xuICBfaW5oZXJpdHMoU2NyaXB0LCBfSW5saW5lKTtcblxuICBmdW5jdGlvbiBTY3JpcHQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNjcmlwdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNjcmlwdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcmlwdCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNjcmlwdCwgbnVsbCwgW3tcbiAgICBrZXk6ICdjcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gJ3N1cGVyJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3VwJyk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnc3ViJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3ViJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX2dldChTY3JpcHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY3JpcHQpLCAnY3JlYXRlJywgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgaWYgKGRvbU5vZGUudGFnTmFtZSA9PT0gJ1NVQicpIHJldHVybiAnc3ViJztcbiAgICAgIGlmIChkb21Ob2RlLnRhZ05hbWUgPT09ICdTVVAnKSByZXR1cm4gJ3N1cGVyJztcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNjcmlwdDtcbn0oX2lubGluZTIuZGVmYXVsdCk7XG5cblNjcmlwdC5ibG90TmFtZSA9ICdzY3JpcHQnO1xuU2NyaXB0LnRhZ05hbWUgPSBbJ1NVQicsICdTVVAnXTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU2NyaXB0O1xuXG4vKioqLyB9KSxcbi8qIDcwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfaW5saW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9pbmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5saW5lKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU3RyaWtlID0gZnVuY3Rpb24gKF9JbmxpbmUpIHtcbiAgX2luaGVyaXRzKFN0cmlrZSwgX0lubGluZSk7XG5cbiAgZnVuY3Rpb24gU3RyaWtlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJpa2UpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTdHJpa2UuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJpa2UpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBTdHJpa2U7XG59KF9pbmxpbmUyLmRlZmF1bHQpO1xuXG5TdHJpa2UuYmxvdE5hbWUgPSAnc3RyaWtlJztcblN0cmlrZS50YWdOYW1lID0gJ1MnO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTdHJpa2U7XG5cbi8qKiovIH0pLFxuLyogNzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9pbmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX2lubGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmxpbmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBVbmRlcmxpbmUgPSBmdW5jdGlvbiAoX0lubGluZSkge1xuICBfaW5oZXJpdHMoVW5kZXJsaW5lLCBfSW5saW5lKTtcblxuICBmdW5jdGlvbiBVbmRlcmxpbmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFVuZGVybGluZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFVuZGVybGluZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFVuZGVybGluZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIFVuZGVybGluZTtcbn0oX2lubGluZTIuZGVmYXVsdCk7XG5cblVuZGVybGluZS5ibG90TmFtZSA9ICd1bmRlcmxpbmUnO1xuVW5kZXJsaW5lLnRhZ05hbWUgPSAnVSc7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFVuZGVybGluZTtcblxuLyoqKi8gfSksXG4vKiA3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9saW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEFUVFJJQlVURVMgPSBbJ2FsdCcsICdoZWlnaHQnLCAnd2lkdGgnXTtcblxudmFyIEltYWdlID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkRW1iZWQpIHtcbiAgX2luaGVyaXRzKEltYWdlLCBfUGFyY2htZW50JEVtYmVkKTtcblxuICBmdW5jdGlvbiBJbWFnZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2UpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChJbWFnZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEltYWdlKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW1hZ2UsIFt7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAoQVRUUklCVVRFUy5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5kb21Ob2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChJbWFnZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbWFnZS5wcm90b3R5cGUpLCAnZm9ybWF0JywgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdjcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgIHZhciBub2RlID0gX2dldChJbWFnZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEltYWdlKSwgJ2NyZWF0ZScsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHRoaXMuc2FuaXRpemUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiBBVFRSSUJVVEVTLnJlZHVjZShmdW5jdGlvbiAoZm9ybWF0cywgYXR0cmlidXRlKSB7XG4gICAgICAgIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgZm9ybWF0c1thdHRyaWJ1dGVdID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICAgIH0sIHt9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtYXRjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKHVybCkge1xuICAgICAgcmV0dXJuICgvXFwuKGpwZT9nfGdpZnxwbmcpJC8udGVzdCh1cmwpIHx8IC9eZGF0YTppbWFnZVxcLy4rO2Jhc2U2NC8udGVzdCh1cmwpXG4gICAgICApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nhbml0aXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FuaXRpemUodXJsKSB7XG4gICAgICByZXR1cm4gKDAsIF9saW5rLnNhbml0aXplKSh1cmwsIFsnaHR0cCcsICdodHRwcycsICdkYXRhJ10pID8gdXJsIDogJy8vOjAnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW1hZ2U7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuRW1iZWQpO1xuXG5JbWFnZS5ibG90TmFtZSA9ICdpbWFnZSc7XG5JbWFnZS50YWdOYW1lID0gJ0lNRyc7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEltYWdlO1xuXG4vKioqLyB9KSxcbi8qIDczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9ibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfbGluayA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG52YXIgX2xpbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGluayk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEFUVFJJQlVURVMgPSBbJ2hlaWdodCcsICd3aWR0aCddO1xuXG52YXIgVmlkZW8gPSBmdW5jdGlvbiAoX0Jsb2NrRW1iZWQpIHtcbiAgX2luaGVyaXRzKFZpZGVvLCBfQmxvY2tFbWJlZCk7XG5cbiAgZnVuY3Rpb24gVmlkZW8oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVmlkZW8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihWaWRlbykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFZpZGVvLCBbe1xuICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKEFUVFJJQlVURVMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuZG9tTm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZG9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoVmlkZW8ucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVmlkZW8ucHJvdG90eXBlKSwgJ2Zvcm1hdCcsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZSA9IF9nZXQoVmlkZW8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihWaWRlbyksICdjcmVhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdmcmFtZWJvcmRlcicsICcwJyk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnYWxsb3dmdWxsc2NyZWVuJywgdHJ1ZSk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3JjJywgdGhpcy5zYW5pdGl6ZSh2YWx1ZSkpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIEFUVFJJQlVURVMucmVkdWNlKGZ1bmN0aW9uIChmb3JtYXRzLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGRvbU5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICBmb3JtYXRzW2F0dHJpYnV0ZV0gPSBkb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nhbml0aXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FuaXRpemUodXJsKSB7XG4gICAgICByZXR1cm4gX2xpbmsyLmRlZmF1bHQuc2FuaXRpemUodXJsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpZGVvO1xufShfYmxvY2suQmxvY2tFbWJlZCk7XG5cblZpZGVvLmJsb3ROYW1lID0gJ3ZpZGVvJztcblZpZGVvLmNsYXNzTmFtZSA9ICdxbC12aWRlbyc7XG5WaWRlby50YWdOYW1lID0gJ0lGUkFNRSc7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFZpZGVvO1xuXG4vKioqLyB9KSxcbi8qIDc0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLkZvcm11bGFCbG90ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfZW1iZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcblxudmFyIF9lbWJlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbWJlZCk7XG5cbnZhciBfcXVpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX3F1aWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsKTtcblxudmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBGb3JtdWxhQmxvdCA9IGZ1bmN0aW9uIChfRW1iZWQpIHtcbiAgX2luaGVyaXRzKEZvcm11bGFCbG90LCBfRW1iZWQpO1xuXG4gIGZ1bmN0aW9uIEZvcm11bGFCbG90KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtdWxhQmxvdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEZvcm11bGFCbG90Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9ybXVsYUJsb3QpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGb3JtdWxhQmxvdCwgbnVsbCwgW3tcbiAgICBrZXk6ICdjcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgIHZhciBub2RlID0gX2dldChGb3JtdWxhQmxvdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvcm11bGFCbG90KSwgJ2NyZWF0ZScsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgd2luZG93LmthdGV4LnJlbmRlcih2YWx1ZSwgbm9kZSwge1xuICAgICAgICAgIHRocm93T25FcnJvcjogZmFsc2UsXG4gICAgICAgICAgZXJyb3JDb2xvcjogJyNmMDAnXG4gICAgICAgIH0pO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvcm11bGFCbG90O1xufShfZW1iZWQyLmRlZmF1bHQpO1xuXG5Gb3JtdWxhQmxvdC5ibG90TmFtZSA9ICdmb3JtdWxhJztcbkZvcm11bGFCbG90LmNsYXNzTmFtZSA9ICdxbC1mb3JtdWxhJztcbkZvcm11bGFCbG90LnRhZ05hbWUgPSAnU1BBTic7XG5cbnZhciBGb3JtdWxhID0gZnVuY3Rpb24gKF9Nb2R1bGUpIHtcbiAgX2luaGVyaXRzKEZvcm11bGEsIF9Nb2R1bGUpO1xuXG4gIF9jcmVhdGVDbGFzcyhGb3JtdWxhLCBudWxsLCBbe1xuICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgICBfcXVpbGwyLmRlZmF1bHQucmVnaXN0ZXIoRm9ybXVsYUJsb3QsIHRydWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIEZvcm11bGEoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm11bGEpO1xuXG4gICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGb3JtdWxhLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9ybXVsYSkpLmNhbGwodGhpcykpO1xuXG4gICAgaWYgKHdpbmRvdy5rYXRleCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm11bGEgbW9kdWxlIHJlcXVpcmVzIEthVGVYLicpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgcmV0dXJuIEZvcm11bGE7XG59KF9tb2R1bGUyLmRlZmF1bHQpO1xuXG5leHBvcnRzLkZvcm11bGFCbG90ID0gRm9ybXVsYUJsb3Q7XG5leHBvcnRzLmRlZmF1bHQgPSBGb3JtdWxhO1xuXG4vKioqLyB9KSxcbi8qIDc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLkNvZGVUb2tlbiA9IGV4cG9ydHMuQ29kZUJsb2NrID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9xdWlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfcXVpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGwpO1xuXG52YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cbnZhciBfY29kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX2NvZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29kZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFN5bnRheENvZGVCbG9jayA9IGZ1bmN0aW9uIChfQ29kZUJsb2NrKSB7XG4gIF9pbmhlcml0cyhTeW50YXhDb2RlQmxvY2ssIF9Db2RlQmxvY2spO1xuXG4gIGZ1bmN0aW9uIFN5bnRheENvZGVCbG9jaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ludGF4Q29kZUJsb2NrKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3ludGF4Q29kZUJsb2NrLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3ludGF4Q29kZUJsb2NrKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3ludGF4Q29kZUJsb2NrLCBbe1xuICAgIGtleTogJ3JlcGxhY2VXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVdpdGgoYmxvY2spIHtcbiAgICAgIHRoaXMuZG9tTm9kZS50ZXh0Q29udGVudCA9IHRoaXMuZG9tTm9kZS50ZXh0Q29udGVudDtcbiAgICAgIHRoaXMuYXR0YWNoKCk7XG4gICAgICBfZ2V0KFN5bnRheENvZGVCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTeW50YXhDb2RlQmxvY2sucHJvdG90eXBlKSwgJ3JlcGxhY2VXaXRoJywgdGhpcykuY2FsbCh0aGlzLCBibG9jayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGlnaGxpZ2h0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlnaGxpZ2h0KF9oaWdobGlnaHQpIHtcbiAgICAgIHZhciB0ZXh0ID0gdGhpcy5kb21Ob2RlLnRleHRDb250ZW50O1xuICAgICAgaWYgKHRoaXMuY2FjaGVkVGV4dCAhPT0gdGV4dCkge1xuICAgICAgICBpZiAodGV4dC50cmltKCkubGVuZ3RoID4gMCB8fCB0aGlzLmNhY2hlZFRleHQgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuZG9tTm9kZS5pbm5lckhUTUwgPSBfaGlnaGxpZ2h0KHRleHQpO1xuICAgICAgICAgIHRoaXMuZG9tTm9kZS5ub3JtYWxpemUoKTtcbiAgICAgICAgICB0aGlzLmF0dGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVkVGV4dCA9IHRleHQ7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN5bnRheENvZGVCbG9jaztcbn0oX2NvZGUyLmRlZmF1bHQpO1xuXG5TeW50YXhDb2RlQmxvY2suY2xhc3NOYW1lID0gJ3FsLXN5bnRheCc7XG5cbnZhciBDb2RlVG9rZW4gPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkNsYXNzKCd0b2tlbicsICdobGpzJywge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkVcbn0pO1xuXG52YXIgU3ludGF4ID0gZnVuY3Rpb24gKF9Nb2R1bGUpIHtcbiAgX2luaGVyaXRzKFN5bnRheCwgX01vZHVsZSk7XG5cbiAgX2NyZWF0ZUNsYXNzKFN5bnRheCwgbnVsbCwgW3tcbiAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKCkge1xuICAgICAgX3F1aWxsMi5kZWZhdWx0LnJlZ2lzdGVyKENvZGVUb2tlbiwgdHJ1ZSk7XG4gICAgICBfcXVpbGwyLmRlZmF1bHQucmVnaXN0ZXIoU3ludGF4Q29kZUJsb2NrLCB0cnVlKTtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBTeW50YXgocXVpbGwsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ludGF4KTtcblxuICAgIHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3ludGF4Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3ludGF4KSkuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucykpO1xuXG4gICAgaWYgKHR5cGVvZiBfdGhpczIub3B0aW9ucy5oaWdobGlnaHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3ludGF4IG1vZHVsZSByZXF1aXJlcyBoaWdobGlnaHQuanMuIFBsZWFzZSBpbmNsdWRlIHRoZSBsaWJyYXJ5IG9uIHRoZSBwYWdlIGJlZm9yZSBRdWlsbC4nKTtcbiAgICB9XG4gICAgdmFyIHRpbWVyID0gbnVsbDtcbiAgICBfdGhpczIucXVpbGwub24oX3F1aWxsMi5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfT1BUSU1JWkUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuaGlnaGxpZ2h0KCk7XG4gICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIH0sIF90aGlzMi5vcHRpb25zLmludGVydmFsKTtcbiAgICB9KTtcbiAgICBfdGhpczIuaGlnaGxpZ2h0KCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTeW50YXgsIFt7XG4gICAga2V5OiAnaGlnaGxpZ2h0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlnaGxpZ2h0KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnF1aWxsLnNlbGVjdGlvbi5jb21wb3NpbmcpIHJldHVybjtcbiAgICAgIHRoaXMucXVpbGwudXBkYXRlKF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHRoaXMucXVpbGwuc2Nyb2xsLmRlc2NlbmRhbnRzKFN5bnRheENvZGVCbG9jaykuZm9yRWFjaChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBjb2RlLmhpZ2hsaWdodChfdGhpczMub3B0aW9ucy5oaWdobGlnaHQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZShfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgaWYgKHJhbmdlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN5bnRheDtcbn0oX21vZHVsZTIuZGVmYXVsdCk7XG5cblN5bnRheC5ERUZBVUxUUyA9IHtcbiAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdpbmRvdy5obGpzID09IG51bGwpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHdpbmRvdy5obGpzLmhpZ2hsaWdodEF1dG8odGV4dCk7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH07XG4gIH0oKSxcbiAgaW50ZXJ2YWw6IDEwMDBcbn07XG5cbmV4cG9ydHMuQ29kZUJsb2NrID0gU3ludGF4Q29kZUJsb2NrO1xuZXhwb3J0cy5Db2RlVG9rZW4gPSBDb2RlVG9rZW47XG5leHBvcnRzLmRlZmF1bHQgPSBTeW50YXg7XG5cbi8qKiovIH0pLFxuLyogNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTMgeDI9MTUgeTE9OSB5Mj05PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTMgeDI9MTMgeTE9MTQgeTI9MTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj05IHkxPTQgeTI9ND48L2xpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDc3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xNSB4Mj0zIHkxPTkgeTI9OT48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xNCB4Mj00IHkxPTE0IHkyPTE0PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTEyIHgyPTYgeTE9NCB5Mj00PjwvbGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogNzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTE1IHgyPTMgeTE9OSB5Mj05PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTE1IHgyPTUgeTE9MTQgeTI9MTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTUgeDI9OSB5MT00IHkyPTQ+PC9saW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA3OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTUgeDI9MyB5MT05IHkyPTk+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTUgeDI9MyB5MT0xNCB5Mj0xND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xNSB4Mj0zIHkxPTQgeTI9ND48L2xpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDgwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxnIGNsYXNzPVxcXCJxbC1maWxsIHFsLWNvbG9yLWxhYmVsXFxcIj4gPHBvbHlnb24gcG9pbnRzPVxcXCI2IDYuODY4IDYgNiA1IDYgNSA3IDUuOTQyIDcgNiA2Ljg2OFxcXCI+PC9wb2x5Z29uPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9NCB5PTQ+PC9yZWN0PiA8cG9seWdvbiBwb2ludHM9XFxcIjYuODE3IDUgNiA1IDYgNiA2LjM4IDYgNi44MTcgNVxcXCI+PC9wb2x5Z29uPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MiB5PTY+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MyB5PTU+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9NCB5PTc+PC9yZWN0PiA8cG9seWdvbiBwb2ludHM9XFxcIjQgMTEuNDM5IDQgMTEgMyAxMSAzIDEyIDMuNzU1IDEyIDQgMTEuNDM5XFxcIj48L3BvbHlnb24+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0yIHk9MTI+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MiB5PTk+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MiB5PTE1PjwvcmVjdD4gPHBvbHlnb24gcG9pbnRzPVxcXCI0LjYzIDEwIDQgMTAgNCAxMSA0LjE5MiAxMSA0LjYzIDEwXFxcIj48L3BvbHlnb24+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0zIHk9OD48L3JlY3Q+IDxwYXRoIGQ9TTEwLjgzMiw0LjJMMTEsNC41ODJWNEgxMC43MDhBMS45NDgsMS45NDgsMCwwLDEsMTAuODMyLDQuMlo+PC9wYXRoPiA8cGF0aCBkPU03LDQuNTgyTDcuMTY4LDQuMkExLjkyOSwxLjkyOSwwLDAsMSw3LjI5Miw0SDdWNC41ODJaPjwvcGF0aD4gPHBhdGggZD1NOCwxM0g3LjY4M2wtMC4zNTEuOGExLjkzMywxLjkzMywwLDAsMS0uMTI0LjJIOFYxM1o+PC9wYXRoPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTIgeT0yPjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTExIHk9Mz48L3JlY3Q+IDxwYXRoIGQ9TTksM0g4VjMuMjgyQTEuOTg1LDEuOTg1LDAsMCwxLDksM1o+PC9wYXRoPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MiB5PTM+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9NiB5PTI+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MyB5PTI+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9NSB5PTM+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9OSB5PTI+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTUgeT0xND48L3JlY3Q+IDxwb2x5Z29uIHBvaW50cz1cXFwiMTMuNDQ3IDEwLjE3NCAxMy40NjkgMTAuMjI1IDEzLjQ3MiAxMC4yMzIgMTMuODA4IDExIDE0IDExIDE0IDEwIDEzLjM3IDEwIDEzLjQ0NyAxMC4xNzRcXFwiPjwvcG9seWdvbj4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTEzIHk9Nz48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xNSB5PTU+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTQgeT02PjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTE1IHk9OD48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xNCB5PTk+PC9yZWN0PiA8cGF0aCBkPU0zLjc3NSwxNEgzdjFINFYxNC4zMTRBMS45NywxLjk3LDAsMCwxLDMuNzc1LDE0Wj48L3BhdGg+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xNCB5PTM+PC9yZWN0PiA8cG9seWdvbiBwb2ludHM9XFxcIjEyIDYuODY4IDEyIDYgMTEuNjIgNiAxMiA2Ljg2OFxcXCI+PC9wb2x5Z29uPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTUgeT0yPjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTEyIHk9NT48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xMyB5PTQ+PC9yZWN0PiA8cG9seWdvbiBwb2ludHM9XFxcIjEyLjkzMyA5IDEzIDkgMTMgOCAxMi40OTUgOCAxMi45MzMgOVxcXCI+PC9wb2x5Z29uPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9OSB5PTE0PjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTggeT0xNT48L3JlY3Q+IDxwYXRoIGQ9TTYsMTQuOTI2VjE1SDdWMTQuMzE2QTEuOTkzLDEuOTkzLDAsMCwxLDYsMTQuOTI2Wj48L3BhdGg+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD01IHk9MTU+PC9yZWN0PiA8cGF0aCBkPU0xMC42NjgsMTMuOEwxMC4zMTcsMTNIMTB2MWgwLjc5MkExLjk0NywxLjk0NywwLDAsMSwxMC42NjgsMTMuOFo+PC9wYXRoPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTEgeT0xNT48L3JlY3Q+IDxwYXRoIGQ9TTE0LjMzMiwxMi4yYTEuOTksMS45OSwwLDAsMSwuMTY2LjhIMTVWMTJIMTQuMjQ1Wj48L3BhdGg+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xNCB5PTE1PjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTE1IHk9MTE+PC9yZWN0PiA8L2c+IDxwb2x5bGluZSBjbGFzcz1xbC1zdHJva2UgcG9pbnRzPVxcXCI1LjUgMTMgOSA1IDEyLjUgMTNcXFwiPjwvcG9seWxpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xMS42MyB4Mj02LjM4IHkxPTExIHkyPTExPjwvbGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHJlY3QgY2xhc3M9XFxcInFsLWZpbGwgcWwtc3Ryb2tlXFxcIiBoZWlnaHQ9MyB3aWR0aD0zIHg9NCB5PTU+PC9yZWN0PiA8cmVjdCBjbGFzcz1cXFwicWwtZmlsbCBxbC1zdHJva2VcXFwiIGhlaWdodD0zIHdpZHRoPTMgeD0xMSB5PTU+PC9yZWN0PiA8cGF0aCBjbGFzcz1cXFwicWwtZXZlbiBxbC1maWxsIHFsLXN0cm9rZVxcXCIgZD1NNyw4YzAsNC4wMzEtMyw1LTMsNT48L3BhdGg+IDxwYXRoIGNsYXNzPVxcXCJxbC1ldmVuIHFsLWZpbGwgcWwtc3Ryb2tlXFxcIiBkPU0xNCw4YzAsNC4wMzEtMyw1LTMsNT48L3BhdGg+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDgyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLXN0cm9rZSBkPU01LDRIOS41QTIuNSwyLjUsMCwwLDEsMTIsNi41djBBMi41LDIuNSwwLDAsMSw5LjUsOUg1QTAsMCwwLDAsMSw1LDlWNEEwLDAsMCwwLDEsNSw0Wj48L3BhdGg+IDxwYXRoIGNsYXNzPXFsLXN0cm9rZSBkPU01LDloNS41QTIuNSwyLjUsMCwwLDEsMTMsMTEuNXYwQTIuNSwyLjUsMCwwLDEsMTAuNSwxNEg1YTAsMCwwLDAsMSwwLDBWOUEwLDAsMCwwLDEsNSw5Wj48L3BhdGg+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIGNsYXNzPVxcXCJcXFwiIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT01IHgyPTEzIHkxPTMgeTI9Mz48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT02IHgyPTkuMzUgeTE9MTIgeTI9Mz48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xMSB4Mj0xNSB5MT0xMSB5Mj0xNT48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xNSB4Mj0xMSB5MT0xMSB5Mj0xNT48L2xpbmU+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEgcng9MC41IHJ5PTAuNSB3aWR0aD03IHg9MiB5PTE0PjwvcmVjdD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9XFxcInFsLWNvbG9yLWxhYmVsIHFsLXN0cm9rZSBxbC10cmFuc3BhcmVudFxcXCIgeDE9MyB4Mj0xNSB5MT0xNSB5Mj0xNT48L2xpbmU+IDxwb2x5bGluZSBjbGFzcz1xbC1zdHJva2UgcG9pbnRzPVxcXCI1LjUgMTEgOSAzIDEyLjUgMTFcXFwiPjwvcG9seWxpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xMS42MyB4Mj02LjM4IHkxPTkgeTI9OT48L2xpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwb2x5Z29uIGNsYXNzPVxcXCJxbC1zdHJva2UgcWwtZmlsbFxcXCIgcG9pbnRzPVxcXCIzIDExIDUgOSAzIDcgMyAxMVxcXCI+PC9wb2x5Z29uPiA8bGluZSBjbGFzcz1cXFwicWwtc3Ryb2tlIHFsLWZpbGxcXFwiIHgxPTE1IHgyPTExIHkxPTQgeTI9ND48L2xpbmU+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTEsM2EzLDMsMCwwLDAsMCw2aDFWM0gxMVo+PC9wYXRoPiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xMSB3aWR0aD0xIHg9MTEgeT00PjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MTEgd2lkdGg9MSB4PTEzIHk9ND48L3JlY3Q+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDg2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwb2x5Z29uIGNsYXNzPVxcXCJxbC1zdHJva2UgcWwtZmlsbFxcXCIgcG9pbnRzPVxcXCIxNSAxMiAxMyAxMCAxNSA4IDE1IDEyXFxcIj48L3BvbHlnb24+IDxsaW5lIGNsYXNzPVxcXCJxbC1zdHJva2UgcWwtZmlsbFxcXCIgeDE9OSB4Mj01IHkxPTQgeTI9ND48L2xpbmU+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NNSwzQTMsMywwLDAsMCw1LDlINlYzSDVaPjwvcGF0aD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MTEgd2lkdGg9MSB4PTUgeT00PjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MTEgd2lkdGg9MSB4PTcgeT00PjwvcmVjdD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xNCwxNkg0YTEsMSwwLDAsMSwwLTJIMTRBMSwxLDAsMCwxLDE0LDE2WiAvPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTE0LDRINEExLDEsMCwwLDEsNCwySDE0QTEsMSwwLDAsMSwxNCw0WiAvPiA8cmVjdCBjbGFzcz1xbC1maWxsIHg9MyB5PTYgd2lkdGg9MTIgaGVpZ2h0PTYgcng9MSByeT0xIC8+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDg4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTMsMTZINWExLDEsMCwwLDEsMC0yaDhBMSwxLDAsMCwxLDEzLDE2WiAvPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTEzLDRINUExLDEsMCwwLDEsNSwyaDhBMSwxLDAsMCwxLDEzLDRaIC8+IDxyZWN0IGNsYXNzPXFsLWZpbGwgeD0yIHk9NiB3aWR0aD0xNCBoZWlnaHQ9NiByeD0xIHJ5PTEgLz4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xNSw4SDEzYTEsMSwwLDAsMSwwLTJoMkExLDEsMCwwLDEsMTUsOFogLz4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xNSwxMkgxM2ExLDEsMCwwLDEsMC0yaDJBMSwxLDAsMCwxLDE1LDEyWiAvPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTE1LDE2SDVhMSwxLDAsMCwxLDAtMkgxNUExLDEsMCwwLDEsMTUsMTZaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTUsNEg1QTEsMSwwLDAsMSw1LDJIMTVBMSwxLDAsMCwxLDE1LDRaIC8+IDxyZWN0IGNsYXNzPXFsLWZpbGwgeD0yIHk9NiB3aWR0aD04IGhlaWdodD02IHJ4PTEgcnk9MSAvPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA5MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTUsOEgzQTEsMSwwLDAsMSwzLDZINUExLDEsMCwwLDEsNSw4WiAvPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTUsMTJIM2ExLDEsMCwwLDEsMC0ySDVBMSwxLDAsMCwxLDUsMTJaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTMsMTZIM2ExLDEsMCwwLDEsMC0ySDEzQTEsMSwwLDAsMSwxMywxNlogLz4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xMyw0SDNBMSwxLDAsMCwxLDMsMkgxM0ExLDEsMCwwLDEsMTMsNFogLz4gPHJlY3QgY2xhc3M9cWwtZmlsbCB4PTggeT02IHdpZHRoPTggaGVpZ2h0PTYgcng9MSByeT0xIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDI0IDE4KSByb3RhdGUoLTE4MClcXFwiLz4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogOTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xMS43NTksMi40ODJhMi41NjEsMi41NjEsMCwwLDAtMy41My42MDdBNy42NTYsNy42NTYsMCwwLDAsNi44LDYuMkM2LjEwOSw5LjE4OCw1LjI3NSwxNC42NzcsNC4xNSwxNC45MjdhMS41NDUsMS41NDUsMCwwLDAtMS4zLS45MzNBMC45MjIsMC45MjIsMCwwLDAsMiwxNS4wMzZTMS45NTQsMTYsNC4xMTksMTZzMy4wOTEtMi42OTEsMy43LTUuNTUzYzAuMTc3LS44MjYuMzYtMS43MjYsMC41NTQtMi42TDguNzc1LDYuMmMwLjM4MS0xLjQyMS44MDctMi41MjEsMS4zMDYtMi42NzZhMS4wMTQsMS4wMTQsMCwwLDAsMS4wMi41NkEwLjk2NiwwLjk2NiwwLDAsMCwxMS43NTksMi40ODJaPjwvcGF0aD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MS42IHJ4PTAuOCByeT0wLjggd2lkdGg9NSB4PTUuMTUgeT02LjI+PC9yZWN0PiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTEzLjY2MywxMi4wMjdhMS42NjIsMS42NjIsMCwwLDEsLjI2Ni0wLjI3NnEwLjE5MywwLjA2OS40NTYsMC4xMzhhMi4xLDIuMSwwLDAsMCwuNTM1LjA2OSwxLjA3NSwxLjA3NSwwLDAsMCwuNzY3LTAuMywxLjA0NCwxLjA0NCwwLDAsMCwuMzE0LTAuOCwwLjg0LDAuODQsMCwwLDAtLjIzOC0wLjYxOSwwLjgsMC44LDAsMCwwLS41OTQtMC4yMzksMS4xNTQsMS4xNTQsMCwwLDAtLjc4MS4zLDQuNjA3LDQuNjA3LDAsMCwwLS43ODEsMXEtMC4wOTEuMTUtLjIxOCwwLjM0NmwtMC4yNDYuMzhjLTAuMDY4LS4yODgtMC4xMzctMC41ODItMC4yMTItMC44ODUtMC40NTktMS44NDctMi40OTQtLjk4NC0yLjk0MS0wLjgtMC40ODIuMi0uMzUzLDAuNjQ3LTAuMDk0LDAuNTI5YTAuODY5LDAuODY5LDAsMCwxLDEuMjgxLjU4NWMwLjIxNywwLjc1MS4zNzcsMS40MzYsMC41MjcsMi4wMzhhNS42ODgsNS42ODgsMCwwLDEtLjM2Mi40NjcsMi42OSwyLjY5LDAsMCwxLS4yNjQuMjcxcS0wLjIyMS0uMDgtMC40NzEtMC4xNDdhMi4wMjksMi4wMjksMCwwLDAtLjUyMi0wLjA2NiwxLjA3OSwxLjA3OSwwLDAsMC0uNzY4LjNBMS4wNTgsMS4wNTgsMCwwLDAsOSwxNS4xMzFhMC44MiwwLjgyLDAsMCwwLC44MzIuODUyLDEuMTM0LDEuMTM0LDAsMCwwLC43ODctMC4zLDUuMTEsNS4xMSwwLDAsMCwuNzc2LTAuOTkzcTAuMTQxLS4yMTkuMjE1LTAuMzRjMC4wNDYtLjA3Ni4xMjItMC4xOTQsMC4yMjMtMC4zNDZhMi43ODYsMi43ODYsMCwwLDAsLjkxOCwxLjcyNiwyLjU4MiwyLjU4MiwwLDAsMCwyLjM3Ni0uMTg1YzAuMzE3LS4xODEuMjEyLTAuNTY1LDAtMC40OTRBMC44MDcsMC44MDcsMCwwLDEsMTQuMTc2LDE1YTUuMTU5LDUuMTU5LDAsMCwxLS45MTMtMi40NDZsMCwwUTEzLjQ4NywxMi4yNCwxMy42NjMsMTIuMDI3Wj48L3BhdGg+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDkyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdCb3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTAsNFYxNGExLDEsMCwwLDEtMiwwVjEwSDN2NGExLDEsMCwwLDEtMiwwVjRBMSwxLDAsMCwxLDMsNFY4SDhWNGExLDEsMCwwLDEsMiwwWm02LjA2Nzg3LDkuMjA5SDE0Ljk4OTc1VjcuNTk4NjNhLjU0MDg1LjU0MDg1LDAsMCwwLS42MDUtLjYwNTQ3aC0uNjI3NDRhMS4wMTExOSwxLjAxMTE5LDAsMCwwLS43NDguMjk2ODhMMTEuNjQ1LDguNTY2NDFhLjU0MzUuNTQzNSwwLDAsMC0uMDIyLjg1ODRsLjI4NjEzLjMwNzYyYS41Mzg2MS41Mzg2MSwwLDAsMCwuODQ3MTcuMDMzMmwuMDk5MTItLjA4Nzg5YTEuMjEzNywxLjIxMzcsMCwwLDAsLjI0MTctLjM1MjU0aC4wMjI0NnMtLjAxMTIzLjMwODU5LS4wMTEyMy42MDU0N1YxMy4yMDlIMTIuMDQxYS41NDA4NS41NDA4NSwwLDAsMC0uNjA1LjYwNTQ3di40Mzk0NWEuNTQwODUuNTQwODUsMCwwLDAsLjYwNS42MDU0N2g0LjAyNjg2YS41NDA4NS41NDA4NSwwLDAsMCwuNjA1LS42MDU0N3YtLjQzOTQ1QS41NDA4NS41NDA4NSwwLDAsMCwxNi4wNjc4NywxMy4yMDlaIC8+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDkzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdCb3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTYuNzM5NzUsMTMuODE0NDV2LjQzOTQ1YS41NDA4NS41NDA4NSwwLDAsMS0uNjA1LjYwNTQ3SDExLjg1NWEuNTgzOTIuNTgzOTIsMCwwLDEtLjY0ODkzLS42MDU0N1YxNC4wMTI3YzAtMi45MDUyNywzLjM5OTQxLTMuNDIxODcsMy4zOTk0MS00LjU1NDY5YS43NzY3NS43NzY3NSwwLDAsMC0uODQ3MTctLjc4MTI1LDEuMTc2ODQsMS4xNzY4NCwwLDAsMC0uODM1OTQuMzg0NzdjLS4yNzQ5LjI2MzY3LS41NjEuMzc0LS44NTc5MS4xMzE4NGwtLjQyOTItLjM0MDgyYy0uMzA4MTEtLjI0MjE5LS4zODUyNS0uNTE3NTgtLjE1NDMtLjgxNDQ1YTIuOTcxNTUsMi45NzE1NSwwLDAsMSwyLjQ1MzYxLTEuMTc2NzYsMi40NTM5MywyLjQ1MzkzLDAsMCwxLDIuNjg0MDgsMi40MDkxOGMwLDIuNDUzMTItMy4xNzkyLDIuOTI2NzYtMy4yNzgzMiwzLjkzODQ4aDIuNzk0NDNBLjU0MDg1LjU0MDg1LDAsMCwxLDE2LjczOTc1LDEzLjgxNDQ1Wk05LDNBLjk5OTc0Ljk5OTc0LDAsMCwwLDgsNFY4SDNWNEExLDEsMCwwLDAsMSw0VjE0YTEsMSwwLDAsMCwyLDBWMTBIOHY0YTEsMSwwLDAsMCwyLDBWNEEuOTk5NzQuOTk5NzQsMCwwLDAsOSwzWiAvPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA5NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9NyB4Mj0xMyB5MT00IHkyPTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9NSB4Mj0xMSB5MT0xNCB5Mj0xND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT04IHgyPTEwIHkxPTE0IHkyPTQ+PC9saW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA5NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cmVjdCBjbGFzcz1xbC1zdHJva2UgaGVpZ2h0PTEwIHdpZHRoPTEyIHg9MyB5PTQ+PC9yZWN0PiA8Y2lyY2xlIGNsYXNzPXFsLWZpbGwgY3g9NiBjeT03IHI9MT48L2NpcmNsZT4gPHBvbHlsaW5lIGNsYXNzPVxcXCJxbC1ldmVuIHFsLWZpbGxcXFwiIHBvaW50cz1cXFwiNSAxMiA1IDExIDcgOSA4IDEwIDExIDcgMTMgOSAxMyAxMiA1IDEyXFxcIj48L3BvbHlsaW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA5NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj0xNSB5MT0xNCB5Mj0xND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTE1IHkxPTQgeTI9ND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT05IHgyPTE1IHkxPTkgeTI9OT48L2xpbmU+IDxwb2x5bGluZSBjbGFzcz1cXFwicWwtZmlsbCBxbC1zdHJva2VcXFwiIHBvaW50cz1cXFwiMyA3IDMgMTEgNSA5IDMgN1xcXCI+PC9wb2x5bGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogOTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTMgeDI9MTUgeTE9MTQgeTI9MTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj0xNSB5MT00IHkyPTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9OSB4Mj0xNSB5MT05IHkyPTk+PC9saW5lPiA8cG9seWxpbmUgY2xhc3M9cWwtc3Ryb2tlIHBvaW50cz1cXFwiNSA3IDUgMTEgMyA5IDUgN1xcXCI+PC9wb2x5bGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogOTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTcgeDI9MTEgeTE9NyB5Mj0xMT48L2xpbmU+IDxwYXRoIGNsYXNzPVxcXCJxbC1ldmVuIHFsLXN0cm9rZVxcXCIgZD1NOC45LDQuNTc3YTMuNDc2LDMuNDc2LDAsMCwxLC4zNiw0LjY3OUEzLjQ3NiwzLjQ3NiwwLDAsMSw0LjU3Nyw4LjlDMy4xODUsNy41LDIuMDM1LDYuNCw0LjIxNyw0LjIxN1M3LjUsMy4xODUsOC45LDQuNTc3Wj48L3BhdGg+IDxwYXRoIGNsYXNzPVxcXCJxbC1ldmVuIHFsLXN0cm9rZVxcXCIgZD1NMTMuNDIzLDkuMWEzLjQ3NiwzLjQ3NiwwLDAsMC00LjY3OS0uMzYsMy40NzYsMy40NzYsMCwwLDAsLjM2LDQuNjc5YzEuMzkyLDEuMzkyLDIuNSwyLjU0Miw0LjY3OS4zNlMxNC44MTUsMTAuNSwxMy40MjMsOS4xWj48L3BhdGg+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDk5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT03IHgyPTE1IHkxPTQgeTI9ND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT03IHgyPTE1IHkxPTkgeTI9OT48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT03IHgyPTE1IHkxPTE0IHkyPTE0PjwvbGluZT4gPGxpbmUgY2xhc3M9XFxcInFsLXN0cm9rZSBxbC10aGluXFxcIiB4MT0yLjUgeDI9NC41IHkxPTUuNSB5Mj01LjU+PC9saW5lPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTMuNSw2QTAuNSwwLjUsMCwwLDEsMyw1LjVWMy4wODVsLTAuMjc2LjEzOEEwLjUsMC41LDAsMCwxLDIuMDUzLDNjLTAuMTI0LS4yNDctMC4wMjMtMC4zMjQuMjI0LTAuNDQ3bDEtLjVBMC41LDAuNSwwLDAsMSw0LDIuNXYzQTAuNSwwLjUsMCwwLDEsMy41LDZaPjwvcGF0aD4gPHBhdGggY2xhc3M9XFxcInFsLXN0cm9rZSBxbC10aGluXFxcIiBkPU00LjUsMTAuNWgtMmMwLS4yMzQsMS44NS0xLjA3NiwxLjg1LTIuMjM0QTAuOTU5LDAuOTU5LDAsMCwwLDIuNSw4LjE1Nj48L3BhdGg+IDxwYXRoIGNsYXNzPVxcXCJxbC1zdHJva2UgcWwtdGhpblxcXCIgZD1NMi41LDE0Ljg0NmEwLjk1OSwwLjk1OSwwLDAsMCwxLjg1LS4xMDlBMC43LDAuNywwLDAsMCwzLjc1LDE0YTAuNjg4LDAuNjg4LDAsMCwwLC42LTAuNzM2LDAuOTU5LDAuOTU5LDAsMCwwLTEuODUtLjEwOT48L3BhdGg+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDEwMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9NiB4Mj0xNSB5MT00IHkyPTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9NiB4Mj0xNSB5MT05IHkyPTk+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9NiB4Mj0xNSB5MT0xNCB5Mj0xND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTMgeTE9NCB5Mj00PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTMgeDI9MyB5MT05IHkyPTk+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj0zIHkxPTE0IHkyPTE0PjwvbGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogMTAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIGNsYXNzPVxcXCJcXFwiIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT05IHgyPTE1IHkxPTQgeTI9ND48L2xpbmU+IDxwb2x5bGluZSBjbGFzcz1xbC1zdHJva2UgcG9pbnRzPVxcXCIzIDQgNCA1IDYgM1xcXCI+PC9wb2x5bGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTkgeDI9MTUgeTE9MTQgeTI9MTQ+PC9saW5lPiA8cG9seWxpbmUgY2xhc3M9cWwtc3Ryb2tlIHBvaW50cz1cXFwiMyAxNCA0IDE1IDYgMTNcXFwiPjwvcG9seWxpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT05IHgyPTE1IHkxPTkgeTI9OT48L2xpbmU+IDxwb2x5bGluZSBjbGFzcz1xbC1zdHJva2UgcG9pbnRzPVxcXCIzIDkgNCAxMCA2IDhcXFwiPjwvcG9seWxpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDEwMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTE1LjUsMTVIMTMuODYxYTMuODU4LDMuODU4LDAsMCwwLDEuOTE0LTIuOTc1LDEuOCwxLjgsMCwwLDAtMS42LTEuNzUxQTEuOTIxLDEuOTIxLDAsMCwwLDEyLjAyMSwxMS43YTAuNTAwMTMsMC41MDAxMywwLDEsMCwuOTU3LjI5MWgwYTAuOTE0LDAuOTE0LDAsMCwxLDEuMDUzLS43MjUsMC44MSwwLjgxLDAsMCwxLC43NDQuNzYyYzAsMS4wNzYtMS4xNjk3MSwxLjg2OTgyLTEuOTM5NzEsMi40MzA4MkExLjQ1NjM5LDEuNDU2MzksMCwwLDAsMTIsMTUuNWEwLjUsMC41LDAsMCwwLC41LjVoM0EwLjUsMC41LDAsMCwwLDE1LjUsMTVaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NOS42NSw1LjI0MWExLDEsMCwwLDAtMS40MDkuMTA4TDYsNy45NjQsMy43NTksNS4zNDlBMSwxLDAsMCwwLDIuMTkyLDYuNTkxNzhRMi4yMTU0MSw2LjYyMTMsMi4yNDEsNi42NDlMNC42ODQsOS41LDIuMjQxLDEyLjM1QTEsMSwwLDAsMCwzLjcxLDEzLjcwNzIycTAuMDI1NTctLjAyNzY4LjA0OS0wLjA1NzIyTDYsMTEuMDM2LDguMjQxLDEzLjY1YTEsMSwwLDEsMCwxLjU2Ny0xLjI0Mjc3UTkuNzg0NTksMTIuMzc3Nyw5Ljc1OSwxMi4zNUw3LjMxNiw5LjUsOS43NTksNi42NTFBMSwxLDAsMCwwLDkuNjUsNS4yNDFaIC8+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDEwMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTE1LjUsN0gxMy44NjFhNC4wMTUsNC4wMTUsMCwwLDAsMS45MTQtMi45NzUsMS44LDEuOCwwLDAsMC0xLjYtMS43NTFBMS45MjIsMS45MjIsMCwwLDAsMTIuMDIxLDMuN2EwLjUsMC41LDAsMSwwLC45NTcuMjkxLDAuOTE3LDAuOTE3LDAsMCwxLDEuMDUzLS43MjUsMC44MSwwLjgxLDAsMCwxLC43NDQuNzYyYzAsMS4wNzctMS4xNjQsMS45MjUtMS45MzQsMi40ODZBMS40MjMsMS40MjMsMCwwLDAsMTIsNy41YTAuNSwwLjUsMCwwLDAsLjUuNWgzQTAuNSwwLjUsMCwwLDAsMTUuNSw3WiAvPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTkuNjUxLDUuMjQxYTEsMSwwLDAsMC0xLjQxLjEwOEw2LDcuOTY0LDMuNzU5LDUuMzQ5YTEsMSwwLDEsMC0xLjUxOSwxLjNMNC42ODMsOS41LDIuMjQxLDEyLjM1YTEsMSwwLDEsMCwxLjUxOSwxLjNMNiwxMS4wMzYsOC4yNDEsMTMuNjVhMSwxLDAsMCwwLDEuNTE5LTEuM0w3LjMxNyw5LjUsOS43NTksNi42NTFBMSwxLDAsMCwwLDkuNjUxLDUuMjQxWiAvPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiAxMDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9XFxcInFsLXN0cm9rZSBxbC10aGluXFxcIiB4MT0xNS41IHgyPTIuNSB5MT04LjUgeTI9OS41PjwvbGluZT4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU05LjAwNyw4QzYuNTQyLDcuNzkxLDYsNy41MTksNiw2LjUsNiw1Ljc5Miw3LjI4Myw1LDksNWMxLjU3MSwwLDIuNzY1LjY3OSwyLjk2OSwxLjMwOWExLDEsMCwwLDAsMS45LS42MTdDMTMuMzU2LDQuMTA2LDExLjM1NCwzLDksMyw2LjIsMyw0LDQuNTM4LDQsNi41YTMuMiwzLjIsMCwwLDAsLjUsMS44NDNaPjwvcGF0aD4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU04Ljk4NCwxMEMxMS40NTcsMTAuMjA4LDEyLDEwLjQ3OSwxMiwxMS41YzAsMC43MDgtMS4yODMsMS41LTMsMS41LTEuNTcxLDAtMi43NjUtLjY3OS0yLjk2OS0xLjMwOWExLDEsMCwxLDAtMS45LjYxN0M0LjY0NCwxMy44OTQsNi42NDYsMTUsOSwxNWMyLjgsMCw1LTEuNTM4LDUtMy41YTMuMiwzLjIsMCwwLDAtLjUtMS44NDNaPjwvcGF0aD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogMTA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLXN0cm9rZSBkPU01LDNWOWE0LjAxMiw0LjAxMiwwLDAsMCw0LDRIOWE0LjAxMiw0LjAxMiwwLDAsMCw0LTRWMz48L3BhdGg+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEgcng9MC41IHJ5PTAuNSB3aWR0aD0xMiB4PTMgeT0xNT48L3JlY3Q+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDEwNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cmVjdCBjbGFzcz1xbC1zdHJva2UgaGVpZ2h0PTEyIHdpZHRoPTEyIHg9MyB5PTM+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xMiB3aWR0aD0xIHg9NSB5PTM+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xMiB3aWR0aD0xIHg9MTIgeT0zPjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MiB3aWR0aD04IHg9NSB5PTg+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHdpZHRoPTMgeD0zIHk9NT48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEgd2lkdGg9MyB4PTMgeT03PjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSB3aWR0aD0zIHg9MyB5PTEwPjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSB3aWR0aD0zIHg9MyB5PTEyPjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSB3aWR0aD0zIHg9MTIgeT01PjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSB3aWR0aD0zIHg9MTIgeT03PjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSB3aWR0aD0zIHg9MTIgeT0xMD48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEgd2lkdGg9MyB4PTEyIHk9MTI+PC9yZWN0PiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiAxMDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBvbHlnb24gY2xhc3M9cWwtc3Ryb2tlIHBvaW50cz1cXFwiNyAxMSA5IDEzIDExIDExIDcgMTFcXFwiPjwvcG9seWdvbj4gPHBvbHlnb24gY2xhc3M9cWwtc3Ryb2tlIHBvaW50cz1cXFwiNyA3IDkgNSAxMSA3IDcgN1xcXCI+PC9wb2x5Z29uPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiAxMDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuQnViYmxlVG9vbHRpcCA9IHVuZGVmaW5lZDtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V4dGVuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZXh0ZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZCk7XG5cbnZhciBfZW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBfZW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbWl0dGVyKTtcblxudmFyIF9iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG5cbnZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcblxudmFyIF9zZWxlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9pY29ucyA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xuXG52YXIgX2ljb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ljb25zKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVE9PTEJBUl9DT05GSUcgPSBbWydib2xkJywgJ2l0YWxpYycsICdsaW5rJ10sIFt7IGhlYWRlcjogMSB9LCB7IGhlYWRlcjogMiB9LCAnYmxvY2txdW90ZSddXTtcblxudmFyIEJ1YmJsZVRoZW1lID0gZnVuY3Rpb24gKF9CYXNlVGhlbWUpIHtcbiAgX2luaGVyaXRzKEJ1YmJsZVRoZW1lLCBfQmFzZVRoZW1lKTtcblxuICBmdW5jdGlvbiBCdWJibGVUaGVtZShxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWJibGVUaGVtZSk7XG5cbiAgICBpZiAob3B0aW9ucy5tb2R1bGVzLnRvb2xiYXIgIT0gbnVsbCAmJiBvcHRpb25zLm1vZHVsZXMudG9vbGJhci5jb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5tb2R1bGVzLnRvb2xiYXIuY29udGFpbmVyID0gVE9PTEJBUl9DT05GSUc7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJ1YmJsZVRoZW1lLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnViYmxlVGhlbWUpKS5jYWxsKHRoaXMsIHF1aWxsLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5xdWlsbC5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgncWwtYnViYmxlJyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJ1YmJsZVRoZW1lLCBbe1xuICAgIGtleTogJ2V4dGVuZFRvb2xiYXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmRUb29sYmFyKHRvb2xiYXIpIHtcbiAgICAgIHRoaXMudG9vbHRpcCA9IG5ldyBCdWJibGVUb29sdGlwKHRoaXMucXVpbGwsIHRoaXMub3B0aW9ucy5ib3VuZHMpO1xuICAgICAgdGhpcy50b29sdGlwLnJvb3QuYXBwZW5kQ2hpbGQodG9vbGJhci5jb250YWluZXIpO1xuICAgICAgdGhpcy5idWlsZEJ1dHRvbnMoW10uc2xpY2UuY2FsbCh0b29sYmFyLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdidXR0b24nKSksIF9pY29uczIuZGVmYXVsdCk7XG4gICAgICB0aGlzLmJ1aWxkUGlja2VycyhbXS5zbGljZS5jYWxsKHRvb2xiYXIuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCcpKSwgX2ljb25zMi5kZWZhdWx0KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnViYmxlVGhlbWU7XG59KF9iYXNlMi5kZWZhdWx0KTtcblxuQnViYmxlVGhlbWUuREVGQVVMVFMgPSAoMCwgX2V4dGVuZDIuZGVmYXVsdCkodHJ1ZSwge30sIF9iYXNlMi5kZWZhdWx0LkRFRkFVTFRTLCB7XG4gIG1vZHVsZXM6IHtcbiAgICB0b29sYmFyOiB7XG4gICAgICBoYW5kbGVyczoge1xuICAgICAgICBsaW5rOiBmdW5jdGlvbiBsaW5rKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2xpbmsnLCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucXVpbGwudGhlbWUudG9vbHRpcC5lZGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxudmFyIEJ1YmJsZVRvb2x0aXAgPSBmdW5jdGlvbiAoX0Jhc2VUb29sdGlwKSB7XG4gIF9pbmhlcml0cyhCdWJibGVUb29sdGlwLCBfQmFzZVRvb2x0aXApO1xuXG4gIGZ1bmN0aW9uIEJ1YmJsZVRvb2x0aXAocXVpbGwsIGJvdW5kcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWJibGVUb29sdGlwKTtcblxuICAgIHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQnViYmxlVG9vbHRpcC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJ1YmJsZVRvb2x0aXApKS5jYWxsKHRoaXMsIHF1aWxsLCBib3VuZHMpKTtcblxuICAgIF90aGlzMi5xdWlsbC5vbihfZW1pdHRlcjIuZGVmYXVsdC5ldmVudHMuRURJVE9SX0NIQU5HRSwgZnVuY3Rpb24gKHR5cGUsIHJhbmdlLCBvbGRSYW5nZSwgc291cmNlKSB7XG4gICAgICBpZiAodHlwZSAhPT0gX2VtaXR0ZXIyLmRlZmF1bHQuZXZlbnRzLlNFTEVDVElPTl9DSEFOR0UpIHJldHVybjtcbiAgICAgIGlmIChyYW5nZSAhPSBudWxsICYmIHJhbmdlLmxlbmd0aCA+IDAgJiYgc291cmNlID09PSBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpIHtcbiAgICAgICAgX3RoaXMyLnNob3coKTtcbiAgICAgICAgLy8gTG9jayBvdXIgd2lkdGggc28gd2Ugd2lsbCBleHBhbmQgYmV5b25kIG91ciBvZmZzZXRQYXJlbnQgYm91bmRhcmllc1xuICAgICAgICBfdGhpczIucm9vdC5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgICAgIF90aGlzMi5yb290LnN0eWxlLndpZHRoID0gJyc7XG4gICAgICAgIF90aGlzMi5yb290LnN0eWxlLndpZHRoID0gX3RoaXMyLnJvb3Qub2Zmc2V0V2lkdGggKyAncHgnO1xuICAgICAgICB2YXIgbGluZXMgPSBfdGhpczIucXVpbGwuZ2V0TGluZXMocmFuZ2UuaW5kZXgsIHJhbmdlLmxlbmd0aCk7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBfdGhpczIucG9zaXRpb24oX3RoaXMyLnF1aWxsLmdldEJvdW5kcyhyYW5nZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsYXN0TGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzMi5xdWlsbC5nZXRJbmRleChsYXN0TGluZSk7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGxhc3RMaW5lLmxlbmd0aCgpIC0gMSwgcmFuZ2UuaW5kZXggKyByYW5nZS5sZW5ndGggLSBpbmRleCk7XG4gICAgICAgICAgdmFyIF9ib3VuZHMgPSBfdGhpczIucXVpbGwuZ2V0Qm91bmRzKG5ldyBfc2VsZWN0aW9uLlJhbmdlKGluZGV4LCBsZW5ndGgpKTtcbiAgICAgICAgICBfdGhpczIucG9zaXRpb24oX2JvdW5kcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gX3RoaXMyLnRleHRib3ggJiYgX3RoaXMyLnF1aWxsLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgX3RoaXMyLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJ1YmJsZVRvb2x0aXAsIFt7XG4gICAga2V5OiAnbGlzdGVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIF9nZXQoQnViYmxlVG9vbHRpcC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCdWJibGVUb29sdGlwLnByb3RvdHlwZSksICdsaXN0ZW4nLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3IoJy5xbC1jbG9zZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMucm9vdC5jbGFzc0xpc3QucmVtb3ZlKCdxbC1lZGl0aW5nJyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucXVpbGwub24oX2VtaXR0ZXIyLmRlZmF1bHQuZXZlbnRzLlNDUk9MTF9PUFRJTUlaRSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBMZXQgc2VsZWN0aW9uIGJlIHJlc3RvcmVkIGJ5IHRvb2xiYXIgaGFuZGxlcnMgYmVmb3JlIHJlcG9zaXRpb25pbmdcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzMy5yb290LmNsYXNzTGlzdC5jb250YWlucygncWwtaGlkZGVuJykpIHJldHVybjtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBfdGhpczMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgaWYgKHJhbmdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzMy5wb3NpdGlvbihfdGhpczMucXVpbGwuZ2V0Qm91bmRzKHJhbmdlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbmNlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Bvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb24ocmVmZXJlbmNlKSB7XG4gICAgICB2YXIgc2hpZnQgPSBfZ2V0KEJ1YmJsZVRvb2x0aXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnViYmxlVG9vbHRpcC5wcm90b3R5cGUpLCAncG9zaXRpb24nLCB0aGlzKS5jYWxsKHRoaXMsIHJlZmVyZW5jZSk7XG4gICAgICB2YXIgYXJyb3cgPSB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcignLnFsLXRvb2x0aXAtYXJyb3cnKTtcbiAgICAgIGFycm93LnN0eWxlLm1hcmdpbkxlZnQgPSAnJztcbiAgICAgIGlmIChzaGlmdCA9PT0gMCkgcmV0dXJuIHNoaWZ0O1xuICAgICAgYXJyb3cuc3R5bGUubWFyZ2luTGVmdCA9IC0xICogc2hpZnQgLSBhcnJvdy5vZmZzZXRXaWR0aCAvIDIgKyAncHgnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCdWJibGVUb29sdGlwO1xufShfYmFzZS5CYXNlVG9vbHRpcCk7XG5cbkJ1YmJsZVRvb2x0aXAuVEVNUExBVEUgPSBbJzxzcGFuIGNsYXNzPVwicWwtdG9vbHRpcC1hcnJvd1wiPjwvc3Bhbj4nLCAnPGRpdiBjbGFzcz1cInFsLXRvb2x0aXAtZWRpdG9yXCI+JywgJzxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtZm9ybXVsYT1cImU9bWNeMlwiIGRhdGEtbGluaz1cImh0dHBzOi8vcXVpbGxqcy5jb21cIiBkYXRhLXZpZGVvPVwiRW1iZWQgVVJMXCI+JywgJzxhIGNsYXNzPVwicWwtY2xvc2VcIj48L2E+JywgJzwvZGl2PiddLmpvaW4oJycpO1xuXG5leHBvcnRzLkJ1YmJsZVRvb2x0aXAgPSBCdWJibGVUb29sdGlwO1xuZXhwb3J0cy5kZWZhdWx0ID0gQnViYmxlVGhlbWU7XG5cbi8qKiovIH0pLFxuLyogMTA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pW1wiZGVmYXVsdFwiXTtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsInNlbGYiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwibiIsIl9fZXNNb2R1bGUiLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsInZhbHVlIiwiY29udGFpbmVyXzEiLCJmb3JtYXRfMSIsImxlYWZfMSIsInNjcm9sbF8xIiwiaW5saW5lXzEiLCJibG9ja18xIiwiZW1iZWRfMSIsInRleHRfMSIsImF0dHJpYnV0b3JfMSIsImNsYXNzXzEiLCJzdHlsZV8xIiwic3RvcmVfMSIsIlJlZ2lzdHJ5IiwiUGFyY2htZW50IiwiU2NvcGUiLCJjcmVhdGUiLCJmaW5kIiwicXVlcnkiLCJyZWdpc3RlciIsIkNvbnRhaW5lciIsImRlZmF1bHQiLCJGb3JtYXQiLCJMZWFmIiwiRW1iZWQiLCJTY3JvbGwiLCJCbG9jayIsIklubGluZSIsIlRleHQiLCJBdHRyaWJ1dG9yIiwiQXR0cmlidXRlIiwiQ2xhc3MiLCJTdHlsZSIsIlN0b3JlIiwiX19leHRlbmRzIiwiZXh0ZW5kU3RhdGljcyIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJiIiwiX18iLCJjb25zdHJ1Y3RvciIsIlBhcmNobWVudEVycm9yIiwiX3N1cGVyIiwibWVzc2FnZSIsIl90aGlzIiwiRXJyb3IiLCJhdHRyaWJ1dGVzIiwiY2xhc3NlcyIsInRhZ3MiLCJ0eXBlcyIsIkRBVEFfS0VZIiwiaW5wdXQiLCJtYXRjaCIsIkJsb3RDbGFzcyIsIm5vZGUiLCJOb2RlIiwiVEVYVF9OT0RFIiwiYnViYmxlIiwiYmxvdCIsInBhcmVudE5vZGUiLCJzY29wZSIsIkFOWSIsIkxFVkVMIiwiQkxPQ0siLCJJTkxJTkUiLCJIVE1MRWxlbWVudCIsIm5hbWVzIiwiZ2V0QXR0cmlidXRlIiwic3BsaXQiLCJ0YWdOYW1lIiwiVFlQRSIsIkRlZmluaXRpb25zIiwiX2kiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJtYXAiLCJEZWZpbml0aW9uIiwiYmxvdE5hbWUiLCJhdHRyTmFtZSIsImtleU5hbWUiLCJjbGFzc05hbWUiLCJpc0FycmF5IiwidG9VcHBlckNhc2UiLCJ0YWdOYW1lcyIsImZvckVhY2giLCJ0YWciLCJkaWZmIiwiZXF1YWwiLCJleHRlbmQiLCJvcCIsIk5VTExfQ0hBUkFDVEVSIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiRGVsdGEiLCJvcHMiLCJpbnNlcnQiLCJ0ZXh0IiwibmV3T3AiLCJrZXlzIiwicHVzaCIsInJldGFpbiIsImluZGV4IiwibGFzdE9wIiwidW5zaGlmdCIsInNwbGljZSIsImNob3AiLCJwb3AiLCJmaWx0ZXIiLCJwcmVkaWNhdGUiLCJwYXJ0aXRpb24iLCJwYXNzZWQiLCJmYWlsZWQiLCJ0YXJnZXQiLCJyZWR1Y2UiLCJpbml0aWFsIiwiY2hhbmdlTGVuZ3RoIiwiZWxlbSIsImRlbGV0ZSIsInNsaWNlIiwic3RhcnQiLCJlbmQiLCJJbmZpbml0eSIsIml0ZXIiLCJpdGVyYXRvciIsImhhc05leHQiLCJuZXh0T3AiLCJuZXh0IiwiY29tcG9zZSIsIm90aGVyIiwidGhpc0l0ZXIiLCJvdGhlckl0ZXIiLCJmaXJzdE90aGVyIiwicGVlayIsImZpcnN0TGVmdCIsInBlZWtUeXBlIiwicGVla0xlbmd0aCIsImRlbHRhIiwiTWF0aCIsIm1pbiIsInRoaXNPcCIsIm90aGVyT3AiLCJyZXN0IiwiY29uY2F0Iiwic3RyaW5ncyIsInByZXAiLCJqb2luIiwiZGlmZlJlc3VsdCIsImNvbXBvbmVudCIsIm9wTGVuZ3RoIiwiSU5TRVJUIiwiREVMRVRFIiwiRVFVQUwiLCJlYWNoTGluZSIsIm5ld2xpbmUiLCJsaW5lIiwiaW5kZXhPZiIsInRyYW5zZm9ybSIsInByaW9yaXR5IiwidHJhbnNmb3JtUG9zaXRpb24iLCJvZmZzZXQiLCJuZXh0VHlwZSIsImhhc093biIsInRvU3RyIiwidG9TdHJpbmciLCJnT1BEIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiYXJyIiwiaXNQbGFpbk9iamVjdCIsIm9iaiIsImhhc093bkNvbnN0cnVjdG9yIiwiaGFzSXNQcm90b3R5cGVPZiIsImtleSIsInNldFByb3BlcnR5Iiwib3B0aW9ucyIsIm5ld1ZhbHVlIiwid3JpdGFibGUiLCJnZXRQcm9wZXJ0eSIsInNyYyIsImNvcHkiLCJjb3B5SXNBcnJheSIsImNsb25lIiwiZGVlcCIsIkJsb2NrRW1iZWQiLCJidWJibGVGb3JtYXRzIiwidW5kZWZpbmVkIiwiX2NyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2dldCIsInJlY2VpdmVyIiwiRnVuY3Rpb24iLCJkZXNjIiwicGFyZW50IiwiZ2V0UHJvdG90eXBlT2YiLCJfZXh0ZW5kIiwiX2V4dGVuZDIiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3F1aWxsRGVsdGEiLCJfcXVpbGxEZWx0YTIiLCJfcGFyY2htZW50IiwiX3BhcmNobWVudDIiLCJfYnJlYWsiLCJfYnJlYWsyIiwiX2lubGluZSIsIl9pbmxpbmUyIiwiX3RleHQiLCJfdGV4dDIiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIlR5cGVFcnJvciIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiUmVmZXJlbmNlRXJyb3IiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJORVdMSU5FX0xFTkdUSCIsIl9QYXJjaG1lbnQkRW1iZWQiLCJhcHBseSIsImF0dGFjaCIsImRvbU5vZGUiLCJmb3JtYXRzIiwidmFsdWVzIiwiZm9ybWF0IiwiYXR0cmlidXRlIiwiQkxPQ0tfQVRUUklCVVRFIiwiZm9ybWF0QXQiLCJpbnNlcnRBdCIsImRlZiIsImVuZHNXaXRoIiwiYmxvY2siLCJpbnNlcnRCZWZvcmUiLCJCTE9DS19CTE9UIiwiX1BhcmNobWVudCRCbG9jayIsIl90aGlzMiIsImNhY2hlIiwiZGVzY2VuZGFudHMiLCJsZWFmIiwiZGVsZXRlQXQiLCJsaW5lcyIsInNoaWZ0IiwiY2hpbGRyZW4iLCJ0YWlsIiwicmVmIiwiaGVhZCIsInJlbW92ZSIsIm1vdmVDaGlsZHJlbiIsIm9wdGltaXplIiwiY29udGV4dCIsInBhdGgiLCJyZW1vdmVDaGlsZCIsImNoaWxkIiwiZm9yY2UiLCJkZWZhdWx0Q2hpbGQiLCJhbGxvd2VkQ2hpbGRyZW4iLCJzdGF0aWNzIiwib3ZlcmxvYWQiLCJleHBhbmRDb25maWciLCJfdHlwZW9mIiwiU3ltYm9sIiwiX3NsaWNlZFRvQXJyYXkiLCJzbGljZUl0ZXJhdG9yIiwiX2FyciIsIl9uIiwiX2QiLCJfZSIsIl9zIiwiZG9uZSIsImVyciIsIl9lZGl0b3IiLCJfZWRpdG9yMiIsIl9lbWl0dGVyMyIsIl9lbWl0dGVyNCIsIl9tb2R1bGUiLCJfbW9kdWxlMiIsIl9zZWxlY3Rpb24iLCJfc2VsZWN0aW9uMiIsIl9sb2dnZXIiLCJfbG9nZ2VyMiIsIl90aGVtZSIsIl90aGVtZTIiLCJfZGVmaW5lUHJvcGVydHkiLCJkZWJ1ZyIsIlF1aWxsIiwibGltaXQiLCJsZXZlbCIsIl9fcXVpbGwiLCJfaW1wb3J0IiwiaW1wb3J0cyIsImVycm9yIiwib3ZlcndyaXRlIiwid2FybiIsInN0YXJ0c1dpdGgiLCJjb250YWluZXIiLCJodG1sIiwiaW5uZXJIVE1MIiwidHJpbSIsImNsYXNzTGlzdCIsImFkZCIsImFkZENvbnRhaW5lciIsInNldEF0dHJpYnV0ZSIsInNjcm9sbGluZ0NvbnRhaW5lciIsImVtaXR0ZXIiLCJzY3JvbGwiLCJ3aGl0ZWxpc3QiLCJlZGl0b3IiLCJzZWxlY3Rpb24iLCJ0aGVtZSIsImtleWJvYXJkIiwiYWRkTW9kdWxlIiwiY2xpcGJvYXJkIiwiaGlzdG9yeSIsImluaXQiLCJvbiIsImV2ZW50cyIsIkVESVRPUl9DSEFOR0UiLCJ0eXBlIiwiVEVYVF9DSEFOR0UiLCJ0b2dnbGUiLCJpc0JsYW5rIiwiU0NST0xMX1VQREFURSIsInNvdXJjZSIsIm11dGF0aW9ucyIsInJhbmdlIiwibGFzdFJhbmdlIiwibW9kaWZ5IiwidXBkYXRlIiwiY29udGVudHMiLCJjb252ZXJ0Iiwic2V0Q29udGVudHMiLCJjbGVhciIsInBsYWNlaG9sZGVyIiwicmVhZE9ubHkiLCJkaXNhYmxlIiwicmVmTm9kZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImJsdXIiLCJzZXRSYW5nZSIsImRlbGV0ZVRleHQiLCJfdGhpczMiLCJfb3ZlcmxvYWQiLCJfb3ZlcmxvYWQyIiwiZW5hYmxlIiwiZW5hYmxlZCIsImZvY3VzIiwic2Nyb2xsVG9wIiwic2Nyb2xsSW50b1ZpZXciLCJfdGhpczQiLCJzb3VyY2VzIiwiQVBJIiwiZ2V0U2VsZWN0aW9uIiwiY2hhbmdlIiwiZm9ybWF0TGluZSIsImZvcm1hdFRleHQiLCJzZXRTZWxlY3Rpb24iLCJTSUxFTlQiLCJfdGhpczUiLCJfb3ZlcmxvYWQzIiwiX292ZXJsb2FkNCIsIl90aGlzNiIsIl9vdmVybG9hZDUiLCJfb3ZlcmxvYWQ2IiwiZ2V0Qm91bmRzIiwiYm91bmRzIiwiY29udGFpbmVyQm91bmRzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYm90dG9tIiwidG9wIiwiaGVpZ2h0IiwibGVmdCIsInJpZ2h0Iiwid2lkdGgiLCJnZXRDb250ZW50cyIsImdldExlbmd0aCIsIl9vdmVybG9hZDciLCJfb3ZlcmxvYWQ4IiwiZ2V0Rm9ybWF0IiwiZ2V0SW5kZXgiLCJnZXRMZWFmIiwiZ2V0TGluZSIsImdldExpbmVzIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiZ2V0TW9kdWxlIiwiZ2V0UmFuZ2UiLCJnZXRUZXh0IiwiX292ZXJsb2FkOSIsIl9vdmVybG9hZDEwIiwiaGFzRm9jdXMiLCJpbnNlcnRFbWJlZCIsImVtYmVkIiwiX3RoaXM3IiwiaW5zZXJ0VGV4dCIsIl90aGlzOCIsIl9vdmVybG9hZDExIiwiX292ZXJsb2FkMTIiLCJpc0VuYWJsZWQiLCJjb250YWlucyIsIm9mZiIsIm9uY2UiLCJwYXN0ZUhUTUwiLCJkYW5nZXJvdXNseVBhc3RlSFRNTCIsInJlbW92ZUZvcm1hdCIsIl90aGlzOSIsIl9vdmVybG9hZDEzIiwiX292ZXJsb2FkMTQiLCJfdGhpczEwIiwiZGVsZXRlZCIsImFwcGxpZWQiLCJhcHBseURlbHRhIiwicmV0IiwiX292ZXJsb2FkMTUiLCJfb3ZlcmxvYWQxNiIsIlJhbmdlIiwic2V0VGV4dCIsIlVTRVIiLCJ1cGRhdGVDb250ZW50cyIsIl90aGlzMTEiLCJERUZBVUxUUyIsInN0cmljdCIsInZlcnNpb24iLCJ1c2VyQ29uZmlnIiwiaW1wb3J0IiwidGhlbWVDb25maWciLCJjb25maWciLCJtb2R1bGVOYW1lcyIsIm1vZHVsZUNvbmZpZyIsIm1vZHVsZUNsYXNzIiwidG9vbGJhciIsInF1ZXJ5U2VsZWN0b3IiLCJtb2RpZmllciIsIm9sZERlbHRhIiwic2hpZnRSYW5nZSIsIl9lbWl0dGVyIiwiYXJncyIsImVtaXQiLCJfZW1pdHRlcjIiLCJfbWFwIiwicG9zIiwiX21hcDIiLCJfbWFwMyIsIm1heCIsIl9tYXA0IiwiX1BhcmNobWVudCRJbmxpbmUiLCJjb21wYXJlIiwiQkxPVCIsImlzb2xhdGUiLCJ3cmFwIiwic2VsZkluZGV4Iiwib3JkZXIiLCJvdGhlckluZGV4IiwiVGV4dEJsb3QiLCJfUGFyY2htZW50JFRleHQiLCJfZXZlbnRlbWl0dGVyIiwiX2V2ZW50ZW1pdHRlcjIiLCJFVkVOVFMiLCJldmVudE5hbWUiLCJhZGRFdmVudExpc3RlbmVyIiwiX2xlbiIsIl9rZXkiLCJxdWVyeVNlbGVjdG9yQWxsIiwiX25vZGUkX19xdWlsbCRlbWl0dGVyIiwiaGFuZGxlRE9NIiwiRW1pdHRlciIsIl9FdmVudEVtaXR0ZXIiLCJsaXN0ZW5lcnMiLCJsb2ciLCJldmVudCIsIl9sZW4yIiwiX2tleTIiLCJfcmVmIiwiaGFuZGxlciIsImxpc3RlbkRPTSIsIlNDUk9MTF9CRUZPUkVfVVBEQVRFIiwiU0NST0xMX09QVElNSVpFIiwiU0VMRUNUSU9OX0NIQU5HRSIsIk1vZHVsZSIsInF1aWxsIiwibGV2ZWxzIiwibWV0aG9kIiwiX2NvbnNvbGUiLCJjb25zb2xlIiwibmFtZXNwYWNlIiwibnMiLCJsb2dnZXIiLCJiaW5kIiwibmV3TGV2ZWwiLCJwU2xpY2UiLCJvYmplY3RLZXlzIiwiaXNBcmd1bWVudHMiLCJkZWVwRXF1YWwiLCJhY3R1YWwiLCJleHBlY3RlZCIsIm9wdHMiLCJEYXRlIiwiZ2V0VGltZSIsIm9iakVxdWl2IiwiaXNVbmRlZmluZWRPck51bGwiLCJpc0J1ZmZlciIsIngiLCJhIiwia2EiLCJrYiIsImUiLCJzb3J0IiwiYXR0cmlidXRlQml0IiwiQVRUUklCVVRFIiwiaXRlbSIsImNhbkFkZCIsInJlcGxhY2UiLCJyZW1vdmVBdHRyaWJ1dGUiLCJDb2RlIiwiX2Jsb2NrIiwiX2Jsb2NrMiIsIl9JbmxpbmUiLCJDb2RlQmxvY2siLCJfQmxvY2siLCJ0ZXh0Q29udGVudCIsImZyYWciLCJfZGVzY2VuZGFudCIsImRlc2NlbmRhbnQiLCJfZGVzY2VuZGFudDIiLCJuZXh0TmV3bGluZSIsIm5ld2xpbmVJbmRleCIsInByZXZOZXdsaW5lIiwiaXNvbGF0ZUxlbmd0aCIsIl9kZXNjZW5kYW50MyIsIl9kZXNjZW5kYW50NCIsInNlYXJjaEluZGV4IiwicmV2ZXJzZSIsImxhc3RJbmRleE9mIiwiYXBwZW5kQ2hpbGQiLCJwcmV2IiwidW53cmFwIiwiVEFCIiwiX29wIiwiX29wMiIsIl9jb2RlIiwiX2NvZGUyIiwiX2N1cnNvciIsIl9jdXJzb3IyIiwiX2Nsb25lIiwiX2Nsb25lMiIsIl9kZWVwRXF1YWwiLCJfZGVlcEVxdWFsMiIsIkFTQ0lJIiwiRWRpdG9yIiwiZ2V0RGVsdGEiLCJjb25zdW1lTmV4dE5ld2xpbmUiLCJzY3JvbGxMZW5ndGgiLCJiYXRjaFN0YXJ0Iiwibm9ybWFsaXplRGVsdGEiLCJfc2Nyb2xsJGxpbmUiLCJfc2Nyb2xsJGxpbmUyIiwiX2xpbmUkZGVzY2VuZGFudCIsIl9saW5lJGRlc2NlbmRhbnQyIiwiYmF0Y2hFbmQiLCJsZW5ndGhSZW1haW5pbmciLCJsaW5lTGVuZ3RoIiwiY29kZUluZGV4IiwiY29kZUxlbmd0aCIsImxlYXZlcyIsIl9wYXRoIiwiZm9ybWF0c0FyciIsImJsb3RzIiwiY29tYmluZUZvcm1hdHMiLCJfc2Nyb2xsJGxpbmUzIiwiX3Njcm9sbCRsaW5lNCIsInN1ZmZpeExlbmd0aCIsInN1ZmZpeCIsImN1cnNvckluZGV4IiwiZGF0YSIsInRleHRCbG90Iiwib2xkVmFsdWUiLCJDT05URU5UUyIsIm9sZFRleHQiLCJuZXdUZXh0IiwiZGlmZkRlbHRhIiwiY29tYmluZWQiLCJtZXJnZWQiLCJpbWFnZSIsImxpc3QiLCJidWxsZXQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIyIiwiZnJvbSIsIlNlbGVjdGlvbiIsImNvbXBvc2luZyIsIm1vdXNlRG93biIsImN1cnNvciIsInNhdmVkUmFuZ2UiLCJoYW5kbGVDb21wb3NpdGlvbiIsImhhbmRsZURyYWdnaW5nIiwic2V0VGltZW91dCIsIm5hdGl2ZSIsImdldE5hdGl2ZVJhbmdlIiwidGV4dE5vZGUiLCJzZXROYXRpdmVSYW5nZSIsImlnbm9yZWQiLCJfY29udGV4dCRyYW5nZSIsInN0YXJ0Tm9kZSIsInN0YXJ0T2Zmc2V0IiwiZW5kTm9kZSIsImVuZE9mZnNldCIsInJlc3RvcmUiLCJib2R5IiwiX2Zvcm1hdCIsIm5hdGl2ZVJhbmdlIiwiY29sbGFwc2VkIiwiYWZ0ZXIiLCJfc2Nyb2xsJGxlYWYiLCJfc2Nyb2xsJGxlYWYyIiwiX2xlYWYkcG9zaXRpb24iLCJwb3NpdGlvbiIsIl9sZWFmJHBvc2l0aW9uMiIsImNyZWF0ZVJhbmdlIiwic2V0U3RhcnQiLCJfc2Nyb2xsJGxlYWYzIiwiX3Njcm9sbCRsZWFmNCIsIl9sZWFmJHBvc2l0aW9uMyIsIl9sZWFmJHBvc2l0aW9uNCIsInNldEVuZCIsInNpZGUiLCJyZWN0IiwicmFuZ2VDb3VudCIsImdldFJhbmdlQXQiLCJub3JtYWxpemVOYXRpdmUiLCJpbmZvIiwibm9ybWFsaXplZCIsIm5vcm1hbGl6ZWRUb1JhbmdlIiwiYWN0aXZlRWxlbWVudCIsInBvc2l0aW9ucyIsImluZGV4ZXMiLCJfcG9zaXRpb24iLCJzdGFydENvbnRhaW5lciIsImVuZENvbnRhaW5lciIsImNoaWxkTm9kZXMiLCJsYXN0Q2hpbGQiLCJyYW5nZVRvTmF0aXZlIiwiX3Njcm9sbCRsZWFmNSIsIl9zY3JvbGwkbGVhZjYiLCJfbGVhZiRwb3NpdGlvbjUiLCJfbGVhZiRwb3NpdGlvbjYiLCJmaXJzdCIsImxhc3QiLCJzY3JvbGxCb3VuZHMiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsIm9sZFJhbmdlIiwiX2dldFJhbmdlIiwiX2dldFJhbmdlMiIsIkJyZWFrIiwiaW5zZXJ0SW50byIsImxpbmtlZF9saXN0XzEiLCJzaGFkb3dfMSIsIkNvbnRhaW5lckJsb3QiLCJidWlsZCIsIm1ha2VCbG90IiwiZm9yRWFjaEF0IiwiY3JpdGVyaWEiLCJfYSIsImxlbmd0aExlZnQiLCJkZXRhY2giLCJjaGlsZEJsb3QiLCJyZWZCbG90Iiwic29tZSIsIm1lbW8iLCJ0YXJnZXRQYXJlbnQiLCJpbmNsdXNpdmUiLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwibXV0YXRpb24iLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSIsIkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyIsIm5leHRTaWJsaW5nIiwicmVwbGFjZUNoaWxkIiwiRm9ybWF0QmxvdCIsInRvTG93ZXJDYXNlIiwicmVwbGFjZVdpdGgiLCJyZXBsYWNlbWVudCIsIndyYXBwZXIiLCJtb3ZlIiwiTGVhZkJsb3QiLCJJTkxJTkVfQkxPVCIsImxpYiIsImtlZXBOdWxsIiwiSXRlcmF0b3IiLCJyZXRPcCIsInN1YnN0ciIsIl9pbnN0YW5jZW9mIiwibmF0aXZlTWFwIiwiTWFwIiwiXyIsIm5hdGl2ZVNldCIsIlNldCIsIm5hdGl2ZVByb21pc2UiLCJQcm9taXNlIiwiY2lyY3VsYXIiLCJkZXB0aCIsImluY2x1ZGVOb25FbnVtZXJhYmxlIiwiYWxsUGFyZW50cyIsImFsbENoaWxkcmVuIiwidXNlQnVmZmVyIiwiQnVmZmVyIiwicHJvdG8iLCJyZXNvbHZlIiwicmVqZWN0IiwidGhlbiIsIl9faXNBcnJheSIsIl9faXNSZWdFeHAiLCJSZWdFeHAiLCJfX2dldFJlZ0V4cEZsYWdzIiwibGFzdEluZGV4IiwiX19pc0RhdGUiLCJhbGxvY1Vuc2FmZSIsImtleUNoaWxkIiwidmFsdWVDaGlsZCIsInNldCIsImVudHJ5Q2hpbGQiLCJhdHRycyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJzeW1ib2wiLCJhbGxQcm9wZXJ0eU5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInByb3BlcnR5TmFtZSIsImNsb25lUHJvdG90eXBlIiwiX19vYmpUb1N0ciIsInJlIiwiZmxhZ3MiLCJnbG9iYWwiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwiX2NvbnRhaW5lciIsIl9jb250YWluZXIyIiwiaXNMaW5lIiwiX1BhcmNobWVudCRTY3JvbGwiLCJiYXRjaCIsIl9saW5lIiwiX2xpbmUyIiwiX2xpbmUzIiwiX2xpbmU0IiwiX25ld2xpbmVJbmRleCIsIm9ic2VydmVyIiwidGFrZVJlY29yZHMiLCJTSE9SVEtFWSIsIl9xdWlsbCIsIl9xdWlsbDIiLCJ0ZXN0IiwibmF2aWdhdG9yIiwicGxhdGZvcm0iLCJLZXlib2FyZCIsIl9Nb2R1bGUiLCJldnQiLCJiaW5kaW5nIiwibm9ybWFsaXplIiwid2hpY2giLCJrZXlDb2RlIiwiYmluZGluZ3MiLCJhZGRCaW5kaW5nIiwiRU5URVIiLCJzaGlmdEtleSIsImhhbmRsZUVudGVyIiwibWV0YUtleSIsImN0cmxLZXkiLCJhbHRLZXkiLCJ1c2VyQWdlbnQiLCJCQUNLU1BBQ0UiLCJoYW5kbGVCYWNrc3BhY2UiLCJoYW5kbGVEZWxldGUiLCJwcmVmaXgiLCJoYW5kbGVEZWxldGVSYW5nZSIsImxpc3RlbiIsImRlZmF1bHRQcmV2ZW50ZWQiLCJfcXVpbGwkZ2V0TGluZSIsIl9xdWlsbCRnZXRMaW5lMiIsIl9xdWlsbCRnZXRMZWFmIiwiX3F1aWxsJGdldExlYWYyIiwibGVhZlN0YXJ0Iiwib2Zmc2V0U3RhcnQiLCJfcmVmMiIsImxlYWZFbmQiLCJvZmZzZXRFbmQiLCJwcmVmaXhUZXh0Iiwic3VmZml4VGV4dCIsImN1ckNvbnRleHQiLCJlbXB0eSIsInByZXZlbnRlZCIsImV2ZXJ5IiwicHJldmVudERlZmF1bHQiLCJFU0NBUEUiLCJMRUZUIiwiVVAiLCJSSUdIVCIsIkRPV04iLCJtYWtlRm9ybWF0SGFuZGxlciIsImluZGVudCIsIm1ha2VDb2RlQmxvY2tIYW5kbGVyIiwiY3V0b2ZmIiwiX3F1aWxsJGdldExpbmUzIiwiX3F1aWxsJGdldExpbmU0IiwiX3F1aWxsJGdldExpbmU1IiwiX3F1aWxsJGdldExpbmU2IiwiaGVhZGVyIiwiX3F1aWxsJGdldExpbmU3IiwiX3F1aWxsJGdldExpbmU4IiwiX3F1aWxsJGdldExpbmU5IiwiX3F1aWxsJGdldExpbmUxMCIsIm1ha2VFbWJlZEFycm93SGFuZGxlciIsIl9yZWYzIiwid2hlcmUiLCJfcXVpbGwkZ2V0TGVhZjMiLCJfcXVpbGwkZ2V0TGVhZjQiLCJfcXVpbGwkZ2V0TGluZTExIiwiX3F1aWxsJGdldExpbmUxMiIsIl9xdWlsbCRnZXRMaW5lMTMiLCJfcXVpbGwkZ2V0TGluZTE0IiwiY3VyRm9ybWF0cyIsInByZXZGb3JtYXRzIiwibmV4dExlbmd0aCIsIl9xdWlsbCRnZXRMaW5lMTUiLCJfcXVpbGwkZ2V0TGluZTE2IiwiX3F1aWxsJGdldExpbmUxNyIsIl9xdWlsbCRnZXRMaW5lMTgiLCJuZXh0Rm9ybWF0cyIsImZpcnN0Rm9ybWF0cyIsImxhc3RGb3JtYXRzIiwibGluZUZvcm1hdHMiLCJfcXVpbGwkc2Nyb2xsJGRlc2NlbmQiLCJfcXVpbGwkc2Nyb2xsJGRlc2NlbmQyIiwic2Nyb2xsSW5kZXgiLCJzaG9ydEtleSIsImNoYXJDb2RlQXQiLCJDdXJzb3IiLCJjcmVhdGVUZXh0Tm9kZSIsIl9sZW5ndGgiLCJyZXN0b3JlVGV4dCIsIl9QYXJjaG1lbnQkQ29udGFpbmVyIiwiQ29sb3JTdHlsZSIsIkNvbG9yQ2xhc3MiLCJDb2xvckF0dHJpYnV0b3IiLCJfUGFyY2htZW50JEF0dHJpYnV0b3IiLCJwYXJzZUludCIsInNhbml0aXplIiwiTGluayIsInVybCIsIl9zYW5pdGl6ZSIsIlBST1RPQ09MX1dISVRFTElTVCIsIlNBTklUSVpFRF9VUkwiLCJwcm90b2NvbHMiLCJhbmNob3IiLCJocmVmIiwicHJvdG9jb2wiLCJfa2V5Ym9hcmQiLCJfa2V5Ym9hcmQyIiwiX2Ryb3Bkb3duIiwiX2Ryb3Bkb3duMiIsIm9wdGlvbnNDb3VudGVyIiwidG9nZ2xlQXJpYUF0dHJpYnV0ZSIsImVsZW1lbnQiLCJQaWNrZXIiLCJzZWxlY3QiLCJidWlsZFBpY2tlciIsInN0eWxlIiwiZGlzcGxheSIsImxhYmVsIiwidG9nZ2xlUGlja2VyIiwiZXNjYXBlIiwiYnVpbGRJdGVtIiwib3B0aW9uIiwidGFiSW5kZXgiLCJoYXNBdHRyaWJ1dGUiLCJzZWxlY3RJdGVtIiwiYnVpbGRMYWJlbCIsImJ1aWxkT3B0aW9ucyIsImlkIiwic2VsZWN0ZWQiLCJjbG9zZSIsInRyaWdnZXIiLCJzZWxlY3RlZEluZGV4IiwiRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJpc0FjdGl2ZSIsIl9lbWJlZCIsIl9lbWJlZDIiLCJfc2Nyb2xsIiwiX3Njcm9sbDIiLCJfY2xpcGJvYXJkIiwiX2NsaXBib2FyZDIiLCJfaGlzdG9yeSIsIl9oaXN0b3J5MiIsIlNoYWRvd0Jsb3QiLCJjbG9uZU5vZGUiLCJwYXJlbnRCbG90IiwicmVmRG9tTm9kZSIsIkF0dHJpYnV0b3JTdG9yZSIsInN0eWxlcyIsImF0dHIiLCJDbGFzc0F0dHJpYnV0b3IiLCJtYXRjaGVzIiwicmVzdWx0IiwiY2FtZWxpemUiLCJwYXJ0cyIsInBhcnQiLCJTdHlsZUF0dHJpYnV0b3IiLCJUaGVtZSIsInRoZW1lcyIsIkdVQVJEX1RFWFQiLCJjb250ZW50Tm9kZSIsImNoaWxkTm9kZSIsImxlZnRHdWFyZCIsInJpZ2h0R3VhcmQiLCJwcmV2TGVuZ3RoIiwiQWxpZ25TdHlsZSIsIkFsaWduQ2xhc3MiLCJBbGlnbkF0dHJpYnV0ZSIsIkJhY2tncm91bmRTdHlsZSIsIkJhY2tncm91bmRDbGFzcyIsIl9jb2xvciIsIkRpcmVjdGlvblN0eWxlIiwiRGlyZWN0aW9uQ2xhc3MiLCJEaXJlY3Rpb25BdHRyaWJ1dGUiLCJGb250Q2xhc3MiLCJGb250U3R5bGUiLCJGb250U3R5bGVBdHRyaWJ1dG9yIiwiU2l6ZVN0eWxlIiwiU2l6ZUNsYXNzIiwiZ2V0TGFzdENoYW5nZUluZGV4IiwiSGlzdG9yeSIsImxhc3RSZWNvcmRlZCIsImlnbm9yZUNoYW5nZSIsInVzZXJPbmx5IiwicmVjb3JkIiwidW5kbyIsInJlZG8iLCJkZXN0Iiwic3RhY2siLCJjaGFuZ2VEZWx0YSIsInVuZG9EZWx0YSIsInRpbWVzdGFtcCIsIm5vdyIsImRlbGF5IiwibWF4U3RhY2siLCJlbmRzV2l0aE5ld2xpbmVDaGFuZ2UiLCJkZWxldGVMZW5ndGgiLCJjaGFuZ2VJbmRleCIsIkJhc2VUb29sdGlwIiwiX2NvbG9yUGlja2VyIiwiX2NvbG9yUGlja2VyMiIsIl9pY29uUGlja2VyIiwiX2ljb25QaWNrZXIyIiwiX3BpY2tlciIsIl9waWNrZXIyIiwiX3Rvb2x0aXAiLCJfdG9vbHRpcDIiLCJBTElHTlMiLCJDT0xPUlMiLCJGT05UUyIsIkhFQURFUlMiLCJTSVpFUyIsIkJhc2VUaGVtZSIsIl9UaGVtZSIsImxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInRvb2x0aXAiLCJ0ZXh0Ym94IiwiaGlkZSIsInBpY2tlcnMiLCJwaWNrZXIiLCJleHRlbmRUb29sYmFyIiwiYnVpbGRCdXR0b25zIiwiYnV0dG9ucyIsImljb25zIiwiYnV0dG9uIiwiYnVpbGRQaWNrZXJzIiwic2VsZWN0cyIsImZpbGxTZWxlY3QiLCJhbGlnbiIsImhhbmRsZXJzIiwiZm9ybXVsYSIsImVkaXQiLCJmaWxlSW5wdXQiLCJmaWxlcyIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJyZWFkQXNEYXRhVVJMIiwiY2xpY2siLCJ2aWRlbyIsIl9Ub29sdGlwIiwiYm91bmRzQ29udGFpbmVyIiwic2F2ZSIsImNhbmNlbCIsIm1vZGUiLCJwcmV2aWV3IiwicmVzdG9yZUZvY3VzIiwibGlua1JhbmdlIiwiZXh0cmFjdFZpZGVvVXJsIiwiZGVmYXVsdFZhbHVlIiwiTGlua2VkTGlzdCIsImFwcGVuZCIsIm5vZGVzIiwiY3VyIiwiY3VyTm9kZSIsImNhbGxiYWNrIiwiY3VySW5kZXgiLCJjdXJMZW5ndGgiLCJPQlNFUlZFUl9DT05GSUciLCJjaGFyYWN0ZXJEYXRhIiwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsIk1BWF9PUFRJTUlaRV9JVEVSQVRJT05TIiwiU2Nyb2xsQmxvdCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsInJlY29yZHMiLCJtYXJrIiwibWFya1BhcmVudCIsInJlbWFpbmluZyIsInByZXZpb3VzU2libGluZyIsImdyYW5kQ2hpbGQiLCJpc0VxdWFsIiwib2JqMSIsIm9iajIiLCJwcm9wIiwiSW5saW5lQmxvdCIsIkJsb2NrQmxvdCIsIkVtYmVkQmxvdCIsInNwbGl0VGV4dCIsIl90b2dnbGUiLCJET01Ub2tlbkxpc3QiLCJ0b2tlbiIsInNlYXJjaFN0cmluZyIsInN1YmplY3RTdHJpbmciLCJpc0Zpbml0ZSIsImZsb29yIiwidGhpc0FyZyIsImV4ZWNDb21tYW5kIiwiRElGRl9ERUxFVEUiLCJESUZGX0lOU0VSVCIsIkRJRkZfRVFVQUwiLCJkaWZmX21haW4iLCJ0ZXh0MSIsInRleHQyIiwiY3Vyc29yX3BvcyIsImNvbW1vbmxlbmd0aCIsImRpZmZfY29tbW9uUHJlZml4IiwiY29tbW9ucHJlZml4Iiwic3Vic3RyaW5nIiwiZGlmZl9jb21tb25TdWZmaXgiLCJjb21tb25zdWZmaXgiLCJkaWZmcyIsImRpZmZfY29tcHV0ZV8iLCJkaWZmX2NsZWFudXBNZXJnZSIsImZpeF9jdXJzb3IiLCJmaXhfZW1vamkiLCJsb25ndGV4dCIsInNob3J0dGV4dCIsImhtIiwiZGlmZl9oYWxmTWF0Y2hfIiwidGV4dDFfYSIsInRleHQxX2IiLCJ0ZXh0Ml9hIiwidGV4dDJfYiIsIm1pZF9jb21tb24iLCJkaWZmc19hIiwiZGlmZnNfYiIsImRpZmZfYmlzZWN0XyIsInRleHQxX2xlbmd0aCIsInRleHQyX2xlbmd0aCIsIm1heF9kIiwiY2VpbCIsInZfb2Zmc2V0Iiwidl9sZW5ndGgiLCJ2MSIsInYyIiwiZnJvbnQiLCJrMXN0YXJ0IiwiazFlbmQiLCJrMnN0YXJ0IiwiazJlbmQiLCJrMSIsImsxX29mZnNldCIsIngxIiwieTEiLCJjaGFyQXQiLCJrMl9vZmZzZXQiLCJ4MiIsImRpZmZfYmlzZWN0U3BsaXRfIiwiazIiLCJ5MiIsInkiLCJ0ZXh0MWEiLCJ0ZXh0MmEiLCJ0ZXh0MWIiLCJ0ZXh0MmIiLCJkaWZmc2IiLCJwb2ludGVybWluIiwicG9pbnRlcm1heCIsInBvaW50ZXJtaWQiLCJwb2ludGVyc3RhcnQiLCJwb2ludGVyZW5kIiwiZGlmZl9oYWxmTWF0Y2hJXyIsInNlZWQiLCJqIiwiYmVzdF9jb21tb24iLCJiZXN0X2xvbmd0ZXh0X2EiLCJiZXN0X2xvbmd0ZXh0X2IiLCJiZXN0X3Nob3J0dGV4dF9hIiwiYmVzdF9zaG9ydHRleHRfYiIsInByZWZpeExlbmd0aCIsImhtMSIsImhtMiIsInBvaW50ZXIiLCJjb3VudF9kZWxldGUiLCJjb3VudF9pbnNlcnQiLCJ0ZXh0X2RlbGV0ZSIsInRleHRfaW5zZXJ0IiwiY2hhbmdlcyIsImN1cnNvcl9ub3JtYWxpemVfZGlmZiIsImN1cnJlbnRfcG9zIiwibmV4dF9wb3MiLCJzcGxpdF9wb3MiLCJkX2xlZnQiLCJkX3JpZ2h0Iiwibm9ybSIsIm5kaWZmcyIsImN1cnNvcl9wb2ludGVyIiwiZF9uZXh0IiwibWVyZ2VfdHVwbGVzIiwiY29tcGFjdCIsInN0YXJ0c193aXRoX3BhaXJfZW5kIiwic3RyIiwiZW5kc193aXRoX3BhaXJfc3RhcnQiLCJmaXhlZF9kaWZmcyIsImxlZnRfZCIsInJpZ2h0X2QiLCJzaGltIiwic3VwcG9ydHNBcmd1bWVudHNDbGFzcyIsInN1cHBvcnRlZCIsInVuc3VwcG9ydGVkIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJoYXMiLCJFdmVudHMiLCJFRSIsImZuIiwiRXZlbnRFbWl0dGVyIiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsImV2ZW50TmFtZXMiLCJleGlzdHMiLCJhdmFpbGFibGUiLCJlZSIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJsZW4iLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImFkZExpc3RlbmVyIiwic2V0TWF4TGlzdGVuZXJzIiwicHJlZml4ZWQiLCJtYXRjaFRleHQiLCJtYXRjaFNwYWNpbmciLCJtYXRjaE5ld2xpbmUiLCJtYXRjaEJsb3QiLCJtYXRjaEF0dHJpYnV0b3IiLCJfZXh0ZW5kMyIsIl9hbGlnbiIsIl9iYWNrZ3JvdW5kIiwiX2RpcmVjdGlvbiIsIl9mb250IiwiX3NpemUiLCJET01fS0VZIiwiQ0xJUEJPQVJEX0NPTkZJRyIsIm1hdGNoQnJlYWsiLCJFTEVNRU5UX05PREUiLCJtYXRjaFN0eWxlcyIsIm1hdGNoSW5kZW50IiwibWF0Y2hBbGlhcyIsIm1hdGNoSWdub3JlIiwiQVRUUklCVVRFX0FUVFJJQlVUT1JTIiwiU1RZTEVfQVRUUklCVVRPUlMiLCJDbGlwYm9hcmQiLCJvblBhc3RlIiwibWF0Y2hlcnMiLCJzZWxlY3RvciIsIm1hdGNoZXIiLCJtYXRjaFZpc3VhbCIsImFkZE1hdGNoZXIiLCJpbm5lclRleHQiLCJfcHJlcGFyZU1hdGNoaW5nIiwicHJlcGFyZU1hdGNoaW5nIiwiX3ByZXBhcmVNYXRjaGluZzIiLCJlbGVtZW50TWF0Y2hlcnMiLCJ0ZXh0TWF0Y2hlcnMiLCJ0cmF2ZXJzZSIsImRlbHRhRW5kc1dpdGgiLCJwYXN0ZSIsInBhaXIiLCJfcGFpciIsImFwcGx5Rm9ybWF0IiwiY29tcHV0ZVN0eWxlIiwibm9kZVR5cGUiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiZW5kVGV4dCIsImNoaWxkcmVuRGVsdGEiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJub2RlSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwicGFyc2VGbG9hdCIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsIm9mZnNldFRvcCIsImZvbnRTdHlsZSIsIml0YWxpYyIsImZvbnRXZWlnaHQiLCJib2xkIiwidGV4dEluZGVudCIsIndoaXRlU3BhY2UiLCJyZXBsYWNlciIsImNvbGxhcHNlIiwiQm9sZCIsImFkZENvbnRyb2xzIiwiVG9vbGJhciIsIl9yZXQiLCJjb250cm9scyIsImFkZEhhbmRsZXIiLCJfdGhpcyRxdWlsbCRzZWxlY3Rpb24iLCJfdGhpcyRxdWlsbCRzZWxlY3Rpb24yIiwiX3F1aWxsJHNlbGVjdGlvbiRnZXRSIiwiX3F1aWxsJHNlbGVjdGlvbiRnZXRSMiIsInByb21wdCIsImFkZEJ1dHRvbiIsImdyb3VwcyIsImdyb3VwIiwiY29udHJvbCIsImFkZFNlbGVjdCIsImNsZWFuIiwiZGlyZWN0aW9uIiwibGluayIsIkNvbG9yUGlja2VyIiwiX1BpY2tlciIsImJhY2tncm91bmRDb2xvciIsImNvbG9yTGFiZWwiLCJzdHJva2UiLCJmaWxsIiwiSWNvblBpY2tlciIsImRlZmF1bHRJdGVtIiwiVG9vbHRpcCIsIlRFTVBMQVRFIiwicmVmZXJlbmNlIiwib2Zmc2V0V2lkdGgiLCJyb290Qm91bmRzIiwidmVydGljYWxTaGlmdCIsInNob3ciLCJfYmFzZSIsIl9iYXNlMiIsIl9saW5rIiwiX2xpbmsyIiwiX2ljb25zIiwiX2ljb25zMiIsIlRPT0xCQVJfQ09ORklHIiwiU25vd1RoZW1lIiwiX0Jhc2VUaGVtZSIsIlNub3dUb29sdGlwIiwiX0Jhc2VUb29sdGlwIiwiX2NvcmUiLCJfY29yZTIiLCJfaW5kZW50IiwiX2Jsb2NrcXVvdGUiLCJfYmxvY2txdW90ZTIiLCJfaGVhZGVyIiwiX2hlYWRlcjIiLCJfbGlzdCIsIl9saXN0MiIsIl9ib2xkIiwiX2JvbGQyIiwiX2l0YWxpYyIsIl9pdGFsaWMyIiwiX3NjcmlwdCIsIl9zY3JpcHQyIiwiX3N0cmlrZSIsIl9zdHJpa2UyIiwiX3VuZGVybGluZSIsIl91bmRlcmxpbmUyIiwiX2ltYWdlIiwiX2ltYWdlMiIsIl92aWRlbyIsIl92aWRlbzIiLCJfZm9ybXVsYSIsIl9mb3JtdWxhMiIsIl9zeW50YXgiLCJfc3ludGF4MiIsIl90b29sYmFyIiwiX3Rvb2xiYXIyIiwiX2J1YmJsZSIsIl9idWJibGUyIiwiX3Nub3ciLCJfc25vdzIiLCJJbmRlbnRDbGFzcyIsIkxpc3RJdGVtIiwiSWRlbnRBdHRyaWJ1dG9yIiwiQmxvY2txdW90ZSIsIkhlYWRlciIsIkxpc3QiLCJfQ29udGFpbmVyIiwibGlzdEV2ZW50SGFuZGxlciIsIkl0YWxpYyIsIl9Cb2xkIiwiU2NyaXB0IiwiU3RyaWtlIiwiVW5kZXJsaW5lIiwiQVRUUklCVVRFUyIsIkltYWdlIiwiVmlkZW8iLCJfQmxvY2tFbWJlZCIsIkZvcm11bGFCbG90IiwiX0VtYmVkIiwia2F0ZXgiLCJyZW5kZXIiLCJ0aHJvd09uRXJyb3IiLCJlcnJvckNvbG9yIiwiRm9ybXVsYSIsIkNvZGVUb2tlbiIsIlN5bnRheENvZGVCbG9jayIsIl9Db2RlQmxvY2siLCJoaWdobGlnaHQiLCJfaGlnaGxpZ2h0IiwiY2FjaGVkVGV4dCIsIlN5bnRheCIsInRpbWVyIiwiY2xlYXJUaW1lb3V0IiwiaW50ZXJ2YWwiLCJjb2RlIiwiaGxqcyIsImhpZ2hsaWdodEF1dG8iLCJCdWJibGVUb29sdGlwIiwiQnViYmxlVGhlbWUiLCJsYXN0TGluZSIsIl9ib3VuZHMiLCJhcnJvdyIsIm1hcmdpbkxlZnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/quill/dist/quill.js\n");

/***/ })

};
;