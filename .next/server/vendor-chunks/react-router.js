"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router";
exports.ids = ["vendor-chunks/react-router"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-router/dist/development/dom-export.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-router/dist/development/dom-export.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * react-router v7.6.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// dom-export.ts\nvar dom_export_exports = {};\n__export(dom_export_exports, {\n    HydratedRouter: ()=>HydratedRouter,\n    RouterProvider: ()=>RouterProvider\n});\nmodule.exports = __toCommonJS(dom_export_exports);\n// lib/dom-export/dom-router-provider.tsx\nvar React = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar ReactDOM = __toESM(__webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"));\nvar import_react_router = __webpack_require__(/*! react-router */ \"(ssr)/./node_modules/react-router/dist/development/index.js\");\nfunction RouterProvider(props) {\n    return /* @__PURE__ */ React.createElement(import_react_router.RouterProvider, {\n        flushSync: ReactDOM.flushSync,\n        ...props\n    });\n}\n// lib/dom-export/hydrated-router.tsx\nvar React2 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar import_react_router2 = __webpack_require__(/*! react-router */ \"(ssr)/./node_modules/react-router/dist/development/index.js\");\nvar ssrInfo = null;\nvar router = null;\nfunction initSsrInfo() {\n    if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {\n        if (window.__reactRouterManifest.sri === true) {\n            const importMap = document.querySelector(\"script[rr-importmap]\");\n            if (importMap?.textContent) {\n                try {\n                    window.__reactRouterManifest.sri = JSON.parse(importMap.textContent).integrity;\n                } catch (err) {\n                    console.error(\"Failed to parse import map\", err);\n                }\n            }\n        }\n        ssrInfo = {\n            context: window.__reactRouterContext,\n            manifest: window.__reactRouterManifest,\n            routeModules: window.__reactRouterRouteModules,\n            stateDecodingPromise: void 0,\n            router: void 0,\n            routerInitialized: false\n        };\n    }\n}\nfunction createHydratedRouter({ unstable_getContext }) {\n    initSsrInfo();\n    if (!ssrInfo) {\n        throw new Error(\"You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`\");\n    }\n    let localSsrInfo = ssrInfo;\n    if (!ssrInfo.stateDecodingPromise) {\n        let stream = ssrInfo.context.stream;\n        (0, import_react_router2.UNSAFE_invariant)(stream, \"No stream found for single fetch decoding\");\n        ssrInfo.context.stream = void 0;\n        ssrInfo.stateDecodingPromise = (0, import_react_router2.UNSAFE_decodeViaTurboStream)(stream, window).then((value)=>{\n            ssrInfo.context.state = value.value;\n            localSsrInfo.stateDecodingPromise.value = true;\n        }).catch((e)=>{\n            localSsrInfo.stateDecodingPromise.error = e;\n        });\n    }\n    if (ssrInfo.stateDecodingPromise.error) {\n        throw ssrInfo.stateDecodingPromise.error;\n    }\n    if (!ssrInfo.stateDecodingPromise.value) {\n        throw ssrInfo.stateDecodingPromise;\n    }\n    let routes = (0, import_react_router2.UNSAFE_createClientRoutes)(ssrInfo.manifest.routes, ssrInfo.routeModules, ssrInfo.context.state, ssrInfo.context.ssr, ssrInfo.context.isSpaMode);\n    let hydrationData = void 0;\n    if (ssrInfo.context.isSpaMode) {\n        let { loaderData } = ssrInfo.context.state;\n        if (ssrInfo.manifest.routes.root?.hasLoader && loaderData && \"root\" in loaderData) {\n            hydrationData = {\n                loaderData: {\n                    root: loaderData.root\n                }\n            };\n        }\n    } else {\n        hydrationData = (0, import_react_router2.UNSAFE_getHydrationData)(ssrInfo.context.state, routes, (routeId)=>({\n                clientLoader: ssrInfo.routeModules[routeId]?.clientLoader,\n                hasLoader: ssrInfo.manifest.routes[routeId]?.hasLoader === true,\n                hasHydrateFallback: ssrInfo.routeModules[routeId]?.HydrateFallback != null\n            }), window.location, window.__reactRouterContext?.basename, ssrInfo.context.isSpaMode);\n        if (hydrationData && hydrationData.errors) {\n            hydrationData.errors = (0, import_react_router2.UNSAFE_deserializeErrors)(hydrationData.errors);\n        }\n    }\n    let router2 = (0, import_react_router2.UNSAFE_createRouter)({\n        routes,\n        history: (0, import_react_router2.UNSAFE_createBrowserHistory)(),\n        basename: ssrInfo.context.basename,\n        unstable_getContext,\n        hydrationData,\n        hydrationRouteProperties: import_react_router2.UNSAFE_hydrationRouteProperties,\n        mapRouteProperties: import_react_router2.UNSAFE_mapRouteProperties,\n        future: {\n            unstable_middleware: ssrInfo.context.future.unstable_middleware\n        },\n        dataStrategy: (0, import_react_router2.UNSAFE_getTurboStreamSingleFetchDataStrategy)(()=>router2, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.basename),\n        patchRoutesOnNavigation: (0, import_react_router2.UNSAFE_getPatchRoutesOnNavigationFunction)(ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode, ssrInfo.context.basename)\n    });\n    ssrInfo.router = router2;\n    if (router2.state.initialized) {\n        ssrInfo.routerInitialized = true;\n        router2.initialize();\n    }\n    router2.createRoutesForHMR = /* spacer so ts-ignore does not affect the right hand of the assignment */ import_react_router2.UNSAFE_createClientRoutesWithHMRRevalidationOptOut;\n    window.__reactRouterDataRouter = router2;\n    return router2;\n}\nfunction HydratedRouter(props) {\n    if (!router) {\n        router = createHydratedRouter({\n            unstable_getContext: props.unstable_getContext\n        });\n    }\n    let [criticalCss, setCriticalCss] = React2.useState( true ? ssrInfo?.context.criticalCss : 0);\n    if (true) {\n        if (ssrInfo) {\n            window.__reactRouterClearCriticalCss = ()=>setCriticalCss(void 0);\n        }\n    }\n    let [location, setLocation] = React2.useState(router.state.location);\n    React2.useLayoutEffect(()=>{\n        if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\n            ssrInfo.routerInitialized = true;\n            ssrInfo.router.initialize();\n        }\n    }, []);\n    React2.useLayoutEffect(()=>{\n        if (ssrInfo && ssrInfo.router) {\n            return ssrInfo.router.subscribe((newState)=>{\n                if (newState.location !== location) {\n                    setLocation(newState.location);\n                }\n            });\n        }\n    }, [\n        location\n    ]);\n    (0, import_react_router2.UNSAFE_invariant)(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\n    (0, import_react_router2.UNSAFE_useFogOFWarDiscovery)(router, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode);\n    return(// This fragment is important to ensure we match the <ServerRouter> JSX\n    // structure so that useId values hydrate correctly\n    /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(import_react_router2.UNSAFE_FrameworkContext.Provider, {\n        value: {\n            manifest: ssrInfo.manifest,\n            routeModules: ssrInfo.routeModules,\n            future: ssrInfo.context.future,\n            criticalCss,\n            ssr: ssrInfo.context.ssr,\n            isSpaMode: ssrInfo.context.isSpaMode,\n            routeDiscovery: ssrInfo.context.routeDiscovery\n        }\n    }, /* @__PURE__ */ React2.createElement(import_react_router2.UNSAFE_RemixErrorBoundary, {\n        location\n    }, /* @__PURE__ */ React2.createElement(RouterProvider, {\n        router\n    }))), /* @__PURE__ */ React2.createElement(React2.Fragment, null)));\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvZG9tLWV4cG9ydC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0NBU0MsR0FDWTtBQUNiLElBQUlBLFdBQVdDLE9BQU9DLE1BQU07QUFDNUIsSUFBSUMsWUFBWUYsT0FBT0csY0FBYztBQUNyQyxJQUFJQyxtQkFBbUJKLE9BQU9LLHdCQUF3QjtBQUN0RCxJQUFJQyxvQkFBb0JOLE9BQU9PLG1CQUFtQjtBQUNsRCxJQUFJQyxlQUFlUixPQUFPUyxjQUFjO0FBQ3hDLElBQUlDLGVBQWVWLE9BQU9XLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsUUFBUUQsSUFDZmIsVUFBVVksUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRUUsWUFBWTtJQUFLO0FBQy9EO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPbEIsa0JBQWtCZSxNQUNoQyxJQUFJLENBQUNYLGFBQWFlLElBQUksQ0FBQ0wsSUFBSUksUUFBUUEsUUFBUUYsUUFDekNwQixVQUFVa0IsSUFBSUksS0FBSztZQUFFUCxLQUFLLElBQU1JLElBQUksQ0FBQ0csSUFBSTtZQUFFTixZQUFZLENBQUVLLENBQUFBLE9BQU9uQixpQkFBaUJpQixNQUFNRyxJQUFHLEtBQU1ELEtBQUtMLFVBQVU7UUFBQztJQUN0SDtJQUNBLE9BQU9FO0FBQ1Q7QUFDQSxJQUFJTSxVQUFVLENBQUNDLEtBQUtDLFlBQVlkLFNBQVlBLENBQUFBLFNBQVNhLE9BQU8sT0FBTzVCLFNBQVNTLGFBQWFtQixRQUFRLENBQUMsR0FBR1IsWUFDbkcsc0VBQXNFO0lBQ3RFLGlFQUFpRTtJQUNqRSxzRUFBc0U7SUFD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bkQsSUFBR0QscUJBQXFCaUYsMkJBQTJCLEVBQ2xEL0UsUUFDQUQsUUFBUW1CLFFBQVEsRUFDaEJuQixRQUFRb0IsWUFBWSxFQUNwQnBCLFFBQVFrQixPQUFPLENBQUNrQixHQUFHLEVBQ25CcEMsUUFBUWtCLE9BQU8sQ0FBQytDLGNBQWMsRUFDOUJqRSxRQUFRa0IsT0FBTyxDQUFDbUIsU0FBUztJQUUzQixPQUNFLHVFQUF1RTtJQUN2RSxtREFBbUQ7SUFDbkQsYUFBYSxHQUFHdkMsT0FBT0YsYUFBYSxDQUFDRSxPQUFPbUYsUUFBUSxFQUFFLE1BQU0sYUFBYSxHQUFHbkYsT0FBT0YsYUFBYSxDQUM5RkcscUJBQXFCbUYsdUJBQXVCLENBQUNDLFFBQVEsRUFDckQ7UUFDRW5HLE9BQU87WUFDTG1DLFVBQVVuQixRQUFRbUIsUUFBUTtZQUMxQkMsY0FBY3BCLFFBQVFvQixZQUFZO1lBQ2xDdUMsUUFBUTNELFFBQVFrQixPQUFPLENBQUN5QyxNQUFNO1lBQzlCWTtZQUNBbkMsS0FBS3BDLFFBQVFrQixPQUFPLENBQUNrQixHQUFHO1lBQ3hCQyxXQUFXckMsUUFBUWtCLE9BQU8sQ0FBQ21CLFNBQVM7WUFDcEM0QixnQkFBZ0JqRSxRQUFRa0IsT0FBTyxDQUFDK0MsY0FBYztRQUNoRDtJQUNGLEdBQ0EsYUFBYSxHQUFHbkUsT0FBT0YsYUFBYSxDQUFDRyxxQkFBcUJxRix5QkFBeUIsRUFBRTtRQUFFckM7SUFBUyxHQUFHLGFBQWEsR0FBR2pELE9BQU9GLGFBQWEsQ0FBQ1IsZ0JBQWdCO1FBQUVhO0lBQU8sTUFDaEssYUFBYSxHQUFHSCxPQUFPRixhQUFhLENBQUNFLE9BQU9tRixRQUFRLEVBQUU7QUFFN0Q7QUFDQSw2REFBNkQ7QUFDN0QsS0FBTTVGLENBQUFBLENBR04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iYWxhbmNlLWNvZGUtYWxsaWFuY2UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvZG9tLWV4cG9ydC5qcz83NDNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVhY3Qtcm91dGVyIHY3LjYuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIGRvbS1leHBvcnQudHNcbnZhciBkb21fZXhwb3J0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGRvbV9leHBvcnRfZXhwb3J0cywge1xuICBIeWRyYXRlZFJvdXRlcjogKCkgPT4gSHlkcmF0ZWRSb3V0ZXIsXG4gIFJvdXRlclByb3ZpZGVyOiAoKSA9PiBSb3V0ZXJQcm92aWRlclxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhkb21fZXhwb3J0X2V4cG9ydHMpO1xuXG4vLyBsaWIvZG9tLWV4cG9ydC9kb20tcm91dGVyLXByb3ZpZGVyLnRzeFxudmFyIFJlYWN0ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIFJlYWN0RE9NID0gX190b0VTTShyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbnZhciBpbXBvcnRfcmVhY3Rfcm91dGVyID0gcmVxdWlyZShcInJlYWN0LXJvdXRlclwiKTtcbmZ1bmN0aW9uIFJvdXRlclByb3ZpZGVyKHByb3BzKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChpbXBvcnRfcmVhY3Rfcm91dGVyLlJvdXRlclByb3ZpZGVyLCB7IGZsdXNoU3luYzogUmVhY3RET00uZmx1c2hTeW5jLCAuLi5wcm9wcyB9KTtcbn1cblxuLy8gbGliL2RvbS1leHBvcnQvaHlkcmF0ZWQtcm91dGVyLnRzeFxudmFyIFJlYWN0MiA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBpbXBvcnRfcmVhY3Rfcm91dGVyMiA9IHJlcXVpcmUoXCJyZWFjdC1yb3V0ZXJcIik7XG52YXIgc3NySW5mbyA9IG51bGw7XG52YXIgcm91dGVyID0gbnVsbDtcbmZ1bmN0aW9uIGluaXRTc3JJbmZvKCkge1xuICBpZiAoIXNzckluZm8gJiYgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0ICYmIHdpbmRvdy5fX3JlYWN0Um91dGVyTWFuaWZlc3QgJiYgd2luZG93Ll9fcmVhY3RSb3V0ZXJSb3V0ZU1vZHVsZXMpIHtcbiAgICBpZiAod2luZG93Ll9fcmVhY3RSb3V0ZXJNYW5pZmVzdC5zcmkgPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IGltcG9ydE1hcCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzY3JpcHRbcnItaW1wb3J0bWFwXVwiKTtcbiAgICAgIGlmIChpbXBvcnRNYXA/LnRleHRDb250ZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd2luZG93Ll9fcmVhY3RSb3V0ZXJNYW5pZmVzdC5zcmkgPSBKU09OLnBhcnNlKFxuICAgICAgICAgICAgaW1wb3J0TWFwLnRleHRDb250ZW50XG4gICAgICAgICAgKS5pbnRlZ3JpdHk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgaW1wb3J0IG1hcFwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNzckluZm8gPSB7XG4gICAgICBjb250ZXh0OiB3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQsXG4gICAgICBtYW5pZmVzdDogd2luZG93Ll9fcmVhY3RSb3V0ZXJNYW5pZmVzdCxcbiAgICAgIHJvdXRlTW9kdWxlczogd2luZG93Ll9fcmVhY3RSb3V0ZXJSb3V0ZU1vZHVsZXMsXG4gICAgICBzdGF0ZURlY29kaW5nUHJvbWlzZTogdm9pZCAwLFxuICAgICAgcm91dGVyOiB2b2lkIDAsXG4gICAgICByb3V0ZXJJbml0aWFsaXplZDogZmFsc2VcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRlZFJvdXRlcih7XG4gIHVuc3RhYmxlX2dldENvbnRleHRcbn0pIHtcbiAgaW5pdFNzckluZm8oKTtcbiAgaWYgKCFzc3JJbmZvKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgbXVzdCBiZSB1c2luZyB0aGUgU1NSIGZlYXR1cmVzIG9mIFJlYWN0IFJvdXRlciBpbiBvcmRlciB0byBza2lwIHBhc3NpbmcgYSBgcm91dGVyYCBwcm9wIHRvIGA8Um91dGVyUHJvdmlkZXI+YFwiXG4gICAgKTtcbiAgfVxuICBsZXQgbG9jYWxTc3JJbmZvID0gc3NySW5mbztcbiAgaWYgKCFzc3JJbmZvLnN0YXRlRGVjb2RpbmdQcm9taXNlKSB7XG4gICAgbGV0IHN0cmVhbSA9IHNzckluZm8uY29udGV4dC5zdHJlYW07XG4gICAgKDAsIGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9pbnZhcmlhbnQpKHN0cmVhbSwgXCJObyBzdHJlYW0gZm91bmQgZm9yIHNpbmdsZSBmZXRjaCBkZWNvZGluZ1wiKTtcbiAgICBzc3JJbmZvLmNvbnRleHQuc3RyZWFtID0gdm9pZCAwO1xuICAgIHNzckluZm8uc3RhdGVEZWNvZGluZ1Byb21pc2UgPSAoMCwgaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX2RlY29kZVZpYVR1cmJvU3RyZWFtKShzdHJlYW0sIHdpbmRvdykudGhlbigodmFsdWUpID0+IHtcbiAgICAgIHNzckluZm8uY29udGV4dC5zdGF0ZSA9IHZhbHVlLnZhbHVlO1xuICAgICAgbG9jYWxTc3JJbmZvLnN0YXRlRGVjb2RpbmdQcm9taXNlLnZhbHVlID0gdHJ1ZTtcbiAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgbG9jYWxTc3JJbmZvLnN0YXRlRGVjb2RpbmdQcm9taXNlLmVycm9yID0gZTtcbiAgICB9KTtcbiAgfVxuICBpZiAoc3NySW5mby5zdGF0ZURlY29kaW5nUHJvbWlzZS5lcnJvcikge1xuICAgIHRocm93IHNzckluZm8uc3RhdGVEZWNvZGluZ1Byb21pc2UuZXJyb3I7XG4gIH1cbiAgaWYgKCFzc3JJbmZvLnN0YXRlRGVjb2RpbmdQcm9taXNlLnZhbHVlKSB7XG4gICAgdGhyb3cgc3NySW5mby5zdGF0ZURlY29kaW5nUHJvbWlzZTtcbiAgfVxuICBsZXQgcm91dGVzID0gKDAsIGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9jcmVhdGVDbGllbnRSb3V0ZXMpKFxuICAgIHNzckluZm8ubWFuaWZlc3Qucm91dGVzLFxuICAgIHNzckluZm8ucm91dGVNb2R1bGVzLFxuICAgIHNzckluZm8uY29udGV4dC5zdGF0ZSxcbiAgICBzc3JJbmZvLmNvbnRleHQuc3NyLFxuICAgIHNzckluZm8uY29udGV4dC5pc1NwYU1vZGVcbiAgKTtcbiAgbGV0IGh5ZHJhdGlvbkRhdGEgPSB2b2lkIDA7XG4gIGlmIChzc3JJbmZvLmNvbnRleHQuaXNTcGFNb2RlKSB7XG4gICAgbGV0IHsgbG9hZGVyRGF0YSB9ID0gc3NySW5mby5jb250ZXh0LnN0YXRlO1xuICAgIGlmIChzc3JJbmZvLm1hbmlmZXN0LnJvdXRlcy5yb290Py5oYXNMb2FkZXIgJiYgbG9hZGVyRGF0YSAmJiBcInJvb3RcIiBpbiBsb2FkZXJEYXRhKSB7XG4gICAgICBoeWRyYXRpb25EYXRhID0ge1xuICAgICAgICBsb2FkZXJEYXRhOiB7XG4gICAgICAgICAgcm9vdDogbG9hZGVyRGF0YS5yb290XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGh5ZHJhdGlvbkRhdGEgPSAoMCwgaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX2dldEh5ZHJhdGlvbkRhdGEpKFxuICAgICAgc3NySW5mby5jb250ZXh0LnN0YXRlLFxuICAgICAgcm91dGVzLFxuICAgICAgKHJvdXRlSWQpID0+ICh7XG4gICAgICAgIGNsaWVudExvYWRlcjogc3NySW5mby5yb3V0ZU1vZHVsZXNbcm91dGVJZF0/LmNsaWVudExvYWRlcixcbiAgICAgICAgaGFzTG9hZGVyOiBzc3JJbmZvLm1hbmlmZXN0LnJvdXRlc1tyb3V0ZUlkXT8uaGFzTG9hZGVyID09PSB0cnVlLFxuICAgICAgICBoYXNIeWRyYXRlRmFsbGJhY2s6IHNzckluZm8ucm91dGVNb2R1bGVzW3JvdXRlSWRdPy5IeWRyYXRlRmFsbGJhY2sgIT0gbnVsbFxuICAgICAgfSksXG4gICAgICB3aW5kb3cubG9jYXRpb24sXG4gICAgICB3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQ/LmJhc2VuYW1lLFxuICAgICAgc3NySW5mby5jb250ZXh0LmlzU3BhTW9kZVxuICAgICk7XG4gICAgaWYgKGh5ZHJhdGlvbkRhdGEgJiYgaHlkcmF0aW9uRGF0YS5lcnJvcnMpIHtcbiAgICAgIGh5ZHJhdGlvbkRhdGEuZXJyb3JzID0gKDAsIGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9kZXNlcmlhbGl6ZUVycm9ycykoaHlkcmF0aW9uRGF0YS5lcnJvcnMpO1xuICAgIH1cbiAgfVxuICBsZXQgcm91dGVyMiA9ICgwLCBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfY3JlYXRlUm91dGVyKSh7XG4gICAgcm91dGVzLFxuICAgIGhpc3Rvcnk6ICgwLCBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfY3JlYXRlQnJvd3Nlckhpc3RvcnkpKCksXG4gICAgYmFzZW5hbWU6IHNzckluZm8uY29udGV4dC5iYXNlbmFtZSxcbiAgICB1bnN0YWJsZV9nZXRDb250ZXh0LFxuICAgIGh5ZHJhdGlvbkRhdGEsXG4gICAgaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzOiBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllczogaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyxcbiAgICBmdXR1cmU6IHtcbiAgICAgIHVuc3RhYmxlX21pZGRsZXdhcmU6IHNzckluZm8uY29udGV4dC5mdXR1cmUudW5zdGFibGVfbWlkZGxld2FyZVxuICAgIH0sXG4gICAgZGF0YVN0cmF0ZWd5OiAoMCwgaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX2dldFR1cmJvU3RyZWFtU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3kpKFxuICAgICAgKCkgPT4gcm91dGVyMixcbiAgICAgIHNzckluZm8ubWFuaWZlc3QsXG4gICAgICBzc3JJbmZvLnJvdXRlTW9kdWxlcyxcbiAgICAgIHNzckluZm8uY29udGV4dC5zc3IsXG4gICAgICBzc3JJbmZvLmNvbnRleHQuYmFzZW5hbWVcbiAgICApLFxuICAgIHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uOiAoMCwgaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX2dldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24pKFxuICAgICAgc3NySW5mby5tYW5pZmVzdCxcbiAgICAgIHNzckluZm8ucm91dGVNb2R1bGVzLFxuICAgICAgc3NySW5mby5jb250ZXh0LnNzcixcbiAgICAgIHNzckluZm8uY29udGV4dC5yb3V0ZURpc2NvdmVyeSxcbiAgICAgIHNzckluZm8uY29udGV4dC5pc1NwYU1vZGUsXG4gICAgICBzc3JJbmZvLmNvbnRleHQuYmFzZW5hbWVcbiAgICApXG4gIH0pO1xuICBzc3JJbmZvLnJvdXRlciA9IHJvdXRlcjI7XG4gIGlmIChyb3V0ZXIyLnN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgc3NySW5mby5yb3V0ZXJJbml0aWFsaXplZCA9IHRydWU7XG4gICAgcm91dGVyMi5pbml0aWFsaXplKCk7XG4gIH1cbiAgcm91dGVyMi5jcmVhdGVSb3V0ZXNGb3JITVIgPSAvKiBzcGFjZXIgc28gdHMtaWdub3JlIGRvZXMgbm90IGFmZmVjdCB0aGUgcmlnaHQgaGFuZCBvZiB0aGUgYXNzaWdubWVudCAqL1xuICBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dDtcbiAgd2luZG93Ll9fcmVhY3RSb3V0ZXJEYXRhUm91dGVyID0gcm91dGVyMjtcbiAgcmV0dXJuIHJvdXRlcjI7XG59XG5mdW5jdGlvbiBIeWRyYXRlZFJvdXRlcihwcm9wcykge1xuICBpZiAoIXJvdXRlcikge1xuICAgIHJvdXRlciA9IGNyZWF0ZUh5ZHJhdGVkUm91dGVyKHtcbiAgICAgIHVuc3RhYmxlX2dldENvbnRleHQ6IHByb3BzLnVuc3RhYmxlX2dldENvbnRleHRcbiAgICB9KTtcbiAgfVxuICBsZXQgW2NyaXRpY2FsQ3NzLCBzZXRDcml0aWNhbENzc10gPSBSZWFjdDIudXNlU3RhdGUoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiA/IHNzckluZm8/LmNvbnRleHQuY3JpdGljYWxDc3MgOiB2b2lkIDBcbiAgKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICBpZiAoc3NySW5mbykge1xuICAgICAgd2luZG93Ll9fcmVhY3RSb3V0ZXJDbGVhckNyaXRpY2FsQ3NzID0gKCkgPT4gc2V0Q3JpdGljYWxDc3Modm9pZCAwKTtcbiAgICB9XG4gIH1cbiAgbGV0IFtsb2NhdGlvbiwgc2V0TG9jYXRpb25dID0gUmVhY3QyLnVzZVN0YXRlKHJvdXRlci5zdGF0ZS5sb2NhdGlvbik7XG4gIFJlYWN0Mi51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzc3JJbmZvICYmIHNzckluZm8ucm91dGVyICYmICFzc3JJbmZvLnJvdXRlckluaXRpYWxpemVkKSB7XG4gICAgICBzc3JJbmZvLnJvdXRlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHNzckluZm8ucm91dGVyLmluaXRpYWxpemUoKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgUmVhY3QyLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHNzckluZm8gJiYgc3NySW5mby5yb3V0ZXIpIHtcbiAgICAgIHJldHVybiBzc3JJbmZvLnJvdXRlci5zdWJzY3JpYmUoKG5ld1N0YXRlKSA9PiB7XG4gICAgICAgIGlmIChuZXdTdGF0ZS5sb2NhdGlvbiAhPT0gbG9jYXRpb24pIHtcbiAgICAgICAgICBzZXRMb2NhdGlvbihuZXdTdGF0ZS5sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2xvY2F0aW9uXSk7XG4gICgwLCBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfaW52YXJpYW50KShzc3JJbmZvLCBcInNzckluZm8gdW5hdmFpbGFibGUgZm9yIEh5ZHJhdGVkUm91dGVyXCIpO1xuICAoMCwgaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX3VzZUZvZ09GV2FyRGlzY292ZXJ5KShcbiAgICByb3V0ZXIsXG4gICAgc3NySW5mby5tYW5pZmVzdCxcbiAgICBzc3JJbmZvLnJvdXRlTW9kdWxlcyxcbiAgICBzc3JJbmZvLmNvbnRleHQuc3NyLFxuICAgIHNzckluZm8uY29udGV4dC5yb3V0ZURpc2NvdmVyeSxcbiAgICBzc3JJbmZvLmNvbnRleHQuaXNTcGFNb2RlXG4gICk7XG4gIHJldHVybiAoXG4gICAgLy8gVGhpcyBmcmFnbWVudCBpcyBpbXBvcnRhbnQgdG8gZW5zdXJlIHdlIG1hdGNoIHRoZSA8U2VydmVyUm91dGVyPiBKU1hcbiAgICAvLyBzdHJ1Y3R1cmUgc28gdGhhdCB1c2VJZCB2YWx1ZXMgaHlkcmF0ZSBjb3JyZWN0bHlcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUmVhY3QyLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfRnJhbWV3b3JrQ29udGV4dC5Qcm92aWRlcixcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBtYW5pZmVzdDogc3NySW5mby5tYW5pZmVzdCxcbiAgICAgICAgICByb3V0ZU1vZHVsZXM6IHNzckluZm8ucm91dGVNb2R1bGVzLFxuICAgICAgICAgIGZ1dHVyZTogc3NySW5mby5jb250ZXh0LmZ1dHVyZSxcbiAgICAgICAgICBjcml0aWNhbENzcyxcbiAgICAgICAgICBzc3I6IHNzckluZm8uY29udGV4dC5zc3IsXG4gICAgICAgICAgaXNTcGFNb2RlOiBzc3JJbmZvLmNvbnRleHQuaXNTcGFNb2RlLFxuICAgICAgICAgIHJvdXRlRGlzY292ZXJ5OiBzc3JJbmZvLmNvbnRleHQucm91dGVEaXNjb3ZlcnlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfUmVtaXhFcnJvckJvdW5kYXJ5LCB7IGxvY2F0aW9uIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSb3V0ZXJQcm92aWRlciwgeyByb3V0ZXIgfSkpXG4gICAgKSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJlYWN0Mi5GcmFnbWVudCwgbnVsbCkpXG4gICk7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgSHlkcmF0ZWRSb3V0ZXIsXG4gIFJvdXRlclByb3ZpZGVyXG59KTtcbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZSIsIk9iamVjdCIsImNyZWF0ZSIsIl9fZGVmUHJvcCIsImRlZmluZVByb3BlcnR5IiwiX19nZXRPd25Qcm9wRGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZ2V0T3duUHJvcE5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9fZ2V0UHJvdG9PZiIsImdldFByb3RvdHlwZU9mIiwiX19oYXNPd25Qcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJfX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJnZXQiLCJlbnVtZXJhYmxlIiwiX19jb3B5UHJvcHMiLCJ0byIsImZyb20iLCJleGNlcHQiLCJkZXNjIiwia2V5IiwiY2FsbCIsIl9fdG9FU00iLCJtb2QiLCJpc05vZGVNb2RlIiwiX19lc01vZHVsZSIsInZhbHVlIiwiX190b0NvbW1vbkpTIiwiZG9tX2V4cG9ydF9leHBvcnRzIiwiSHlkcmF0ZWRSb3V0ZXIiLCJSb3V0ZXJQcm92aWRlciIsIm1vZHVsZSIsImV4cG9ydHMiLCJSZWFjdCIsInJlcXVpcmUiLCJSZWFjdERPTSIsImltcG9ydF9yZWFjdF9yb3V0ZXIiLCJwcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJmbHVzaFN5bmMiLCJSZWFjdDIiLCJpbXBvcnRfcmVhY3Rfcm91dGVyMiIsInNzckluZm8iLCJyb3V0ZXIiLCJpbml0U3NySW5mbyIsIndpbmRvdyIsIl9fcmVhY3RSb3V0ZXJDb250ZXh0IiwiX19yZWFjdFJvdXRlck1hbmlmZXN0IiwiX19yZWFjdFJvdXRlclJvdXRlTW9kdWxlcyIsInNyaSIsImltcG9ydE1hcCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInRleHRDb250ZW50IiwiSlNPTiIsInBhcnNlIiwiaW50ZWdyaXR5IiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiY29udGV4dCIsIm1hbmlmZXN0Iiwicm91dGVNb2R1bGVzIiwic3RhdGVEZWNvZGluZ1Byb21pc2UiLCJyb3V0ZXJJbml0aWFsaXplZCIsImNyZWF0ZUh5ZHJhdGVkUm91dGVyIiwidW5zdGFibGVfZ2V0Q29udGV4dCIsIkVycm9yIiwibG9jYWxTc3JJbmZvIiwic3RyZWFtIiwiVU5TQUZFX2ludmFyaWFudCIsIlVOU0FGRV9kZWNvZGVWaWFUdXJib1N0cmVhbSIsInRoZW4iLCJzdGF0ZSIsImNhdGNoIiwiZSIsInJvdXRlcyIsIlVOU0FGRV9jcmVhdGVDbGllbnRSb3V0ZXMiLCJzc3IiLCJpc1NwYU1vZGUiLCJoeWRyYXRpb25EYXRhIiwibG9hZGVyRGF0YSIsInJvb3QiLCJoYXNMb2FkZXIiLCJVTlNBRkVfZ2V0SHlkcmF0aW9uRGF0YSIsInJvdXRlSWQiLCJjbGllbnRMb2FkZXIiLCJoYXNIeWRyYXRlRmFsbGJhY2siLCJIeWRyYXRlRmFsbGJhY2siLCJsb2NhdGlvbiIsImJhc2VuYW1lIiwiZXJyb3JzIiwiVU5TQUZFX2Rlc2VyaWFsaXplRXJyb3JzIiwicm91dGVyMiIsIlVOU0FGRV9jcmVhdGVSb3V0ZXIiLCJoaXN0b3J5IiwiVU5TQUZFX2NyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzIiwiVU5TQUZFX2h5ZHJhdGlvblJvdXRlUHJvcGVydGllcyIsIm1hcFJvdXRlUHJvcGVydGllcyIsIlVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMiLCJmdXR1cmUiLCJ1bnN0YWJsZV9taWRkbGV3YXJlIiwiZGF0YVN0cmF0ZWd5IiwiVU5TQUZFX2dldFR1cmJvU3RyZWFtU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3kiLCJwYXRjaFJvdXRlc09uTmF2aWdhdGlvbiIsIlVOU0FGRV9nZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uIiwicm91dGVEaXNjb3ZlcnkiLCJpbml0aWFsaXplZCIsImluaXRpYWxpemUiLCJjcmVhdGVSb3V0ZXNGb3JITVIiLCJVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dCIsIl9fcmVhY3RSb3V0ZXJEYXRhUm91dGVyIiwiY3JpdGljYWxDc3MiLCJzZXRDcml0aWNhbENzcyIsInVzZVN0YXRlIiwicHJvY2VzcyIsIl9fcmVhY3RSb3V0ZXJDbGVhckNyaXRpY2FsQ3NzIiwic2V0TG9jYXRpb24iLCJ1c2VMYXlvdXRFZmZlY3QiLCJzdWJzY3JpYmUiLCJuZXdTdGF0ZSIsIlVOU0FGRV91c2VGb2dPRldhckRpc2NvdmVyeSIsIkZyYWdtZW50IiwiVU5TQUZFX0ZyYW1ld29ya0NvbnRleHQiLCJQcm92aWRlciIsIlVOU0FGRV9SZW1peEVycm9yQm91bmRhcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/development/dom-export.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-router/dist/development/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-router/dist/development/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * react-router v7.6.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __typeError = (msg)=>{\n    throw TypeError(msg);\n};\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\nvar __accessCheck = (obj, member, msg)=>member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter)=>(__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value)=>member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n// index.ts\nvar react_router_exports = {};\n__export(react_router_exports, {\n    Await: ()=>Await,\n    BrowserRouter: ()=>BrowserRouter,\n    Form: ()=>Form,\n    HashRouter: ()=>HashRouter,\n    IDLE_BLOCKER: ()=>IDLE_BLOCKER,\n    IDLE_FETCHER: ()=>IDLE_FETCHER,\n    IDLE_NAVIGATION: ()=>IDLE_NAVIGATION,\n    Link: ()=>Link,\n    Links: ()=>Links,\n    MemoryRouter: ()=>MemoryRouter,\n    Meta: ()=>Meta,\n    NavLink: ()=>NavLink,\n    Navigate: ()=>Navigate,\n    NavigationType: ()=>Action,\n    Outlet: ()=>Outlet,\n    PrefetchPageLinks: ()=>PrefetchPageLinks,\n    Route: ()=>Route,\n    Router: ()=>Router,\n    RouterProvider: ()=>RouterProvider,\n    Routes: ()=>Routes,\n    Scripts: ()=>Scripts,\n    ScrollRestoration: ()=>ScrollRestoration,\n    ServerRouter: ()=>ServerRouter,\n    StaticRouter: ()=>StaticRouter,\n    StaticRouterProvider: ()=>StaticRouterProvider,\n    UNSAFE_DataRouterContext: ()=>DataRouterContext,\n    UNSAFE_DataRouterStateContext: ()=>DataRouterStateContext,\n    UNSAFE_ErrorResponseImpl: ()=>ErrorResponseImpl,\n    UNSAFE_FetchersContext: ()=>FetchersContext,\n    UNSAFE_FrameworkContext: ()=>FrameworkContext,\n    UNSAFE_LocationContext: ()=>LocationContext,\n    UNSAFE_NavigationContext: ()=>NavigationContext,\n    UNSAFE_RemixErrorBoundary: ()=>RemixErrorBoundary,\n    UNSAFE_RouteContext: ()=>RouteContext,\n    UNSAFE_ServerMode: ()=>ServerMode,\n    UNSAFE_SingleFetchRedirectSymbol: ()=>SingleFetchRedirectSymbol,\n    UNSAFE_ViewTransitionContext: ()=>ViewTransitionContext,\n    UNSAFE_createBrowserHistory: ()=>createBrowserHistory,\n    UNSAFE_createClientRoutes: ()=>createClientRoutes,\n    UNSAFE_createClientRoutesWithHMRRevalidationOptOut: ()=>createClientRoutesWithHMRRevalidationOptOut,\n    UNSAFE_createRouter: ()=>createRouter,\n    UNSAFE_decodeViaTurboStream: ()=>decodeViaTurboStream,\n    UNSAFE_deserializeErrors: ()=>deserializeErrors2,\n    UNSAFE_getHydrationData: ()=>getHydrationData,\n    UNSAFE_getPatchRoutesOnNavigationFunction: ()=>getPatchRoutesOnNavigationFunction,\n    UNSAFE_getTurboStreamSingleFetchDataStrategy: ()=>getTurboStreamSingleFetchDataStrategy,\n    UNSAFE_hydrationRouteProperties: ()=>hydrationRouteProperties,\n    UNSAFE_invariant: ()=>invariant,\n    UNSAFE_mapRouteProperties: ()=>mapRouteProperties,\n    UNSAFE_shouldHydrateRouteLoader: ()=>shouldHydrateRouteLoader,\n    UNSAFE_useFogOFWarDiscovery: ()=>useFogOFWarDiscovery,\n    UNSAFE_useScrollRestoration: ()=>useScrollRestoration,\n    createBrowserRouter: ()=>createBrowserRouter,\n    createCookie: ()=>createCookie,\n    createCookieSessionStorage: ()=>createCookieSessionStorage,\n    createHashRouter: ()=>createHashRouter,\n    createMemoryRouter: ()=>createMemoryRouter,\n    createMemorySessionStorage: ()=>createMemorySessionStorage,\n    createPath: ()=>createPath,\n    createRequestHandler: ()=>createRequestHandler,\n    createRoutesFromChildren: ()=>createRoutesFromChildren,\n    createRoutesFromElements: ()=>createRoutesFromElements,\n    createRoutesStub: ()=>createRoutesStub,\n    createSearchParams: ()=>createSearchParams,\n    createSession: ()=>createSession,\n    createSessionStorage: ()=>createSessionStorage,\n    createStaticHandler: ()=>createStaticHandler2,\n    createStaticRouter: ()=>createStaticRouter,\n    data: ()=>data,\n    generatePath: ()=>generatePath,\n    href: ()=>href,\n    isCookie: ()=>isCookie,\n    isRouteErrorResponse: ()=>isRouteErrorResponse,\n    isSession: ()=>isSession,\n    matchPath: ()=>matchPath,\n    matchRoutes: ()=>matchRoutes,\n    parsePath: ()=>parsePath,\n    redirect: ()=>redirect,\n    redirectDocument: ()=>redirectDocument,\n    renderMatches: ()=>renderMatches,\n    replace: ()=>replace,\n    resolvePath: ()=>resolvePath,\n    unstable_HistoryRouter: ()=>HistoryRouter,\n    unstable_RouterContextProvider: ()=>unstable_RouterContextProvider,\n    unstable_createContext: ()=>unstable_createContext,\n    unstable_setDevServerHooks: ()=>setDevServerHooks,\n    unstable_usePrompt: ()=>usePrompt,\n    useActionData: ()=>useActionData,\n    useAsyncError: ()=>useAsyncError,\n    useAsyncValue: ()=>useAsyncValue,\n    useBeforeUnload: ()=>useBeforeUnload,\n    useBlocker: ()=>useBlocker,\n    useFetcher: ()=>useFetcher,\n    useFetchers: ()=>useFetchers,\n    useFormAction: ()=>useFormAction,\n    useHref: ()=>useHref,\n    useInRouterContext: ()=>useInRouterContext,\n    useLinkClickHandler: ()=>useLinkClickHandler,\n    useLoaderData: ()=>useLoaderData,\n    useLocation: ()=>useLocation,\n    useMatch: ()=>useMatch,\n    useMatches: ()=>useMatches,\n    useNavigate: ()=>useNavigate,\n    useNavigation: ()=>useNavigation,\n    useNavigationType: ()=>useNavigationType,\n    useOutlet: ()=>useOutlet,\n    useOutletContext: ()=>useOutletContext,\n    useParams: ()=>useParams,\n    useResolvedPath: ()=>useResolvedPath,\n    useRevalidator: ()=>useRevalidator,\n    useRouteError: ()=>useRouteError,\n    useRouteLoaderData: ()=>useRouteLoaderData,\n    useRoutes: ()=>useRoutes,\n    useSearchParams: ()=>useSearchParams,\n    useSubmit: ()=>useSubmit,\n    useViewTransitionState: ()=>useViewTransitionState\n});\nmodule.exports = __toCommonJS(react_router_exports);\n// lib/router/history.ts\nvar Action = /* @__PURE__ */ ((Action2)=>{\n    Action2[\"Pop\"] = \"POP\";\n    Action2[\"Push\"] = \"PUSH\";\n    Action2[\"Replace\"] = \"REPLACE\";\n    return Action2;\n})(Action || {});\nvar PopStateEventType = \"popstate\";\nfunction createMemoryHistory(options = {}) {\n    let { initialEntries = [\n        \"/\"\n    ], initialIndex, v5Compat = false } = options;\n    let entries;\n    entries = initialEntries.map((entry, index2)=>createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index2 === 0 ? \"default\" : void 0));\n    let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n    let action = \"POP\" /* Pop */ ;\n    let listener = null;\n    function clampIndex(n) {\n        return Math.min(Math.max(n, 0), entries.length - 1);\n    }\n    function getCurrentLocation() {\n        return entries[index];\n    }\n    function createMemoryLocation(to, state = null, key) {\n        let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n        warning(location.pathname.charAt(0) === \"/\", `relative pathnames are not supported in memory history: ${JSON.stringify(to)}`);\n        return location;\n    }\n    function createHref2(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    let history = {\n        get index () {\n            return index;\n        },\n        get action () {\n            return action;\n        },\n        get location () {\n            return getCurrentLocation();\n        },\n        createHref: createHref2,\n        createURL (to) {\n            return new URL(createHref2(to), \"http://localhost\");\n        },\n        encodeLocation (to) {\n            let path = typeof to === \"string\" ? parsePath(to) : to;\n            return {\n                pathname: path.pathname || \"\",\n                search: path.search || \"\",\n                hash: path.hash || \"\"\n            };\n        },\n        push (to, state) {\n            action = \"PUSH\" /* Push */ ;\n            let nextLocation = createMemoryLocation(to, state);\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 1\n                });\n            }\n        },\n        replace (to, state) {\n            action = \"REPLACE\" /* Replace */ ;\n            let nextLocation = createMemoryLocation(to, state);\n            entries[index] = nextLocation;\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 0\n                });\n            }\n        },\n        go (delta) {\n            action = \"POP\" /* Pop */ ;\n            let nextIndex = clampIndex(index + delta);\n            let nextLocation = entries[nextIndex];\n            index = nextIndex;\n            if (listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta\n                });\n            }\n        },\n        listen (fn) {\n            listener = fn;\n            return ()=>{\n                listener = null;\n            };\n        }\n    };\n    return history;\n}\nfunction createBrowserHistory(options = {}) {\n    function createBrowserLocation(window2, globalHistory) {\n        let { pathname, search, hash } = window2.location;\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createBrowserHref(window2, to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\nfunction createHashHistory(options = {}) {\n    function createHashLocation(window2, globalHistory) {\n        let { pathname = \"/\", search = \"\", hash = \"\" } = parsePath(window2.location.hash.substring(1));\n        if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n            pathname = \"/\" + pathname;\n        }\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createHashHref(window2, to) {\n        let base = window2.document.querySelector(\"base\");\n        let href2 = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            let url = window2.location.href;\n            let hashIndex = url.indexOf(\"#\");\n            href2 = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href2 + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n    }\n    function validateHashLocation(location, to) {\n        warning(location.pathname.charAt(0) === \"/\", `relative pathnames are not supported in hash history.push(${JSON.stringify(to)})`);\n    }\n    return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        throw new Error(message);\n    }\n}\nfunction warning(cond, message) {\n    if (!cond) {\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            throw new Error(message);\n        } catch (e) {}\n    }\n}\nfunction createKey() {\n    return Math.random().toString(36).substring(2, 10);\n}\nfunction getHistoryState(location, index) {\n    return {\n        usr: location.state,\n        key: location.key,\n        idx: index\n    };\n}\nfunction createLocation(current, to, state = null, key) {\n    let location = {\n        pathname: typeof current === \"string\" ? current : current.pathname,\n        search: \"\",\n        hash: \"\",\n        ...typeof to === \"string\" ? parsePath(to) : to,\n        state,\n        // TODO: This could be cleaned up.  push/replace should probably just take\n        // full Locations now and avoid the need to run through this flow at all\n        // But that's a pretty big refactor to the current test suite so going to\n        // keep as is for the time being and just let any incoming keys take precedence\n        key: to && to.key || key || createKey()\n    };\n    return location;\n}\nfunction createPath({ pathname = \"/\", search = \"\", hash = \"\" }) {\n    if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\nfunction parsePath(path) {\n    let parsedPath = {};\n    if (path) {\n        let hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substring(hashIndex);\n            path = path.substring(0, hashIndex);\n        }\n        let searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substring(searchIndex);\n            path = path.substring(0, searchIndex);\n        }\n        if (path) {\n            parsedPath.pathname = path;\n        }\n    }\n    return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {\n    let { window: window2 = document.defaultView, v5Compat = false } = options;\n    let globalHistory = window2.history;\n    let action = \"POP\" /* Pop */ ;\n    let listener = null;\n    let index = getIndex();\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState({\n            ...globalHistory.state,\n            idx: index\n        }, \"\");\n    }\n    function getIndex() {\n        let state = globalHistory.state || {\n            idx: null\n        };\n        return state.idx;\n    }\n    function handlePop() {\n        action = \"POP\" /* Pop */ ;\n        let nextIndex = getIndex();\n        let delta = nextIndex == null ? null : nextIndex - index;\n        index = nextIndex;\n        if (listener) {\n            listener({\n                action,\n                location: history.location,\n                delta\n            });\n        }\n    }\n    function push(to, state) {\n        action = \"PUSH\" /* Push */ ;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex() + 1;\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        try {\n            globalHistory.pushState(historyState, \"\", url);\n        } catch (error) {\n            if (error instanceof DOMException && error.name === \"DataCloneError\") {\n                throw error;\n            }\n            window2.location.assign(url);\n        }\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 1\n            });\n        }\n    }\n    function replace2(to, state) {\n        action = \"REPLACE\" /* Replace */ ;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex();\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        globalHistory.replaceState(historyState, \"\", url);\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 0\n            });\n        }\n    }\n    function createURL(to) {\n        return createBrowserURLImpl(to);\n    }\n    let history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return getLocation(window2, globalHistory);\n        },\n        listen (fn) {\n            if (listener) {\n                throw new Error(\"A history only accepts one active listener\");\n            }\n            window2.addEventListener(PopStateEventType, handlePop);\n            listener = fn;\n            return ()=>{\n                window2.removeEventListener(PopStateEventType, handlePop);\n                listener = null;\n            };\n        },\n        createHref (to) {\n            return createHref2(window2, to);\n        },\n        createURL,\n        encodeLocation (to) {\n            let url = createURL(to);\n            return {\n                pathname: url.pathname,\n                search: url.search,\n                hash: url.hash\n            };\n        },\n        push,\n        replace: replace2,\n        go (n) {\n            return globalHistory.go(n);\n        }\n    };\n    return history;\n}\nfunction createBrowserURLImpl(to, isAbsolute = false) {\n    let base = \"http://localhost\";\n    if (false) {}\n    invariant(base, \"No window.location.(origin|href) available to create URL\");\n    let href2 = typeof to === \"string\" ? to : createPath(to);\n    href2 = href2.replace(/ $/, \"%20\");\n    if (!isAbsolute && href2.startsWith(\"//\")) {\n        href2 = base + href2;\n    }\n    return new URL(href2, base);\n}\n// lib/router/utils.ts\nfunction unstable_createContext(defaultValue) {\n    return {\n        defaultValue\n    };\n}\nvar _map;\nvar unstable_RouterContextProvider = class {\n    constructor(init){\n        __privateAdd(this, _map, /* @__PURE__ */ new Map());\n        if (init) {\n            for (let [context, value] of init){\n                this.set(context, value);\n            }\n        }\n    }\n    get(context) {\n        if (__privateGet(this, _map).has(context)) {\n            return __privateGet(this, _map).get(context);\n        }\n        if (context.defaultValue !== void 0) {\n            return context.defaultValue;\n        }\n        throw new Error(\"No value found for context\");\n    }\n    set(context, value) {\n        __privateGet(this, _map).set(context, value);\n    }\n};\n_map = new WeakMap();\nvar unsupportedLazyRouteObjectKeys = /* @__PURE__ */ new Set([\n    \"lazy\",\n    \"caseSensitive\",\n    \"path\",\n    \"id\",\n    \"index\",\n    \"children\"\n]);\nfunction isUnsupportedLazyRouteObjectKey(key) {\n    return unsupportedLazyRouteObjectKeys.has(key);\n}\nvar unsupportedLazyRouteFunctionKeys = /* @__PURE__ */ new Set([\n    \"lazy\",\n    \"caseSensitive\",\n    \"path\",\n    \"id\",\n    \"index\",\n    \"unstable_middleware\",\n    \"children\"\n]);\nfunction isUnsupportedLazyRouteFunctionKey(key) {\n    return unsupportedLazyRouteFunctionKeys.has(key);\n}\nfunction isIndexRoute(route) {\n    return route.index === true;\n}\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}) {\n    return routes.map((route, index)=>{\n        let treePath = [\n            ...parentPath,\n            String(index)\n        ];\n        let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n        invariant(route.index !== true || !route.children, `Cannot specify children on an index route`);\n        invariant(!manifest[id], `Found a route id collision on id \"${id}\".  Route id's must be globally unique within Data Router usages`);\n        if (isIndexRoute(route)) {\n            let indexRoute = {\n                ...route,\n                ...mapRouteProperties2(route),\n                id\n            };\n            manifest[id] = indexRoute;\n            return indexRoute;\n        } else {\n            let pathOrLayoutRoute = {\n                ...route,\n                ...mapRouteProperties2(route),\n                id,\n                children: void 0\n            };\n            manifest[id] = pathOrLayoutRoute;\n            if (route.children) {\n                pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);\n            }\n            return pathOrLayoutRoute;\n        }\n    });\n}\nfunction matchRoutes(routes, locationArg, basename = \"/\") {\n    return matchRoutesImpl(routes, locationArg, basename, false);\n}\nfunction matchRoutesImpl(routes, locationArg, basename, allowPartial) {\n    let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    let pathname = stripBasename(location.pathname || \"/\", basename);\n    if (pathname == null) {\n        return null;\n    }\n    let branches = flattenRoutes(routes);\n    rankRouteBranches(branches);\n    let matches = null;\n    for(let i = 0; matches == null && i < branches.length; ++i){\n        let decoded = decodePath(pathname);\n        matches = matchRouteBranch(branches[i], decoded, allowPartial);\n    }\n    return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n    let { route, pathname, params } = match;\n    return {\n        id: route.id,\n        pathname,\n        params,\n        data: loaderData[route.id],\n        handle: route.handle\n    };\n}\nfunction flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = \"\") {\n    let flattenRoute = (route, index, relativePath)=>{\n        let meta = {\n            relativePath: relativePath === void 0 ? route.path || \"\" : relativePath,\n            caseSensitive: route.caseSensitive === true,\n            childrenIndex: index,\n            route\n        };\n        if (meta.relativePath.startsWith(\"/\")) {\n            invariant(meta.relativePath.startsWith(parentPath), `Absolute route path \"${meta.relativePath}\" nested under path \"${parentPath}\" is not valid. An absolute child route path must start with the combined path of all its parent routes.`);\n            meta.relativePath = meta.relativePath.slice(parentPath.length);\n        }\n        let path = joinPaths([\n            parentPath,\n            meta.relativePath\n        ]);\n        let routesMeta = parentsMeta.concat(meta);\n        if (route.children && route.children.length > 0) {\n            invariant(// Our types know better, but runtime JS may not!\n            // @ts-expect-error\n            route.index !== true, `Index routes must not have child routes. Please remove all child routes from route path \"${path}\".`);\n            flattenRoutes(route.children, branches, routesMeta, path);\n        }\n        if (route.path == null && !route.index) {\n            return;\n        }\n        branches.push({\n            path,\n            score: computeScore(path, route.index),\n            routesMeta\n        });\n    };\n    routes.forEach((route, index)=>{\n        if (route.path === \"\" || !route.path?.includes(\"?\")) {\n            flattenRoute(route, index);\n        } else {\n            for (let exploded of explodeOptionalSegments(route.path)){\n                flattenRoute(route, index, exploded);\n            }\n        }\n    });\n    return branches;\n}\nfunction explodeOptionalSegments(path) {\n    let segments = path.split(\"/\");\n    if (segments.length === 0) return [];\n    let [first, ...rest] = segments;\n    let isOptional = first.endsWith(\"?\");\n    let required = first.replace(/\\?$/, \"\");\n    if (rest.length === 0) {\n        return isOptional ? [\n            required,\n            \"\"\n        ] : [\n            required\n        ];\n    }\n    let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n    let result = [];\n    result.push(...restExploded.map((subpath)=>subpath === \"\" ? required : [\n            required,\n            subpath\n        ].join(\"/\")));\n    if (isOptional) {\n        result.push(...restExploded);\n    }\n    return result.map((exploded)=>path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n    branches.sort((a, b)=>a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta)=>meta.childrenIndex), b.routesMeta.map((meta)=>meta.childrenIndex)));\n}\nvar paramRe = /^:[\\w-]+$/;\nvar dynamicSegmentValue = 3;\nvar indexRouteValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\nvar isSplat = (s)=>s === \"*\";\nfunction computeScore(path, index) {\n    let segments = path.split(\"/\");\n    let initialScore = segments.length;\n    if (segments.some(isSplat)) {\n        initialScore += splatPenalty;\n    }\n    if (index) {\n        initialScore += indexRouteValue;\n    }\n    return segments.filter((s)=>!isSplat(s)).reduce((score, segment)=>score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n    let siblings = a.length === b.length && a.slice(0, -1).every((n, i)=>n === b[i]);\n    return siblings ? // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0;\n}\nfunction matchRouteBranch(branch, pathname, allowPartial = false) {\n    let { routesMeta } = branch;\n    let matchedParams = {};\n    let matchedPathname = \"/\";\n    let matches = [];\n    for(let i = 0; i < routesMeta.length; ++i){\n        let meta = routesMeta[i];\n        let end = i === routesMeta.length - 1;\n        let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n        let match = matchPath({\n            path: meta.relativePath,\n            caseSensitive: meta.caseSensitive,\n            end\n        }, remainingPathname);\n        let route = meta.route;\n        if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {\n            match = matchPath({\n                path: meta.relativePath,\n                caseSensitive: meta.caseSensitive,\n                end: false\n            }, remainingPathname);\n        }\n        if (!match) {\n            return null;\n        }\n        Object.assign(matchedParams, match.params);\n        matches.push({\n            // TODO: Can this as be avoided?\n            params: matchedParams,\n            pathname: joinPaths([\n                matchedPathname,\n                match.pathname\n            ]),\n            pathnameBase: normalizePathname(joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ])),\n            route\n        });\n        if (match.pathnameBase !== \"/\") {\n            matchedPathname = joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ]);\n        }\n    }\n    return matches;\n}\nfunction generatePath(originalPath, params = {}) {\n    let path = originalPath;\n    if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n        warning(false, `Route path \"${path}\" will be treated as if it were \"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must always follow a \\`/\\` in the pattern. To get rid of this warning, please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`);\n        path = path.replace(/\\*$/, \"/*\");\n    }\n    const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n    const stringify2 = (p)=>p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n    const segments = path.split(/\\/+/).map((segment, index, array)=>{\n        const isLastSegment = index === array.length - 1;\n        if (isLastSegment && segment === \"*\") {\n            const star = \"*\";\n            return stringify2(params[star]);\n        }\n        const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n        if (keyMatch) {\n            const [, key, optional] = keyMatch;\n            let param = params[key];\n            invariant(optional === \"?\" || param != null, `Missing \":${key}\" param`);\n            return stringify2(param);\n        }\n        return segment.replace(/\\?$/g, \"\");\n    }).filter((segment)=>!!segment);\n    return prefix + segments.join(\"/\");\n}\nfunction matchPath(pattern, pathname) {\n    if (typeof pattern === \"string\") {\n        pattern = {\n            path: pattern,\n            caseSensitive: false,\n            end: true\n        };\n    }\n    let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n    let match = pathname.match(matcher);\n    if (!match) return null;\n    let matchedPathname = match[0];\n    let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n    let captureGroups = match.slice(1);\n    let params = compiledParams.reduce((memo2, { paramName, isOptional }, index)=>{\n        if (paramName === \"*\") {\n            let splatValue = captureGroups[index] || \"\";\n            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n        }\n        const value = captureGroups[index];\n        if (isOptional && !value) {\n            memo2[paramName] = void 0;\n        } else {\n            memo2[paramName] = (value || \"\").replace(/%2F/g, \"/\");\n        }\n        return memo2;\n    }, {});\n    return {\n        params,\n        pathname: matchedPathname,\n        pathnameBase,\n        pattern\n    };\n}\nfunction compilePath(path, caseSensitive = false, end = true) {\n    warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), `Route path \"${path}\" will be treated as if it were \"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must always follow a \\`/\\` in the pattern. To get rid of this warning, please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`);\n    let params = [];\n    let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\").replace(/^\\/*/, \"/\").replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\").replace(/\\/:([\\w-]+)(\\?)?/g, (_, paramName, isOptional)=>{\n        params.push({\n            paramName,\n            isOptional: isOptional != null\n        });\n        return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n    });\n    if (path.endsWith(\"*\")) {\n        params.push({\n            paramName: \"*\"\n        });\n        regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" : \"(?:\\\\/(.+)|\\\\/*)$\";\n    } else if (end) {\n        regexpSource += \"\\\\/*$\";\n    } else if (path !== \"\" && path !== \"/\") {\n        regexpSource += \"(?:(?=\\\\/|$))\";\n    } else {}\n    let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : \"i\");\n    return [\n        matcher,\n        params\n    ];\n}\nfunction decodePath(value) {\n    try {\n        return value.split(\"/\").map((v)=>decodeURIComponent(v).replace(/\\//g, \"%2F\")).join(\"/\");\n    } catch (error) {\n        warning(false, `The URL path \"${value}\" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`);\n        return value;\n    }\n}\nfunction stripBasename(pathname, basename) {\n    if (basename === \"/\") return pathname;\n    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n        return null;\n    }\n    let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n    let nextChar = pathname.charAt(startIndex);\n    if (nextChar && nextChar !== \"/\") {\n        return null;\n    }\n    return pathname.slice(startIndex) || \"/\";\n}\nfunction resolvePath(to, fromPathname = \"/\") {\n    let { pathname: toPathname, search = \"\", hash = \"\" } = typeof to === \"string\" ? parsePath(to) : to;\n    let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n    return {\n        pathname,\n        search: normalizeSearch(search),\n        hash: normalizeHash(hash)\n    };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n    let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n    let relativeSegments = relativePath.split(\"/\");\n    relativeSegments.forEach((segment)=>{\n        if (segment === \"..\") {\n            if (segments.length > 1) segments.pop();\n        } else if (segment !== \".\") {\n            segments.push(segment);\n        }\n    });\n    return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n    return `Cannot include a '${char}' character in a manually specified \\`to.${field}\\` field [${JSON.stringify(path)}].  Please separate it out to the \\`to.${dest}\\` field. Alternatively you may provide the full path as a string in <Link to=\"...\"> and the router will parse it for you.`;\n}\nfunction getPathContributingMatches(matches) {\n    return matches.filter((match, index)=>index === 0 || match.route.path && match.route.path.length > 0);\n}\nfunction getResolveToMatches(matches) {\n    let pathMatches = getPathContributingMatches(matches);\n    return pathMatches.map((match, idx)=>idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);\n}\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {\n    let to;\n    if (typeof toArg === \"string\") {\n        to = parsePath(toArg);\n    } else {\n        to = {\n            ...toArg\n        };\n        invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n        invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n        invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n    }\n    let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n    let toPathname = isEmptyPath ? \"/\" : to.pathname;\n    let from;\n    if (toPathname == null) {\n        from = locationPathname;\n    } else {\n        let routePathnameIndex = routePathnames.length - 1;\n        if (!isPathRelative && toPathname.startsWith(\"..\")) {\n            let toSegments = toPathname.split(\"/\");\n            while(toSegments[0] === \"..\"){\n                toSegments.shift();\n                routePathnameIndex -= 1;\n            }\n            to.pathname = toSegments.join(\"/\");\n        }\n        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n    }\n    let path = resolvePath(to, from);\n    let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n    if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n        path.pathname += \"/\";\n    }\n    return path;\n}\nvar joinPaths = (paths)=>paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\nvar normalizePathname = (pathname)=>pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\nvar normalizeSearch = (search)=>!search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\nvar normalizeHash = (hash)=>!hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\nvar DataWithResponseInit = class {\n    constructor(data2, init){\n        this.type = \"DataWithResponseInit\";\n        this.data = data2;\n        this.init = init || null;\n    }\n};\nfunction data(data2, init) {\n    return new DataWithResponseInit(data2, typeof init === \"number\" ? {\n        status: init\n    } : init);\n}\nvar redirect = (url, init = 302)=>{\n    let responseInit = init;\n    if (typeof responseInit === \"number\") {\n        responseInit = {\n            status: responseInit\n        };\n    } else if (typeof responseInit.status === \"undefined\") {\n        responseInit.status = 302;\n    }\n    let headers = new Headers(responseInit.headers);\n    headers.set(\"Location\", url);\n    return new Response(null, {\n        ...responseInit,\n        headers\n    });\n};\nvar redirectDocument = (url, init)=>{\n    let response = redirect(url, init);\n    response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n    return response;\n};\nvar replace = (url, init)=>{\n    let response = redirect(url, init);\n    response.headers.set(\"X-Remix-Replace\", \"true\");\n    return response;\n};\nvar ErrorResponseImpl = class {\n    constructor(status, statusText, data2, internal = false){\n        this.status = status;\n        this.statusText = statusText || \"\";\n        this.internal = internal;\n        if (data2 instanceof Error) {\n            this.data = data2.toString();\n            this.error = data2;\n        } else {\n            this.data = data2;\n        }\n    }\n};\nfunction isRouteErrorResponse(error) {\n    return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\n// lib/router/router.ts\nvar validMutationMethodsArr = [\n    \"POST\",\n    \"PUT\",\n    \"PATCH\",\n    \"DELETE\"\n];\nvar validMutationMethods = new Set(validMutationMethodsArr);\nvar validRequestMethodsArr = [\n    \"GET\",\n    ...validMutationMethodsArr\n];\nvar validRequestMethods = new Set(validRequestMethodsArr);\nvar redirectStatusCodes = /* @__PURE__ */ new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\nvar redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([\n    307,\n    308\n]);\nvar IDLE_NAVIGATION = {\n    state: \"idle\",\n    location: void 0,\n    formMethod: void 0,\n    formAction: void 0,\n    formEncType: void 0,\n    formData: void 0,\n    json: void 0,\n    text: void 0\n};\nvar IDLE_FETCHER = {\n    state: \"idle\",\n    data: void 0,\n    formMethod: void 0,\n    formAction: void 0,\n    formEncType: void 0,\n    formData: void 0,\n    json: void 0,\n    text: void 0\n};\nvar IDLE_BLOCKER = {\n    state: \"unblocked\",\n    proceed: void 0,\n    reset: void 0,\n    location: void 0\n};\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar defaultMapRouteProperties = (route)=>({\n        hasErrorBoundary: Boolean(route.hasErrorBoundary)\n    });\nvar TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\nvar ResetLoaderDataSymbol = Symbol(\"ResetLoaderData\");\nfunction createRouter(init) {\n    const routerWindow = init.window ? init.window :  false ? 0 : void 0;\n    const isBrowser2 = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n    invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n    let hydrationRouteProperties2 = init.hydrationRouteProperties || [];\n    let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;\n    let manifest = {};\n    let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);\n    let inFlightDataRoutes;\n    let basename = init.basename || \"/\";\n    let dataStrategyImpl = init.dataStrategy || defaultDataStrategyWithMiddleware;\n    let future = {\n        unstable_middleware: false,\n        ...init.future\n    };\n    let unlistenHistory = null;\n    let subscribers = /* @__PURE__ */ new Set();\n    let savedScrollPositions2 = null;\n    let getScrollRestorationKey2 = null;\n    let getScrollPosition = null;\n    let initialScrollRestored = init.hydrationData != null;\n    let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n    let initialMatchesIsFOW = false;\n    let initialErrors = null;\n    let initialized;\n    if (initialMatches == null && !init.patchRoutesOnNavigation) {\n        let error = getInternalRouterError(404, {\n            pathname: init.history.location.pathname\n        });\n        let { matches, route } = getShortCircuitMatches(dataRoutes);\n        initialized = true;\n        initialMatches = matches;\n        initialErrors = {\n            [route.id]: error\n        };\n    } else {\n        if (initialMatches && !init.hydrationData) {\n            let fogOfWar = checkFogOfWar(initialMatches, dataRoutes, init.history.location.pathname);\n            if (fogOfWar.active) {\n                initialMatches = null;\n            }\n        }\n        if (!initialMatches) {\n            initialized = false;\n            initialMatches = [];\n            let fogOfWar = checkFogOfWar(null, dataRoutes, init.history.location.pathname);\n            if (fogOfWar.active && fogOfWar.matches) {\n                initialMatchesIsFOW = true;\n                initialMatches = fogOfWar.matches;\n            }\n        } else if (initialMatches.some((m)=>m.route.lazy)) {\n            initialized = false;\n        } else if (!initialMatches.some((m)=>m.route.loader)) {\n            initialized = true;\n        } else {\n            let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n            let errors = init.hydrationData ? init.hydrationData.errors : null;\n            if (errors) {\n                let idx = initialMatches.findIndex((m)=>errors[m.route.id] !== void 0);\n                initialized = initialMatches.slice(0, idx + 1).every((m)=>!shouldLoadRouteOnHydration(m.route, loaderData, errors));\n            } else {\n                initialized = initialMatches.every((m)=>!shouldLoadRouteOnHydration(m.route, loaderData, errors));\n            }\n        }\n    }\n    let router;\n    let state = {\n        historyAction: init.history.action,\n        location: init.history.location,\n        matches: initialMatches,\n        initialized,\n        navigation: IDLE_NAVIGATION,\n        // Don't restore on initial updateState() if we were SSR'd\n        restoreScrollPosition: init.hydrationData != null ? false : null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n        actionData: init.hydrationData && init.hydrationData.actionData || null,\n        errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n        fetchers: /* @__PURE__ */ new Map(),\n        blockers: /* @__PURE__ */ new Map()\n    };\n    let pendingAction = \"POP\" /* Pop */ ;\n    let pendingPreventScrollReset = false;\n    let pendingNavigationController;\n    let pendingViewTransitionEnabled = false;\n    let appliedViewTransitions = /* @__PURE__ */ new Map();\n    let removePageHideEventListener = null;\n    let isUninterruptedRevalidation = false;\n    let isRevalidationRequired = false;\n    let cancelledFetcherLoads = /* @__PURE__ */ new Set();\n    let fetchControllers = /* @__PURE__ */ new Map();\n    let incrementingLoadId = 0;\n    let pendingNavigationLoadId = -1;\n    let fetchReloadIds = /* @__PURE__ */ new Map();\n    let fetchRedirectIds = /* @__PURE__ */ new Set();\n    let fetchLoadMatches = /* @__PURE__ */ new Map();\n    let activeFetchers = /* @__PURE__ */ new Map();\n    let fetchersQueuedForDeletion = /* @__PURE__ */ new Set();\n    let blockerFunctions = /* @__PURE__ */ new Map();\n    let unblockBlockerHistoryUpdate = void 0;\n    let pendingRevalidationDfd = null;\n    function initialize() {\n        unlistenHistory = init.history.listen(({ action: historyAction, location, delta })=>{\n            if (unblockBlockerHistoryUpdate) {\n                unblockBlockerHistoryUpdate();\n                unblockBlockerHistoryUpdate = void 0;\n                return;\n            }\n            warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.\");\n            let blockerKey = shouldBlockNavigation({\n                currentLocation: state.location,\n                nextLocation: location,\n                historyAction\n            });\n            if (blockerKey && delta != null) {\n                let nextHistoryUpdatePromise = new Promise((resolve)=>{\n                    unblockBlockerHistoryUpdate = resolve;\n                });\n                init.history.go(delta * -1);\n                updateBlocker(blockerKey, {\n                    state: \"blocked\",\n                    location,\n                    proceed () {\n                        updateBlocker(blockerKey, {\n                            state: \"proceeding\",\n                            proceed: void 0,\n                            reset: void 0,\n                            location\n                        });\n                        nextHistoryUpdatePromise.then(()=>init.history.go(delta));\n                    },\n                    reset () {\n                        let blockers = new Map(state.blockers);\n                        blockers.set(blockerKey, IDLE_BLOCKER);\n                        updateState({\n                            blockers\n                        });\n                    }\n                });\n                return;\n            }\n            return startNavigation(historyAction, location);\n        });\n        if (isBrowser2) {\n            restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n            let _saveAppliedTransitions = ()=>persistAppliedTransitions(routerWindow, appliedViewTransitions);\n            routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n            removePageHideEventListener = ()=>routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n        }\n        if (!state.initialized) {\n            startNavigation(\"POP\" /* Pop */ , state.location, {\n                initialHydration: true\n            });\n        }\n        return router;\n    }\n    function dispose() {\n        if (unlistenHistory) {\n            unlistenHistory();\n        }\n        if (removePageHideEventListener) {\n            removePageHideEventListener();\n        }\n        subscribers.clear();\n        pendingNavigationController && pendingNavigationController.abort();\n        state.fetchers.forEach((_, key)=>deleteFetcher(key));\n        state.blockers.forEach((_, key)=>deleteBlocker(key));\n    }\n    function subscribe(fn) {\n        subscribers.add(fn);\n        return ()=>subscribers.delete(fn);\n    }\n    function updateState(newState, opts = {}) {\n        state = {\n            ...state,\n            ...newState\n        };\n        let unmountedFetchers = [];\n        let mountedFetchers = [];\n        state.fetchers.forEach((fetcher, key)=>{\n            if (fetcher.state === \"idle\") {\n                if (fetchersQueuedForDeletion.has(key)) {\n                    unmountedFetchers.push(key);\n                } else {\n                    mountedFetchers.push(key);\n                }\n            }\n        });\n        fetchersQueuedForDeletion.forEach((key)=>{\n            if (!state.fetchers.has(key) && !fetchControllers.has(key)) {\n                unmountedFetchers.push(key);\n            }\n        });\n        [\n            ...subscribers\n        ].forEach((subscriber)=>subscriber(state, {\n                deletedFetchers: unmountedFetchers,\n                viewTransitionOpts: opts.viewTransitionOpts,\n                flushSync: opts.flushSync === true\n            }));\n        unmountedFetchers.forEach((key)=>deleteFetcher(key));\n        mountedFetchers.forEach((key)=>state.fetchers.delete(key));\n    }\n    function completeNavigation(location, newState, { flushSync } = {}) {\n        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && location.state?._isRedirect !== true;\n        let actionData;\n        if (newState.actionData) {\n            if (Object.keys(newState.actionData).length > 0) {\n                actionData = newState.actionData;\n            } else {\n                actionData = null;\n            }\n        } else if (isActionReload) {\n            actionData = state.actionData;\n        } else {\n            actionData = null;\n        }\n        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n        let blockers = state.blockers;\n        if (blockers.size > 0) {\n            blockers = new Map(blockers);\n            blockers.forEach((_, k)=>blockers.set(k, IDLE_BLOCKER));\n        }\n        let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && location.state?._isRedirect !== true;\n        if (inFlightDataRoutes) {\n            dataRoutes = inFlightDataRoutes;\n            inFlightDataRoutes = void 0;\n        }\n        if (isUninterruptedRevalidation) {} else if (pendingAction === \"POP\" /* Pop */ ) {} else if (pendingAction === \"PUSH\" /* Push */ ) {\n            init.history.push(location, location.state);\n        } else if (pendingAction === \"REPLACE\" /* Replace */ ) {\n            init.history.replace(location, location.state);\n        }\n        let viewTransitionOpts;\n        if (pendingAction === \"POP\" /* Pop */ ) {\n            let priorPaths = appliedViewTransitions.get(state.location.pathname);\n            if (priorPaths && priorPaths.has(location.pathname)) {\n                viewTransitionOpts = {\n                    currentLocation: state.location,\n                    nextLocation: location\n                };\n            } else if (appliedViewTransitions.has(location.pathname)) {\n                viewTransitionOpts = {\n                    currentLocation: location,\n                    nextLocation: state.location\n                };\n            }\n        } else if (pendingViewTransitionEnabled) {\n            let toPaths = appliedViewTransitions.get(state.location.pathname);\n            if (toPaths) {\n                toPaths.add(location.pathname);\n            } else {\n                toPaths = /* @__PURE__ */ new Set([\n                    location.pathname\n                ]);\n                appliedViewTransitions.set(state.location.pathname, toPaths);\n            }\n            viewTransitionOpts = {\n                currentLocation: state.location,\n                nextLocation: location\n            };\n        }\n        updateState({\n            ...newState,\n            // matches, errors, fetchers go through as-is\n            actionData,\n            loaderData,\n            historyAction: pendingAction,\n            location,\n            initialized: true,\n            navigation: IDLE_NAVIGATION,\n            revalidation: \"idle\",\n            restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n            preventScrollReset,\n            blockers\n        }, {\n            viewTransitionOpts,\n            flushSync: flushSync === true\n        });\n        pendingAction = \"POP\" /* Pop */ ;\n        pendingPreventScrollReset = false;\n        pendingViewTransitionEnabled = false;\n        isUninterruptedRevalidation = false;\n        isRevalidationRequired = false;\n        pendingRevalidationDfd?.resolve();\n        pendingRevalidationDfd = null;\n    }\n    async function navigate(to, opts) {\n        if (typeof to === \"number\") {\n            init.history.go(to);\n            return;\n        }\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, to, opts?.fromRouteId, opts?.relative);\n        let { path, submission, error } = normalizeNavigateOptions(false, normalizedPath, opts);\n        let currentLocation = state.location;\n        let nextLocation = createLocation(state.location, path, opts && opts.state);\n        nextLocation = {\n            ...nextLocation,\n            ...init.history.encodeLocation(nextLocation)\n        };\n        let userReplace = opts && opts.replace != null ? opts.replace : void 0;\n        let historyAction = \"PUSH\" /* Push */ ;\n        if (userReplace === true) {\n            historyAction = \"REPLACE\" /* Replace */ ;\n        } else if (userReplace === false) {} else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n            historyAction = \"REPLACE\" /* Replace */ ;\n        }\n        let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : void 0;\n        let flushSync = (opts && opts.flushSync) === true;\n        let blockerKey = shouldBlockNavigation({\n            currentLocation,\n            nextLocation,\n            historyAction\n        });\n        if (blockerKey) {\n            updateBlocker(blockerKey, {\n                state: \"blocked\",\n                location: nextLocation,\n                proceed () {\n                    updateBlocker(blockerKey, {\n                        state: \"proceeding\",\n                        proceed: void 0,\n                        reset: void 0,\n                        location: nextLocation\n                    });\n                    navigate(to, opts);\n                },\n                reset () {\n                    let blockers = new Map(state.blockers);\n                    blockers.set(blockerKey, IDLE_BLOCKER);\n                    updateState({\n                        blockers\n                    });\n                }\n            });\n            return;\n        }\n        await startNavigation(historyAction, nextLocation, {\n            submission,\n            // Send through the formData serialization error if we have one so we can\n            // render at the right error boundary after we match routes\n            pendingError: error,\n            preventScrollReset,\n            replace: opts && opts.replace,\n            enableViewTransition: opts && opts.viewTransition,\n            flushSync\n        });\n    }\n    function revalidate() {\n        if (!pendingRevalidationDfd) {\n            pendingRevalidationDfd = createDeferred();\n        }\n        interruptActiveLoads();\n        updateState({\n            revalidation: \"loading\"\n        });\n        let promise = pendingRevalidationDfd.promise;\n        if (state.navigation.state === \"submitting\") {\n            return promise;\n        }\n        if (state.navigation.state === \"idle\") {\n            startNavigation(state.historyAction, state.location, {\n                startUninterruptedRevalidation: true\n            });\n            return promise;\n        }\n        startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n            overrideNavigation: state.navigation,\n            // Proxy through any rending view transition\n            enableViewTransition: pendingViewTransitionEnabled === true\n        });\n        return promise;\n    }\n    async function startNavigation(historyAction, location, opts) {\n        pendingNavigationController && pendingNavigationController.abort();\n        pendingNavigationController = null;\n        pendingAction = historyAction;\n        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n        saveScrollPosition(state.location, state.matches);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let loadingNavigation = opts && opts.overrideNavigation;\n        let matches = opts?.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? // `matchRoutes()` has already been called if we're in here via `router.initialize()`\n        state.matches : matchRoutes(routesToUse, location, basename);\n        let flushSync = (opts && opts.flushSync) === true;\n        if (matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n            completeNavigation(location, {\n                matches\n            }, {\n                flushSync\n            });\n            return;\n        }\n        let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);\n        if (fogOfWar.active && fogOfWar.matches) {\n            matches = fogOfWar.matches;\n        }\n        if (!matches) {\n            let { error, notFoundMatches, route } = handleNavigational404(location.pathname);\n            completeNavigation(location, {\n                matches: notFoundMatches,\n                loaderData: {},\n                errors: {\n                    [route.id]: error\n                }\n            }, {\n                flushSync\n            });\n            return;\n        }\n        pendingNavigationController = new AbortController();\n        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n        let scopedContext = new unstable_RouterContextProvider(init.unstable_getContext ? await init.unstable_getContext() : void 0);\n        let pendingActionResult;\n        if (opts && opts.pendingError) {\n            pendingActionResult = [\n                findNearestBoundary(matches).route.id,\n                {\n                    type: \"error\" /* error */ ,\n                    error: opts.pendingError\n                }\n            ];\n        } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n            let actionResult = await handleAction(request, location, opts.submission, matches, scopedContext, fogOfWar.active, opts && opts.initialHydration === true, {\n                replace: opts.replace,\n                flushSync\n            });\n            if (actionResult.shortCircuited) {\n                return;\n            }\n            if (actionResult.pendingActionResult) {\n                let [routeId, result] = actionResult.pendingActionResult;\n                if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {\n                    pendingNavigationController = null;\n                    completeNavigation(location, {\n                        matches: actionResult.matches,\n                        loaderData: {},\n                        errors: {\n                            [routeId]: result.error\n                        }\n                    });\n                    return;\n                }\n            }\n            matches = actionResult.matches || matches;\n            pendingActionResult = actionResult.pendingActionResult;\n            loadingNavigation = getLoadingNavigation(location, opts.submission);\n            flushSync = false;\n            fogOfWar.active = false;\n            request = createClientSideRequest(init.history, request.url, request.signal);\n        }\n        let { shortCircuited, matches: updatedMatches, loaderData, errors } = await handleLoaders(request, location, matches, scopedContext, fogOfWar.active, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionResult);\n        if (shortCircuited) {\n            return;\n        }\n        pendingNavigationController = null;\n        completeNavigation(location, {\n            matches: updatedMatches || matches,\n            ...getActionDataForCommit(pendingActionResult),\n            loaderData,\n            errors\n        });\n    }\n    async function handleAction(request, location, submission, matches, scopedContext, isFogOfWar, initialHydration, opts = {}) {\n        interruptActiveLoads();\n        let navigation = getSubmittingNavigation(location, submission);\n        updateState({\n            navigation\n        }, {\n            flushSync: opts.flushSync === true\n        });\n        if (isFogOfWar) {\n            let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);\n            if (discoverResult.type === \"aborted\") {\n                return {\n                    shortCircuited: true\n                };\n            } else if (discoverResult.type === \"error\") {\n                let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n                return {\n                    matches: discoverResult.partialMatches,\n                    pendingActionResult: [\n                        boundaryId,\n                        {\n                            type: \"error\" /* error */ ,\n                            error: discoverResult.error\n                        }\n                    ]\n                };\n            } else if (!discoverResult.matches) {\n                let { notFoundMatches, error, route } = handleNavigational404(location.pathname);\n                return {\n                    matches: notFoundMatches,\n                    pendingActionResult: [\n                        route.id,\n                        {\n                            type: \"error\" /* error */ ,\n                            error\n                        }\n                    ]\n                };\n            } else {\n                matches = discoverResult.matches;\n            }\n        }\n        let result;\n        let actionMatch = getTargetMatch(matches, location);\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            result = {\n                type: \"error\" /* error */ ,\n                error: getInternalRouterError(405, {\n                    method: request.method,\n                    pathname: location.pathname,\n                    routeId: actionMatch.route.id\n                })\n            };\n        } else {\n            let dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, actionMatch, initialHydration ? [] : hydrationRouteProperties2, scopedContext);\n            let results = await callDataStrategy(request, dsMatches, scopedContext, null);\n            result = results[actionMatch.route.id];\n            if (!result) {\n                for (let match of matches){\n                    if (results[match.route.id]) {\n                        result = results[match.route.id];\n                        break;\n                    }\n                }\n            }\n            if (request.signal.aborted) {\n                return {\n                    shortCircuited: true\n                };\n            }\n        }\n        if (isRedirectResult(result)) {\n            let replace2;\n            if (opts && opts.replace != null) {\n                replace2 = opts.replace;\n            } else {\n                let location2 = normalizeRedirectLocation(result.response.headers.get(\"Location\"), new URL(request.url), basename);\n                replace2 = location2 === state.location.pathname + state.location.search;\n            }\n            await startRedirectNavigation(request, result, true, {\n                submission,\n                replace: replace2\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        if (isErrorResult(result)) {\n            let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            if ((opts && opts.replace) !== true) {\n                pendingAction = \"PUSH\" /* Push */ ;\n            }\n            return {\n                matches,\n                pendingActionResult: [\n                    boundaryMatch.route.id,\n                    result,\n                    actionMatch.route.id\n                ]\n            };\n        }\n        return {\n            matches,\n            pendingActionResult: [\n                actionMatch.route.id,\n                result\n            ]\n        };\n    }\n    async function handleLoaders(request, location, matches, scopedContext, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {\n        let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n        let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n        let shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration;\n        if (isFogOfWar) {\n            if (shouldUpdateNavigationState) {\n                let actionData = getUpdatedActionData(pendingActionResult);\n                updateState({\n                    navigation: loadingNavigation,\n                    ...actionData !== void 0 ? {\n                        actionData\n                    } : {}\n                }, {\n                    flushSync\n                });\n            }\n            let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);\n            if (discoverResult.type === \"aborted\") {\n                return {\n                    shortCircuited: true\n                };\n            } else if (discoverResult.type === \"error\") {\n                let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n                return {\n                    matches: discoverResult.partialMatches,\n                    loaderData: {},\n                    errors: {\n                        [boundaryId]: discoverResult.error\n                    }\n                };\n            } else if (!discoverResult.matches) {\n                let { error, notFoundMatches, route } = handleNavigational404(location.pathname);\n                return {\n                    matches: notFoundMatches,\n                    loaderData: {},\n                    errors: {\n                        [route.id]: error\n                    }\n                };\n            } else {\n                matches = discoverResult.matches;\n            }\n        }\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let { dsMatches, revalidatingFetchers } = getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, init.history, state, matches, activeSubmission, location, initialHydration ? [] : hydrationRouteProperties2, initialHydration === true, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, init.patchRoutesOnNavigation != null, pendingActionResult);\n        pendingNavigationLoadId = ++incrementingLoadId;\n        if (!init.dataStrategy && !dsMatches.some((m)=>m.shouldLoad) && revalidatingFetchers.length === 0) {\n            let updatedFetchers2 = markFetchRedirectsDone();\n            completeNavigation(location, {\n                matches,\n                loaderData: {},\n                // Commit pending error if we're short circuiting\n                errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\n                    [pendingActionResult[0]]: pendingActionResult[1].error\n                } : null,\n                ...getActionDataForCommit(pendingActionResult),\n                ...updatedFetchers2 ? {\n                    fetchers: new Map(state.fetchers)\n                } : {}\n            }, {\n                flushSync\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        if (shouldUpdateNavigationState) {\n            let updates = {};\n            if (!isFogOfWar) {\n                updates.navigation = loadingNavigation;\n                let actionData = getUpdatedActionData(pendingActionResult);\n                if (actionData !== void 0) {\n                    updates.actionData = actionData;\n                }\n            }\n            if (revalidatingFetchers.length > 0) {\n                updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);\n            }\n            updateState(updates, {\n                flushSync\n            });\n        }\n        revalidatingFetchers.forEach((rf)=>{\n            abortFetcher(rf.key);\n            if (rf.controller) {\n                fetchControllers.set(rf.key, rf.controller);\n            }\n        });\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((f)=>abortFetcher(f.key));\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(dsMatches, revalidatingFetchers, request, scopedContext);\n        if (request.signal.aborted) {\n            return {\n                shortCircuited: true\n            };\n        }\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        revalidatingFetchers.forEach((rf)=>fetchControllers.delete(rf.key));\n        let redirect2 = findRedirect(loaderResults);\n        if (redirect2) {\n            await startRedirectNavigation(request, redirect2.result, true, {\n                replace: replace2\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        redirect2 = findRedirect(fetcherResults);\n        if (redirect2) {\n            fetchRedirectIds.add(redirect2.key);\n            await startRedirectNavigation(request, redirect2.result, true, {\n                replace: replace2\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        let { loaderData, errors } = processLoaderData(state, matches, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults);\n        if (initialHydration && state.errors) {\n            errors = {\n                ...state.errors,\n                ...errors\n            };\n        }\n        let updatedFetchers = markFetchRedirectsDone();\n        let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n        let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n        return {\n            matches,\n            loaderData,\n            errors,\n            ...shouldUpdateFetchers ? {\n                fetchers: new Map(state.fetchers)\n            } : {}\n        };\n    }\n    function getUpdatedActionData(pendingActionResult) {\n        if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {\n            return {\n                [pendingActionResult[0]]: pendingActionResult[1].data\n            };\n        } else if (state.actionData) {\n            if (Object.keys(state.actionData).length === 0) {\n                return null;\n            } else {\n                return state.actionData;\n            }\n        }\n    }\n    function getUpdatedRevalidatingFetchers(revalidatingFetchers) {\n        revalidatingFetchers.forEach((rf)=>{\n            let fetcher = state.fetchers.get(rf.key);\n            let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);\n            state.fetchers.set(rf.key, revalidatingFetcher);\n        });\n        return new Map(state.fetchers);\n    }\n    async function fetch2(key, routeId, href2, opts) {\n        abortFetcher(key);\n        let flushSync = (opts && opts.flushSync) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, href2, routeId, opts?.relative);\n        let matches = matchRoutes(routesToUse, normalizedPath, basename);\n        let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);\n        if (fogOfWar.active && fogOfWar.matches) {\n            matches = fogOfWar.matches;\n        }\n        if (!matches) {\n            setFetcherError(key, routeId, getInternalRouterError(404, {\n                pathname: normalizedPath\n            }), {\n                flushSync\n            });\n            return;\n        }\n        let { path, submission, error } = normalizeNavigateOptions(true, normalizedPath, opts);\n        if (error) {\n            setFetcherError(key, routeId, error, {\n                flushSync\n            });\n            return;\n        }\n        let match = getTargetMatch(matches, path);\n        let scopedContext = new unstable_RouterContextProvider(init.unstable_getContext ? await init.unstable_getContext() : void 0);\n        let preventScrollReset = (opts && opts.preventScrollReset) === true;\n        if (submission && isMutationMethod(submission.formMethod)) {\n            await handleFetcherAction(key, routeId, path, match, matches, scopedContext, fogOfWar.active, flushSync, preventScrollReset, submission);\n            return;\n        }\n        fetchLoadMatches.set(key, {\n            routeId,\n            path\n        });\n        await handleFetcherLoader(key, routeId, path, match, matches, scopedContext, fogOfWar.active, flushSync, preventScrollReset, submission);\n    }\n    async function handleFetcherAction(key, routeId, path, match, requestMatches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {\n        interruptActiveLoads();\n        fetchLoadMatches.delete(key);\n        function detectAndHandle405Error(m) {\n            if (!m.route.action && !m.route.lazy) {\n                let error = getInternalRouterError(405, {\n                    method: submission.formMethod,\n                    pathname: path,\n                    routeId\n                });\n                setFetcherError(key, routeId, error, {\n                    flushSync\n                });\n                return true;\n            }\n            return false;\n        }\n        if (!isFogOfWar && detectAndHandle405Error(match)) {\n            return;\n        }\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n            flushSync\n        });\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n        if (isFogOfWar) {\n            let discoverResult = await discoverRoutes(requestMatches, path, fetchRequest.signal, key);\n            if (discoverResult.type === \"aborted\") {\n                return;\n            } else if (discoverResult.type === \"error\") {\n                setFetcherError(key, routeId, discoverResult.error, {\n                    flushSync\n                });\n                return;\n            } else if (!discoverResult.matches) {\n                setFetcherError(key, routeId, getInternalRouterError(404, {\n                    pathname: path\n                }), {\n                    flushSync\n                });\n                return;\n            } else {\n                requestMatches = discoverResult.matches;\n                match = getTargetMatch(requestMatches, path);\n                if (detectAndHandle405Error(match)) {\n                    return;\n                }\n            }\n        }\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let fetchMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, requestMatches, match, hydrationRouteProperties2, scopedContext);\n        let actionResults = await callDataStrategy(fetchRequest, fetchMatches, scopedContext, key);\n        let actionResult = actionResults[match.route.id];\n        if (fetchRequest.signal.aborted) {\n            if (fetchControllers.get(key) === abortController) {\n                fetchControllers.delete(key);\n            }\n            return;\n        }\n        if (fetchersQueuedForDeletion.has(key)) {\n            if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n                updateFetcherState(key, getDoneFetcher(void 0));\n                return;\n            }\n        } else {\n            if (isRedirectResult(actionResult)) {\n                fetchControllers.delete(key);\n                if (pendingNavigationLoadId > originatingLoadId) {\n                    updateFetcherState(key, getDoneFetcher(void 0));\n                    return;\n                } else {\n                    fetchRedirectIds.add(key);\n                    updateFetcherState(key, getLoadingFetcher(submission));\n                    return startRedirectNavigation(fetchRequest, actionResult, false, {\n                        fetcherSubmission: submission,\n                        preventScrollReset\n                    });\n                }\n            }\n            if (isErrorResult(actionResult)) {\n                setFetcherError(key, routeId, actionResult.error);\n                return;\n            }\n        }\n        let nextLocation = state.navigation.location || state.location;\n        let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n        invariant(matches, \"Didn't find any matches after fetcher action\");\n        let loadId = ++incrementingLoadId;\n        fetchReloadIds.set(key, loadId);\n        let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n        state.fetchers.set(key, loadFetcher);\n        let { dsMatches, revalidatingFetchers } = getMatchesToLoad(revalidationRequest, scopedContext, mapRouteProperties2, manifest, init.history, state, matches, submission, nextLocation, hydrationRouteProperties2, false, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, init.patchRoutesOnNavigation != null, [\n            match.route.id,\n            actionResult\n        ]);\n        revalidatingFetchers.filter((rf)=>rf.key !== key).forEach((rf)=>{\n            let staleKey = rf.key;\n            let existingFetcher2 = state.fetchers.get(staleKey);\n            let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);\n            state.fetchers.set(staleKey, revalidatingFetcher);\n            abortFetcher(staleKey);\n            if (rf.controller) {\n                fetchControllers.set(staleKey, rf.controller);\n            }\n        });\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((rf)=>abortFetcher(rf.key));\n        abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(dsMatches, revalidatingFetchers, revalidationRequest, scopedContext);\n        if (abortController.signal.aborted) {\n            return;\n        }\n        abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        fetchReloadIds.delete(key);\n        fetchControllers.delete(key);\n        revalidatingFetchers.forEach((r)=>fetchControllers.delete(r.key));\n        if (state.fetchers.has(key)) {\n            let doneFetcher = getDoneFetcher(actionResult.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n        let redirect2 = findRedirect(loaderResults);\n        if (redirect2) {\n            return startRedirectNavigation(revalidationRequest, redirect2.result, false, {\n                preventScrollReset\n            });\n        }\n        redirect2 = findRedirect(fetcherResults);\n        if (redirect2) {\n            fetchRedirectIds.add(redirect2.key);\n            return startRedirectNavigation(revalidationRequest, redirect2.result, false, {\n                preventScrollReset\n            });\n        }\n        let { loaderData, errors } = processLoaderData(state, matches, loaderResults, void 0, revalidatingFetchers, fetcherResults);\n        abortStaleFetchLoads(loadId);\n        if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n            invariant(pendingAction, \"Expected pending action\");\n            pendingNavigationController && pendingNavigationController.abort();\n            completeNavigation(state.navigation.location, {\n                matches,\n                loaderData,\n                errors,\n                fetchers: new Map(state.fetchers)\n            });\n        } else {\n            updateState({\n                errors,\n                loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n                fetchers: new Map(state.fetchers)\n            });\n            isRevalidationRequired = false;\n        }\n    }\n    async function handleFetcherLoader(key, routeId, path, match, matches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {\n            flushSync\n        });\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n        if (isFogOfWar) {\n            let discoverResult = await discoverRoutes(matches, path, fetchRequest.signal, key);\n            if (discoverResult.type === \"aborted\") {\n                return;\n            } else if (discoverResult.type === \"error\") {\n                setFetcherError(key, routeId, discoverResult.error, {\n                    flushSync\n                });\n                return;\n            } else if (!discoverResult.matches) {\n                setFetcherError(key, routeId, getInternalRouterError(404, {\n                    pathname: path\n                }), {\n                    flushSync\n                });\n                return;\n            } else {\n                matches = discoverResult.matches;\n                match = getTargetMatch(matches, path);\n            }\n        }\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, matches, match, hydrationRouteProperties2, scopedContext);\n        let results = await callDataStrategy(fetchRequest, dsMatches, scopedContext, key);\n        let result = results[match.route.id];\n        if (fetchControllers.get(key) === abortController) {\n            fetchControllers.delete(key);\n        }\n        if (fetchRequest.signal.aborted) {\n            return;\n        }\n        if (fetchersQueuedForDeletion.has(key)) {\n            updateFetcherState(key, getDoneFetcher(void 0));\n            return;\n        }\n        if (isRedirectResult(result)) {\n            if (pendingNavigationLoadId > originatingLoadId) {\n                updateFetcherState(key, getDoneFetcher(void 0));\n                return;\n            } else {\n                fetchRedirectIds.add(key);\n                await startRedirectNavigation(fetchRequest, result, false, {\n                    preventScrollReset\n                });\n                return;\n            }\n        }\n        if (isErrorResult(result)) {\n            setFetcherError(key, routeId, result.error);\n            return;\n        }\n        updateFetcherState(key, getDoneFetcher(result.data));\n    }\n    async function startRedirectNavigation(request, redirect2, isNavigation, { submission, fetcherSubmission, preventScrollReset, replace: replace2 } = {}) {\n        if (redirect2.response.headers.has(\"X-Remix-Revalidate\")) {\n            isRevalidationRequired = true;\n        }\n        let location = redirect2.response.headers.get(\"Location\");\n        invariant(location, \"Expected a Location header on the redirect Response\");\n        location = normalizeRedirectLocation(location, new URL(request.url), basename);\n        let redirectLocation = createLocation(state.location, location, {\n            _isRedirect: true\n        });\n        if (isBrowser2) {\n            let isDocumentReload = false;\n            if (redirect2.response.headers.has(\"X-Remix-Reload-Document\")) {\n                isDocumentReload = true;\n            } else if (ABSOLUTE_URL_REGEX.test(location)) {\n                const url = createBrowserURLImpl(location, true);\n                isDocumentReload = url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n                stripBasename(url.pathname, basename) == null;\n            }\n            if (isDocumentReload) {\n                if (replace2) {\n                    routerWindow.location.replace(location);\n                } else {\n                    routerWindow.location.assign(location);\n                }\n                return;\n            }\n        }\n        pendingNavigationController = null;\n        let redirectNavigationType = replace2 === true || redirect2.response.headers.has(\"X-Remix-Replace\") ? \"REPLACE\" /* Replace */  : \"PUSH\" /* Push */ ;\n        let { formMethod, formAction, formEncType } = state.navigation;\n        if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n            submission = getSubmissionFromNavigation(state.navigation);\n        }\n        let activeSubmission = submission || fetcherSubmission;\n        if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n            await startNavigation(redirectNavigationType, redirectLocation, {\n                submission: {\n                    ...activeSubmission,\n                    formAction: location\n                },\n                // Preserve these flags across redirects\n                preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n                enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0\n            });\n        } else {\n            let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n            await startNavigation(redirectNavigationType, redirectLocation, {\n                overrideNavigation,\n                // Send fetcher submissions through for shouldRevalidate\n                fetcherSubmission,\n                // Preserve these flags across redirects\n                preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n                enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0\n            });\n        }\n    }\n    async function callDataStrategy(request, matches, scopedContext, fetcherKey) {\n        let results;\n        let dataResults = {};\n        try {\n            results = await callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, false);\n        } catch (e) {\n            matches.filter((m)=>m.shouldLoad).forEach((m)=>{\n                dataResults[m.route.id] = {\n                    type: \"error\" /* error */ ,\n                    error: e\n                };\n            });\n            return dataResults;\n        }\n        if (request.signal.aborted) {\n            return dataResults;\n        }\n        for (let [routeId, result] of Object.entries(results)){\n            if (isRedirectDataStrategyResult(result)) {\n                let response = result.result;\n                dataResults[routeId] = {\n                    type: \"redirect\" /* redirect */ ,\n                    response: normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename)\n                };\n            } else {\n                dataResults[routeId] = await convertDataStrategyResultToDataResult(result);\n            }\n        }\n        return dataResults;\n    }\n    async function callLoadersAndMaybeResolveData(matches, fetchersToLoad, request, scopedContext) {\n        let loaderResultsPromise = callDataStrategy(request, matches, scopedContext, null);\n        let fetcherResultsPromise = Promise.all(fetchersToLoad.map(async (f)=>{\n            if (f.matches && f.match && f.request && f.controller) {\n                let results = await callDataStrategy(f.request, f.matches, scopedContext, f.key);\n                let result = results[f.match.route.id];\n                return {\n                    [f.key]: result\n                };\n            } else {\n                return Promise.resolve({\n                    [f.key]: {\n                        type: \"error\" /* error */ ,\n                        error: getInternalRouterError(404, {\n                            pathname: f.path\n                        })\n                    }\n                });\n            }\n        }));\n        let loaderResults = await loaderResultsPromise;\n        let fetcherResults = (await fetcherResultsPromise).reduce((acc, r)=>Object.assign(acc, r), {});\n        return {\n            loaderResults,\n            fetcherResults\n        };\n    }\n    function interruptActiveLoads() {\n        isRevalidationRequired = true;\n        fetchLoadMatches.forEach((_, key)=>{\n            if (fetchControllers.has(key)) {\n                cancelledFetcherLoads.add(key);\n            }\n            abortFetcher(key);\n        });\n    }\n    function updateFetcherState(key, fetcher, opts = {}) {\n        state.fetchers.set(key, fetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function setFetcherError(key, routeId, error, opts = {}) {\n        let boundaryMatch = findNearestBoundary(state.matches, routeId);\n        deleteFetcher(key);\n        updateState({\n            errors: {\n                [boundaryMatch.route.id]: error\n            },\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function getFetcher(key) {\n        activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n        if (fetchersQueuedForDeletion.has(key)) {\n            fetchersQueuedForDeletion.delete(key);\n        }\n        return state.fetchers.get(key) || IDLE_FETCHER;\n    }\n    function deleteFetcher(key) {\n        let fetcher = state.fetchers.get(key);\n        if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n            abortFetcher(key);\n        }\n        fetchLoadMatches.delete(key);\n        fetchReloadIds.delete(key);\n        fetchRedirectIds.delete(key);\n        fetchersQueuedForDeletion.delete(key);\n        cancelledFetcherLoads.delete(key);\n        state.fetchers.delete(key);\n    }\n    function queueFetcherForDeletion(key) {\n        let count = (activeFetchers.get(key) || 0) - 1;\n        if (count <= 0) {\n            activeFetchers.delete(key);\n            fetchersQueuedForDeletion.add(key);\n        } else {\n            activeFetchers.set(key, count);\n        }\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n    }\n    function abortFetcher(key) {\n        let controller = fetchControllers.get(key);\n        if (controller) {\n            controller.abort();\n            fetchControllers.delete(key);\n        }\n    }\n    function markFetchersDone(keys) {\n        for (let key of keys){\n            let fetcher = getFetcher(key);\n            let doneFetcher = getDoneFetcher(fetcher.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    function markFetchRedirectsDone() {\n        let doneKeys = [];\n        let updatedFetchers = false;\n        for (let key of fetchRedirectIds){\n            let fetcher = state.fetchers.get(key);\n            invariant(fetcher, `Expected fetcher: ${key}`);\n            if (fetcher.state === \"loading\") {\n                fetchRedirectIds.delete(key);\n                doneKeys.push(key);\n                updatedFetchers = true;\n            }\n        }\n        markFetchersDone(doneKeys);\n        return updatedFetchers;\n    }\n    function abortStaleFetchLoads(landedId) {\n        let yeetedKeys = [];\n        for (let [key, id] of fetchReloadIds){\n            if (id < landedId) {\n                let fetcher = state.fetchers.get(key);\n                invariant(fetcher, `Expected fetcher: ${key}`);\n                if (fetcher.state === \"loading\") {\n                    abortFetcher(key);\n                    fetchReloadIds.delete(key);\n                    yeetedKeys.push(key);\n                }\n            }\n        }\n        markFetchersDone(yeetedKeys);\n        return yeetedKeys.length > 0;\n    }\n    function getBlocker(key, fn) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        if (blockerFunctions.get(key) !== fn) {\n            blockerFunctions.set(key, fn);\n        }\n        return blocker;\n    }\n    function deleteBlocker(key) {\n        state.blockers.delete(key);\n        blockerFunctions.delete(key);\n    }\n    function updateBlocker(key, newBlocker) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`);\n        let blockers = new Map(state.blockers);\n        blockers.set(key, newBlocker);\n        updateState({\n            blockers\n        });\n    }\n    function shouldBlockNavigation({ currentLocation, nextLocation, historyAction }) {\n        if (blockerFunctions.size === 0) {\n            return;\n        }\n        if (blockerFunctions.size > 1) {\n            warning(false, \"A router only supports one blocker at a time\");\n        }\n        let entries = Array.from(blockerFunctions.entries());\n        let [blockerKey, blockerFunction] = entries[entries.length - 1];\n        let blocker = state.blockers.get(blockerKey);\n        if (blocker && blocker.state === \"proceeding\") {\n            return;\n        }\n        if (blockerFunction({\n            currentLocation,\n            nextLocation,\n            historyAction\n        })) {\n            return blockerKey;\n        }\n    }\n    function handleNavigational404(pathname) {\n        let error = getInternalRouterError(404, {\n            pathname\n        });\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let { matches, route } = getShortCircuitMatches(routesToUse);\n        return {\n            notFoundMatches: matches,\n            route,\n            error\n        };\n    }\n    function enableScrollRestoration(positions, getPosition, getKey) {\n        savedScrollPositions2 = positions;\n        getScrollPosition = getPosition;\n        getScrollRestorationKey2 = getKey || null;\n        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n            initialScrollRestored = true;\n            let y = getSavedScrollPosition(state.location, state.matches);\n            if (y != null) {\n                updateState({\n                    restoreScrollPosition: y\n                });\n            }\n        }\n        return ()=>{\n            savedScrollPositions2 = null;\n            getScrollPosition = null;\n            getScrollRestorationKey2 = null;\n        };\n    }\n    function getScrollKey(location, matches) {\n        if (getScrollRestorationKey2) {\n            let key = getScrollRestorationKey2(location, matches.map((m)=>convertRouteMatchToUiMatch(m, state.loaderData)));\n            return key || location.key;\n        }\n        return location.key;\n    }\n    function saveScrollPosition(location, matches) {\n        if (savedScrollPositions2 && getScrollPosition) {\n            let key = getScrollKey(location, matches);\n            savedScrollPositions2[key] = getScrollPosition();\n        }\n    }\n    function getSavedScrollPosition(location, matches) {\n        if (savedScrollPositions2) {\n            let key = getScrollKey(location, matches);\n            let y = savedScrollPositions2[key];\n            if (typeof y === \"number\") {\n                return y;\n            }\n        }\n        return null;\n    }\n    function checkFogOfWar(matches, routesToUse, pathname) {\n        if (init.patchRoutesOnNavigation) {\n            if (!matches) {\n                let fogMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\n                return {\n                    active: true,\n                    matches: fogMatches || []\n                };\n            } else {\n                if (Object.keys(matches[0].params).length > 0) {\n                    let partialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\n                    return {\n                        active: true,\n                        matches: partialMatches\n                    };\n                }\n            }\n        }\n        return {\n            active: false,\n            matches: null\n        };\n    }\n    async function discoverRoutes(matches, pathname, signal, fetcherKey) {\n        if (!init.patchRoutesOnNavigation) {\n            return {\n                type: \"success\",\n                matches\n            };\n        }\n        let partialMatches = matches;\n        while(true){\n            let isNonHMR = inFlightDataRoutes == null;\n            let routesToUse = inFlightDataRoutes || dataRoutes;\n            let localManifest = manifest;\n            try {\n                await init.patchRoutesOnNavigation({\n                    signal,\n                    path: pathname,\n                    matches: partialMatches,\n                    fetcherKey,\n                    patch: (routeId, children)=>{\n                        if (signal.aborted) return;\n                        patchRoutesImpl(routeId, children, routesToUse, localManifest, mapRouteProperties2);\n                    }\n                });\n            } catch (e) {\n                return {\n                    type: \"error\",\n                    error: e,\n                    partialMatches\n                };\n            } finally{\n                if (isNonHMR && !signal.aborted) {\n                    dataRoutes = [\n                        ...dataRoutes\n                    ];\n                }\n            }\n            if (signal.aborted) {\n                return {\n                    type: \"aborted\"\n                };\n            }\n            let newMatches = matchRoutes(routesToUse, pathname, basename);\n            if (newMatches) {\n                return {\n                    type: \"success\",\n                    matches: newMatches\n                };\n            }\n            let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\n            if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every((m, i)=>m.route.id === newPartialMatches[i].route.id)) {\n                return {\n                    type: \"success\",\n                    matches: null\n                };\n            }\n            partialMatches = newPartialMatches;\n        }\n    }\n    function _internalSetRoutes(newRoutes) {\n        manifest = {};\n        inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);\n    }\n    function patchRoutes(routeId, children) {\n        let isNonHMR = inFlightDataRoutes == null;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2);\n        if (isNonHMR) {\n            dataRoutes = [\n                ...dataRoutes\n            ];\n            updateState({});\n        }\n    }\n    router = {\n        get basename () {\n            return basename;\n        },\n        get future () {\n            return future;\n        },\n        get state () {\n            return state;\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        get window () {\n            return routerWindow;\n        },\n        initialize,\n        subscribe,\n        enableScrollRestoration,\n        navigate,\n        fetch: fetch2,\n        revalidate,\n        // Passthrough to history-aware createHref used by useHref so we get proper\n        // hash-aware URLs in DOM paths\n        createHref: (to)=>init.history.createHref(to),\n        encodeLocation: (to)=>init.history.encodeLocation(to),\n        getFetcher,\n        deleteFetcher: queueFetcherForDeletion,\n        dispose,\n        getBlocker,\n        deleteBlocker,\n        patchRoutes,\n        _internalFetchControllers: fetchControllers,\n        // TODO: Remove setRoutes, it's temporary to avoid dealing with\n        // updating the tree while validating the update algorithm.\n        _internalSetRoutes\n    };\n    return router;\n}\nfunction createStaticHandler(routes, opts) {\n    invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n    let manifest = {};\n    let basename = (opts ? opts.basename : null) || \"/\";\n    let mapRouteProperties2 = opts?.mapRouteProperties || defaultMapRouteProperties;\n    let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties2, void 0, manifest);\n    async function query(request, { requestContext, filterMatchesToLoad, skipLoaderErrorBubbling, skipRevalidation, dataStrategy, unstable_respond: respond } = {}) {\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();\n        if (!isValidMethod(method) && method !== \"HEAD\") {\n            let error = getInternalRouterError(405, {\n                method\n            });\n            let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);\n            let staticContext = {\n                basename,\n                location,\n                matches: methodNotAllowedMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {}\n            };\n            return respond ? respond(staticContext) : staticContext;\n        } else if (!matches) {\n            let error = getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);\n            let staticContext = {\n                basename,\n                location,\n                matches: notFoundMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {}\n            };\n            return respond ? respond(staticContext) : staticContext;\n        }\n        if (respond && matches.some((m)=>m.route.unstable_middleware || typeof m.route.lazy === \"object\" && m.route.lazy.unstable_middleware)) {\n            invariant(requestContext instanceof unstable_RouterContextProvider, \"When using middleware in `staticHandler.query()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`\");\n            try {\n                await loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2);\n                let renderedStaticContext;\n                let response = await runMiddlewarePipeline({\n                    request,\n                    matches,\n                    params: matches[0].params,\n                    // If we're calling middleware then it must be enabled so we can cast\n                    // this to the proper type knowing it's not an `AppLoadContext`\n                    context: requestContext\n                }, true, async ()=>{\n                    let result2 = await queryImpl(request, location, matches, requestContext, dataStrategy || null, skipLoaderErrorBubbling === true, null, filterMatchesToLoad || null, skipRevalidation === true);\n                    if (isResponse(result2)) {\n                        return result2;\n                    }\n                    renderedStaticContext = {\n                        location,\n                        basename,\n                        ...result2\n                    };\n                    let res = await respond(renderedStaticContext);\n                    return res;\n                }, async (error, routeId)=>{\n                    if (isResponse(error)) {\n                        return error;\n                    }\n                    if (renderedStaticContext) {\n                        if (routeId in renderedStaticContext.loaderData) {\n                            renderedStaticContext.loaderData[routeId] = void 0;\n                        }\n                        return respond(getStaticContextFromError(dataRoutes, renderedStaticContext, error, skipLoaderErrorBubbling ? routeId : findNearestBoundary(matches, routeId).route.id));\n                    } else {\n                        let boundaryRouteId = skipLoaderErrorBubbling ? routeId : findNearestBoundary(matches, matches.find((m)=>m.route.id === routeId || m.route.loader)?.route.id || routeId).route.id;\n                        return respond({\n                            matches,\n                            location,\n                            basename,\n                            loaderData: {},\n                            actionData: null,\n                            errors: {\n                                [boundaryRouteId]: error\n                            },\n                            statusCode: isRouteErrorResponse(error) ? error.status : 500,\n                            actionHeaders: {},\n                            loaderHeaders: {}\n                        });\n                    }\n                });\n                invariant(isResponse(response), \"Expected a response in query()\");\n                return response;\n            } catch (e) {\n                if (isResponse(e)) {\n                    return e;\n                }\n                throw e;\n            }\n        }\n        let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, skipLoaderErrorBubbling === true, null, filterMatchesToLoad || null, skipRevalidation === true);\n        if (isResponse(result)) {\n            return result;\n        }\n        return {\n            location,\n            basename,\n            ...result\n        };\n    }\n    async function queryRoute(request, { routeId, requestContext, dataStrategy, unstable_respond: respond } = {}) {\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();\n        if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n            throw getInternalRouterError(405, {\n                method\n            });\n        } else if (!matches) {\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        let match = routeId ? matches.find((m)=>m.route.id === routeId) : getTargetMatch(matches, location);\n        if (routeId && !match) {\n            throw getInternalRouterError(403, {\n                pathname: location.pathname,\n                routeId\n            });\n        } else if (!match) {\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        if (respond && matches.some((m)=>m.route.unstable_middleware || typeof m.route.lazy === \"object\" && m.route.lazy.unstable_middleware)) {\n            invariant(requestContext instanceof unstable_RouterContextProvider, \"When using middleware in `staticHandler.queryRoute()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`\");\n            await loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2);\n            let response = await runMiddlewarePipeline({\n                request,\n                matches,\n                params: matches[0].params,\n                // If we're calling middleware then it must be enabled so we can cast\n                // this to the proper type knowing it's not an `AppLoadContext`\n                context: requestContext\n            }, true, async ()=>{\n                let result2 = await queryImpl(request, location, matches, requestContext, dataStrategy || null, false, match, null, false);\n                if (isResponse(result2)) {\n                    return respond(result2);\n                }\n                let error2 = result2.errors ? Object.values(result2.errors)[0] : void 0;\n                if (error2 !== void 0) {\n                    throw error2;\n                }\n                let value = result2.actionData ? Object.values(result2.actionData)[0] : Object.values(result2.loaderData)[0];\n                return typeof value === \"string\" ? new Response(value) : Response.json(value);\n            }, (error2)=>{\n                if (isResponse(error2)) {\n                    return respond(error2);\n                }\n                return new Response(String(error2), {\n                    status: 500,\n                    statusText: \"Unexpected Server Error\"\n                });\n            });\n            return response;\n        }\n        let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, false, match, null, false);\n        if (isResponse(result)) {\n            return result;\n        }\n        let error = result.errors ? Object.values(result.errors)[0] : void 0;\n        if (error !== void 0) {\n            throw error;\n        }\n        if (result.actionData) {\n            return Object.values(result.actionData)[0];\n        }\n        if (result.loaderData) {\n            return Object.values(result.loaderData)[0];\n        }\n        return void 0;\n    }\n    async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, skipRevalidation) {\n        invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n        try {\n            if (isMutationMethod(request.method)) {\n                let result2 = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch != null, filterMatchesToLoad, skipRevalidation);\n                return result2;\n            }\n            let result = await loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad);\n            return isResponse(result) ? result : {\n                ...result,\n                actionData: null,\n                actionHeaders: {}\n            };\n        } catch (e) {\n            if (isDataStrategyResult(e) && isResponse(e.result)) {\n                if (e.type === \"error\" /* error */ ) {\n                    throw e.result;\n                }\n                return e.result;\n            }\n            if (isRedirectResponse(e)) {\n                return e;\n            }\n            throw e;\n        }\n    }\n    async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest, filterMatchesToLoad, skipRevalidation) {\n        let result;\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            let error = getInternalRouterError(405, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: actionMatch.route.id\n            });\n            if (isRouteRequest) {\n                throw error;\n            }\n            result = {\n                type: \"error\" /* error */ ,\n                error\n            };\n        } else {\n            let dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, actionMatch, [], requestContext);\n            let results = await callDataStrategy(request, dsMatches, isRouteRequest, requestContext, dataStrategy);\n            result = results[actionMatch.route.id];\n            if (request.signal.aborted) {\n                throwStaticHandlerAbortedError(request, isRouteRequest);\n            }\n        }\n        if (isRedirectResult(result)) {\n            throw new Response(null, {\n                status: result.response.status,\n                headers: {\n                    Location: result.response.headers.get(\"Location\")\n                }\n            });\n        }\n        if (isRouteRequest) {\n            if (isErrorResult(result)) {\n                throw result.error;\n            }\n            return {\n                matches: [\n                    actionMatch\n                ],\n                loaderData: {},\n                actionData: {\n                    [actionMatch.route.id]: result.data\n                },\n                errors: null,\n                // Note: statusCode + headers are unused here since queryRoute will\n                // return the raw Response or value\n                statusCode: 200,\n                loaderHeaders: {},\n                actionHeaders: {}\n            };\n        }\n        if (skipRevalidation) {\n            if (isErrorResult(result)) {\n                let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\n                return {\n                    statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\n                    actionData: null,\n                    actionHeaders: {\n                        ...result.headers ? {\n                            [actionMatch.route.id]: result.headers\n                        } : {}\n                    },\n                    matches,\n                    loaderData: {},\n                    errors: {\n                        [boundaryMatch.route.id]: result.error\n                    },\n                    loaderHeaders: {}\n                };\n            } else {\n                return {\n                    actionData: {\n                        [actionMatch.route.id]: result.data\n                    },\n                    actionHeaders: result.headers ? {\n                        [actionMatch.route.id]: result.headers\n                    } : {},\n                    matches,\n                    loaderData: {},\n                    errors: null,\n                    statusCode: result.statusCode || 200,\n                    loaderHeaders: {}\n                };\n            }\n        }\n        let loaderRequest = new Request(request.url, {\n            headers: request.headers,\n            redirect: request.redirect,\n            signal: request.signal\n        });\n        if (isErrorResult(result)) {\n            let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\n            let handlerContext2 = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null, filterMatchesToLoad, [\n                boundaryMatch.route.id,\n                result\n            ]);\n            return {\n                ...handlerContext2,\n                statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\n                actionData: null,\n                actionHeaders: {\n                    ...result.headers ? {\n                        [actionMatch.route.id]: result.headers\n                    } : {}\n                }\n            };\n        }\n        let handlerContext = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null, filterMatchesToLoad);\n        return {\n            ...handlerContext,\n            actionData: {\n                [actionMatch.route.id]: result.data\n            },\n            // action status codes take precedence over loader status codes\n            ...result.statusCode ? {\n                statusCode: result.statusCode\n            } : {},\n            actionHeaders: result.headers ? {\n                [actionMatch.route.id]: result.headers\n            } : {}\n        };\n    }\n    async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, pendingActionResult) {\n        let isRouteRequest = routeMatch != null;\n        if (isRouteRequest && !routeMatch?.route.loader && !routeMatch?.route.lazy) {\n            throw getInternalRouterError(400, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: routeMatch?.route.id\n            });\n        }\n        let dsMatches;\n        if (routeMatch) {\n            dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, routeMatch, [], requestContext);\n        } else {\n            let maxIdx = pendingActionResult && isErrorResult(pendingActionResult[1]) ? // Up to but not including the boundary\n            matches.findIndex((m)=>m.route.id === pendingActionResult[0]) - 1 : void 0;\n            dsMatches = matches.map((match, index)=>{\n                if (maxIdx != null && index > maxIdx) {\n                    return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, [], requestContext, false);\n                }\n                return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, [], requestContext, (match.route.loader || match.route.lazy) != null && (!filterMatchesToLoad || filterMatchesToLoad(match)));\n            });\n        }\n        if (!dataStrategy && !dsMatches.some((m)=>m.shouldLoad)) {\n            return {\n                matches,\n                loaderData: {},\n                errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\n                    [pendingActionResult[0]]: pendingActionResult[1].error\n                } : null,\n                statusCode: 200,\n                loaderHeaders: {}\n            };\n        }\n        let results = await callDataStrategy(request, dsMatches, isRouteRequest, requestContext, dataStrategy);\n        if (request.signal.aborted) {\n            throwStaticHandlerAbortedError(request, isRouteRequest);\n        }\n        let handlerContext = processRouteLoaderData(matches, results, pendingActionResult, true, skipLoaderErrorBubbling);\n        return {\n            ...handlerContext,\n            matches\n        };\n    }\n    async function callDataStrategy(request, matches, isRouteRequest, requestContext, dataStrategy) {\n        let results = await callDataStrategyImpl(dataStrategy || defaultDataStrategy, request, matches, null, requestContext, true);\n        let dataResults = {};\n        await Promise.all(matches.map(async (match)=>{\n            if (!(match.route.id in results)) {\n                return;\n            }\n            let result = results[match.route.id];\n            if (isRedirectDataStrategyResult(result)) {\n                let response = result.result;\n                throw normalizeRelativeRoutingRedirectResponse(response, request, match.route.id, matches, basename);\n            }\n            if (isResponse(result.result) && isRouteRequest) {\n                throw result;\n            }\n            dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);\n        }));\n        return dataResults;\n    }\n    return {\n        dataRoutes,\n        query,\n        queryRoute\n    };\n}\nfunction getStaticContextFromError(routes, handlerContext, error, boundaryId) {\n    let errorBoundaryId = boundaryId || handlerContext._deepestRenderedBoundaryId || routes[0].id;\n    return {\n        ...handlerContext,\n        statusCode: isRouteErrorResponse(error) ? error.status : 500,\n        errors: {\n            [errorBoundaryId]: error\n        }\n    };\n}\nfunction throwStaticHandlerAbortedError(request, isRouteRequest) {\n    if (request.signal.reason !== void 0) {\n        throw request.signal.reason;\n    }\n    let method = isRouteRequest ? \"queryRoute\" : \"query\";\n    throw new Error(`${method}() call aborted without an \\`AbortSignal.reason\\`: ${request.method} ${request.url}`);\n}\nfunction isSubmissionNavigation(opts) {\n    return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== void 0);\n}\nfunction normalizeTo(location, matches, basename, to, fromRouteId, relative) {\n    let contextualMatches;\n    let activeRouteMatch;\n    if (fromRouteId) {\n        contextualMatches = [];\n        for (let match of matches){\n            contextualMatches.push(match);\n            if (match.route.id === fromRouteId) {\n                activeRouteMatch = match;\n                break;\n            }\n        }\n    } else {\n        contextualMatches = matches;\n        activeRouteMatch = matches[matches.length - 1];\n    }\n    let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n    if (to == null) {\n        path.search = location.search;\n        path.hash = location.hash;\n    }\n    if ((to == null || to === \"\" || to === \".\") && activeRouteMatch) {\n        let nakedIndex = hasNakedIndexQuery(path.search);\n        if (activeRouteMatch.route.index && !nakedIndex) {\n            path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n        } else if (!activeRouteMatch.route.index && nakedIndex) {\n            let params = new URLSearchParams(path.search);\n            let indexValues = params.getAll(\"index\");\n            params.delete(\"index\");\n            indexValues.filter((v)=>v).forEach((v)=>params.append(\"index\", v));\n            let qs = params.toString();\n            path.search = qs ? `?${qs}` : \"\";\n        }\n    }\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n            basename,\n            path.pathname\n        ]);\n    }\n    return createPath(path);\n}\nfunction normalizeNavigateOptions(isFetcher, path, opts) {\n    if (!opts || !isSubmissionNavigation(opts)) {\n        return {\n            path\n        };\n    }\n    if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n        return {\n            path,\n            error: getInternalRouterError(405, {\n                method: opts.formMethod\n            })\n        };\n    }\n    let getInvalidBodyError = ()=>({\n            path,\n            error: getInternalRouterError(400, {\n                type: \"invalid-body\"\n            })\n        });\n    let rawFormMethod = opts.formMethod || \"get\";\n    let formMethod = rawFormMethod.toUpperCase();\n    let formAction = stripHashFromPath(path);\n    if (opts.body !== void 0) {\n        if (opts.formEncType === \"text/plain\") {\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce((acc, [name, value])=>`${acc}${name}=${value}\n`, \"\") : String(opts.body);\n            return {\n                path,\n                submission: {\n                    formMethod,\n                    formAction,\n                    formEncType: opts.formEncType,\n                    formData: void 0,\n                    json: void 0,\n                    text\n                }\n            };\n        } else if (opts.formEncType === \"application/json\") {\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            try {\n                let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n                return {\n                    path,\n                    submission: {\n                        formMethod,\n                        formAction,\n                        formEncType: opts.formEncType,\n                        formData: void 0,\n                        json,\n                        text: void 0\n                    }\n                };\n            } catch (e) {\n                return getInvalidBodyError();\n            }\n        }\n    }\n    invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n    let searchParams;\n    let formData;\n    if (opts.formData) {\n        searchParams = convertFormDataToSearchParams(opts.formData);\n        formData = opts.formData;\n    } else if (opts.body instanceof FormData) {\n        searchParams = convertFormDataToSearchParams(opts.body);\n        formData = opts.body;\n    } else if (opts.body instanceof URLSearchParams) {\n        searchParams = opts.body;\n        formData = convertSearchParamsToFormData(searchParams);\n    } else if (opts.body == null) {\n        searchParams = new URLSearchParams();\n        formData = new FormData();\n    } else {\n        try {\n            searchParams = new URLSearchParams(opts.body);\n            formData = convertSearchParamsToFormData(searchParams);\n        } catch (e) {\n            return getInvalidBodyError();\n        }\n    }\n    let submission = {\n        formMethod,\n        formAction,\n        formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n        formData,\n        json: void 0,\n        text: void 0\n    };\n    if (isMutationMethod(submission.formMethod)) {\n        return {\n            path,\n            submission\n        };\n    }\n    let parsedPath = parsePath(path);\n    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n        searchParams.append(\"index\", \"\");\n    }\n    parsedPath.search = `?${searchParams}`;\n    return {\n        path: createPath(parsedPath),\n        submission\n    };\n}\nfunction getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, history, state, matches, submission, location, lazyRoutePropertiesToSkip, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, hasPatchRoutesOnNavigation, pendingActionResult) {\n    let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;\n    let currentUrl = history.createURL(state.location);\n    let nextUrl = history.createURL(location);\n    let maxIdx;\n    if (initialHydration && state.errors) {\n        let boundaryId = Object.keys(state.errors)[0];\n        maxIdx = matches.findIndex((m)=>m.route.id === boundaryId);\n    } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {\n        let boundaryId = pendingActionResult[0];\n        maxIdx = matches.findIndex((m)=>m.route.id === boundaryId) - 1;\n    }\n    let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;\n    let shouldSkipRevalidation = actionStatus && actionStatus >= 400;\n    let baseShouldRevalidateArgs = {\n        currentUrl,\n        currentParams: state.matches[0]?.params || {},\n        nextUrl,\n        nextParams: matches[0].params,\n        ...submission,\n        actionResult,\n        actionStatus\n    };\n    let dsMatches = matches.map((match, index)=>{\n        let { route } = match;\n        let forceShouldLoad = null;\n        if (maxIdx != null && index > maxIdx) {\n            forceShouldLoad = false;\n        } else if (route.lazy) {\n            forceShouldLoad = true;\n        } else if (route.loader == null) {\n            forceShouldLoad = false;\n        } else if (initialHydration) {\n            forceShouldLoad = shouldLoadRouteOnHydration(route, state.loaderData, state.errors);\n        } else if (isNewLoader(state.loaderData, state.matches[index], match)) {\n            forceShouldLoad = true;\n        }\n        if (forceShouldLoad !== null) {\n            return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, forceShouldLoad);\n        }\n        let defaultShouldRevalidate = shouldSkipRevalidation ? false : // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n        isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n        currentUrl.search !== nextUrl.search || isNewRouteInstance(state.matches[index], match);\n        let shouldRevalidateArgs = {\n            ...baseShouldRevalidateArgs,\n            defaultShouldRevalidate\n        };\n        let shouldLoad = shouldRevalidateLoader(match, shouldRevalidateArgs);\n        return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, shouldRevalidateArgs);\n    });\n    let revalidatingFetchers = [];\n    fetchLoadMatches.forEach((f, key)=>{\n        if (initialHydration || !matches.some((m)=>m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {\n            return;\n        }\n        let fetcher = state.fetchers.get(key);\n        let isMidInitialLoad = fetcher && fetcher.state !== \"idle\" && fetcher.data === void 0;\n        let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n        if (!fetcherMatches) {\n            if (hasPatchRoutesOnNavigation && isMidInitialLoad) {\n                return;\n            }\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: null,\n                match: null,\n                request: null,\n                controller: null\n            });\n            return;\n        }\n        if (fetchRedirectIds.has(key)) {\n            return;\n        }\n        let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n        let fetchController = new AbortController();\n        let fetchRequest = createClientSideRequest(history, f.path, fetchController.signal);\n        let fetcherDsMatches = null;\n        if (cancelledFetcherLoads.has(key)) {\n            cancelledFetcherLoads.delete(key);\n            fetcherDsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, fetcherMatches, fetcherMatch, lazyRoutePropertiesToSkip, scopedContext);\n        } else if (isMidInitialLoad) {\n            if (isRevalidationRequired) {\n                fetcherDsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, fetcherMatches, fetcherMatch, lazyRoutePropertiesToSkip, scopedContext);\n            }\n        } else {\n            let shouldRevalidateArgs = {\n                ...baseShouldRevalidateArgs,\n                defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired\n            };\n            if (shouldRevalidateLoader(fetcherMatch, shouldRevalidateArgs)) {\n                fetcherDsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, fetcherMatches, fetcherMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs);\n            }\n        }\n        if (fetcherDsMatches) {\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: fetcherDsMatches,\n                match: fetcherMatch,\n                request: fetchRequest,\n                controller: fetchController\n            });\n        }\n    });\n    return {\n        dsMatches,\n        revalidatingFetchers\n    };\n}\nfunction shouldLoadRouteOnHydration(route, loaderData, errors) {\n    if (route.lazy) {\n        return true;\n    }\n    if (!route.loader) {\n        return false;\n    }\n    let hasData = loaderData != null && route.id in loaderData;\n    let hasError = errors != null && errors[route.id] !== void 0;\n    if (!hasData && hasError) {\n        return false;\n    }\n    if (typeof route.loader === \"function\" && route.loader.hydrate === true) {\n        return true;\n    }\n    return !hasData && !hasError;\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n    let isNew = // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n    let isMissingData = !currentLoaderData.hasOwnProperty(match.route.id);\n    return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n    let currentPath = currentMatch.route.path;\n    return(// param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]);\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n    if (loaderMatch.route.shouldRevalidate) {\n        let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n        if (typeof routeChoice === \"boolean\") {\n            return routeChoice;\n        }\n    }\n    return arg.defaultShouldRevalidate;\n}\nfunction patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {\n    let childrenToPatch;\n    if (routeId) {\n        let route = manifest[routeId];\n        invariant(route, `No route found to patch children into: routeId = ${routeId}`);\n        if (!route.children) {\n            route.children = [];\n        }\n        childrenToPatch = route.children;\n    } else {\n        childrenToPatch = routesToUse;\n    }\n    let uniqueChildren = children.filter((newRoute)=>!childrenToPatch.some((existingRoute)=>isSameRoute(newRoute, existingRoute)));\n    let newRoutes = convertRoutesToDataRoutes(uniqueChildren, mapRouteProperties2, [\n        routeId || \"_\",\n        \"patch\",\n        String(childrenToPatch?.length || \"0\")\n    ], manifest);\n    childrenToPatch.push(...newRoutes);\n}\nfunction isSameRoute(newRoute, existingRoute) {\n    if (\"id\" in newRoute && \"id\" in existingRoute && newRoute.id === existingRoute.id) {\n        return true;\n    }\n    if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {\n        return false;\n    }\n    if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {\n        return true;\n    }\n    return newRoute.children.every((aChild, i)=>existingRoute.children?.some((bChild)=>isSameRoute(aChild, bChild)));\n}\nvar lazyRoutePropertyCache = /* @__PURE__ */ new WeakMap();\nvar loadLazyRouteProperty = ({ key, route, manifest, mapRouteProperties: mapRouteProperties2 })=>{\n    let routeToUpdate = manifest[route.id];\n    invariant(routeToUpdate, \"No route found in manifest\");\n    if (!routeToUpdate.lazy || typeof routeToUpdate.lazy !== \"object\") {\n        return;\n    }\n    let lazyFn = routeToUpdate.lazy[key];\n    if (!lazyFn) {\n        return;\n    }\n    let cache = lazyRoutePropertyCache.get(routeToUpdate);\n    if (!cache) {\n        cache = {};\n        lazyRoutePropertyCache.set(routeToUpdate, cache);\n    }\n    let cachedPromise = cache[key];\n    if (cachedPromise) {\n        return cachedPromise;\n    }\n    let propertyPromise = (async ()=>{\n        let isUnsupported = isUnsupportedLazyRouteObjectKey(key);\n        let staticRouteValue = routeToUpdate[key];\n        let isStaticallyDefined = staticRouteValue !== void 0 && key !== \"hasErrorBoundary\";\n        if (isUnsupported) {\n            warning(!isUnsupported, \"Route property \" + key + \" is not a supported lazy route property. This property will be ignored.\");\n            cache[key] = Promise.resolve();\n        } else if (isStaticallyDefined) {\n            warning(false, `Route \"${routeToUpdate.id}\" has a static property \"${key}\" defined. The lazy property will be ignored.`);\n        } else {\n            let value = await lazyFn();\n            if (value != null) {\n                Object.assign(routeToUpdate, {\n                    [key]: value\n                });\n                Object.assign(routeToUpdate, mapRouteProperties2(routeToUpdate));\n            }\n        }\n        if (typeof routeToUpdate.lazy === \"object\") {\n            routeToUpdate.lazy[key] = void 0;\n            if (Object.values(routeToUpdate.lazy).every((value)=>value === void 0)) {\n                routeToUpdate.lazy = void 0;\n            }\n        }\n    })();\n    cache[key] = propertyPromise;\n    return propertyPromise;\n};\nvar lazyRouteFunctionCache = /* @__PURE__ */ new WeakMap();\nfunction loadLazyRoute(route, type, manifest, mapRouteProperties2, lazyRoutePropertiesToSkip) {\n    let routeToUpdate = manifest[route.id];\n    invariant(routeToUpdate, \"No route found in manifest\");\n    if (!route.lazy) {\n        return {\n            lazyRoutePromise: void 0,\n            lazyHandlerPromise: void 0\n        };\n    }\n    if (typeof route.lazy === \"function\") {\n        let cachedPromise = lazyRouteFunctionCache.get(routeToUpdate);\n        if (cachedPromise) {\n            return {\n                lazyRoutePromise: cachedPromise,\n                lazyHandlerPromise: cachedPromise\n            };\n        }\n        let lazyRoutePromise2 = (async ()=>{\n            invariant(typeof route.lazy === \"function\", \"No lazy route function found\");\n            let lazyRoute = await route.lazy();\n            let routeUpdates = {};\n            for(let lazyRouteProperty in lazyRoute){\n                let lazyValue = lazyRoute[lazyRouteProperty];\n                if (lazyValue === void 0) {\n                    continue;\n                }\n                let isUnsupported = isUnsupportedLazyRouteFunctionKey(lazyRouteProperty);\n                let staticRouteValue = routeToUpdate[lazyRouteProperty];\n                let isStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based\n                // on the route updates\n                lazyRouteProperty !== \"hasErrorBoundary\";\n                if (isUnsupported) {\n                    warning(!isUnsupported, \"Route property \" + lazyRouteProperty + \" is not a supported property to be returned from a lazy route function. This property will be ignored.\");\n                } else if (isStaticallyDefined) {\n                    warning(!isStaticallyDefined, `Route \"${routeToUpdate.id}\" has a static property \"${lazyRouteProperty}\" defined but its lazy function is also returning a value for this property. The lazy route property \"${lazyRouteProperty}\" will be ignored.`);\n                } else {\n                    routeUpdates[lazyRouteProperty] = lazyValue;\n                }\n            }\n            Object.assign(routeToUpdate, routeUpdates);\n            Object.assign(routeToUpdate, {\n                // To keep things framework agnostic, we use the provided `mapRouteProperties`\n                // function to set the framework-aware properties (`element`/`hasErrorBoundary`)\n                // since the logic will differ between frameworks.\n                ...mapRouteProperties2(routeToUpdate),\n                lazy: void 0\n            });\n        })();\n        lazyRouteFunctionCache.set(routeToUpdate, lazyRoutePromise2);\n        lazyRoutePromise2.catch(()=>{});\n        return {\n            lazyRoutePromise: lazyRoutePromise2,\n            lazyHandlerPromise: lazyRoutePromise2\n        };\n    }\n    let lazyKeys = Object.keys(route.lazy);\n    let lazyPropertyPromises = [];\n    let lazyHandlerPromise = void 0;\n    for (let key of lazyKeys){\n        if (lazyRoutePropertiesToSkip && lazyRoutePropertiesToSkip.includes(key)) {\n            continue;\n        }\n        let promise = loadLazyRouteProperty({\n            key,\n            route,\n            manifest,\n            mapRouteProperties: mapRouteProperties2\n        });\n        if (promise) {\n            lazyPropertyPromises.push(promise);\n            if (key === type) {\n                lazyHandlerPromise = promise;\n            }\n        }\n    }\n    let lazyRoutePromise = lazyPropertyPromises.length > 0 ? Promise.all(lazyPropertyPromises).then(()=>{}) : void 0;\n    lazyRoutePromise?.catch(()=>{});\n    lazyHandlerPromise?.catch(()=>{});\n    return {\n        lazyRoutePromise,\n        lazyHandlerPromise\n    };\n}\nfunction isNonNullable(value) {\n    return value !== void 0;\n}\nfunction loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2) {\n    let promises = matches.map(({ route })=>{\n        if (typeof route.lazy !== \"object\" || !route.lazy.unstable_middleware) {\n            return void 0;\n        }\n        return loadLazyRouteProperty({\n            key: \"unstable_middleware\",\n            route,\n            manifest,\n            mapRouteProperties: mapRouteProperties2\n        });\n    }).filter(isNonNullable);\n    return promises.length > 0 ? Promise.all(promises) : void 0;\n}\nasync function defaultDataStrategy(args) {\n    let matchesToLoad = args.matches.filter((m)=>m.shouldLoad);\n    let keyedResults = {};\n    let results = await Promise.all(matchesToLoad.map((m)=>m.resolve()));\n    results.forEach((result, i)=>{\n        keyedResults[matchesToLoad[i].route.id] = result;\n    });\n    return keyedResults;\n}\nasync function defaultDataStrategyWithMiddleware(args) {\n    if (!args.matches.some((m)=>m.route.unstable_middleware)) {\n        return defaultDataStrategy(args);\n    }\n    return runMiddlewarePipeline(args, false, ()=>defaultDataStrategy(args), (error, routeId)=>({\n            [routeId]: {\n                type: \"error\",\n                result: error\n            }\n        }));\n}\nasync function runMiddlewarePipeline(args, propagateResult, handler, errorHandler) {\n    let { matches, request, params, context } = args;\n    let middlewareState = {\n        handlerResult: void 0\n    };\n    try {\n        let tuples = matches.flatMap((m)=>m.route.unstable_middleware ? m.route.unstable_middleware.map((fn)=>[\n                    m.route.id,\n                    fn\n                ]) : []);\n        let result = await callRouteMiddleware({\n            request,\n            params,\n            context\n        }, tuples, propagateResult, middlewareState, handler);\n        return propagateResult ? result : middlewareState.handlerResult;\n    } catch (e) {\n        if (!middlewareState.middlewareError) {\n            throw e;\n        }\n        let result = await errorHandler(middlewareState.middlewareError.error, middlewareState.middlewareError.routeId);\n        if (propagateResult || !middlewareState.handlerResult) {\n            return result;\n        }\n        return Object.assign(middlewareState.handlerResult, result);\n    }\n}\nasync function callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx = 0) {\n    let { request } = args;\n    if (request.signal.aborted) {\n        if (request.signal.reason) {\n            throw request.signal.reason;\n        }\n        throw new Error(`Request aborted without an \\`AbortSignal.reason\\`: ${request.method} ${request.url}`);\n    }\n    let tuple = middlewares[idx];\n    if (!tuple) {\n        middlewareState.handlerResult = await handler();\n        return middlewareState.handlerResult;\n    }\n    let [routeId, middleware] = tuple;\n    let nextCalled = false;\n    let nextResult = void 0;\n    let next = async ()=>{\n        if (nextCalled) {\n            throw new Error(\"You may only call `next()` once per middleware\");\n        }\n        nextCalled = true;\n        let result = await callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx + 1);\n        if (propagateResult) {\n            nextResult = result;\n            return nextResult;\n        }\n    };\n    try {\n        let result = await middleware({\n            request: args.request,\n            params: args.params,\n            context: args.context\n        }, next);\n        if (nextCalled) {\n            if (result === void 0) {\n                return nextResult;\n            } else {\n                return result;\n            }\n        } else {\n            return next();\n        }\n    } catch (error) {\n        if (!middlewareState.middlewareError) {\n            middlewareState.middlewareError = {\n                routeId,\n                error\n            };\n        } else if (middlewareState.middlewareError.error !== error) {\n            middlewareState.middlewareError = {\n                routeId,\n                error\n            };\n        }\n        throw error;\n    }\n}\nfunction getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip) {\n    let lazyMiddlewarePromise = loadLazyRouteProperty({\n        key: \"unstable_middleware\",\n        route: match.route,\n        manifest,\n        mapRouteProperties: mapRouteProperties2\n    });\n    let lazyRoutePromises = loadLazyRoute(match.route, isMutationMethod(request.method) ? \"action\" : \"loader\", manifest, mapRouteProperties2, lazyRoutePropertiesToSkip);\n    return {\n        middleware: lazyMiddlewarePromise,\n        route: lazyRoutePromises.lazyRoutePromise,\n        handler: lazyRoutePromises.lazyHandlerPromise\n    };\n}\nfunction getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, unstable_shouldRevalidateArgs = null) {\n    let isUsingNewApi = false;\n    let _lazyPromises = getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip);\n    return {\n        ...match,\n        _lazyPromises,\n        shouldLoad,\n        unstable_shouldRevalidateArgs,\n        unstable_shouldCallHandler (defaultShouldRevalidate) {\n            isUsingNewApi = true;\n            if (!unstable_shouldRevalidateArgs) {\n                return shouldLoad;\n            }\n            if (typeof defaultShouldRevalidate === \"boolean\") {\n                return shouldRevalidateLoader(match, {\n                    ...unstable_shouldRevalidateArgs,\n                    defaultShouldRevalidate\n                });\n            }\n            return shouldRevalidateLoader(match, unstable_shouldRevalidateArgs);\n        },\n        resolve (handlerOverride) {\n            if (isUsingNewApi || shouldLoad || handlerOverride && request.method === \"GET\" && (match.route.lazy || match.route.loader)) {\n                return callLoaderOrAction({\n                    request,\n                    match,\n                    lazyHandlerPromise: _lazyPromises?.handler,\n                    lazyRoutePromise: _lazyPromises?.route,\n                    handlerOverride,\n                    scopedContext\n                });\n            }\n            return Promise.resolve({\n                type: \"data\" /* data */ ,\n                result: void 0\n            });\n        }\n    };\n}\nfunction getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, targetMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs = null) {\n    return matches.map((match)=>{\n        if (match.route.id !== targetMatch.route.id) {\n            return {\n                ...match,\n                shouldLoad: false,\n                unstable_shouldRevalidateArgs: shouldRevalidateArgs,\n                unstable_shouldCallHandler: ()=>false,\n                _lazyPromises: getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip),\n                resolve: ()=>Promise.resolve({\n                        type: \"data\",\n                        result: void 0\n                    })\n            };\n        }\n        return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, true, shouldRevalidateArgs);\n    });\n}\nasync function callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, isStaticHandler) {\n    if (matches.some((m)=>m._lazyPromises?.middleware)) {\n        await Promise.all(matches.map((m)=>m._lazyPromises?.middleware));\n    }\n    let dataStrategyArgs = {\n        request,\n        params: matches[0].params,\n        context: scopedContext,\n        matches\n    };\n    let unstable_runClientMiddleware = isStaticHandler ? ()=>{\n        throw new Error(\"You cannot call `unstable_runClientMiddleware()` from a static handler `dataStrategy`. Middleware is run outside of `dataStrategy` during SSR in order to bubble up the Response.  You can enable middleware via the `respond` API in `query`/`queryRoute`\");\n    } : (cb)=>{\n        let typedDataStrategyArgs = dataStrategyArgs;\n        return runMiddlewarePipeline(typedDataStrategyArgs, false, ()=>cb({\n                ...typedDataStrategyArgs,\n                fetcherKey,\n                unstable_runClientMiddleware: ()=>{\n                    throw new Error(\"Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler\");\n                }\n            }), (error, routeId)=>({\n                [routeId]: {\n                    type: \"error\",\n                    result: error\n                }\n            }));\n    };\n    let results = await dataStrategyImpl({\n        ...dataStrategyArgs,\n        fetcherKey,\n        unstable_runClientMiddleware\n    });\n    try {\n        await Promise.all(matches.flatMap((m)=>[\n                m._lazyPromises?.handler,\n                m._lazyPromises?.route\n            ]));\n    } catch (e) {}\n    return results;\n}\nasync function callLoaderOrAction({ request, match, lazyHandlerPromise, lazyRoutePromise, handlerOverride, scopedContext }) {\n    let result;\n    let onReject;\n    let isAction = isMutationMethod(request.method);\n    let type = isAction ? \"action\" : \"loader\";\n    let runHandler = (handler)=>{\n        let reject;\n        let abortPromise = new Promise((_, r)=>reject = r);\n        onReject = ()=>reject();\n        request.signal.addEventListener(\"abort\", onReject);\n        let actualHandler = (ctx)=>{\n            if (typeof handler !== \"function\") {\n                return Promise.reject(new Error(`You cannot call the handler for a route which defines a boolean \"${type}\" [routeId: ${match.route.id}]`));\n            }\n            return handler({\n                request,\n                params: match.params,\n                context: scopedContext\n            }, ...ctx !== void 0 ? [\n                ctx\n            ] : []);\n        };\n        let handlerPromise = (async ()=>{\n            try {\n                let val = await (handlerOverride ? handlerOverride((ctx)=>actualHandler(ctx)) : actualHandler());\n                return {\n                    type: \"data\",\n                    result: val\n                };\n            } catch (e) {\n                return {\n                    type: \"error\",\n                    result: e\n                };\n            }\n        })();\n        return Promise.race([\n            handlerPromise,\n            abortPromise\n        ]);\n    };\n    try {\n        let handler = isAction ? match.route.action : match.route.loader;\n        if (lazyHandlerPromise || lazyRoutePromise) {\n            if (handler) {\n                let handlerError;\n                let [value] = await Promise.all([\n                    // If the handler throws, don't let it immediately bubble out,\n                    // since we need to let the lazy() execution finish so we know if this\n                    // route has a boundary that can handle the error\n                    runHandler(handler).catch((e)=>{\n                        handlerError = e;\n                    }),\n                    // Ensure all lazy route promises are resolved before continuing\n                    lazyHandlerPromise,\n                    lazyRoutePromise\n                ]);\n                if (handlerError !== void 0) {\n                    throw handlerError;\n                }\n                result = value;\n            } else {\n                await lazyHandlerPromise;\n                let handler2 = isAction ? match.route.action : match.route.loader;\n                if (handler2) {\n                    [result] = await Promise.all([\n                        runHandler(handler2),\n                        lazyRoutePromise\n                    ]);\n                } else if (type === \"action\") {\n                    let url = new URL(request.url);\n                    let pathname = url.pathname + url.search;\n                    throw getInternalRouterError(405, {\n                        method: request.method,\n                        pathname,\n                        routeId: match.route.id\n                    });\n                } else {\n                    return {\n                        type: \"data\" /* data */ ,\n                        result: void 0\n                    };\n                }\n            }\n        } else if (!handler) {\n            let url = new URL(request.url);\n            let pathname = url.pathname + url.search;\n            throw getInternalRouterError(404, {\n                pathname\n            });\n        } else {\n            result = await runHandler(handler);\n        }\n    } catch (e) {\n        return {\n            type: \"error\" /* error */ ,\n            result: e\n        };\n    } finally{\n        if (onReject) {\n            request.signal.removeEventListener(\"abort\", onReject);\n        }\n    }\n    return result;\n}\nasync function convertDataStrategyResultToDataResult(dataStrategyResult) {\n    let { result, type } = dataStrategyResult;\n    if (isResponse(result)) {\n        let data2;\n        try {\n            let contentType = result.headers.get(\"Content-Type\");\n            if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n                if (result.body == null) {\n                    data2 = null;\n                } else {\n                    data2 = await result.json();\n                }\n            } else {\n                data2 = await result.text();\n            }\n        } catch (e) {\n            return {\n                type: \"error\" /* error */ ,\n                error: e\n            };\n        }\n        if (type === \"error\" /* error */ ) {\n            return {\n                type: \"error\" /* error */ ,\n                error: new ErrorResponseImpl(result.status, result.statusText, data2),\n                statusCode: result.status,\n                headers: result.headers\n            };\n        }\n        return {\n            type: \"data\" /* data */ ,\n            data: data2,\n            statusCode: result.status,\n            headers: result.headers\n        };\n    }\n    if (type === \"error\" /* error */ ) {\n        if (isDataWithResponseInit(result)) {\n            if (result.data instanceof Error) {\n                return {\n                    type: \"error\" /* error */ ,\n                    error: result.data,\n                    statusCode: result.init?.status,\n                    headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n                };\n            }\n            return {\n                type: \"error\" /* error */ ,\n                error: new ErrorResponseImpl(result.init?.status || 500, void 0, result.data),\n                statusCode: isRouteErrorResponse(result) ? result.status : void 0,\n                headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n            };\n        }\n        return {\n            type: \"error\" /* error */ ,\n            error: result,\n            statusCode: isRouteErrorResponse(result) ? result.status : void 0\n        };\n    }\n    if (isDataWithResponseInit(result)) {\n        return {\n            type: \"data\" /* data */ ,\n            data: result.data,\n            statusCode: result.init?.status,\n            headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n        };\n    }\n    return {\n        type: \"data\" /* data */ ,\n        data: result\n    };\n}\nfunction normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename) {\n    let location = response.headers.get(\"Location\");\n    invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n    if (!ABSOLUTE_URL_REGEX.test(location)) {\n        let trimmedMatches = matches.slice(0, matches.findIndex((m)=>m.route.id === routeId) + 1);\n        location = normalizeTo(new URL(request.url), trimmedMatches, basename, location);\n        response.headers.set(\"Location\", location);\n    }\n    return response;\n}\nfunction normalizeRedirectLocation(location, currentUrl, basename) {\n    if (ABSOLUTE_URL_REGEX.test(location)) {\n        let normalizedLocation = location;\n        let url = normalizedLocation.startsWith(\"//\") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n            return url.pathname + url.search + url.hash;\n        }\n    }\n    return location;\n}\nfunction createClientSideRequest(history, location, signal, submission) {\n    let url = history.createURL(stripHashFromPath(location)).toString();\n    let init = {\n        signal\n    };\n    if (submission && isMutationMethod(submission.formMethod)) {\n        let { formMethod, formEncType } = submission;\n        init.method = formMethod.toUpperCase();\n        if (formEncType === \"application/json\") {\n            init.headers = new Headers({\n                \"Content-Type\": formEncType\n            });\n            init.body = JSON.stringify(submission.json);\n        } else if (formEncType === \"text/plain\") {\n            init.body = submission.text;\n        } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n            init.body = convertFormDataToSearchParams(submission.formData);\n        } else {\n            init.body = submission.formData;\n        }\n    }\n    return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n    let searchParams = new URLSearchParams();\n    for (let [key, value] of formData.entries()){\n        searchParams.append(key, typeof value === \"string\" ? value : value.name);\n    }\n    return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n    let formData = new FormData();\n    for (let [key, value] of searchParams.entries()){\n        formData.append(key, value);\n    }\n    return formData;\n}\nfunction processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {\n    let loaderData = {};\n    let errors = null;\n    let statusCode;\n    let foundError = false;\n    let loaderHeaders = {};\n    let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;\n    matches.forEach((match)=>{\n        if (!(match.route.id in results)) {\n            return;\n        }\n        let id = match.route.id;\n        let result = results[id];\n        invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n        if (isErrorResult(result)) {\n            let error = result.error;\n            if (pendingError !== void 0) {\n                error = pendingError;\n                pendingError = void 0;\n            }\n            errors = errors || {};\n            if (skipLoaderErrorBubbling) {\n                errors[id] = error;\n            } else {\n                let boundaryMatch = findNearestBoundary(matches, id);\n                if (errors[boundaryMatch.route.id] == null) {\n                    errors[boundaryMatch.route.id] = error;\n                }\n            }\n            if (!isStaticHandler) {\n                loaderData[id] = ResetLoaderDataSymbol;\n            }\n            if (!foundError) {\n                foundError = true;\n                statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        } else {\n            loaderData[id] = result.data;\n            if (result.statusCode && result.statusCode !== 200 && !foundError) {\n                statusCode = result.statusCode;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        }\n    });\n    if (pendingError !== void 0 && pendingActionResult) {\n        errors = {\n            [pendingActionResult[0]]: pendingError\n        };\n        if (pendingActionResult[2]) {\n            loaderData[pendingActionResult[2]] = void 0;\n        }\n    }\n    return {\n        loaderData,\n        errors,\n        statusCode: statusCode || 200,\n        loaderHeaders\n    };\n}\nfunction processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {\n    let { loaderData, errors } = processRouteLoaderData(matches, results, pendingActionResult);\n    revalidatingFetchers.filter((f)=>!f.matches || f.matches.some((m)=>m.shouldLoad)).forEach((rf)=>{\n        let { key, match, controller } = rf;\n        let result = fetcherResults[key];\n        invariant(result, \"Did not find corresponding fetcher result\");\n        if (controller && controller.signal.aborted) {\n            return;\n        } else if (isErrorResult(result)) {\n            let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);\n            if (!(errors && errors[boundaryMatch.route.id])) {\n                errors = {\n                    ...errors,\n                    [boundaryMatch.route.id]: result.error\n                };\n            }\n            state.fetchers.delete(key);\n        } else if (isRedirectResult(result)) {\n            invariant(false, \"Unhandled fetcher revalidation redirect\");\n        } else {\n            let doneFetcher = getDoneFetcher(result.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    });\n    return {\n        loaderData,\n        errors\n    };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n    let mergedLoaderData = Object.entries(newLoaderData).filter(([, v])=>v !== ResetLoaderDataSymbol).reduce((merged, [k, v])=>{\n        merged[k] = v;\n        return merged;\n    }, {});\n    for (let match of matches){\n        let id = match.route.id;\n        if (!newLoaderData.hasOwnProperty(id) && loaderData.hasOwnProperty(id) && match.route.loader) {\n            mergedLoaderData[id] = loaderData[id];\n        }\n        if (errors && errors.hasOwnProperty(id)) {\n            break;\n        }\n    }\n    return mergedLoaderData;\n}\nfunction getActionDataForCommit(pendingActionResult) {\n    if (!pendingActionResult) {\n        return {};\n    }\n    return isErrorResult(pendingActionResult[1]) ? {\n        // Clear out prior actionData on errors\n        actionData: {}\n    } : {\n        actionData: {\n            [pendingActionResult[0]]: pendingActionResult[1].data\n        }\n    };\n}\nfunction findNearestBoundary(matches, routeId) {\n    let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m)=>m.route.id === routeId) + 1) : [\n        ...matches\n    ];\n    return eligibleMatches.reverse().find((m)=>m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n    let route = routes.length === 1 ? routes[0] : routes.find((r)=>r.index || !r.path || r.path === \"/\") || {\n        id: `__shim-error-route__`\n    };\n    return {\n        matches: [\n            {\n                params: {},\n                pathname: \"\",\n                pathnameBase: \"\",\n                route\n            }\n        ],\n        route\n    };\n}\nfunction getInternalRouterError(status, { pathname, routeId, method, type, message } = {}) {\n    let statusText = \"Unknown Server Error\";\n    let errorMessage = \"Unknown @remix-run/router error\";\n    if (status === 400) {\n        statusText = \"Bad Request\";\n        if (method && pathname && routeId) {\n            errorMessage = `You made a ${method} request to \"${pathname}\" but did not provide a \\`loader\\` for route \"${routeId}\", so there is no way to handle the request.`;\n        } else if (type === \"invalid-body\") {\n            errorMessage = \"Unable to encode submission body\";\n        }\n    } else if (status === 403) {\n        statusText = \"Forbidden\";\n        errorMessage = `Route \"${routeId}\" does not match URL \"${pathname}\"`;\n    } else if (status === 404) {\n        statusText = \"Not Found\";\n        errorMessage = `No route matches URL \"${pathname}\"`;\n    } else if (status === 405) {\n        statusText = \"Method Not Allowed\";\n        if (method && pathname && routeId) {\n            errorMessage = `You made a ${method.toUpperCase()} request to \"${pathname}\" but did not provide an \\`action\\` for route \"${routeId}\", so there is no way to handle the request.`;\n        } else if (method) {\n            errorMessage = `Invalid request method \"${method.toUpperCase()}\"`;\n        }\n    }\n    return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\nfunction findRedirect(results) {\n    let entries = Object.entries(results);\n    for(let i = entries.length - 1; i >= 0; i--){\n        let [key, result] = entries[i];\n        if (isRedirectResult(result)) {\n            return {\n                key,\n                result\n            };\n        }\n    }\n}\nfunction stripHashFromPath(path) {\n    let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n    return createPath({\n        ...parsedPath,\n        hash: \"\"\n    });\n}\nfunction isHashChangeOnly(a, b) {\n    if (a.pathname !== b.pathname || a.search !== b.search) {\n        return false;\n    }\n    if (a.hash === \"\") {\n        return b.hash !== \"\";\n    } else if (a.hash === b.hash) {\n        return true;\n    } else if (b.hash !== \"\") {\n        return true;\n    }\n    return false;\n}\nfunction isDataStrategyResult(result) {\n    return result != null && typeof result === \"object\" && \"type\" in result && \"result\" in result && (result.type === \"data\" /* data */  || result.type === \"error\" /* error */ );\n}\nfunction isRedirectDataStrategyResult(result) {\n    return isResponse(result.result) && redirectStatusCodes.has(result.result.status);\n}\nfunction isErrorResult(result) {\n    return result.type === \"error\" /* error */ ;\n}\nfunction isRedirectResult(result) {\n    return (result && result.type) === \"redirect\" /* redirect */ ;\n}\nfunction isDataWithResponseInit(value) {\n    return typeof value === \"object\" && value != null && \"type\" in value && \"data\" in value && \"init\" in value && value.type === \"DataWithResponseInit\";\n}\nfunction isResponse(value) {\n    return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectStatusCode(statusCode) {\n    return redirectStatusCodes.has(statusCode);\n}\nfunction isRedirectResponse(result) {\n    return isResponse(result) && isRedirectStatusCode(result.status) && result.headers.has(\"Location\");\n}\nfunction isValidMethod(method) {\n    return validRequestMethods.has(method.toUpperCase());\n}\nfunction isMutationMethod(method) {\n    return validMutationMethods.has(method.toUpperCase());\n}\nfunction hasNakedIndexQuery(search) {\n    return new URLSearchParams(search).getAll(\"index\").some((v)=>v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n    let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n        return matches[matches.length - 1];\n    }\n    let pathMatches = getPathContributingMatches(matches);\n    return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n    let { formMethod, formAction, formEncType, text, formData, json } = navigation;\n    if (!formMethod || !formAction || !formEncType) {\n        return;\n    }\n    if (text != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: void 0,\n            json: void 0,\n            text\n        };\n    } else if (formData != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData,\n            json: void 0,\n            text: void 0\n        };\n    } else if (json !== void 0) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: void 0,\n            json,\n            text: void 0\n        };\n    }\n}\nfunction getLoadingNavigation(location, submission) {\n    if (submission) {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text\n        };\n        return navigation;\n    } else {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: void 0,\n            formAction: void 0,\n            formEncType: void 0,\n            formData: void 0,\n            json: void 0,\n            text: void 0\n        };\n        return navigation;\n    }\n}\nfunction getSubmittingNavigation(location, submission) {\n    let navigation = {\n        state: \"submitting\",\n        location,\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text\n    };\n    return navigation;\n}\nfunction getLoadingFetcher(submission, data2) {\n    if (submission) {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text,\n            data: data2\n        };\n        return fetcher;\n    } else {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: void 0,\n            formAction: void 0,\n            formEncType: void 0,\n            formData: void 0,\n            json: void 0,\n            text: void 0,\n            data: data2\n        };\n        return fetcher;\n    }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n    let fetcher = {\n        state: \"submitting\",\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text,\n        data: existingFetcher ? existingFetcher.data : void 0\n    };\n    return fetcher;\n}\nfunction getDoneFetcher(data2) {\n    let fetcher = {\n        state: \"idle\",\n        formMethod: void 0,\n        formAction: void 0,\n        formEncType: void 0,\n        formData: void 0,\n        json: void 0,\n        text: void 0,\n        data: data2\n    };\n    return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n    try {\n        let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n        if (sessionPositions) {\n            let json = JSON.parse(sessionPositions);\n            for (let [k, v] of Object.entries(json || {})){\n                if (v && Array.isArray(v)) {\n                    transitions.set(k, new Set(v || []));\n                }\n            }\n        }\n    } catch (e) {}\n}\nfunction persistAppliedTransitions(_window, transitions) {\n    if (transitions.size > 0) {\n        let json = {};\n        for (let [k, v] of transitions){\n            json[k] = [\n                ...v\n            ];\n        }\n        try {\n            _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));\n        } catch (error) {\n            warning(false, `Failed to save applied view transitions in sessionStorage (${error}).`);\n        }\n    }\n}\nfunction createDeferred() {\n    let resolve;\n    let reject;\n    let promise = new Promise((res, rej)=>{\n        resolve = async (val)=>{\n            res(val);\n            try {\n                await promise;\n            } catch (e) {}\n        };\n        reject = async (error)=>{\n            rej(error);\n            try {\n                await promise;\n            } catch (e) {}\n        };\n    });\n    return {\n        promise,\n        //@ts-ignore\n        resolve,\n        //@ts-ignore\n        reject\n    };\n}\n// lib/components.tsx\nvar React3 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/context.ts\nvar React = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar DataRouterContext = React.createContext(null);\nDataRouterContext.displayName = \"DataRouter\";\nvar DataRouterStateContext = React.createContext(null);\nDataRouterStateContext.displayName = \"DataRouterState\";\nvar ViewTransitionContext = React.createContext({\n    isTransitioning: false\n});\nViewTransitionContext.displayName = \"ViewTransition\";\nvar FetchersContext = React.createContext(/* @__PURE__ */ new Map());\nFetchersContext.displayName = \"Fetchers\";\nvar AwaitContext = React.createContext(null);\nAwaitContext.displayName = \"Await\";\nvar NavigationContext = React.createContext(null);\nNavigationContext.displayName = \"Navigation\";\nvar LocationContext = React.createContext(null);\nLocationContext.displayName = \"Location\";\nvar RouteContext = React.createContext({\n    outlet: null,\n    matches: [],\n    isDataRoute: false\n});\nRouteContext.displayName = \"Route\";\nvar RouteErrorContext = React.createContext(null);\nRouteErrorContext.displayName = \"RouteError\";\nvar ENABLE_DEV_WARNINGS = true;\n// lib/hooks.tsx\nvar React2 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction useHref(to, { relative } = {}) {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`);\n    let { basename, navigator } = React2.useContext(NavigationContext);\n    let { hash, pathname, search } = useResolvedPath(to, {\n        relative\n    });\n    let joinedPathname = pathname;\n    if (basename !== \"/\") {\n        joinedPathname = pathname === \"/\" ? basename : joinPaths([\n            basename,\n            pathname\n        ]);\n    }\n    return navigator.createHref({\n        pathname: joinedPathname,\n        search,\n        hash\n    });\n}\nfunction useInRouterContext() {\n    return React2.useContext(LocationContext) != null;\n}\nfunction useLocation() {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`);\n    return React2.useContext(LocationContext).location;\n}\nfunction useNavigationType() {\n    return React2.useContext(LocationContext).navigationType;\n}\nfunction useMatch(pattern) {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`);\n    let { pathname } = useLocation();\n    return React2.useMemo(()=>matchPath(pattern, decodePath(pathname)), [\n        pathname,\n        pattern\n    ]);\n}\nvar navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;\nfunction useIsomorphicLayoutEffect(cb) {\n    let isStatic = React2.useContext(NavigationContext).static;\n    if (!isStatic) {\n        React2.useLayoutEffect(cb);\n    }\n}\nfunction useNavigate() {\n    let { isDataRoute } = React2.useContext(RouteContext);\n    return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`);\n    let dataRouterContext = React2.useContext(DataRouterContext);\n    let { basename, navigator } = React2.useContext(NavigationContext);\n    let { matches } = React2.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));\n    let activeRef = React2.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = React2.useCallback((to, options = {})=>{\n        warning(activeRef.current, navigateEffectWarning);\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            navigator.go(to);\n            return;\n        }\n        let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n        if (dataRouterContext == null && basename !== \"/\") {\n            path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n                basename,\n                path.pathname\n            ]);\n        }\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [\n        basename,\n        navigator,\n        routePathnamesJson,\n        locationPathname,\n        dataRouterContext\n    ]);\n    return navigate;\n}\nvar OutletContext = React2.createContext(null);\nfunction useOutletContext() {\n    return React2.useContext(OutletContext);\n}\nfunction useOutlet(context) {\n    let outlet = React2.useContext(RouteContext).outlet;\n    if (outlet) {\n        return /* @__PURE__ */ React2.createElement(OutletContext.Provider, {\n            value: context\n        }, outlet);\n    }\n    return outlet;\n}\nfunction useParams() {\n    let { matches } = React2.useContext(RouteContext);\n    let routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n}\nfunction useResolvedPath(to, { relative } = {}) {\n    let { matches } = React2.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));\n    return React2.useMemo(()=>resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [\n        to,\n        routePathnamesJson,\n        locationPathname,\n        relative\n    ]);\n}\nfunction useRoutes(routes, locationArg) {\n    return useRoutesImpl(routes, locationArg);\n}\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`);\n    let { navigator } = React2.useContext(NavigationContext);\n    let { matches: parentMatches } = React2.useContext(RouteContext);\n    let routeMatch = parentMatches[parentMatches.length - 1];\n    let parentParams = routeMatch ? routeMatch.params : {};\n    let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    let parentRoute = routeMatch && routeMatch.route;\n    if (ENABLE_DEV_WARNINGS) {\n        let parentPath = parentRoute && parentRoute.path || \"\";\n        warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\") || parentPath.endsWith(\"*?\"), `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at \"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the parent route path has no trailing \"*\". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path=\"${parentPath}\"> to <Route path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`);\n    }\n    let locationFromContext = useLocation();\n    let location;\n    if (locationArg) {\n        let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n        invariant(parentPathnameBase === \"/\" || parsedLocationArg.pathname?.startsWith(parentPathnameBase), `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`);\n        location = parsedLocationArg;\n    } else {\n        location = locationFromContext;\n    }\n    let pathname = location.pathname || \"/\";\n    let remainingPathname = pathname;\n    if (parentPathnameBase !== \"/\") {\n        let parentSegments = parentPathnameBase.replace(/^\\//, \"\").split(\"/\");\n        let segments = pathname.replace(/^\\//, \"\").split(\"/\");\n        remainingPathname = \"/\" + segments.slice(parentSegments.length).join(\"/\");\n    }\n    let matches = matchRoutes(routes, {\n        pathname: remainingPathname\n    });\n    if (ENABLE_DEV_WARNINGS) {\n        warning(parentRoute || matches != null, `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `);\n        warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0, `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`);\n    }\n    let renderedMatches = _renderMatches(matches && matches.map((match)=>Object.assign({}, match, {\n            params: Object.assign({}, parentParams, match.params),\n            pathname: joinPaths([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\n            ]),\n            pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n            ])\n        })), parentMatches, dataRouterState, future);\n    if (locationArg && renderedMatches) {\n        return /* @__PURE__ */ React2.createElement(LocationContext.Provider, {\n            value: {\n                location: {\n                    pathname: \"/\",\n                    search: \"\",\n                    hash: \"\",\n                    state: null,\n                    key: \"default\",\n                    ...location\n                },\n                navigationType: \"POP\" /* Pop */ \n            }\n        }, renderedMatches);\n    }\n    return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n    let error = useRouteError();\n    let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);\n    let stack = error instanceof Error ? error.stack : null;\n    let lightgrey = \"rgba(200,200,200, 0.5)\";\n    let preStyles = {\n        padding: \"0.5rem\",\n        backgroundColor: lightgrey\n    };\n    let codeStyles = {\n        padding: \"2px 4px\",\n        backgroundColor: lightgrey\n    };\n    let devInfo = null;\n    if (ENABLE_DEV_WARNINGS) {\n        console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n        devInfo = /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /* @__PURE__ */ React2.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /* @__PURE__ */ React2.createElement(\"code\", {\n            style: codeStyles\n        }, \"ErrorBoundary\"), \" or\", \" \", /* @__PURE__ */ React2.createElement(\"code\", {\n            style: codeStyles\n        }, \"errorElement\"), \" prop on your route.\"));\n    }\n    return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\"h2\", null, \"Unexpected Application Error!\"), /* @__PURE__ */ React2.createElement(\"h3\", {\n        style: {\n            fontStyle: \"italic\"\n        }\n    }, message), stack ? /* @__PURE__ */ React2.createElement(\"pre\", {\n        style: preStyles\n    }, stack) : null, devInfo);\n}\nvar defaultErrorElement = /* @__PURE__ */ React2.createElement(DefaultErrorComponent, null);\nvar RenderErrorBoundary = class extends React2.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            location: props.location,\n            revalidation: props.revalidation,\n            error: props.error\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n            return {\n                error: props.error,\n                location: props.location,\n                revalidation: props.revalidation\n            };\n        }\n        return {\n            error: props.error !== void 0 ? props.error : state.error,\n            location: state.location,\n            revalidation: props.revalidation || state.revalidation\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"React Router caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        return this.state.error !== void 0 ? /* @__PURE__ */ React2.createElement(RouteContext.Provider, {\n            value: this.props.routeContext\n        }, /* @__PURE__ */ React2.createElement(RouteErrorContext.Provider, {\n            value: this.state.error,\n            children: this.props.component\n        })) : this.props.children;\n    }\n};\nfunction RenderedRoute({ routeContext, match, children }) {\n    let dataRouterContext = React2.useContext(DataRouterContext);\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n    }\n    return /* @__PURE__ */ React2.createElement(RouteContext.Provider, {\n        value: routeContext\n    }, children);\n}\nfunction _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {\n    if (matches == null) {\n        if (!dataRouterState) {\n            return null;\n        }\n        if (dataRouterState.errors) {\n            matches = dataRouterState.matches;\n        } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {\n            matches = dataRouterState.matches;\n        } else {\n            return null;\n        }\n    }\n    let renderedMatches = matches;\n    let errors = dataRouterState?.errors;\n    if (errors != null) {\n        let errorIndex = renderedMatches.findIndex((m)=>m.route.id && errors?.[m.route.id] !== void 0);\n        invariant(errorIndex >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(errors).join(\",\")}`);\n        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n    let renderFallback = false;\n    let fallbackIndex = -1;\n    if (dataRouterState) {\n        for(let i = 0; i < renderedMatches.length; i++){\n            let match = renderedMatches[i];\n            if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n                fallbackIndex = i;\n            }\n            if (match.route.id) {\n                let { loaderData, errors: errors2 } = dataRouterState;\n                let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);\n                if (match.route.lazy || needsToRunLoader) {\n                    renderFallback = true;\n                    if (fallbackIndex >= 0) {\n                        renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n                    } else {\n                        renderedMatches = [\n                            renderedMatches[0]\n                        ];\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return renderedMatches.reduceRight((outlet, match, index)=>{\n        let error;\n        let shouldRenderHydrateFallback = false;\n        let errorElement = null;\n        let hydrateFallbackElement = null;\n        if (dataRouterState) {\n            error = errors && match.route.id ? errors[match.route.id] : void 0;\n            errorElement = match.route.errorElement || defaultErrorElement;\n            if (renderFallback) {\n                if (fallbackIndex < 0 && index === 0) {\n                    warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = null;\n                } else if (fallbackIndex === index) {\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n                }\n            }\n        }\n        let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));\n        let getChildren = ()=>{\n            let children;\n            if (error) {\n                children = errorElement;\n            } else if (shouldRenderHydrateFallback) {\n                children = hydrateFallbackElement;\n            } else if (match.route.Component) {\n                children = /* @__PURE__ */ React2.createElement(match.route.Component, null);\n            } else if (match.route.element) {\n                children = match.route.element;\n            } else {\n                children = outlet;\n            }\n            return /* @__PURE__ */ React2.createElement(RenderedRoute, {\n                match,\n                routeContext: {\n                    outlet,\n                    matches: matches2,\n                    isDataRoute: dataRouterState != null\n                },\n                children\n            });\n        };\n        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ React2.createElement(RenderErrorBoundary, {\n            location: dataRouterState.location,\n            revalidation: dataRouterState.revalidation,\n            component: errorElement,\n            error,\n            children: getChildren(),\n            routeContext: {\n                outlet: null,\n                matches: matches2,\n                isDataRoute: true\n            }\n        }) : getChildren();\n    }, null);\n}\nfunction getDataRouterConsoleError(hookName) {\n    return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\nfunction useDataRouterContext(hookName) {\n    let ctx = React2.useContext(DataRouterContext);\n    invariant(ctx, getDataRouterConsoleError(hookName));\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    let state = React2.useContext(DataRouterStateContext);\n    invariant(state, getDataRouterConsoleError(hookName));\n    return state;\n}\nfunction useRouteContext(hookName) {\n    let route = React2.useContext(RouteContext);\n    invariant(route, getDataRouterConsoleError(hookName));\n    return route;\n}\nfunction useCurrentRouteId(hookName) {\n    let route = useRouteContext(hookName);\n    let thisRoute = route.matches[route.matches.length - 1];\n    invariant(thisRoute.route.id, `${hookName} can only be used on routes that contain a unique \"id\"`);\n    return thisRoute.route.id;\n}\nfunction useRouteId() {\n    return useCurrentRouteId(\"useRouteId\" /* UseRouteId */ );\n}\nfunction useNavigation() {\n    let state = useDataRouterState(\"useNavigation\" /* UseNavigation */ );\n    return state.navigation;\n}\nfunction useRevalidator() {\n    let dataRouterContext = useDataRouterContext(\"useRevalidator\" /* UseRevalidator */ );\n    let state = useDataRouterState(\"useRevalidator\" /* UseRevalidator */ );\n    let revalidate = React2.useCallback(async ()=>{\n        await dataRouterContext.router.revalidate();\n    }, [\n        dataRouterContext.router\n    ]);\n    return React2.useMemo(()=>({\n            revalidate,\n            state: state.revalidation\n        }), [\n        revalidate,\n        state.revalidation\n    ]);\n}\nfunction useMatches() {\n    let { matches, loaderData } = useDataRouterState(\"useMatches\" /* UseMatches */ );\n    return React2.useMemo(()=>matches.map((m)=>convertRouteMatchToUiMatch(m, loaderData)), [\n        matches,\n        loaderData\n    ]);\n}\nfunction useLoaderData() {\n    let state = useDataRouterState(\"useLoaderData\" /* UseLoaderData */ );\n    let routeId = useCurrentRouteId(\"useLoaderData\" /* UseLoaderData */ );\n    return state.loaderData[routeId];\n}\nfunction useRouteLoaderData(routeId) {\n    let state = useDataRouterState(\"useRouteLoaderData\" /* UseRouteLoaderData */ );\n    return state.loaderData[routeId];\n}\nfunction useActionData() {\n    let state = useDataRouterState(\"useActionData\" /* UseActionData */ );\n    let routeId = useCurrentRouteId(\"useLoaderData\" /* UseLoaderData */ );\n    return state.actionData ? state.actionData[routeId] : void 0;\n}\nfunction useRouteError() {\n    let error = React2.useContext(RouteErrorContext);\n    let state = useDataRouterState(\"useRouteError\" /* UseRouteError */ );\n    let routeId = useCurrentRouteId(\"useRouteError\" /* UseRouteError */ );\n    if (error !== void 0) {\n        return error;\n    }\n    return state.errors?.[routeId];\n}\nfunction useAsyncValue() {\n    let value = React2.useContext(AwaitContext);\n    return value?._data;\n}\nfunction useAsyncError() {\n    let value = React2.useContext(AwaitContext);\n    return value?._error;\n}\nvar blockerId = 0;\nfunction useBlocker(shouldBlock) {\n    let { router, basename } = useDataRouterContext(\"useBlocker\" /* UseBlocker */ );\n    let state = useDataRouterState(\"useBlocker\" /* UseBlocker */ );\n    let [blockerKey, setBlockerKey] = React2.useState(\"\");\n    let blockerFunction = React2.useCallback((arg)=>{\n        if (typeof shouldBlock !== \"function\") {\n            return !!shouldBlock;\n        }\n        if (basename === \"/\") {\n            return shouldBlock(arg);\n        }\n        let { currentLocation, nextLocation, historyAction } = arg;\n        return shouldBlock({\n            currentLocation: {\n                ...currentLocation,\n                pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n            },\n            nextLocation: {\n                ...nextLocation,\n                pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n            },\n            historyAction\n        });\n    }, [\n        basename,\n        shouldBlock\n    ]);\n    React2.useEffect(()=>{\n        let key = String(++blockerId);\n        setBlockerKey(key);\n        return ()=>router.deleteBlocker(key);\n    }, [\n        router\n    ]);\n    React2.useEffect(()=>{\n        if (blockerKey !== \"\") {\n            router.getBlocker(blockerKey, blockerFunction);\n        }\n    }, [\n        router,\n        blockerKey,\n        blockerFunction\n    ]);\n    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\nfunction useNavigateStable() {\n    let { router } = useDataRouterContext(\"useNavigate\" /* UseNavigateStable */ );\n    let id = useCurrentRouteId(\"useNavigate\" /* UseNavigateStable */ );\n    let activeRef = React2.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = React2.useCallback(async (to, options = {})=>{\n        warning(activeRef.current, navigateEffectWarning);\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            router.navigate(to);\n        } else {\n            await router.navigate(to, {\n                fromRouteId: id,\n                ...options\n            });\n        }\n    }, [\n        router,\n        id\n    ]);\n    return navigate;\n}\nvar alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned[key]) {\n        alreadyWarned[key] = true;\n        warning(false, message);\n    }\n}\n// lib/server-runtime/warnings.ts\nvar alreadyWarned2 = {};\nfunction warnOnce(condition, message) {\n    if (!condition && !alreadyWarned2[message]) {\n        alreadyWarned2[message] = true;\n        console.warn(message);\n    }\n}\n// lib/components.tsx\nfunction mapRouteProperties(route) {\n    let updates = {\n        // Note: this check also occurs in createRoutesFromChildren so update\n        // there if you change this -- please and thank you!\n        hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null\n    };\n    if (route.Component) {\n        if (ENABLE_DEV_WARNINGS) {\n            if (route.element) {\n                warning(false, \"You should not include both `Component` and `element` on your route - `Component` will be used.\");\n            }\n        }\n        Object.assign(updates, {\n            element: React3.createElement(route.Component),\n            Component: void 0\n        });\n    }\n    if (route.HydrateFallback) {\n        if (ENABLE_DEV_WARNINGS) {\n            if (route.hydrateFallbackElement) {\n                warning(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.\");\n            }\n        }\n        Object.assign(updates, {\n            hydrateFallbackElement: React3.createElement(route.HydrateFallback),\n            HydrateFallback: void 0\n        });\n    }\n    if (route.ErrorBoundary) {\n        if (ENABLE_DEV_WARNINGS) {\n            if (route.errorElement) {\n                warning(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.\");\n            }\n        }\n        Object.assign(updates, {\n            errorElement: React3.createElement(route.ErrorBoundary),\n            ErrorBoundary: void 0\n        });\n    }\n    return updates;\n}\nvar hydrationRouteProperties = [\n    \"HydrateFallback\",\n    \"hydrateFallbackElement\"\n];\nfunction createMemoryRouter(routes, opts) {\n    return createRouter({\n        basename: opts?.basename,\n        unstable_getContext: opts?.unstable_getContext,\n        future: opts?.future,\n        history: createMemoryHistory({\n            initialEntries: opts?.initialEntries,\n            initialIndex: opts?.initialIndex\n        }),\n        hydrationData: opts?.hydrationData,\n        routes,\n        hydrationRouteProperties,\n        mapRouteProperties,\n        dataStrategy: opts?.dataStrategy,\n        patchRoutesOnNavigation: opts?.patchRoutesOnNavigation\n    }).initialize();\n}\nvar Deferred = class {\n    constructor(){\n        this.status = \"pending\";\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = (value)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"resolved\";\n                    resolve(value);\n                }\n            };\n            this.reject = (reason)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"rejected\";\n                    reject(reason);\n                }\n            };\n        });\n    }\n};\nfunction RouterProvider({ router, flushSync: reactDomFlushSyncImpl }) {\n    let [state, setStateImpl] = React3.useState(router.state);\n    let [pendingState, setPendingState] = React3.useState();\n    let [vtContext, setVtContext] = React3.useState({\n        isTransitioning: false\n    });\n    let [renderDfd, setRenderDfd] = React3.useState();\n    let [transition, setTransition] = React3.useState();\n    let [interruption, setInterruption] = React3.useState();\n    let fetcherData = React3.useRef(/* @__PURE__ */ new Map());\n    let setState = React3.useCallback((newState, { deletedFetchers, flushSync, viewTransitionOpts })=>{\n        newState.fetchers.forEach((fetcher, key)=>{\n            if (fetcher.data !== void 0) {\n                fetcherData.current.set(key, fetcher.data);\n            }\n        });\n        deletedFetchers.forEach((key)=>fetcherData.current.delete(key));\n        warnOnce(flushSync === false || reactDomFlushSyncImpl != null, 'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from \"react-router/dom\"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.');\n        let isViewTransitionAvailable = router.window != null && router.window.document != null && typeof router.window.document.startViewTransition === \"function\";\n        warnOnce(viewTransitionOpts == null || isViewTransitionAvailable, \"You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available.\");\n        if (!viewTransitionOpts || !isViewTransitionAvailable) {\n            if (reactDomFlushSyncImpl && flushSync) {\n                reactDomFlushSyncImpl(()=>setStateImpl(newState));\n            } else {\n                React3.startTransition(()=>setStateImpl(newState));\n            }\n            return;\n        }\n        if (reactDomFlushSyncImpl && flushSync) {\n            reactDomFlushSyncImpl(()=>{\n                if (transition) {\n                    renderDfd && renderDfd.resolve();\n                    transition.skipTransition();\n                }\n                setVtContext({\n                    isTransitioning: true,\n                    flushSync: true,\n                    currentLocation: viewTransitionOpts.currentLocation,\n                    nextLocation: viewTransitionOpts.nextLocation\n                });\n            });\n            let t = router.window.document.startViewTransition(()=>{\n                reactDomFlushSyncImpl(()=>setStateImpl(newState));\n            });\n            t.finished.finally(()=>{\n                reactDomFlushSyncImpl(()=>{\n                    setRenderDfd(void 0);\n                    setTransition(void 0);\n                    setPendingState(void 0);\n                    setVtContext({\n                        isTransitioning: false\n                    });\n                });\n            });\n            reactDomFlushSyncImpl(()=>setTransition(t));\n            return;\n        }\n        if (transition) {\n            renderDfd && renderDfd.resolve();\n            transition.skipTransition();\n            setInterruption({\n                state: newState,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        } else {\n            setPendingState(newState);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        }\n    }, [\n        router.window,\n        reactDomFlushSyncImpl,\n        transition,\n        renderDfd\n    ]);\n    React3.useLayoutEffect(()=>router.subscribe(setState), [\n        router,\n        setState\n    ]);\n    React3.useEffect(()=>{\n        if (vtContext.isTransitioning && !vtContext.flushSync) {\n            setRenderDfd(new Deferred());\n        }\n    }, [\n        vtContext\n    ]);\n    React3.useEffect(()=>{\n        if (renderDfd && pendingState && router.window) {\n            let newState = pendingState;\n            let renderPromise = renderDfd.promise;\n            let transition2 = router.window.document.startViewTransition(async ()=>{\n                React3.startTransition(()=>setStateImpl(newState));\n                await renderPromise;\n            });\n            transition2.finished.finally(()=>{\n                setRenderDfd(void 0);\n                setTransition(void 0);\n                setPendingState(void 0);\n                setVtContext({\n                    isTransitioning: false\n                });\n            });\n            setTransition(transition2);\n        }\n    }, [\n        pendingState,\n        renderDfd,\n        router.window\n    ]);\n    React3.useEffect(()=>{\n        if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n            renderDfd.resolve();\n        }\n    }, [\n        renderDfd,\n        transition,\n        state.location,\n        pendingState\n    ]);\n    React3.useEffect(()=>{\n        if (!vtContext.isTransitioning && interruption) {\n            setPendingState(interruption.state);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: interruption.currentLocation,\n                nextLocation: interruption.nextLocation\n            });\n            setInterruption(void 0);\n        }\n    }, [\n        vtContext.isTransitioning,\n        interruption\n    ]);\n    let navigator = React3.useMemo(()=>{\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: (n)=>router.navigate(n),\n            push: (to, state2, opts)=>router.navigate(to, {\n                    state: state2,\n                    preventScrollReset: opts?.preventScrollReset\n                }),\n            replace: (to, state2, opts)=>router.navigate(to, {\n                    replace: true,\n                    state: state2,\n                    preventScrollReset: opts?.preventScrollReset\n                })\n        };\n    }, [\n        router\n    ]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = React3.useMemo(()=>({\n            router,\n            navigator,\n            static: false,\n            basename\n        }), [\n        router,\n        navigator,\n        basename\n    ]);\n    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /* @__PURE__ */ React3.createElement(DataRouterStateContext.Provider, {\n        value: state\n    }, /* @__PURE__ */ React3.createElement(FetchersContext.Provider, {\n        value: fetcherData.current\n    }, /* @__PURE__ */ React3.createElement(ViewTransitionContext.Provider, {\n        value: vtContext\n    }, /* @__PURE__ */ React3.createElement(Router, {\n        basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator\n    }, /* @__PURE__ */ React3.createElement(MemoizedDataRoutes, {\n        routes: router.routes,\n        future: router.future,\n        state\n    })))))), null);\n}\nvar MemoizedDataRoutes = React3.memo(DataRoutes);\nfunction DataRoutes({ routes, future, state }) {\n    return useRoutesImpl(routes, void 0, state, future);\n}\nfunction MemoryRouter({ basename, children, initialEntries, initialIndex }) {\n    let historyRef = React3.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = createMemoryHistory({\n            initialEntries,\n            initialIndex,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React3.useState({\n        action: history.action,\n        location: history.location\n    });\n    let setState = React3.useCallback((newState)=>{\n        React3.startTransition(()=>setStateImpl(newState));\n    }, [\n        setStateImpl\n    ]);\n    React3.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /* @__PURE__ */ React3.createElement(Router, {\n        basename,\n        children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nfunction Navigate({ to, replace: replace2, state, relative }) {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`);\n    let { static: isStatic } = React3.useContext(NavigationContext);\n    warning(!isStatic, `<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.`);\n    let { matches } = React3.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let navigate = useNavigate();\n    let path = resolveTo(to, getResolveToMatches(matches), locationPathname, relative === \"path\");\n    let jsonPath = JSON.stringify(path);\n    React3.useEffect(()=>{\n        navigate(JSON.parse(jsonPath), {\n            replace: replace2,\n            state,\n            relative\n        });\n    }, [\n        navigate,\n        jsonPath,\n        relative,\n        replace2,\n        state\n    ]);\n    return null;\n}\nfunction Outlet(props) {\n    return useOutlet(props.context);\n}\nfunction Route(_props) {\n    invariant(false, `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`);\n}\nfunction Router({ basename: basenameProp = \"/\", children = null, location: locationProp, navigationType = \"POP\" /* Pop */ , navigator, static: staticProp = false }) {\n    invariant(!useInRouterContext(), `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`);\n    let basename = basenameProp.replace(/^\\/*/, \"/\");\n    let navigationContext = React3.useMemo(()=>({\n            basename,\n            navigator,\n            static: staticProp,\n            future: {}\n        }), [\n        basename,\n        navigator,\n        staticProp\n    ]);\n    if (typeof locationProp === \"string\") {\n        locationProp = parsePath(locationProp);\n    }\n    let { pathname = \"/\", search = \"\", hash = \"\", state = null, key = \"default\" } = locationProp;\n    let locationContext = React3.useMemo(()=>{\n        let trailingPathname = stripBasename(pathname, basename);\n        if (trailingPathname == null) {\n            return null;\n        }\n        return {\n            location: {\n                pathname: trailingPathname,\n                search,\n                hash,\n                state,\n                key\n            },\n            navigationType\n        };\n    }, [\n        basename,\n        pathname,\n        search,\n        hash,\n        state,\n        key,\n        navigationType\n    ]);\n    warning(locationContext != null, `<Router basename=\"${basename}\"> is not able to match the URL \"${pathname}${search}${hash}\" because it does not start with the basename, so the <Router> won't render anything.`);\n    if (locationContext == null) {\n        return null;\n    }\n    return /* @__PURE__ */ React3.createElement(NavigationContext.Provider, {\n        value: navigationContext\n    }, /* @__PURE__ */ React3.createElement(LocationContext.Provider, {\n        children,\n        value: locationContext\n    }));\n}\nfunction Routes({ children, location }) {\n    return useRoutes(createRoutesFromChildren(children), location);\n}\nfunction Await({ children, errorElement, resolve }) {\n    return /* @__PURE__ */ React3.createElement(AwaitErrorBoundary, {\n        resolve,\n        errorElement\n    }, /* @__PURE__ */ React3.createElement(ResolveAwait, null, children));\n}\nvar AwaitErrorBoundary = class extends React3.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            error: null\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        let { children, errorElement, resolve } = this.props;\n        let promise = null;\n        let status = 0 /* pending */ ;\n        if (!(resolve instanceof Promise)) {\n            status = 1 /* success */ ;\n            promise = Promise.resolve();\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_data\", {\n                get: ()=>resolve\n            });\n        } else if (this.state.error) {\n            status = 2 /* error */ ;\n            let renderError = this.state.error;\n            promise = Promise.reject().catch(()=>{});\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>renderError\n            });\n        } else if (resolve._tracked) {\n            promise = resolve;\n            status = \"_error\" in promise ? 2 /* error */  : \"_data\" in promise ? 1 /* success */  : 0 /* pending */ ;\n        } else {\n            status = 0 /* pending */ ;\n            Object.defineProperty(resolve, \"_tracked\", {\n                get: ()=>true\n            });\n            promise = resolve.then((data2)=>Object.defineProperty(resolve, \"_data\", {\n                    get: ()=>data2\n                }), (error)=>Object.defineProperty(resolve, \"_error\", {\n                    get: ()=>error\n                }));\n        }\n        if (status === 2 /* error */  && !errorElement) {\n            throw promise._error;\n        }\n        if (status === 2 /* error */ ) {\n            return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: errorElement\n            });\n        }\n        if (status === 1 /* success */ ) {\n            return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, {\n                value: promise,\n                children\n            });\n        }\n        throw promise;\n    }\n};\nfunction ResolveAwait({ children }) {\n    let data2 = useAsyncValue();\n    let toRender = typeof children === \"function\" ? children(data2) : children;\n    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, toRender);\n}\nfunction createRoutesFromChildren(children, parentPath = []) {\n    let routes = [];\n    React3.Children.forEach(children, (element, index)=>{\n        if (!React3.isValidElement(element)) {\n            return;\n        }\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        if (element.type === React3.Fragment) {\n            routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n            return;\n        }\n        invariant(element.type === Route, `[${typeof element.type === \"string\" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`);\n        invariant(!element.props.index || !element.props.children, \"An index route cannot have child routes.\");\n        let route = {\n            id: element.props.id || treePath.join(\"-\"),\n            caseSensitive: element.props.caseSensitive,\n            element: element.props.element,\n            Component: element.props.Component,\n            index: element.props.index,\n            path: element.props.path,\n            loader: element.props.loader,\n            action: element.props.action,\n            hydrateFallbackElement: element.props.hydrateFallbackElement,\n            HydrateFallback: element.props.HydrateFallback,\n            errorElement: element.props.errorElement,\n            ErrorBoundary: element.props.ErrorBoundary,\n            hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,\n            shouldRevalidate: element.props.shouldRevalidate,\n            handle: element.props.handle,\n            lazy: element.props.lazy\n        };\n        if (element.props.children) {\n            route.children = createRoutesFromChildren(element.props.children, treePath);\n        }\n        routes.push(route);\n    });\n    return routes;\n}\nvar createRoutesFromElements = createRoutesFromChildren;\nfunction renderMatches(matches) {\n    return _renderMatches(matches);\n}\n// lib/dom/lib.tsx\nvar React10 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/dom/dom.ts\nvar defaultMethod = \"get\";\nvar defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n    return event.button === 0 && // Ignore everything but left clicks\n    (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event);\n}\nfunction createSearchParams(init = \"\") {\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key)=>{\n        let value = init[key];\n        return memo2.concat(Array.isArray(value) ? value.map((v)=>[\n                key,\n                v\n            ]) : [\n            [\n                key,\n                value\n            ]\n        ]);\n    }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    let searchParams = createSearchParams(locationSearch);\n    if (defaultSearchParams) {\n        defaultSearchParams.forEach((_, key)=>{\n            if (!searchParams.has(key)) {\n                defaultSearchParams.getAll(key).forEach((value)=>{\n                    searchParams.append(key, value);\n                });\n            }\n        });\n    }\n    return searchParams;\n}\nvar _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n    if (_formDataSupportsSubmitter === null) {\n        try {\n            new FormData(document.createElement(\"form\"), // @ts-expect-error if FormData supports the submitter parameter, this will throw\n            0);\n            _formDataSupportsSubmitter = false;\n        } catch (e) {\n            _formDataSupportsSubmitter = true;\n        }\n    }\n    return _formDataSupportsSubmitter;\n}\nvar supportedFormEncTypes = /* @__PURE__ */ new Set([\n    \"application/x-www-form-urlencoded\",\n    \"multipart/form-data\",\n    \"text/plain\"\n]);\nfunction getFormEncType(encType) {\n    if (encType != null && !supportedFormEncTypes.has(encType)) {\n        warning(false, `\"${encType}\" is not a valid \\`encType\\` for \\`<Form>\\`/\\`<fetcher.Form>\\` and will default to \"${defaultEncType}\"`);\n        return null;\n    }\n    return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    let body;\n    if (isFormElement(target)) {\n        let attr = target.getAttribute(\"action\");\n        action = attr ? stripBasename(attr, basename) : null;\n        method = target.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n        formData = new FormData(target);\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n        let form = target.form;\n        if (form == null) {\n            throw new Error(`Cannot submit a <button> or <input type=\"submit\"> without a <form>`);\n        }\n        let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n        action = attr ? stripBasename(attr, basename) : null;\n        method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n        formData = new FormData(form, target);\n        if (!isFormDataSubmitterSupported()) {\n            let { name, type, value } = target;\n            if (type === \"image\") {\n                let prefix = name ? `${name}.` : \"\";\n                formData.append(`${prefix}x`, \"0\");\n                formData.append(`${prefix}y`, \"0\");\n            } else if (name) {\n                formData.append(name, value);\n            }\n        }\n    } else if (isHtmlElement(target)) {\n        throw new Error(`Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">`);\n    } else {\n        method = defaultMethod;\n        action = null;\n        encType = defaultEncType;\n        body = target;\n    }\n    if (formData && encType === \"text/plain\") {\n        body = formData;\n        formData = void 0;\n    }\n    return {\n        action,\n        method: method.toLowerCase(),\n        encType,\n        formData,\n        body\n    };\n}\n// lib/dom/ssr/components.tsx\nvar React9 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/dom/ssr/invariant.ts\nfunction invariant2(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        throw new Error(message);\n    }\n}\n// lib/dom/ssr/routeModules.ts\nasync function loadRouteModule(route, routeModulesCache) {\n    if (route.id in routeModulesCache) {\n        return routeModulesCache[route.id];\n    }\n    try {\n        let routeModule = await import(/* @vite-ignore */ /* webpackIgnore: true */ route.module);\n        routeModulesCache[route.id] = routeModule;\n        return routeModule;\n    } catch (error) {\n        console.error(`Error loading route module \\`${route.module}\\`, reloading page...`);\n        console.error(error);\n        if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error\n        void 0) {\n            throw error;\n        }\n        window.location.reload();\n        return new Promise(()=>{});\n    }\n}\n// lib/dom/ssr/links.ts\nfunction getKeyedLinksForMatches(matches, routeModules, manifest) {\n    let descriptors = matches.map((match)=>{\n        let module2 = routeModules[match.route.id];\n        let route = manifest.routes[match.route.id];\n        return [\n            route && route.css ? route.css.map((href2)=>({\n                    rel: \"stylesheet\",\n                    href: href2\n                })) : [],\n            module2?.links?.() || []\n        ];\n    }).flat(2);\n    let preloads = getModuleLinkHrefs(matches, manifest);\n    return dedupeLinkDescriptors(descriptors, preloads);\n}\nfunction getRouteCssDescriptors(route) {\n    if (!route.css) return [];\n    return route.css.map((href2)=>({\n            rel: \"stylesheet\",\n            href: href2\n        }));\n}\nasync function prefetchRouteCss(route) {\n    if (!route.css) return;\n    let descriptors = getRouteCssDescriptors(route);\n    await Promise.all(descriptors.map(prefetchStyleLink));\n}\nasync function prefetchStyleLinks(route, routeModule) {\n    if (!route.css && !routeModule.links || !isPreloadSupported()) return;\n    let descriptors = [];\n    if (route.css) {\n        descriptors.push(...getRouteCssDescriptors(route));\n    }\n    if (routeModule.links) {\n        descriptors.push(...routeModule.links());\n    }\n    if (descriptors.length === 0) return;\n    let styleLinks = [];\n    for (let descriptor of descriptors){\n        if (!isPageLinkDescriptor(descriptor) && descriptor.rel === \"stylesheet\") {\n            styleLinks.push({\n                ...descriptor,\n                rel: \"preload\",\n                as: \"style\"\n            });\n        }\n    }\n    await Promise.all(styleLinks.map(prefetchStyleLink));\n}\nasync function prefetchStyleLink(descriptor) {\n    return new Promise((resolve)=>{\n        if (descriptor.media && !window.matchMedia(descriptor.media).matches || document.querySelector(`link[rel=\"stylesheet\"][href=\"${descriptor.href}\"]`)) {\n            return resolve();\n        }\n        let link = document.createElement(\"link\");\n        Object.assign(link, descriptor);\n        function removeLink() {\n            if (document.head.contains(link)) {\n                document.head.removeChild(link);\n            }\n        }\n        link.onload = ()=>{\n            removeLink();\n            resolve();\n        };\n        link.onerror = ()=>{\n            removeLink();\n            resolve();\n        };\n        document.head.appendChild(link);\n    });\n}\nfunction isPageLinkDescriptor(object) {\n    return object != null && typeof object.page === \"string\";\n}\nfunction isHtmlLinkDescriptor(object) {\n    if (object == null) {\n        return false;\n    }\n    if (object.href == null) {\n        return object.rel === \"preload\" && typeof object.imageSrcSet === \"string\" && typeof object.imageSizes === \"string\";\n    }\n    return typeof object.rel === \"string\" && typeof object.href === \"string\";\n}\nasync function getKeyedPrefetchLinks(matches, manifest, routeModules) {\n    let links = await Promise.all(matches.map(async (match)=>{\n        let route = manifest.routes[match.route.id];\n        if (route) {\n            let mod = await loadRouteModule(route, routeModules);\n            return mod.links ? mod.links() : [];\n        }\n        return [];\n    }));\n    return dedupeLinkDescriptors(links.flat(1).filter(isHtmlLinkDescriptor).filter((link)=>link.rel === \"stylesheet\" || link.rel === \"preload\").map((link)=>link.rel === \"stylesheet\" ? {\n            ...link,\n            rel: \"prefetch\",\n            as: \"style\"\n        } : {\n            ...link,\n            rel: \"prefetch\"\n        }));\n}\nfunction getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {\n    let isNew = (match, index)=>{\n        if (!currentMatches[index]) return true;\n        return match.route.id !== currentMatches[index].route.id;\n    };\n    let matchPathChanged = (match, index)=>{\n        return(// param change, /users/123 -> /users/456\n        currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path\n        // e.g. /files/images/avatar.jpg -> files/finances.xls\n        currentMatches[index].route.path?.endsWith(\"*\") && currentMatches[index].params[\"*\"] !== match.params[\"*\"]);\n    };\n    if (mode === \"assets\") {\n        return nextMatches.filter((match, index)=>isNew(match, index) || matchPathChanged(match, index));\n    }\n    if (mode === \"data\") {\n        return nextMatches.filter((match, index)=>{\n            let manifestRoute = manifest.routes[match.route.id];\n            if (!manifestRoute || !manifestRoute.hasLoader) {\n                return false;\n            }\n            if (isNew(match, index) || matchPathChanged(match, index)) {\n                return true;\n            }\n            if (match.route.shouldRevalidate) {\n                let routeChoice = match.route.shouldRevalidate({\n                    currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),\n                    currentParams: currentMatches[0]?.params || {},\n                    nextUrl: new URL(page, window.origin),\n                    nextParams: match.params,\n                    defaultShouldRevalidate: true\n                });\n                if (typeof routeChoice === \"boolean\") {\n                    return routeChoice;\n                }\n            }\n            return true;\n        });\n    }\n    return [];\n}\nfunction getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {\n    return dedupeHrefs(matches.map((match)=>{\n        let route = manifest.routes[match.route.id];\n        if (!route) return [];\n        let hrefs = [\n            route.module\n        ];\n        if (route.clientActionModule) {\n            hrefs = hrefs.concat(route.clientActionModule);\n        }\n        if (route.clientLoaderModule) {\n            hrefs = hrefs.concat(route.clientLoaderModule);\n        }\n        if (includeHydrateFallback && route.hydrateFallbackModule) {\n            hrefs = hrefs.concat(route.hydrateFallbackModule);\n        }\n        if (route.imports) {\n            hrefs = hrefs.concat(route.imports);\n        }\n        return hrefs;\n    }).flat(1));\n}\nfunction dedupeHrefs(hrefs) {\n    return [\n        ...new Set(hrefs)\n    ];\n}\nfunction sortKeys(obj) {\n    let sorted = {};\n    let keys = Object.keys(obj).sort();\n    for (let key of keys){\n        sorted[key] = obj[key];\n    }\n    return sorted;\n}\nfunction dedupeLinkDescriptors(descriptors, preloads) {\n    let set = /* @__PURE__ */ new Set();\n    let preloadsSet = new Set(preloads);\n    return descriptors.reduce((deduped, descriptor)=>{\n        let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === \"script\" && descriptor.href && preloadsSet.has(descriptor.href);\n        if (alreadyModulePreload) {\n            return deduped;\n        }\n        let key = JSON.stringify(sortKeys(descriptor));\n        if (!set.has(key)) {\n            set.add(key);\n            deduped.push({\n                key,\n                link: descriptor\n            });\n        }\n        return deduped;\n    }, []);\n}\nvar _isPreloadSupported;\nfunction isPreloadSupported() {\n    if (_isPreloadSupported !== void 0) {\n        return _isPreloadSupported;\n    }\n    let el = document.createElement(\"link\");\n    _isPreloadSupported = el.relList.supports(\"preload\");\n    el = null;\n    return _isPreloadSupported;\n}\n// lib/dom/ssr/markup.ts\nvar ESCAPE_LOOKUP = {\n    \"&\": \"\\\\u0026\",\n    \">\": \"\\\\u003e\",\n    \"<\": \"\\\\u003c\",\n    \"\\u2028\": \"\\\\u2028\",\n    \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml(html) {\n    return html.replace(ESCAPE_REGEX, (match)=>ESCAPE_LOOKUP[match]);\n}\nfunction createHtml(html) {\n    return {\n        __html: html\n    };\n}\n// lib/dom/ssr/single-fetch.tsx\nvar React4 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// vendor/turbo-stream-v2/utils.ts\nvar HOLE = -1;\nvar NAN = -2;\nvar NEGATIVE_INFINITY = -3;\nvar NEGATIVE_ZERO = -4;\nvar NULL = -5;\nvar POSITIVE_INFINITY = -6;\nvar UNDEFINED = -7;\nvar TYPE_BIGINT = \"B\";\nvar TYPE_DATE = \"D\";\nvar TYPE_ERROR = \"E\";\nvar TYPE_MAP = \"M\";\nvar TYPE_NULL_OBJECT = \"N\";\nvar TYPE_PROMISE = \"P\";\nvar TYPE_REGEXP = \"R\";\nvar TYPE_SET = \"S\";\nvar TYPE_SYMBOL = \"Y\";\nvar TYPE_URL = \"U\";\nvar TYPE_PREVIOUS_RESOLVED = \"Z\";\nvar Deferred2 = class {\n    constructor(){\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n};\nfunction createLineSplittingTransform() {\n    const decoder = new TextDecoder();\n    let leftover = \"\";\n    return new TransformStream({\n        transform (chunk, controller) {\n            const str = decoder.decode(chunk, {\n                stream: true\n            });\n            const parts = (leftover + str).split(\"\\n\");\n            leftover = parts.pop() || \"\";\n            for (const part of parts){\n                controller.enqueue(part);\n            }\n        },\n        flush (controller) {\n            if (leftover) {\n                controller.enqueue(leftover);\n            }\n        }\n    });\n}\n// vendor/turbo-stream-v2/flatten.ts\nfunction flatten(input) {\n    const { indices } = this;\n    const existing = indices.get(input);\n    if (existing) return [\n        existing\n    ];\n    if (input === void 0) return UNDEFINED;\n    if (input === null) return NULL;\n    if (Number.isNaN(input)) return NAN;\n    if (input === Number.POSITIVE_INFINITY) return POSITIVE_INFINITY;\n    if (input === Number.NEGATIVE_INFINITY) return NEGATIVE_INFINITY;\n    if (input === 0 && 1 / input < 0) return NEGATIVE_ZERO;\n    const index = this.index++;\n    indices.set(input, index);\n    stringify.call(this, input, index);\n    return index;\n}\nfunction stringify(input, index) {\n    const { deferred, plugins, postPlugins } = this;\n    const str = this.stringified;\n    const stack = [\n        [\n            input,\n            index\n        ]\n    ];\n    while(stack.length > 0){\n        const [input2, index2] = stack.pop();\n        const partsForObj = (obj)=>Object.keys(obj).map((k)=>`\"_${flatten.call(this, k)}\":${flatten.call(this, obj[k])}`).join(\",\");\n        let error = null;\n        switch(typeof input2){\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                str[index2] = JSON.stringify(input2);\n                break;\n            case \"bigint\":\n                str[index2] = `[\"${TYPE_BIGINT}\",\"${input2}\"]`;\n                break;\n            case \"symbol\":\n                {\n                    const keyFor = Symbol.keyFor(input2);\n                    if (!keyFor) {\n                        error = new Error(\"Cannot encode symbol unless created with Symbol.for()\");\n                    } else {\n                        str[index2] = `[\"${TYPE_SYMBOL}\",${JSON.stringify(keyFor)}]`;\n                    }\n                    break;\n                }\n            case \"object\":\n                {\n                    if (!input2) {\n                        str[index2] = `${NULL}`;\n                        break;\n                    }\n                    const isArray = Array.isArray(input2);\n                    let pluginHandled = false;\n                    if (!isArray && plugins) {\n                        for (const plugin of plugins){\n                            const pluginResult = plugin(input2);\n                            if (Array.isArray(pluginResult)) {\n                                pluginHandled = true;\n                                const [pluginIdentifier, ...rest] = pluginResult;\n                                str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n                                if (rest.length > 0) {\n                                    str[index2] += `,${rest.map((v)=>flatten.call(this, v)).join(\",\")}`;\n                                }\n                                str[index2] += \"]\";\n                                break;\n                            }\n                        }\n                    }\n                    if (!pluginHandled) {\n                        let result = isArray ? \"[\" : \"{\";\n                        if (isArray) {\n                            for(let i = 0; i < input2.length; i++)result += (i ? \",\" : \"\") + (i in input2 ? flatten.call(this, input2[i]) : HOLE);\n                            str[index2] = `${result}]`;\n                        } else if (input2 instanceof Date) {\n                            str[index2] = `[\"${TYPE_DATE}\",${input2.getTime()}]`;\n                        } else if (input2 instanceof URL) {\n                            str[index2] = `[\"${TYPE_URL}\",${JSON.stringify(input2.href)}]`;\n                        } else if (input2 instanceof RegExp) {\n                            str[index2] = `[\"${TYPE_REGEXP}\",${JSON.stringify(input2.source)},${JSON.stringify(input2.flags)}]`;\n                        } else if (input2 instanceof Set) {\n                            if (input2.size > 0) {\n                                str[index2] = `[\"${TYPE_SET}\",${[\n                                    ...input2\n                                ].map((val)=>flatten.call(this, val)).join(\",\")}]`;\n                            } else {\n                                str[index2] = `[\"${TYPE_SET}\"]`;\n                            }\n                        } else if (input2 instanceof Map) {\n                            if (input2.size > 0) {\n                                str[index2] = `[\"${TYPE_MAP}\",${[\n                                    ...input2\n                                ].flatMap(([k, v])=>[\n                                        flatten.call(this, k),\n                                        flatten.call(this, v)\n                                    ]).join(\",\")}]`;\n                            } else {\n                                str[index2] = `[\"${TYPE_MAP}\"]`;\n                            }\n                        } else if (input2 instanceof Promise) {\n                            str[index2] = `[\"${TYPE_PROMISE}\",${index2}]`;\n                            deferred[index2] = input2;\n                        } else if (input2 instanceof Error) {\n                            str[index2] = `[\"${TYPE_ERROR}\",${JSON.stringify(input2.message)}`;\n                            if (input2.name !== \"Error\") {\n                                str[index2] += `,${JSON.stringify(input2.name)}`;\n                            }\n                            str[index2] += \"]\";\n                        } else if (Object.getPrototypeOf(input2) === null) {\n                            str[index2] = `[\"${TYPE_NULL_OBJECT}\",{${partsForObj(input2)}}]`;\n                        } else if (isPlainObject(input2)) {\n                            str[index2] = `{${partsForObj(input2)}}`;\n                        } else {\n                            error = new Error(\"Cannot encode object with prototype\");\n                        }\n                    }\n                    break;\n                }\n            default:\n                {\n                    const isArray = Array.isArray(input2);\n                    let pluginHandled = false;\n                    if (!isArray && plugins) {\n                        for (const plugin of plugins){\n                            const pluginResult = plugin(input2);\n                            if (Array.isArray(pluginResult)) {\n                                pluginHandled = true;\n                                const [pluginIdentifier, ...rest] = pluginResult;\n                                str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n                                if (rest.length > 0) {\n                                    str[index2] += `,${rest.map((v)=>flatten.call(this, v)).join(\",\")}`;\n                                }\n                                str[index2] += \"]\";\n                                break;\n                            }\n                        }\n                    }\n                    if (!pluginHandled) {\n                        error = new Error(\"Cannot encode function or unexpected type\");\n                    }\n                }\n        }\n        if (error) {\n            let pluginHandled = false;\n            if (postPlugins) {\n                for (const plugin of postPlugins){\n                    const pluginResult = plugin(input2);\n                    if (Array.isArray(pluginResult)) {\n                        pluginHandled = true;\n                        const [pluginIdentifier, ...rest] = pluginResult;\n                        str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n                        if (rest.length > 0) {\n                            str[index2] += `,${rest.map((v)=>flatten.call(this, v)).join(\",\")}`;\n                        }\n                        str[index2] += \"]\";\n                        break;\n                    }\n                }\n            }\n            if (!pluginHandled) {\n                throw error;\n            }\n        }\n    }\n}\nvar objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(\"\\x00\");\nfunction isPlainObject(thing) {\n    const proto = Object.getPrototypeOf(thing);\n    return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(\"\\x00\") === objectProtoNames;\n}\n// vendor/turbo-stream-v2/unflatten.ts\nvar globalObj =  false ? 0 : typeof globalThis !== \"undefined\" ? globalThis : void 0;\nfunction unflatten(parsed) {\n    const { hydrated, values } = this;\n    if (typeof parsed === \"number\") return hydrate.call(this, parsed);\n    if (!Array.isArray(parsed) || !parsed.length) throw new SyntaxError();\n    const startIndex = values.length;\n    for (const value of parsed){\n        values.push(value);\n    }\n    hydrated.length = values.length;\n    return hydrate.call(this, startIndex);\n}\nfunction hydrate(index) {\n    const { hydrated, values, deferred, plugins } = this;\n    let result;\n    const stack = [\n        [\n            index,\n            (v)=>{\n                result = v;\n            }\n        ]\n    ];\n    let postRun = [];\n    while(stack.length > 0){\n        const [index2, set] = stack.pop();\n        switch(index2){\n            case UNDEFINED:\n                set(void 0);\n                continue;\n            case NULL:\n                set(null);\n                continue;\n            case NAN:\n                set(NaN);\n                continue;\n            case POSITIVE_INFINITY:\n                set(Infinity);\n                continue;\n            case NEGATIVE_INFINITY:\n                set(-Infinity);\n                continue;\n            case NEGATIVE_ZERO:\n                set(-0);\n                continue;\n        }\n        if (hydrated[index2]) {\n            set(hydrated[index2]);\n            continue;\n        }\n        const value = values[index2];\n        if (!value || typeof value !== \"object\") {\n            hydrated[index2] = value;\n            set(value);\n            continue;\n        }\n        if (Array.isArray(value)) {\n            if (typeof value[0] === \"string\") {\n                const [type, b, c] = value;\n                switch(type){\n                    case TYPE_DATE:\n                        set(hydrated[index2] = new Date(b));\n                        continue;\n                    case TYPE_URL:\n                        set(hydrated[index2] = new URL(b));\n                        continue;\n                    case TYPE_BIGINT:\n                        set(hydrated[index2] = BigInt(b));\n                        continue;\n                    case TYPE_REGEXP:\n                        set(hydrated[index2] = new RegExp(b, c));\n                        continue;\n                    case TYPE_SYMBOL:\n                        set(hydrated[index2] = Symbol.for(b));\n                        continue;\n                    case TYPE_SET:\n                        const newSet = /* @__PURE__ */ new Set();\n                        hydrated[index2] = newSet;\n                        for(let i = value.length - 1; i > 0; i--)stack.push([\n                            value[i],\n                            (v)=>{\n                                newSet.add(v);\n                            }\n                        ]);\n                        set(newSet);\n                        continue;\n                    case TYPE_MAP:\n                        const map = /* @__PURE__ */ new Map();\n                        hydrated[index2] = map;\n                        for(let i = value.length - 2; i > 0; i -= 2){\n                            const r = [];\n                            stack.push([\n                                value[i + 1],\n                                (v)=>{\n                                    r[1] = v;\n                                }\n                            ]);\n                            stack.push([\n                                value[i],\n                                (k)=>{\n                                    r[0] = k;\n                                }\n                            ]);\n                            postRun.push(()=>{\n                                map.set(r[0], r[1]);\n                            });\n                        }\n                        set(map);\n                        continue;\n                    case TYPE_NULL_OBJECT:\n                        const obj = /* @__PURE__ */ Object.create(null);\n                        hydrated[index2] = obj;\n                        for (const key of Object.keys(b).reverse()){\n                            const r = [];\n                            stack.push([\n                                b[key],\n                                (v)=>{\n                                    r[1] = v;\n                                }\n                            ]);\n                            stack.push([\n                                Number(key.slice(1)),\n                                (k)=>{\n                                    r[0] = k;\n                                }\n                            ]);\n                            postRun.push(()=>{\n                                obj[r[0]] = r[1];\n                            });\n                        }\n                        set(obj);\n                        continue;\n                    case TYPE_PROMISE:\n                        if (hydrated[b]) {\n                            set(hydrated[index2] = hydrated[b]);\n                        } else {\n                            const d = new Deferred2();\n                            deferred[b] = d;\n                            set(hydrated[index2] = d.promise);\n                        }\n                        continue;\n                    case TYPE_ERROR:\n                        const [, message, errorType] = value;\n                        let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);\n                        hydrated[index2] = error;\n                        set(error);\n                        continue;\n                    case TYPE_PREVIOUS_RESOLVED:\n                        set(hydrated[index2] = hydrated[b]);\n                        continue;\n                    default:\n                        if (Array.isArray(plugins)) {\n                            const r = [];\n                            const vals = value.slice(1);\n                            for(let i = 0; i < vals.length; i++){\n                                const v = vals[i];\n                                stack.push([\n                                    v,\n                                    (v2)=>{\n                                        r[i] = v2;\n                                    }\n                                ]);\n                            }\n                            postRun.push(()=>{\n                                for (const plugin of plugins){\n                                    const result2 = plugin(value[0], ...r);\n                                    if (result2) {\n                                        set(hydrated[index2] = result2.value);\n                                        return;\n                                    }\n                                }\n                                throw new SyntaxError();\n                            });\n                            continue;\n                        }\n                        throw new SyntaxError();\n                }\n            } else {\n                const array = [];\n                hydrated[index2] = array;\n                for(let i = 0; i < value.length; i++){\n                    const n = value[i];\n                    if (n !== HOLE) {\n                        stack.push([\n                            n,\n                            (v)=>{\n                                array[i] = v;\n                            }\n                        ]);\n                    }\n                }\n                set(array);\n                continue;\n            }\n        } else {\n            const object = {};\n            hydrated[index2] = object;\n            for (const key of Object.keys(value).reverse()){\n                const r = [];\n                stack.push([\n                    value[key],\n                    (v)=>{\n                        r[1] = v;\n                    }\n                ]);\n                stack.push([\n                    Number(key.slice(1)),\n                    (k)=>{\n                        r[0] = k;\n                    }\n                ]);\n                postRun.push(()=>{\n                    object[r[0]] = r[1];\n                });\n            }\n            set(object);\n            continue;\n        }\n    }\n    while(postRun.length > 0){\n        postRun.pop()();\n    }\n    return result;\n}\n// vendor/turbo-stream-v2/turbo-stream.ts\nasync function decode(readable, options) {\n    const { plugins } = options ?? {};\n    const done = new Deferred2();\n    const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();\n    const decoder = {\n        values: [],\n        hydrated: [],\n        deferred: {},\n        plugins\n    };\n    const decoded = await decodeInitial.call(decoder, reader);\n    let donePromise = done.promise;\n    if (decoded.done) {\n        done.resolve();\n    } else {\n        donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason)=>{\n            for (const deferred of Object.values(decoder.deferred)){\n                deferred.reject(reason);\n            }\n            done.reject(reason);\n        });\n    }\n    return {\n        done: donePromise.then(()=>reader.closed),\n        value: decoded.value\n    };\n}\nasync function decodeInitial(reader) {\n    const read = await reader.read();\n    if (!read.value) {\n        throw new SyntaxError();\n    }\n    let line;\n    try {\n        line = JSON.parse(read.value);\n    } catch (reason) {\n        throw new SyntaxError();\n    }\n    return {\n        done: read.done,\n        value: unflatten.call(this, line)\n    };\n}\nasync function decodeDeferred(reader) {\n    let read = await reader.read();\n    while(!read.done){\n        if (!read.value) continue;\n        const line = read.value;\n        switch(line[0]){\n            case TYPE_PROMISE:\n                {\n                    const colonIndex = line.indexOf(\":\");\n                    const deferredId = Number(line.slice(1, colonIndex));\n                    const deferred = this.deferred[deferredId];\n                    if (!deferred) {\n                        throw new Error(`Deferred ID ${deferredId} not found in stream`);\n                    }\n                    const lineData = line.slice(colonIndex + 1);\n                    let jsonLine;\n                    try {\n                        jsonLine = JSON.parse(lineData);\n                    } catch (reason) {\n                        throw new SyntaxError();\n                    }\n                    const value = unflatten.call(this, jsonLine);\n                    deferred.resolve(value);\n                    break;\n                }\n            case TYPE_ERROR:\n                {\n                    const colonIndex = line.indexOf(\":\");\n                    const deferredId = Number(line.slice(1, colonIndex));\n                    const deferred = this.deferred[deferredId];\n                    if (!deferred) {\n                        throw new Error(`Deferred ID ${deferredId} not found in stream`);\n                    }\n                    const lineData = line.slice(colonIndex + 1);\n                    let jsonLine;\n                    try {\n                        jsonLine = JSON.parse(lineData);\n                    } catch (reason) {\n                        throw new SyntaxError();\n                    }\n                    const value = unflatten.call(this, jsonLine);\n                    deferred.reject(value);\n                    break;\n                }\n            default:\n                throw new SyntaxError();\n        }\n        read = await reader.read();\n    }\n}\nfunction encode(input, options) {\n    const { plugins, postPlugins, signal } = options ?? {};\n    const encoder2 = {\n        deferred: {},\n        index: 0,\n        indices: /* @__PURE__ */ new Map(),\n        stringified: [],\n        plugins,\n        postPlugins,\n        signal\n    };\n    const textEncoder = new TextEncoder();\n    let lastSentIndex = 0;\n    const readable = new ReadableStream({\n        async start (controller) {\n            const id = flatten.call(encoder2, input);\n            if (Array.isArray(id)) {\n                throw new Error(\"This should never happen\");\n            }\n            if (id < 0) {\n                controller.enqueue(textEncoder.encode(`${id}\n`));\n            } else {\n                controller.enqueue(textEncoder.encode(`[${encoder2.stringified.join(\",\")}]\n`));\n                lastSentIndex = encoder2.stringified.length - 1;\n            }\n            const seenPromises = /* @__PURE__ */ new WeakSet();\n            if (Object.keys(encoder2.deferred).length) {\n                let raceDone;\n                const racePromise = new Promise((resolve, reject)=>{\n                    raceDone = resolve;\n                    if (signal) {\n                        const rejectPromise = ()=>reject(signal.reason || new Error(\"Signal was aborted.\"));\n                        if (signal.aborted) {\n                            rejectPromise();\n                        } else {\n                            signal.addEventListener(\"abort\", (event)=>{\n                                rejectPromise();\n                            });\n                        }\n                    }\n                });\n                while(Object.keys(encoder2.deferred).length > 0){\n                    for (const [deferredId, deferred] of Object.entries(encoder2.deferred)){\n                        if (seenPromises.has(deferred)) continue;\n                        seenPromises.add(// biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n                        encoder2.deferred[Number(deferredId)] = Promise.race([\n                            racePromise,\n                            deferred\n                        ]).then((resolved)=>{\n                            const id2 = flatten.call(encoder2, resolved);\n                            if (Array.isArray(id2)) {\n                                controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`));\n                                encoder2.index++;\n                                lastSentIndex++;\n                            } else if (id2 < 0) {\n                                controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}\n`));\n                            } else {\n                                const values = encoder2.stringified.slice(lastSentIndex + 1).join(\",\");\n                                controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[${values}]\n`));\n                                lastSentIndex = encoder2.stringified.length - 1;\n                            }\n                        }, (reason)=>{\n                            if (!reason || typeof reason !== \"object\" || !(reason instanceof Error)) {\n                                reason = new Error(\"An unknown error occurred\");\n                            }\n                            const id2 = flatten.call(encoder2, reason);\n                            if (Array.isArray(id2)) {\n                                controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`));\n                                encoder2.index++;\n                                lastSentIndex++;\n                            } else if (id2 < 0) {\n                                controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}\n`));\n                            } else {\n                                const values = encoder2.stringified.slice(lastSentIndex + 1).join(\",\");\n                                controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[${values}]\n`));\n                                lastSentIndex = encoder2.stringified.length - 1;\n                            }\n                        }).finally(()=>{\n                            delete encoder2.deferred[Number(deferredId)];\n                        }));\n                    }\n                    await Promise.race(Object.values(encoder2.deferred));\n                }\n                raceDone();\n            }\n            await Promise.all(Object.values(encoder2.deferred));\n            controller.close();\n        }\n    });\n    return readable;\n}\n// lib/dom/ssr/data.ts\nasync function createRequestInit(request) {\n    let init = {\n        signal: request.signal\n    };\n    if (request.method !== \"GET\") {\n        init.method = request.method;\n        let contentType = request.headers.get(\"Content-Type\");\n        if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n            init.headers = {\n                \"Content-Type\": contentType\n            };\n            init.body = JSON.stringify(await request.json());\n        } else if (contentType && /\\btext\\/plain\\b/.test(contentType)) {\n            init.headers = {\n                \"Content-Type\": contentType\n            };\n            init.body = await request.text();\n        } else if (contentType && /\\bapplication\\/x-www-form-urlencoded\\b/.test(contentType)) {\n            init.body = new URLSearchParams(await request.text());\n        } else {\n            init.body = await request.formData();\n        }\n    }\n    return init;\n}\n// lib/dom/ssr/single-fetch.tsx\nvar SingleFetchRedirectSymbol = Symbol(\"SingleFetchRedirect\");\nvar SingleFetchNoResultError = class extends Error {\n};\nvar SINGLE_FETCH_REDIRECT_STATUS = 202;\nvar NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([\n    100,\n    101,\n    204,\n    205\n]);\nfunction StreamTransfer({ context, identifier, reader, textDecoder, nonce }) {\n    if (!context.renderMeta || !context.renderMeta.didRenderScripts) {\n        return null;\n    }\n    if (!context.renderMeta.streamCache) {\n        context.renderMeta.streamCache = {};\n    }\n    let { streamCache } = context.renderMeta;\n    let promise = streamCache[identifier];\n    if (!promise) {\n        promise = streamCache[identifier] = reader.read().then((result)=>{\n            streamCache[identifier].result = {\n                done: result.done,\n                value: textDecoder.decode(result.value, {\n                    stream: true\n                })\n            };\n        }).catch((e)=>{\n            streamCache[identifier].error = e;\n        });\n    }\n    if (promise.error) {\n        throw promise.error;\n    }\n    if (promise.result === void 0) {\n        throw promise;\n    }\n    let { done, value } = promise.result;\n    let scriptTag = value ? /* @__PURE__ */ React4.createElement(\"script\", {\n        nonce,\n        dangerouslySetInnerHTML: {\n            __html: `window.__reactRouterContext.streamController.enqueue(${escapeHtml(JSON.stringify(value))});`\n        }\n    }) : null;\n    if (done) {\n        return /* @__PURE__ */ React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */ React4.createElement(\"script\", {\n            nonce,\n            dangerouslySetInnerHTML: {\n                __html: `window.__reactRouterContext.streamController.close();`\n            }\n        }));\n    } else {\n        return /* @__PURE__ */ React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */ React4.createElement(React4.Suspense, null, /* @__PURE__ */ React4.createElement(StreamTransfer, {\n            context,\n            identifier: identifier + 1,\n            reader,\n            textDecoder,\n            nonce\n        })));\n    }\n}\nfunction getTurboStreamSingleFetchDataStrategy(getRouter, manifest, routeModules, ssr, basename) {\n    let dataStrategy = getSingleFetchDataStrategyImpl(getRouter, (match)=>{\n        let manifestRoute = manifest.routes[match.route.id];\n        invariant2(manifestRoute, \"Route not found in manifest\");\n        let routeModule = routeModules[match.route.id];\n        return {\n            hasLoader: manifestRoute.hasLoader,\n            hasClientLoader: manifestRoute.hasClientLoader,\n            hasShouldRevalidate: Boolean(routeModule?.shouldRevalidate)\n        };\n    }, fetchAndDecodeViaTurboStream, ssr, basename);\n    return async (args)=>args.unstable_runClientMiddleware(dataStrategy);\n}\nfunction getSingleFetchDataStrategyImpl(getRouter, getRouteInfo, fetchAndDecode, ssr, basename) {\n    return async (args)=>{\n        let { request, matches, fetcherKey } = args;\n        let router = getRouter();\n        if (request.method !== \"GET\") {\n            return singleFetchActionStrategy(args, fetchAndDecode, basename);\n        }\n        let foundRevalidatingServerLoader = matches.some((m)=>{\n            let { hasLoader, hasClientLoader } = getRouteInfo(m);\n            return m.unstable_shouldCallHandler() && hasLoader && !hasClientLoader;\n        });\n        if (!ssr && !foundRevalidatingServerLoader) {\n            return nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename);\n        }\n        if (fetcherKey) {\n            return singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename);\n        }\n        return singleFetchLoaderNavigationStrategy(args, router, getRouteInfo, fetchAndDecode, ssr, basename);\n    };\n}\nasync function singleFetchActionStrategy(args, fetchAndDecode, basename) {\n    let actionMatch = args.matches.find((m)=>m.unstable_shouldCallHandler());\n    invariant2(actionMatch, \"No action match found\");\n    let actionStatus = void 0;\n    let result = await actionMatch.resolve(async (handler)=>{\n        let result2 = await handler(async ()=>{\n            let { data: data2, status } = await fetchAndDecode(args, basename, [\n                actionMatch.route.id\n            ]);\n            actionStatus = status;\n            return unwrapSingleFetchResult(data2, actionMatch.route.id);\n        });\n        return result2;\n    });\n    if (isResponse(result.result) || isRouteErrorResponse(result.result) || isDataWithResponseInit(result.result)) {\n        return {\n            [actionMatch.route.id]: result\n        };\n    }\n    return {\n        [actionMatch.route.id]: {\n            type: result.type,\n            result: data(result.result, actionStatus)\n        }\n    };\n}\nasync function nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename) {\n    let matchesToLoad = args.matches.filter((m)=>m.unstable_shouldCallHandler());\n    let results = {};\n    await Promise.all(matchesToLoad.map((m)=>m.resolve(async (handler)=>{\n            try {\n                let { hasClientLoader } = getRouteInfo(m);\n                let routeId = m.route.id;\n                let result = hasClientLoader ? await handler(async ()=>{\n                    let { data: data2 } = await fetchAndDecode(args, basename, [\n                        routeId\n                    ]);\n                    return unwrapSingleFetchResult(data2, routeId);\n                }) : await handler();\n                results[m.route.id] = {\n                    type: \"data\",\n                    result\n                };\n            } catch (e) {\n                results[m.route.id] = {\n                    type: \"error\",\n                    result: e\n                };\n            }\n        })));\n    return results;\n}\nasync function singleFetchLoaderNavigationStrategy(args, router, getRouteInfo, fetchAndDecode, ssr, basename) {\n    let routesParams = /* @__PURE__ */ new Set();\n    let foundOptOutRoute = false;\n    let routeDfds = args.matches.map(()=>createDeferred2());\n    let singleFetchDfd = createDeferred2();\n    let results = {};\n    let resolvePromise = Promise.all(args.matches.map(async (m, i)=>m.resolve(async (handler)=>{\n            routeDfds[i].resolve();\n            let routeId = m.route.id;\n            let { hasLoader, hasClientLoader, hasShouldRevalidate } = getRouteInfo(m);\n            let defaultShouldRevalidate = !m.unstable_shouldRevalidateArgs || m.unstable_shouldRevalidateArgs.actionStatus == null || m.unstable_shouldRevalidateArgs.actionStatus < 400;\n            let shouldCall = m.unstable_shouldCallHandler(defaultShouldRevalidate);\n            if (!shouldCall) {\n                foundOptOutRoute || (foundOptOutRoute = m.unstable_shouldRevalidateArgs != null && // This is a revalidation,\n                hasLoader && // for a route with a server loader,\n                hasShouldRevalidate === true);\n                return;\n            }\n            if (hasClientLoader) {\n                if (hasLoader) {\n                    foundOptOutRoute = true;\n                }\n                try {\n                    let result = await handler(async ()=>{\n                        let { data: data2 } = await fetchAndDecode(args, basename, [\n                            routeId\n                        ]);\n                        return unwrapSingleFetchResult(data2, routeId);\n                    });\n                    results[routeId] = {\n                        type: \"data\",\n                        result\n                    };\n                } catch (e) {\n                    results[routeId] = {\n                        type: \"error\",\n                        result: e\n                    };\n                }\n                return;\n            }\n            if (hasLoader) {\n                routesParams.add(routeId);\n            }\n            try {\n                let result = await handler(async ()=>{\n                    let data2 = await singleFetchDfd.promise;\n                    return unwrapSingleFetchResult(data2, routeId);\n                });\n                results[routeId] = {\n                    type: \"data\",\n                    result\n                };\n            } catch (e) {\n                results[routeId] = {\n                    type: \"error\",\n                    result: e\n                };\n            }\n        })));\n    await Promise.all(routeDfds.map((d)=>d.promise));\n    let isInitialLoad = !router.state.initialized && router.state.navigation.state === \"idle\";\n    if ((isInitialLoad || routesParams.size === 0) && !window.__reactRouterHdrActive) {\n        singleFetchDfd.resolve({\n            routes: {}\n        });\n    } else {\n        let targetRoutes = ssr && foundOptOutRoute && routesParams.size > 0 ? [\n            ...routesParams.keys()\n        ] : void 0;\n        try {\n            let data2 = await fetchAndDecode(args, basename, targetRoutes);\n            singleFetchDfd.resolve(data2.data);\n        } catch (e) {\n            singleFetchDfd.reject(e);\n        }\n    }\n    await resolvePromise;\n    await bubbleMiddlewareErrors(singleFetchDfd.promise, args.matches, routesParams, results);\n    return results;\n}\nasync function bubbleMiddlewareErrors(singleFetchPromise, matches, routesParams, results) {\n    try {\n        let middlewareError;\n        let fetchedData = await singleFetchPromise;\n        if (\"routes\" in fetchedData) {\n            for (let match of matches){\n                if (match.route.id in fetchedData.routes) {\n                    let routeResult = fetchedData.routes[match.route.id];\n                    if (\"error\" in routeResult) {\n                        middlewareError = routeResult.error;\n                        break;\n                    }\n                }\n            }\n        }\n        if (middlewareError !== void 0) {\n            Array.from(routesParams.values()).forEach((routeId)=>{\n                if (results[routeId].result instanceof SingleFetchNoResultError) {\n                    results[routeId].result = middlewareError;\n                }\n            });\n        }\n    } catch (e) {}\n}\nasync function singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename) {\n    let fetcherMatch = args.matches.find((m)=>m.unstable_shouldCallHandler());\n    invariant2(fetcherMatch, \"No fetcher match found\");\n    let routeId = fetcherMatch.route.id;\n    let result = await fetcherMatch.resolve(async (handler)=>handler(async ()=>{\n            let { data: data2 } = await fetchAndDecode(args, basename, [\n                routeId\n            ]);\n            return unwrapSingleFetchResult(data2, routeId);\n        }));\n    return {\n        [fetcherMatch.route.id]: result\n    };\n}\nfunction stripIndexParam(url) {\n    let indexValues = url.searchParams.getAll(\"index\");\n    url.searchParams.delete(\"index\");\n    let indexValuesToKeep = [];\n    for (let indexValue of indexValues){\n        if (indexValue) {\n            indexValuesToKeep.push(indexValue);\n        }\n    }\n    for (let toKeep of indexValuesToKeep){\n        url.searchParams.append(\"index\", toKeep);\n    }\n    return url;\n}\nfunction singleFetchUrl(reqUrl, basename) {\n    let url = typeof reqUrl === \"string\" ? new URL(reqUrl, // This can be called during the SSR flow via PrefetchPageLinksImpl so\n    // don't assume window is available\n     true ? \"server://singlefetch/\" : 0) : reqUrl;\n    if (url.pathname === \"/\") {\n        url.pathname = \"_root.data\";\n    } else if (basename && stripBasename(url.pathname, basename) === \"/\") {\n        url.pathname = `${basename.replace(/\\/$/, \"\")}/_root.data`;\n    } else {\n        url.pathname = `${url.pathname.replace(/\\/$/, \"\")}.data`;\n    }\n    return url;\n}\nasync function fetchAndDecodeViaTurboStream(args, basename, targetRoutes) {\n    let { request } = args;\n    let url = singleFetchUrl(request.url, basename);\n    if (request.method === \"GET\") {\n        url = stripIndexParam(url);\n        if (targetRoutes) {\n            url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\n        }\n    }\n    let res = await fetch(url, await createRequestInit(request));\n    if (res.status === 404 && !res.headers.has(\"X-Remix-Response\")) {\n        throw new ErrorResponseImpl(404, \"Not Found\", true);\n    }\n    if (res.status === 204 && res.headers.has(\"X-Remix-Redirect\")) {\n        return {\n            status: SINGLE_FETCH_REDIRECT_STATUS,\n            data: {\n                redirect: {\n                    redirect: res.headers.get(\"X-Remix-Redirect\"),\n                    status: Number(res.headers.get(\"X-Remix-Status\") || \"302\"),\n                    revalidate: res.headers.get(\"X-Remix-Revalidate\") === \"true\",\n                    reload: res.headers.get(\"X-Remix-Reload-Document\") === \"true\",\n                    replace: res.headers.get(\"X-Remix-Replace\") === \"true\"\n                }\n            }\n        };\n    }\n    if (NO_BODY_STATUS_CODES.has(res.status)) {\n        let routes = {};\n        if (targetRoutes && request.method !== \"GET\") {\n            routes[targetRoutes[0]] = {\n                data: void 0\n            };\n        }\n        return {\n            status: res.status,\n            data: {\n                routes\n            }\n        };\n    }\n    invariant2(res.body, \"No response body to decode\");\n    try {\n        let decoded = await decodeViaTurboStream(res.body, window);\n        let data2;\n        if (request.method === \"GET\") {\n            let typed = decoded.value;\n            if (SingleFetchRedirectSymbol in typed) {\n                data2 = {\n                    redirect: typed[SingleFetchRedirectSymbol]\n                };\n            } else {\n                data2 = {\n                    routes: typed\n                };\n            }\n        } else {\n            let typed = decoded.value;\n            let routeId = targetRoutes?.[0];\n            invariant2(routeId, \"No routeId found for single fetch call decoding\");\n            if (\"redirect\" in typed) {\n                data2 = {\n                    redirect: typed\n                };\n            } else {\n                data2 = {\n                    routes: {\n                        [routeId]: typed\n                    }\n                };\n            }\n        }\n        return {\n            status: res.status,\n            data: data2\n        };\n    } catch (e) {\n        throw new Error(\"Unable to decode turbo-stream response\");\n    }\n}\nfunction decodeViaTurboStream(body, global2) {\n    return decode(body, {\n        plugins: [\n            (type, ...rest)=>{\n                if (type === \"SanitizedError\") {\n                    let [name, message, stack] = rest;\n                    let Constructor = Error;\n                    if (name && name in global2 && typeof global2[name] === \"function\") {\n                        Constructor = global2[name];\n                    }\n                    let error = new Constructor(message);\n                    error.stack = stack;\n                    return {\n                        value: error\n                    };\n                }\n                if (type === \"ErrorResponse\") {\n                    let [data2, status, statusText] = rest;\n                    return {\n                        value: new ErrorResponseImpl(status, statusText, data2)\n                    };\n                }\n                if (type === \"SingleFetchRedirect\") {\n                    return {\n                        value: {\n                            [SingleFetchRedirectSymbol]: rest[0]\n                        }\n                    };\n                }\n                if (type === \"SingleFetchClassInstance\") {\n                    return {\n                        value: rest[0]\n                    };\n                }\n                if (type === \"SingleFetchFallback\") {\n                    return {\n                        value: void 0\n                    };\n                }\n            }\n        ]\n    });\n}\nfunction unwrapSingleFetchResult(result, routeId) {\n    if (\"redirect\" in result) {\n        let { redirect: location, revalidate, reload, replace: replace2, status } = result.redirect;\n        throw redirect(location, {\n            status,\n            headers: {\n                // Three R's of redirecting (lol Veep)\n                ...revalidate ? {\n                    \"X-Remix-Revalidate\": \"yes\"\n                } : null,\n                ...reload ? {\n                    \"X-Remix-Reload-Document\": \"yes\"\n                } : null,\n                ...replace2 ? {\n                    \"X-Remix-Replace\": \"yes\"\n                } : null\n            }\n        });\n    }\n    let routeResult = result.routes[routeId];\n    if (routeResult == null) {\n        throw new SingleFetchNoResultError(`No result found for routeId \"${routeId}\"`);\n    } else if (\"error\" in routeResult) {\n        throw routeResult.error;\n    } else if (\"data\" in routeResult) {\n        return routeResult.data;\n    } else {\n        throw new Error(`Invalid response found for routeId \"${routeId}\"`);\n    }\n}\nfunction createDeferred2() {\n    let resolve;\n    let reject;\n    let promise = new Promise((res, rej)=>{\n        resolve = async (val)=>{\n            res(val);\n            try {\n                await promise;\n            } catch (e) {}\n        };\n        reject = async (error)=>{\n            rej(error);\n            try {\n                await promise;\n            } catch (e) {}\n        };\n    });\n    return {\n        promise,\n        //@ts-ignore\n        resolve,\n        //@ts-ignore\n        reject\n    };\n}\n// lib/dom/ssr/fog-of-war.ts\nvar React8 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/dom/ssr/routes.tsx\nvar React7 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/dom/ssr/errorBoundaries.tsx\nvar React5 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar RemixErrorBoundary = class extends React5.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            error: props.error || null,\n            location: props.location\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        if (state.location !== props.location) {\n            return {\n                error: props.error || null,\n                location: props.location\n            };\n        }\n        return {\n            error: props.error || state.error,\n            location: state.location\n        };\n    }\n    render() {\n        if (this.state.error) {\n            return /* @__PURE__ */ React5.createElement(RemixRootDefaultErrorBoundary, {\n                error: this.state.error,\n                isOutsideRemixApp: true\n            });\n        } else {\n            return this.props.children;\n        }\n    }\n};\nfunction RemixRootDefaultErrorBoundary({ error, isOutsideRemixApp }) {\n    console.error(error);\n    let heyDeveloper = /* @__PURE__ */ React5.createElement(\"script\", {\n        dangerouslySetInnerHTML: {\n            __html: `\n        console.log(\n          \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information.\"\n        );\n      `\n        }\n    });\n    if (isRouteErrorResponse(error)) {\n        return /* @__PURE__ */ React5.createElement(BoundaryShell, {\n            title: \"Unhandled Thrown Response!\"\n        }, /* @__PURE__ */ React5.createElement(\"h1\", {\n            style: {\n                fontSize: \"24px\"\n            }\n        }, error.status, \" \", error.statusText), ENABLE_DEV_WARNINGS ? heyDeveloper : null);\n    }\n    let errorInstance;\n    if (error instanceof Error) {\n        errorInstance = error;\n    } else {\n        let errorString = error == null ? \"Unknown Error\" : typeof error === \"object\" && \"toString\" in error ? error.toString() : JSON.stringify(error);\n        errorInstance = new Error(errorString);\n    }\n    return /* @__PURE__ */ React5.createElement(BoundaryShell, {\n        title: \"Application Error!\",\n        isOutsideRemixApp\n    }, /* @__PURE__ */ React5.createElement(\"h1\", {\n        style: {\n            fontSize: \"24px\"\n        }\n    }, \"Application Error\"), /* @__PURE__ */ React5.createElement(\"pre\", {\n        style: {\n            padding: \"2rem\",\n            background: \"hsla(10, 50%, 50%, 0.1)\",\n            color: \"red\",\n            overflow: \"auto\"\n        }\n    }, errorInstance.stack), heyDeveloper);\n}\nfunction BoundaryShell({ title, renderScripts, isOutsideRemixApp, children }) {\n    let { routeModules } = useFrameworkContext();\n    if (routeModules.root?.Layout && !isOutsideRemixApp) {\n        return children;\n    }\n    return /* @__PURE__ */ React5.createElement(\"html\", {\n        lang: \"en\"\n    }, /* @__PURE__ */ React5.createElement(\"head\", null, /* @__PURE__ */ React5.createElement(\"meta\", {\n        charSet: \"utf-8\"\n    }), /* @__PURE__ */ React5.createElement(\"meta\", {\n        name: \"viewport\",\n        content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n    }), /* @__PURE__ */ React5.createElement(\"title\", null, title)), /* @__PURE__ */ React5.createElement(\"body\", null, /* @__PURE__ */ React5.createElement(\"main\", {\n        style: {\n            fontFamily: \"system-ui, sans-serif\",\n            padding: \"2rem\"\n        }\n    }, children, renderScripts ? /* @__PURE__ */ React5.createElement(Scripts, null) : null)));\n}\n// lib/dom/ssr/fallback.tsx\nvar React6 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction RemixRootDefaultHydrateFallback() {\n    return /* @__PURE__ */ React6.createElement(BoundaryShell, {\n        title: \"Loading...\",\n        renderScripts: true\n    }, ENABLE_DEV_WARNINGS ? /* @__PURE__ */ React6.createElement(\"script\", {\n        dangerouslySetInnerHTML: {\n            __html: `\n              console.log(\n                \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this \" +\n                \"when your app is loading JS modules and/or running \\`clientLoader\\` \" +\n                \"functions. Check out https://reactrouter.com/start/framework/route-module#hydratefallback \" +\n                \"for more information.\"\n              );\n            `\n        }\n    }) : null);\n}\n// lib/dom/ssr/routes.tsx\nfunction groupRoutesByParentId(manifest) {\n    let routes = {};\n    Object.values(manifest).forEach((route)=>{\n        if (route) {\n            let parentId = route.parentId || \"\";\n            if (!routes[parentId]) {\n                routes[parentId] = [];\n            }\n            routes[parentId].push(route);\n        }\n    });\n    return routes;\n}\nfunction getRouteComponents(route, routeModule, isSpaMode) {\n    let Component4 = getRouteModuleComponent(routeModule);\n    let HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === \"root\") ? routeModule.HydrateFallback : route.id === \"root\" ? RemixRootDefaultHydrateFallback : void 0;\n    let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === \"root\" ? ()=>/* @__PURE__ */ React7.createElement(RemixRootDefaultErrorBoundary, {\n            error: useRouteError()\n        }) : void 0;\n    if (route.id === \"root\" && routeModule.Layout) {\n        return {\n            ...Component4 ? {\n                element: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(Component4, null))\n            } : {\n                Component: Component4\n            },\n            ...ErrorBoundary ? {\n                errorElement: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(ErrorBoundary, null))\n            } : {\n                ErrorBoundary\n            },\n            ...HydrateFallback ? {\n                hydrateFallbackElement: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(HydrateFallback, null))\n            } : {\n                HydrateFallback\n            }\n        };\n    }\n    return {\n        Component: Component4,\n        ErrorBoundary,\n        HydrateFallback\n    };\n}\nfunction createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({\n    Component: ()=>null\n})) {\n    return (routesByParentId[parentId] || []).map((route)=>{\n        let routeModule = routeModules[route.id];\n        invariant2(routeModule, \"No `routeModule` available to create server routes\");\n        let dataRoute = {\n            ...getRouteComponents(route, routeModule, isSpaMode),\n            caseSensitive: route.caseSensitive,\n            id: route.id,\n            index: route.index,\n            path: route.path,\n            handle: routeModule.handle,\n            // For SPA Mode, all routes are lazy except root.  However we tell the\n            // router root is also lazy here too since we don't need a full\n            // implementation - we just need a `lazy` prop to tell the RR rendering\n            // where to stop which is always at the root route in SPA mode\n            lazy: isSpaMode ? ()=>spaModeLazyPromise : void 0,\n            // For partial hydration rendering, we need to indicate when the route\n            // has a loader/clientLoader, but it won't ever be called during the static\n            // render, so just give it a no-op function so we can render down to the\n            // proper fallback\n            loader: route.hasLoader || route.hasClientLoader ? ()=>null : void 0\n        };\n        let children = createServerRoutes(manifest, routeModules, future, isSpaMode, route.id, routesByParentId, spaModeLazyPromise);\n        if (children.length > 0) dataRoute.children = children;\n        return dataRoute;\n    });\n}\nfunction createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, ssr, isSpaMode) {\n    return createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, \"\", groupRoutesByParentId(manifest), needsRevalidation);\n}\nfunction preventInvalidServerHandlerCall(type, route) {\n    if (type === \"loader\" && !route.hasLoader || type === \"action\" && !route.hasAction) {\n        let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n        let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${route.id}\")`;\n        console.error(msg);\n        throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n    }\n}\nfunction noActionDefinedError(type, routeId) {\n    let article = type === \"clientAction\" ? \"a\" : \"an\";\n    let msg = `Route \"${routeId}\" does not have ${article} ${type}, but you are trying to submit to it. To fix this, please add ${article} \\`${type}\\` function to the route`;\n    console.error(msg);\n    throw new ErrorResponseImpl(405, \"Method Not Allowed\", new Error(msg), true);\n}\nfunction createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {\n    return (routesByParentId[parentId] || []).map((route)=>{\n        let routeModule = routeModulesCache[route.id];\n        function fetchServerHandler(singleFetch) {\n            invariant2(typeof singleFetch === \"function\", \"No single fetch function available for route handler\");\n            return singleFetch();\n        }\n        function fetchServerLoader(singleFetch) {\n            if (!route.hasLoader) return Promise.resolve(null);\n            return fetchServerHandler(singleFetch);\n        }\n        function fetchServerAction(singleFetch) {\n            if (!route.hasAction) {\n                throw noActionDefinedError(\"action\", route.id);\n            }\n            return fetchServerHandler(singleFetch);\n        }\n        function prefetchModule(modulePath) {\n            import(/* @vite-ignore */ /* webpackIgnore: true */ modulePath);\n        }\n        function prefetchRouteModuleChunks(route2) {\n            if (route2.clientActionModule) {\n                prefetchModule(route2.clientActionModule);\n            }\n            if (route2.clientLoaderModule) {\n                prefetchModule(route2.clientLoaderModule);\n            }\n        }\n        async function prefetchStylesAndCallHandler(handler) {\n            let cachedModule = routeModulesCache[route.id];\n            let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();\n            try {\n                return handler();\n            } finally{\n                await linkPrefetchPromise;\n            }\n        }\n        let dataRoute = {\n            id: route.id,\n            index: route.index,\n            path: route.path\n        };\n        if (routeModule) {\n            Object.assign(dataRoute, {\n                ...dataRoute,\n                ...getRouteComponents(route, routeModule, isSpaMode),\n                unstable_middleware: routeModule.unstable_clientMiddleware,\n                handle: routeModule.handle,\n                shouldRevalidate: getShouldRevalidateFunction(dataRoute.path, routeModule, route, ssr, needsRevalidation)\n            });\n            let hasInitialData = initialState && initialState.loaderData && route.id in initialState.loaderData;\n            let initialData = hasInitialData ? initialState?.loaderData?.[route.id] : void 0;\n            let hasInitialError = initialState && initialState.errors && route.id in initialState.errors;\n            let initialError = hasInitialError ? initialState?.errors?.[route.id] : void 0;\n            let isHydrationRequest = needsRevalidation == null && (routeModule.clientLoader?.hydrate === true || !route.hasLoader);\n            dataRoute.loader = async ({ request, params, context }, singleFetch)=>{\n                try {\n                    let result = await prefetchStylesAndCallHandler(async ()=>{\n                        invariant2(routeModule, \"No `routeModule` available for critical-route loader\");\n                        if (!routeModule.clientLoader) {\n                            return fetchServerLoader(singleFetch);\n                        }\n                        return routeModule.clientLoader({\n                            request,\n                            params,\n                            context,\n                            async serverLoader () {\n                                preventInvalidServerHandlerCall(\"loader\", route);\n                                if (isHydrationRequest) {\n                                    if (hasInitialData) {\n                                        return initialData;\n                                    }\n                                    if (hasInitialError) {\n                                        throw initialError;\n                                    }\n                                }\n                                return fetchServerLoader(singleFetch);\n                            }\n                        });\n                    });\n                    return result;\n                } finally{\n                    isHydrationRequest = false;\n                }\n            };\n            dataRoute.loader.hydrate = shouldHydrateRouteLoader(route.id, routeModule.clientLoader, route.hasLoader, isSpaMode);\n            dataRoute.action = ({ request, params, context }, singleFetch)=>{\n                return prefetchStylesAndCallHandler(async ()=>{\n                    invariant2(routeModule, \"No `routeModule` available for critical-route action\");\n                    if (!routeModule.clientAction) {\n                        if (isSpaMode) {\n                            throw noActionDefinedError(\"clientAction\", route.id);\n                        }\n                        return fetchServerAction(singleFetch);\n                    }\n                    return routeModule.clientAction({\n                        request,\n                        params,\n                        context,\n                        async serverAction () {\n                            preventInvalidServerHandlerCall(\"action\", route);\n                            return fetchServerAction(singleFetch);\n                        }\n                    });\n                });\n            };\n        } else {\n            if (!route.hasClientLoader) {\n                dataRoute.loader = (_, singleFetch)=>prefetchStylesAndCallHandler(()=>{\n                        return fetchServerLoader(singleFetch);\n                    });\n            }\n            if (!route.hasClientAction) {\n                dataRoute.action = (_, singleFetch)=>prefetchStylesAndCallHandler(()=>{\n                        if (isSpaMode) {\n                            throw noActionDefinedError(\"clientAction\", route.id);\n                        }\n                        return fetchServerAction(singleFetch);\n                    });\n            }\n            let lazyRoutePromise;\n            async function getLazyRoute() {\n                if (lazyRoutePromise) {\n                    return await lazyRoutePromise;\n                }\n                lazyRoutePromise = (async ()=>{\n                    if (route.clientLoaderModule || route.clientActionModule) {\n                        await new Promise((resolve)=>setTimeout(resolve, 0));\n                    }\n                    let routeModulePromise = loadRouteModuleWithBlockingLinks(route, routeModulesCache);\n                    prefetchRouteModuleChunks(route);\n                    return await routeModulePromise;\n                })();\n                return await lazyRoutePromise;\n            }\n            dataRoute.lazy = {\n                loader: route.hasClientLoader ? async ()=>{\n                    let { clientLoader } = route.clientLoaderModule ? await import(/* @vite-ignore */ /* webpackIgnore: true */ route.clientLoaderModule) : await getLazyRoute();\n                    invariant2(clientLoader, \"No `clientLoader` export found\");\n                    return (args, singleFetch)=>clientLoader({\n                            ...args,\n                            async serverLoader () {\n                                preventInvalidServerHandlerCall(\"loader\", route);\n                                return fetchServerLoader(singleFetch);\n                            }\n                        });\n                } : void 0,\n                action: route.hasClientAction ? async ()=>{\n                    let clientActionPromise = route.clientActionModule ? import(/* @vite-ignore */ /* webpackIgnore: true */ route.clientActionModule) : getLazyRoute();\n                    prefetchRouteModuleChunks(route);\n                    let { clientAction } = await clientActionPromise;\n                    invariant2(clientAction, \"No `clientAction` export found\");\n                    return (args, singleFetch)=>clientAction({\n                            ...args,\n                            async serverAction () {\n                                preventInvalidServerHandlerCall(\"action\", route);\n                                return fetchServerAction(singleFetch);\n                            }\n                        });\n                } : void 0,\n                unstable_middleware: route.hasClientMiddleware ? async ()=>{\n                    let { unstable_clientMiddleware } = route.clientMiddlewareModule ? await import(/* @vite-ignore */ /* webpackIgnore: true */ route.clientMiddlewareModule) : await getLazyRoute();\n                    invariant2(unstable_clientMiddleware, \"No `unstable_clientMiddleware` export found\");\n                    return unstable_clientMiddleware;\n                } : void 0,\n                shouldRevalidate: async ()=>{\n                    let lazyRoute = await getLazyRoute();\n                    return getShouldRevalidateFunction(dataRoute.path, lazyRoute, route, ssr, needsRevalidation);\n                },\n                handle: async ()=>(await getLazyRoute()).handle,\n                // No need to wrap these in layout since the root route is never\n                // loaded via route.lazy()\n                Component: async ()=>(await getLazyRoute()).Component,\n                ErrorBoundary: route.hasErrorBoundary ? async ()=>(await getLazyRoute()).ErrorBoundary : void 0\n            };\n        }\n        let children = createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, route.id, routesByParentId, needsRevalidation);\n        if (children.length > 0) dataRoute.children = children;\n        return dataRoute;\n    });\n}\nfunction getShouldRevalidateFunction(path, route, manifestRoute, ssr, needsRevalidation) {\n    if (needsRevalidation) {\n        return wrapShouldRevalidateForHdr(manifestRoute.id, route.shouldRevalidate, needsRevalidation);\n    }\n    if (!ssr && manifestRoute.hasLoader && !manifestRoute.hasClientLoader) {\n        let myParams = path ? compilePath(path)[1].map((p)=>p.paramName) : [];\n        const didParamsChange = (opts)=>myParams.some((p)=>opts.currentParams[p] !== opts.nextParams[p]);\n        if (route.shouldRevalidate) {\n            let fn = route.shouldRevalidate;\n            return (opts)=>fn({\n                    ...opts,\n                    defaultShouldRevalidate: didParamsChange(opts)\n                });\n        } else {\n            return (opts)=>didParamsChange(opts);\n        }\n    }\n    if (ssr && route.shouldRevalidate) {\n        let fn = route.shouldRevalidate;\n        return (opts)=>fn({\n                ...opts,\n                defaultShouldRevalidate: true\n            });\n    }\n    return route.shouldRevalidate;\n}\nfunction wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {\n    let handledRevalidation = false;\n    return (arg)=>{\n        if (!handledRevalidation) {\n            handledRevalidation = true;\n            return needsRevalidation.has(routeId);\n        }\n        return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;\n    };\n}\nasync function loadRouteModuleWithBlockingLinks(route, routeModules) {\n    let routeModulePromise = loadRouteModule(route, routeModules);\n    let prefetchRouteCssPromise = prefetchRouteCss(route);\n    let routeModule = await routeModulePromise;\n    await Promise.all([\n        prefetchRouteCssPromise,\n        prefetchStyleLinks(route, routeModule)\n    ]);\n    return {\n        Component: getRouteModuleComponent(routeModule),\n        ErrorBoundary: routeModule.ErrorBoundary,\n        unstable_clientMiddleware: routeModule.unstable_clientMiddleware,\n        clientAction: routeModule.clientAction,\n        clientLoader: routeModule.clientLoader,\n        handle: routeModule.handle,\n        links: routeModule.links,\n        meta: routeModule.meta,\n        shouldRevalidate: routeModule.shouldRevalidate\n    };\n}\nfunction getRouteModuleComponent(routeModule) {\n    if (routeModule.default == null) return void 0;\n    let isEmptyObject = typeof routeModule.default === \"object\" && Object.keys(routeModule.default).length === 0;\n    if (!isEmptyObject) {\n        return routeModule.default;\n    }\n}\nfunction shouldHydrateRouteLoader(routeId, clientLoader, hasLoader, isSpaMode) {\n    return isSpaMode && routeId !== \"root\" || clientLoader != null && (clientLoader.hydrate === true || hasLoader !== true);\n}\n// lib/dom/ssr/fog-of-war.ts\nvar nextPaths = /* @__PURE__ */ new Set();\nvar discoveredPathsMaxSize = 1e3;\nvar discoveredPaths = /* @__PURE__ */ new Set();\nvar URL_LIMIT = 7680;\nfunction isFogOfWarEnabled(routeDiscovery, ssr) {\n    return routeDiscovery.mode === \"lazy\" && ssr === true;\n}\nfunction getPartialManifest({ sri, ...manifest }, router) {\n    let routeIds = new Set(router.state.matches.map((m)=>m.route.id));\n    let segments = router.state.location.pathname.split(\"/\").filter(Boolean);\n    let paths = [\n        \"/\"\n    ];\n    segments.pop();\n    while(segments.length > 0){\n        paths.push(`/${segments.join(\"/\")}`);\n        segments.pop();\n    }\n    paths.forEach((path)=>{\n        let matches = matchRoutes(router.routes, path, router.basename);\n        if (matches) {\n            matches.forEach((m)=>routeIds.add(m.route.id));\n        }\n    });\n    let initialRoutes = [\n        ...routeIds\n    ].reduce((acc, id)=>Object.assign(acc, {\n            [id]: manifest.routes[id]\n        }), {});\n    return {\n        ...manifest,\n        routes: initialRoutes,\n        sri: sri ? true : void 0\n    };\n}\nfunction getPatchRoutesOnNavigationFunction(manifest, routeModules, ssr, routeDiscovery, isSpaMode, basename) {\n    if (!isFogOfWarEnabled(routeDiscovery, ssr)) {\n        return void 0;\n    }\n    return async ({ path, patch, signal, fetcherKey })=>{\n        if (discoveredPaths.has(path)) {\n            return;\n        }\n        await fetchAndApplyManifestPatches([\n            path\n        ], fetcherKey ? window.location.href : path, manifest, routeModules, ssr, isSpaMode, basename, routeDiscovery.manifestPath, patch, signal);\n    };\n}\nfunction useFogOFWarDiscovery(router, manifest, routeModules, ssr, routeDiscovery, isSpaMode) {\n    React8.useEffect(()=>{\n        if (!isFogOfWarEnabled(routeDiscovery, ssr) || // @ts-expect-error - TS doesn't know about this yet\n        window.navigator?.connection?.saveData === true) {\n            return;\n        }\n        function registerElement(el) {\n            let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\n            if (!path) {\n                return;\n            }\n            let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\n            if (!discoveredPaths.has(pathname)) {\n                nextPaths.add(pathname);\n            }\n        }\n        async function fetchPatches() {\n            document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\n            let lazyPaths = Array.from(nextPaths.keys()).filter((path)=>{\n                if (discoveredPaths.has(path)) {\n                    nextPaths.delete(path);\n                    return false;\n                }\n                return true;\n            });\n            if (lazyPaths.length === 0) {\n                return;\n            }\n            try {\n                await fetchAndApplyManifestPatches(lazyPaths, null, manifest, routeModules, ssr, isSpaMode, router.basename, routeDiscovery.manifestPath, router.patchRoutes);\n            } catch (e) {\n                console.error(\"Failed to fetch manifest patches\", e);\n            }\n        }\n        let debouncedFetchPatches = debounce(fetchPatches, 100);\n        fetchPatches();\n        let observer = new MutationObserver(()=>debouncedFetchPatches());\n        observer.observe(document.documentElement, {\n            subtree: true,\n            childList: true,\n            attributes: true,\n            attributeFilter: [\n                \"data-discover\",\n                \"href\",\n                \"action\"\n            ]\n        });\n        return ()=>observer.disconnect();\n    }, [\n        ssr,\n        isSpaMode,\n        manifest,\n        routeModules,\n        router,\n        routeDiscovery\n    ]);\n}\nfunction getManifestPath(_manifestPath, basename) {\n    let manifestPath = _manifestPath || \"/__manifest\";\n    if (basename == null) {\n        return manifestPath;\n    }\n    return `${basename}${manifestPath}`.replace(/\\/+/g, \"/\");\n}\nvar MANIFEST_VERSION_STORAGE_KEY = \"react-router-manifest-version\";\nasync function fetchAndApplyManifestPatches(paths, errorReloadPath, manifest, routeModules, ssr, isSpaMode, basename, manifestPath, patchRoutes, signal) {\n    let url = new URL(getManifestPath(manifestPath, basename), window.location.origin);\n    paths.sort().forEach((path)=>url.searchParams.append(\"p\", path));\n    url.searchParams.set(\"version\", manifest.version);\n    if (url.toString().length > URL_LIMIT) {\n        nextPaths.clear();\n        return;\n    }\n    let serverPatches;\n    try {\n        let res = await fetch(url, {\n            signal\n        });\n        if (!res.ok) {\n            throw new Error(`${res.status} ${res.statusText}`);\n        } else if (res.status === 204 && res.headers.has(\"X-Remix-Reload-Document\")) {\n            if (!errorReloadPath) {\n                console.warn(\"Detected a manifest version mismatch during eager route discovery. The next navigation/fetch to an undiscovered route will result in a new document navigation to sync up with the latest manifest.\");\n                return;\n            }\n            if (sessionStorage.getItem(MANIFEST_VERSION_STORAGE_KEY) === manifest.version) {\n                console.error(\"Unable to discover routes due to manifest version mismatch.\");\n                return;\n            }\n            sessionStorage.setItem(MANIFEST_VERSION_STORAGE_KEY, manifest.version);\n            window.location.href = errorReloadPath;\n            console.warn(\"Detected manifest version mismatch, reloading...\");\n            await new Promise(()=>{});\n        } else if (res.status >= 400) {\n            throw new Error(await res.text());\n        }\n        sessionStorage.removeItem(MANIFEST_VERSION_STORAGE_KEY);\n        serverPatches = await res.json();\n    } catch (e) {\n        if (signal?.aborted) return;\n        throw e;\n    }\n    let knownRoutes = new Set(Object.keys(manifest.routes));\n    let patches = Object.values(serverPatches).reduce((acc, route)=>{\n        if (route && !knownRoutes.has(route.id)) {\n            acc[route.id] = route;\n        }\n        return acc;\n    }, {});\n    Object.assign(manifest.routes, patches);\n    paths.forEach((p)=>addToFifoQueue(p, discoveredPaths));\n    let parentIds = /* @__PURE__ */ new Set();\n    Object.values(patches).forEach((patch)=>{\n        if (patch && (!patch.parentId || !patches[patch.parentId])) {\n            parentIds.add(patch.parentId);\n        }\n    });\n    parentIds.forEach((parentId)=>patchRoutes(parentId || null, createClientRoutes(patches, routeModules, null, ssr, isSpaMode, parentId)));\n}\nfunction addToFifoQueue(path, queue) {\n    if (queue.size >= discoveredPathsMaxSize) {\n        let first = queue.values().next().value;\n        queue.delete(first);\n    }\n    queue.add(path);\n}\nfunction debounce(callback, wait) {\n    let timeoutId;\n    return (...args)=>{\n        window.clearTimeout(timeoutId);\n        timeoutId = window.setTimeout(()=>callback(...args), wait);\n    };\n}\n// lib/dom/ssr/components.tsx\nfunction useDataRouterContext2() {\n    let context = React9.useContext(DataRouterContext);\n    invariant2(context, \"You must render this element inside a <DataRouterContext.Provider> element\");\n    return context;\n}\nfunction useDataRouterStateContext() {\n    let context = React9.useContext(DataRouterStateContext);\n    invariant2(context, \"You must render this element inside a <DataRouterStateContext.Provider> element\");\n    return context;\n}\nvar FrameworkContext = React9.createContext(void 0);\nFrameworkContext.displayName = \"FrameworkContext\";\nfunction useFrameworkContext() {\n    let context = React9.useContext(FrameworkContext);\n    invariant2(context, \"You must render this element inside a <HydratedRouter> element\");\n    return context;\n}\nfunction usePrefetchBehavior(prefetch, theirElementProps) {\n    let frameworkContext = React9.useContext(FrameworkContext);\n    let [maybePrefetch, setMaybePrefetch] = React9.useState(false);\n    let [shouldPrefetch, setShouldPrefetch] = React9.useState(false);\n    let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;\n    let ref = React9.useRef(null);\n    React9.useEffect(()=>{\n        if (prefetch === \"render\") {\n            setShouldPrefetch(true);\n        }\n        if (prefetch === \"viewport\") {\n            let callback = (entries)=>{\n                entries.forEach((entry)=>{\n                    setShouldPrefetch(entry.isIntersecting);\n                });\n            };\n            let observer = new IntersectionObserver(callback, {\n                threshold: 0.5\n            });\n            if (ref.current) observer.observe(ref.current);\n            return ()=>{\n                observer.disconnect();\n            };\n        }\n    }, [\n        prefetch\n    ]);\n    React9.useEffect(()=>{\n        if (maybePrefetch) {\n            let id = setTimeout(()=>{\n                setShouldPrefetch(true);\n            }, 100);\n            return ()=>{\n                clearTimeout(id);\n            };\n        }\n    }, [\n        maybePrefetch\n    ]);\n    let setIntent = ()=>{\n        setMaybePrefetch(true);\n    };\n    let cancelIntent = ()=>{\n        setMaybePrefetch(false);\n        setShouldPrefetch(false);\n    };\n    if (!frameworkContext) {\n        return [\n            false,\n            ref,\n            {}\n        ];\n    }\n    if (prefetch !== \"intent\") {\n        return [\n            shouldPrefetch,\n            ref,\n            {}\n        ];\n    }\n    return [\n        shouldPrefetch,\n        ref,\n        {\n            onFocus: composeEventHandlers(onFocus, setIntent),\n            onBlur: composeEventHandlers(onBlur, cancelIntent),\n            onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),\n            onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),\n            onTouchStart: composeEventHandlers(onTouchStart, setIntent)\n        }\n    ];\n}\nfunction composeEventHandlers(theirHandler, ourHandler) {\n    return (event)=>{\n        theirHandler && theirHandler(event);\n        if (!event.defaultPrevented) {\n            ourHandler(event);\n        }\n    };\n}\nfunction getActiveMatches(matches, errors, isSpaMode) {\n    if (isSpaMode && !isHydrated) {\n        return [\n            matches[0]\n        ];\n    }\n    if (errors) {\n        let errorIdx = matches.findIndex((m)=>errors[m.route.id] !== void 0);\n        return matches.slice(0, errorIdx + 1);\n    }\n    return matches;\n}\nfunction Links() {\n    let { isSpaMode, manifest, routeModules, criticalCss } = useFrameworkContext();\n    let { errors, matches: routerMatches } = useDataRouterStateContext();\n    let matches = getActiveMatches(routerMatches, errors, isSpaMode);\n    let keyedLinks = React9.useMemo(()=>getKeyedLinksForMatches(matches, routeModules, manifest), [\n        matches,\n        routeModules,\n        manifest\n    ]);\n    return /* @__PURE__ */ React9.createElement(React9.Fragment, null, typeof criticalCss === \"string\" ? /* @__PURE__ */ React9.createElement(\"style\", {\n        dangerouslySetInnerHTML: {\n            __html: criticalCss\n        }\n    }) : null, typeof criticalCss === \"object\" ? /* @__PURE__ */ React9.createElement(\"link\", {\n        rel: \"stylesheet\",\n        href: criticalCss.href\n    }) : null, keyedLinks.map(({ key, link })=>isPageLinkDescriptor(link) ? /* @__PURE__ */ React9.createElement(PrefetchPageLinks, {\n            key,\n            ...link\n        }) : /* @__PURE__ */ React9.createElement(\"link\", {\n            key,\n            ...link\n        })));\n}\nfunction PrefetchPageLinks({ page, ...dataLinkProps }) {\n    let { router } = useDataRouterContext2();\n    let matches = React9.useMemo(()=>matchRoutes(router.routes, page, router.basename), [\n        router.routes,\n        page,\n        router.basename\n    ]);\n    if (!matches) {\n        return null;\n    }\n    return /* @__PURE__ */ React9.createElement(PrefetchPageLinksImpl, {\n        page,\n        matches,\n        ...dataLinkProps\n    });\n}\nfunction useKeyedPrefetchLinks(matches) {\n    let { manifest, routeModules } = useFrameworkContext();\n    let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React9.useState([]);\n    React9.useEffect(()=>{\n        let interrupted = false;\n        void getKeyedPrefetchLinks(matches, manifest, routeModules).then((links)=>{\n            if (!interrupted) {\n                setKeyedPrefetchLinks(links);\n            }\n        });\n        return ()=>{\n            interrupted = true;\n        };\n    }, [\n        matches,\n        manifest,\n        routeModules\n    ]);\n    return keyedPrefetchLinks;\n}\nfunction PrefetchPageLinksImpl({ page, matches: nextMatches, ...linkProps }) {\n    let location = useLocation();\n    let { manifest, routeModules } = useFrameworkContext();\n    let { basename } = useDataRouterContext2();\n    let { loaderData, matches } = useDataRouterStateContext();\n    let newMatchesForData = React9.useMemo(()=>getNewMatchesForLinks(page, nextMatches, matches, manifest, location, \"data\"), [\n        page,\n        nextMatches,\n        matches,\n        manifest,\n        location\n    ]);\n    let newMatchesForAssets = React9.useMemo(()=>getNewMatchesForLinks(page, nextMatches, matches, manifest, location, \"assets\"), [\n        page,\n        nextMatches,\n        matches,\n        manifest,\n        location\n    ]);\n    let dataHrefs = React9.useMemo(()=>{\n        if (page === location.pathname + location.search + location.hash) {\n            return [];\n        }\n        let routesParams = /* @__PURE__ */ new Set();\n        let foundOptOutRoute = false;\n        nextMatches.forEach((m)=>{\n            let manifestRoute = manifest.routes[m.route.id];\n            if (!manifestRoute || !manifestRoute.hasLoader) {\n                return;\n            }\n            if (!newMatchesForData.some((m2)=>m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {\n                foundOptOutRoute = true;\n            } else if (manifestRoute.hasClientLoader) {\n                foundOptOutRoute = true;\n            } else {\n                routesParams.add(m.route.id);\n            }\n        });\n        if (routesParams.size === 0) {\n            return [];\n        }\n        let url = singleFetchUrl(page, basename);\n        if (foundOptOutRoute && routesParams.size > 0) {\n            url.searchParams.set(\"_routes\", nextMatches.filter((m)=>routesParams.has(m.route.id)).map((m)=>m.route.id).join(\",\"));\n        }\n        return [\n            url.pathname + url.search\n        ];\n    }, [\n        basename,\n        loaderData,\n        location,\n        manifest,\n        newMatchesForData,\n        nextMatches,\n        page,\n        routeModules\n    ]);\n    let moduleHrefs = React9.useMemo(()=>getModuleLinkHrefs(newMatchesForAssets, manifest), [\n        newMatchesForAssets,\n        manifest\n    ]);\n    let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);\n    return /* @__PURE__ */ React9.createElement(React9.Fragment, null, dataHrefs.map((href2)=>/* @__PURE__ */ React9.createElement(\"link\", {\n            key: href2,\n            rel: \"prefetch\",\n            as: \"fetch\",\n            href: href2,\n            ...linkProps\n        })), moduleHrefs.map((href2)=>/* @__PURE__ */ React9.createElement(\"link\", {\n            key: href2,\n            rel: \"modulepreload\",\n            href: href2,\n            ...linkProps\n        })), keyedPrefetchLinks.map(({ key, link })=>// these don't spread `linkProps` because they are full link descriptors\n        // already with their own props\n        /* @__PURE__ */ React9.createElement(\"link\", {\n            key,\n            ...link\n        })));\n}\nfunction Meta() {\n    let { isSpaMode, routeModules } = useFrameworkContext();\n    let { errors, matches: routerMatches, loaderData } = useDataRouterStateContext();\n    let location = useLocation();\n    let _matches = getActiveMatches(routerMatches, errors, isSpaMode);\n    let error = null;\n    if (errors) {\n        error = errors[_matches[_matches.length - 1].route.id];\n    }\n    let meta = [];\n    let leafMeta = null;\n    let matches = [];\n    for(let i = 0; i < _matches.length; i++){\n        let _match = _matches[i];\n        let routeId = _match.route.id;\n        let data2 = loaderData[routeId];\n        let params = _match.params;\n        let routeModule = routeModules[routeId];\n        let routeMeta = [];\n        let match = {\n            id: routeId,\n            data: data2,\n            meta: [],\n            params: _match.params,\n            pathname: _match.pathname,\n            handle: _match.route.handle,\n            error\n        };\n        matches[i] = match;\n        if (routeModule?.meta) {\n            routeMeta = typeof routeModule.meta === \"function\" ? routeModule.meta({\n                data: data2,\n                params,\n                location,\n                matches,\n                error\n            }) : Array.isArray(routeModule.meta) ? [\n                ...routeModule.meta\n            ] : routeModule.meta;\n        } else if (leafMeta) {\n            routeMeta = [\n                ...leafMeta\n            ];\n        }\n        routeMeta = routeMeta || [];\n        if (!Array.isArray(routeMeta)) {\n            throw new Error(\"The route at \" + _match.route.path + \" returns an invalid value. All route meta functions must return an array of meta objects.\\n\\nTo reference the meta function API, see https://remix.run/route/meta\");\n        }\n        match.meta = routeMeta;\n        matches[i] = match;\n        meta = [\n            ...routeMeta\n        ];\n        leafMeta = meta;\n    }\n    return /* @__PURE__ */ React9.createElement(React9.Fragment, null, meta.flat().map((metaProps)=>{\n        if (!metaProps) {\n            return null;\n        }\n        if (\"tagName\" in metaProps) {\n            let { tagName, ...rest } = metaProps;\n            if (!isValidMetaTag(tagName)) {\n                console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`);\n                return null;\n            }\n            let Comp = tagName;\n            return /* @__PURE__ */ React9.createElement(Comp, {\n                key: JSON.stringify(rest),\n                ...rest\n            });\n        }\n        if (\"title\" in metaProps) {\n            return /* @__PURE__ */ React9.createElement(\"title\", {\n                key: \"title\"\n            }, String(metaProps.title));\n        }\n        if (\"charset\" in metaProps) {\n            metaProps.charSet ?? (metaProps.charSet = metaProps.charset);\n            delete metaProps.charset;\n        }\n        if (\"charSet\" in metaProps && metaProps.charSet != null) {\n            return typeof metaProps.charSet === \"string\" ? /* @__PURE__ */ React9.createElement(\"meta\", {\n                key: \"charSet\",\n                charSet: metaProps.charSet\n            }) : null;\n        }\n        if (\"script:ld+json\" in metaProps) {\n            try {\n                let json = JSON.stringify(metaProps[\"script:ld+json\"]);\n                return /* @__PURE__ */ React9.createElement(\"script\", {\n                    key: `script:ld+json:${json}`,\n                    type: \"application/ld+json\",\n                    dangerouslySetInnerHTML: {\n                        __html: json\n                    }\n                });\n            } catch (err) {\n                return null;\n            }\n        }\n        return /* @__PURE__ */ React9.createElement(\"meta\", {\n            key: JSON.stringify(metaProps),\n            ...metaProps\n        });\n    }));\n}\nfunction isValidMetaTag(tagName) {\n    return typeof tagName === \"string\" && /^(meta|link)$/.test(tagName);\n}\nvar isHydrated = false;\nfunction Scripts(props) {\n    let { manifest, serverHandoffString, isSpaMode, renderMeta, routeDiscovery, ssr } = useFrameworkContext();\n    let { router, static: isStatic, staticContext } = useDataRouterContext2();\n    let { matches: routerMatches } = useDataRouterStateContext();\n    let enableFogOfWar = isFogOfWarEnabled(routeDiscovery, ssr);\n    if (renderMeta) {\n        renderMeta.didRenderScripts = true;\n    }\n    let matches = getActiveMatches(routerMatches, null, isSpaMode);\n    React9.useEffect(()=>{\n        isHydrated = true;\n    }, []);\n    let initialScripts = React9.useMemo(()=>{\n        let streamScript = \"window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());\";\n        let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : \" \";\n        let routeModulesScript = !isStatic ? \" \" : `${manifest.hmr?.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : \"\"}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : \"\"};\n${matches.map((match, routeIndex)=>{\n            let routeVarName = `route${routeIndex}`;\n            let manifestEntry = manifest.routes[match.route.id];\n            invariant2(manifestEntry, `Route ${match.route.id} not found in manifest`);\n            let { clientActionModule, clientLoaderModule, clientMiddlewareModule, hydrateFallbackModule, module: module2 } = manifestEntry;\n            let chunks = [\n                ...clientActionModule ? [\n                    {\n                        module: clientActionModule,\n                        varName: `${routeVarName}_clientAction`\n                    }\n                ] : [],\n                ...clientLoaderModule ? [\n                    {\n                        module: clientLoaderModule,\n                        varName: `${routeVarName}_clientLoader`\n                    }\n                ] : [],\n                ...clientMiddlewareModule ? [\n                    {\n                        module: clientMiddlewareModule,\n                        varName: `${routeVarName}_clientMiddleware`\n                    }\n                ] : [],\n                ...hydrateFallbackModule ? [\n                    {\n                        module: hydrateFallbackModule,\n                        varName: `${routeVarName}_HydrateFallback`\n                    }\n                ] : [],\n                {\n                    module: module2,\n                    varName: `${routeVarName}_main`\n                }\n            ];\n            if (chunks.length === 1) {\n                return `import * as ${routeVarName} from ${JSON.stringify(module2)};`;\n            }\n            let chunkImportsSnippet = chunks.map((chunk)=>`import * as ${chunk.varName} from \"${chunk.module}\";`).join(\"\\n\");\n            let mergedChunksSnippet = `const ${routeVarName} = {${chunks.map((chunk)=>`...${chunk.varName}`).join(\",\")}};`;\n            return [\n                chunkImportsSnippet,\n                mergedChunksSnippet\n            ].join(\"\\n\");\n        }).join(\"\\n\")}\n  ${enableFogOfWar ? // Inline a minimal manifest with the SSR matches\n        `window.__reactRouterManifest = ${JSON.stringify(getPartialManifest(manifest, router), null, 2)};` : \"\"}\n  window.__reactRouterRouteModules = {${matches.map((match, index)=>`${JSON.stringify(match.route.id)}:route${index}`).join(\",\")}};\n\nimport(${JSON.stringify(manifest.entry.module)});`;\n        return /* @__PURE__ */ React9.createElement(React9.Fragment, null, /* @__PURE__ */ React9.createElement(\"script\", {\n            ...props,\n            suppressHydrationWarning: true,\n            dangerouslySetInnerHTML: createHtml(contextScript),\n            type: void 0\n        }), /* @__PURE__ */ React9.createElement(\"script\", {\n            ...props,\n            suppressHydrationWarning: true,\n            dangerouslySetInnerHTML: createHtml(routeModulesScript),\n            type: \"module\",\n            async: true\n        }));\n    }, []);\n    let preloads = isHydrated ? [] : dedupe(manifest.entry.imports.concat(getModuleLinkHrefs(matches, manifest, {\n        includeHydrateFallback: true\n    })));\n    let sri = typeof manifest.sri === \"object\" ? manifest.sri : {};\n    return isHydrated ? null : /* @__PURE__ */ React9.createElement(React9.Fragment, null, typeof manifest.sri === \"object\" ? /* @__PURE__ */ React9.createElement(\"script\", {\n        \"rr-importmap\": \"\",\n        type: \"importmap\",\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: {\n            __html: JSON.stringify({\n                integrity: sri\n            })\n        }\n    }) : null, !enableFogOfWar ? /* @__PURE__ */ React9.createElement(\"link\", {\n        rel: \"modulepreload\",\n        href: manifest.url,\n        crossOrigin: props.crossOrigin,\n        integrity: sri[manifest.url],\n        suppressHydrationWarning: true\n    }) : null, /* @__PURE__ */ React9.createElement(\"link\", {\n        rel: \"modulepreload\",\n        href: manifest.entry.module,\n        crossOrigin: props.crossOrigin,\n        integrity: sri[manifest.entry.module],\n        suppressHydrationWarning: true\n    }), preloads.map((path)=>/* @__PURE__ */ React9.createElement(\"link\", {\n            key: path,\n            rel: \"modulepreload\",\n            href: path,\n            crossOrigin: props.crossOrigin,\n            integrity: sri[path],\n            suppressHydrationWarning: true\n        })), initialScripts);\n}\nfunction dedupe(array) {\n    return [\n        ...new Set(array)\n    ];\n}\nfunction mergeRefs(...refs) {\n    return (value)=>{\n        refs.forEach((ref)=>{\n            if (typeof ref === \"function\") {\n                ref(value);\n            } else if (ref != null) {\n                ref.current = value;\n            }\n        });\n    };\n}\n// lib/dom/lib.tsx\nvar isBrowser =  false && 0;\ntry {\n    if (isBrowser) {\n        window.__reactRouterVersion = \"7.6.1\";\n    }\n} catch (e) {}\nfunction createBrowserRouter(routes, opts) {\n    return createRouter({\n        basename: opts?.basename,\n        unstable_getContext: opts?.unstable_getContext,\n        future: opts?.future,\n        history: createBrowserHistory({\n            window: opts?.window\n        }),\n        hydrationData: opts?.hydrationData || parseHydrationData(),\n        routes,\n        mapRouteProperties,\n        hydrationRouteProperties,\n        dataStrategy: opts?.dataStrategy,\n        patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,\n        window: opts?.window\n    }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n    return createRouter({\n        basename: opts?.basename,\n        unstable_getContext: opts?.unstable_getContext,\n        future: opts?.future,\n        history: createHashHistory({\n            window: opts?.window\n        }),\n        hydrationData: opts?.hydrationData || parseHydrationData(),\n        routes,\n        mapRouteProperties,\n        hydrationRouteProperties,\n        dataStrategy: opts?.dataStrategy,\n        patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,\n        window: opts?.window\n    }).initialize();\n}\nfunction parseHydrationData() {\n    let state = window?.__staticRouterHydrationData;\n    if (state && state.errors) {\n        state = {\n            ...state,\n            errors: deserializeErrors(state.errors)\n        };\n    }\n    return state;\n}\nfunction deserializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        if (val && val.__type === \"RouteErrorResponse\") {\n            serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n        } else if (val && val.__type === \"Error\") {\n            if (val.__subType) {\n                let ErrorConstructor = window[val.__subType];\n                if (typeof ErrorConstructor === \"function\") {\n                    try {\n                        let error = new ErrorConstructor(val.message);\n                        error.stack = \"\";\n                        serialized[key] = error;\n                    } catch (e) {}\n                }\n            }\n            if (serialized[key] == null) {\n                let error = new Error(val.message);\n                error.stack = \"\";\n                serialized[key] = error;\n            }\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\nfunction BrowserRouter({ basename, children, window: window2 }) {\n    let historyRef = React10.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = createBrowserHistory({\n            window: window2,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React10.useState({\n        action: history.action,\n        location: history.location\n    });\n    let setState = React10.useCallback((newState)=>{\n        React10.startTransition(()=>setStateImpl(newState));\n    }, [\n        setStateImpl\n    ]);\n    React10.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /* @__PURE__ */ React10.createElement(Router, {\n        basename,\n        children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nfunction HashRouter({ basename, children, window: window2 }) {\n    let historyRef = React10.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = createHashHistory({\n            window: window2,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React10.useState({\n        action: history.action,\n        location: history.location\n    });\n    let setState = React10.useCallback((newState)=>{\n        React10.startTransition(()=>setStateImpl(newState));\n    }, [\n        setStateImpl\n    ]);\n    React10.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /* @__PURE__ */ React10.createElement(Router, {\n        basename,\n        children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nfunction HistoryRouter({ basename, children, history }) {\n    let [state, setStateImpl] = React10.useState({\n        action: history.action,\n        location: history.location\n    });\n    let setState = React10.useCallback((newState)=>{\n        React10.startTransition(()=>setStateImpl(newState));\n    }, [\n        setStateImpl\n    ]);\n    React10.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /* @__PURE__ */ React10.createElement(Router, {\n        basename,\n        children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nHistoryRouter.displayName = \"unstable_HistoryRouter\";\nvar ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar Link = React10.forwardRef(function LinkWithRef({ onClick, discover = \"render\", prefetch = \"none\", relative, reloadDocument, replace: replace2, state, target, to, preventScrollReset, viewTransition, ...rest }, forwardedRef) {\n    let { basename } = React10.useContext(NavigationContext);\n    let isAbsolute = typeof to === \"string\" && ABSOLUTE_URL_REGEX2.test(to);\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && isAbsolute) {\n        absoluteHref = to;\n        if (isBrowser) {\n            try {\n                let currentUrl = new URL(window.location.href);\n                let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n                let path = stripBasename(targetUrl.pathname, basename);\n                if (targetUrl.origin === currentUrl.origin && path != null) {\n                    to = path + targetUrl.search + targetUrl.hash;\n                } else {\n                    isExternal = true;\n                }\n            } catch (e) {\n                warning(false, `<Link to=\"${to}\"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`);\n            }\n        }\n    }\n    let href2 = useHref(to, {\n        relative\n    });\n    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(prefetch, rest);\n    let internalOnClick = useLinkClickHandler(to, {\n        replace: replace2,\n        state,\n        target,\n        preventScrollReset,\n        relative,\n        viewTransition\n    });\n    function handleClick(event) {\n        if (onClick) onClick(event);\n        if (!event.defaultPrevented) {\n            internalOnClick(event);\n        }\n    }\n    let link = // eslint-disable-next-line jsx-a11y/anchor-has-content\n    /* @__PURE__ */ React10.createElement(\"a\", {\n        ...rest,\n        ...prefetchHandlers,\n        href: absoluteHref || href2,\n        onClick: isExternal || reloadDocument ? onClick : handleClick,\n        ref: mergeRefs(forwardedRef, prefetchRef),\n        target,\n        \"data-discover\": !isAbsolute && discover === \"render\" ? \"true\" : void 0\n    });\n    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React10.createElement(React10.Fragment, null, link, /* @__PURE__ */ React10.createElement(PrefetchPageLinks, {\n        page: href2\n    })) : link;\n});\nLink.displayName = \"Link\";\nvar NavLink = React10.forwardRef(function NavLinkWithRef({ \"aria-current\": ariaCurrentProp = \"page\", caseSensitive = false, className: classNameProp = \"\", end = false, style: styleProp, to, viewTransition, children, ...rest }, ref) {\n    let path = useResolvedPath(to, {\n        relative: rest.relative\n    });\n    let location = useLocation();\n    let routerState = React10.useContext(DataRouterStateContext);\n    let { navigator, basename } = React10.useContext(NavigationContext);\n    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useViewTransitionState(path) && viewTransition === true;\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n        locationPathname = locationPathname.toLowerCase();\n        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n        toPathname = toPathname.toLowerCase();\n    }\n    if (nextLocationPathname && basename) {\n        nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;\n    }\n    const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let renderProps = {\n        isActive,\n        isPending,\n        isTransitioning\n    };\n    let ariaCurrent = isActive ? ariaCurrentProp : void 0;\n    let className;\n    if (typeof classNameProp === \"function\") {\n        className = classNameProp(renderProps);\n    } else {\n        className = [\n            classNameProp,\n            isActive ? \"active\" : null,\n            isPending ? \"pending\" : null,\n            isTransitioning ? \"transitioning\" : null\n        ].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n    return /* @__PURE__ */ React10.createElement(Link, {\n        ...rest,\n        \"aria-current\": ariaCurrent,\n        className,\n        ref,\n        style,\n        to,\n        viewTransition\n    }, typeof children === \"function\" ? children(renderProps) : children);\n});\nNavLink.displayName = \"NavLink\";\nvar Form = React10.forwardRef(({ discover = \"render\", fetcherKey, navigate, reloadDocument, replace: replace2, state, method = defaultMethod, action, onSubmit, relative, preventScrollReset, viewTransition, ...props }, forwardedRef)=>{\n    let submit = useSubmit();\n    let formAction = useFormAction(action, {\n        relative\n    });\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let isAbsolute = typeof action === \"string\" && ABSOLUTE_URL_REGEX2.test(action);\n    let submitHandler = (event)=>{\n        onSubmit && onSubmit(event);\n        if (event.defaultPrevented) return;\n        event.preventDefault();\n        let submitter = event.nativeEvent.submitter;\n        let submitMethod = submitter?.getAttribute(\"formmethod\") || method;\n        submit(submitter || event.currentTarget, {\n            fetcherKey,\n            method: submitMethod,\n            navigate,\n            replace: replace2,\n            state,\n            relative,\n            preventScrollReset,\n            viewTransition\n        });\n    };\n    return /* @__PURE__ */ React10.createElement(\"form\", {\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler,\n        ...props,\n        \"data-discover\": !isAbsolute && discover === \"render\" ? \"true\" : void 0\n    });\n});\nForm.displayName = \"Form\";\nfunction ScrollRestoration({ getKey, storageKey, ...props }) {\n    let remixContext = React10.useContext(FrameworkContext);\n    let { basename } = React10.useContext(NavigationContext);\n    let location = useLocation();\n    let matches = useMatches();\n    useScrollRestoration({\n        getKey,\n        storageKey\n    });\n    let ssrKey = React10.useMemo(()=>{\n        if (!remixContext || !getKey) return null;\n        let userKey = getScrollRestorationKey(location, matches, basename, getKey);\n        return userKey !== location.key ? userKey : null;\n    }, // Nah, we only need this the first time for the SSR render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    if (!remixContext || remixContext.isSpaMode) {\n        return null;\n    }\n    let restoreScroll = ((storageKey2, restoreKey)=>{\n        if (!window.history.state || !window.history.state.key) {\n            let key = Math.random().toString(32).slice(2);\n            window.history.replaceState({\n                key\n            }, \"\");\n        }\n        try {\n            let positions = JSON.parse(sessionStorage.getItem(storageKey2) || \"{}\");\n            let storedY = positions[restoreKey || window.history.state.key];\n            if (typeof storedY === \"number\") {\n                window.scrollTo(0, storedY);\n            }\n        } catch (error) {\n            console.error(error);\n            sessionStorage.removeItem(storageKey2);\n        }\n    }).toString();\n    return /* @__PURE__ */ React10.createElement(\"script\", {\n        ...props,\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: {\n            __html: `(${restoreScroll})(${JSON.stringify(storageKey || SCROLL_RESTORATION_STORAGE_KEY)}, ${JSON.stringify(ssrKey)})`\n        }\n    });\n}\nScrollRestoration.displayName = \"ScrollRestoration\";\nfunction getDataRouterConsoleError2(hookName) {\n    return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\nfunction useDataRouterContext3(hookName) {\n    let ctx = React10.useContext(DataRouterContext);\n    invariant(ctx, getDataRouterConsoleError2(hookName));\n    return ctx;\n}\nfunction useDataRouterState2(hookName) {\n    let state = React10.useContext(DataRouterStateContext);\n    invariant(state, getDataRouterConsoleError2(hookName));\n    return state;\n}\nfunction useLinkClickHandler(to, { target, replace: replaceProp, state, preventScrollReset, relative, viewTransition } = {}) {\n    let navigate = useNavigate();\n    let location = useLocation();\n    let path = useResolvedPath(to, {\n        relative\n    });\n    return React10.useCallback((event)=>{\n        if (shouldProcessLinkClick(event, target)) {\n            event.preventDefault();\n            let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);\n            navigate(to, {\n                replace: replace2,\n                state,\n                preventScrollReset,\n                relative,\n                viewTransition\n            });\n        }\n    }, [\n        location,\n        navigate,\n        path,\n        replaceProp,\n        state,\n        target,\n        to,\n        preventScrollReset,\n        relative,\n        viewTransition\n    ]);\n}\nfunction useSearchParams(defaultInit) {\n    warning(typeof URLSearchParams !== \"undefined\", `You cannot use the \\`useSearchParams\\` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`);\n    let defaultSearchParamsRef = React10.useRef(createSearchParams(defaultInit));\n    let hasSetSearchParamsRef = React10.useRef(false);\n    let location = useLocation();\n    let searchParams = React10.useMemo(()=>// Only merge in the defaults if we haven't yet called setSearchParams.\n        // Once we call that we want those to take precedence, otherwise you can't\n        // remove a param with setSearchParams({}) if it has an initial value\n        getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [\n        location.search\n    ]);\n    let navigate = useNavigate();\n    let setSearchParams = React10.useCallback((nextInit, navigateOptions)=>{\n        const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n        hasSetSearchParamsRef.current = true;\n        navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [\n        navigate,\n        searchParams\n    ]);\n    return [\n        searchParams,\n        setSearchParams\n    ];\n}\nvar fetcherId = 0;\nvar getUniqueFetcherId = ()=>`__${String(++fetcherId)}__`;\nfunction useSubmit() {\n    let { router } = useDataRouterContext3(\"useSubmit\" /* UseSubmit */ );\n    let { basename } = React10.useContext(NavigationContext);\n    let currentRouteId = useRouteId();\n    return React10.useCallback(async (target, options = {})=>{\n        let { action, method, encType, formData, body } = getFormSubmissionInfo(target, basename);\n        if (options.navigate === false) {\n            let key = options.fetcherKey || getUniqueFetcherId();\n            await router.fetch(key, currentRouteId, options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                flushSync: options.flushSync\n            });\n        } else {\n            await router.navigate(options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                replace: options.replace,\n                state: options.state,\n                fromRouteId: currentRouteId,\n                flushSync: options.flushSync,\n                viewTransition: options.viewTransition\n            });\n        }\n    }, [\n        router,\n        basename,\n        currentRouteId\n    ]);\n}\nfunction useFormAction(action, { relative } = {}) {\n    let { basename } = React10.useContext(NavigationContext);\n    let routeContext = React10.useContext(RouteContext);\n    invariant(routeContext, \"useFormAction must be used inside a RouteContext\");\n    let [match] = routeContext.matches.slice(-1);\n    let path = {\n        ...useResolvedPath(action ? action : \".\", {\n            relative\n        })\n    };\n    let location = useLocation();\n    if (action == null) {\n        path.search = location.search;\n        let params = new URLSearchParams(path.search);\n        let indexValues = params.getAll(\"index\");\n        let hasNakedIndexParam = indexValues.some((v)=>v === \"\");\n        if (hasNakedIndexParam) {\n            params.delete(\"index\");\n            indexValues.filter((v)=>v).forEach((v)=>params.append(\"index\", v));\n            let qs = params.toString();\n            path.search = qs ? `?${qs}` : \"\";\n        }\n    }\n    if ((!action || action === \".\") && match.route.index) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n            basename,\n            path.pathname\n        ]);\n    }\n    return createPath(path);\n}\nfunction useFetcher({ key } = {}) {\n    let { router } = useDataRouterContext3(\"useFetcher\" /* UseFetcher */ );\n    let state = useDataRouterState2(\"useFetcher\" /* UseFetcher */ );\n    let fetcherData = React10.useContext(FetchersContext);\n    let route = React10.useContext(RouteContext);\n    let routeId = route.matches[route.matches.length - 1]?.route.id;\n    invariant(fetcherData, `useFetcher must be used inside a FetchersContext`);\n    invariant(route, `useFetcher must be used inside a RouteContext`);\n    invariant(routeId != null, `useFetcher can only be used on routes that contain a unique \"id\"`);\n    let defaultKey = React10.useId();\n    let [fetcherKey, setFetcherKey] = React10.useState(key || defaultKey);\n    if (key && key !== fetcherKey) {\n        setFetcherKey(key);\n    }\n    React10.useEffect(()=>{\n        router.getFetcher(fetcherKey);\n        return ()=>router.deleteFetcher(fetcherKey);\n    }, [\n        router,\n        fetcherKey\n    ]);\n    let load = React10.useCallback(async (href2, opts)=>{\n        invariant(routeId, \"No routeId available for fetcher.load()\");\n        await router.fetch(fetcherKey, routeId, href2, opts);\n    }, [\n        fetcherKey,\n        routeId,\n        router\n    ]);\n    let submitImpl = useSubmit();\n    let submit = React10.useCallback(async (target, opts)=>{\n        await submitImpl(target, {\n            ...opts,\n            navigate: false,\n            fetcherKey\n        });\n    }, [\n        fetcherKey,\n        submitImpl\n    ]);\n    let FetcherForm = React10.useMemo(()=>{\n        let FetcherForm2 = React10.forwardRef((props, ref)=>{\n            return /* @__PURE__ */ React10.createElement(Form, {\n                ...props,\n                navigate: false,\n                fetcherKey,\n                ref\n            });\n        });\n        FetcherForm2.displayName = \"fetcher.Form\";\n        return FetcherForm2;\n    }, [\n        fetcherKey\n    ]);\n    let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\n    let data2 = fetcherData.get(fetcherKey);\n    let fetcherWithComponents = React10.useMemo(()=>({\n            Form: FetcherForm,\n            submit,\n            load,\n            ...fetcher,\n            data: data2\n        }), [\n        FetcherForm,\n        submit,\n        load,\n        fetcher,\n        data2\n    ]);\n    return fetcherWithComponents;\n}\nfunction useFetchers() {\n    let state = useDataRouterState2(\"useFetchers\" /* UseFetchers */ );\n    return Array.from(state.fetchers.entries()).map(([key, fetcher])=>({\n            ...fetcher,\n            key\n        }));\n}\nvar SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nvar savedScrollPositions = {};\nfunction getScrollRestorationKey(location, matches, basename, getKey) {\n    let key = null;\n    if (getKey) {\n        if (basename !== \"/\") {\n            key = getKey({\n                ...location,\n                pathname: stripBasename(location.pathname, basename) || location.pathname\n            }, matches);\n        } else {\n            key = getKey(location, matches);\n        }\n    }\n    if (key == null) {\n        key = location.key;\n    }\n    return key;\n}\nfunction useScrollRestoration({ getKey, storageKey } = {}) {\n    let { router } = useDataRouterContext3(\"useScrollRestoration\" /* UseScrollRestoration */ );\n    let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(\"useScrollRestoration\" /* UseScrollRestoration */ );\n    let { basename } = React10.useContext(NavigationContext);\n    let location = useLocation();\n    let matches = useMatches();\n    let navigation = useNavigation();\n    React10.useEffect(()=>{\n        window.history.scrollRestoration = \"manual\";\n        return ()=>{\n            window.history.scrollRestoration = \"auto\";\n        };\n    }, []);\n    usePageHide(React10.useCallback(()=>{\n        if (navigation.state === \"idle\") {\n            let key = getScrollRestorationKey(location, matches, basename, getKey);\n            savedScrollPositions[key] = window.scrollY;\n        }\n        try {\n            sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n        } catch (error) {\n            warning(false, `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`);\n        }\n        window.history.scrollRestoration = \"auto\";\n    }, [\n        navigation.state,\n        getKey,\n        basename,\n        location,\n        matches,\n        storageKey\n    ]));\n    if (typeof document !== \"undefined\") {\n        React10.useLayoutEffect(()=>{\n            try {\n                let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n                if (sessionPositions) {\n                    savedScrollPositions = JSON.parse(sessionPositions);\n                }\n            } catch (e) {}\n        }, [\n            storageKey\n        ]);\n        React10.useLayoutEffect(()=>{\n            let disableScrollRestoration = router?.enableScrollRestoration(savedScrollPositions, ()=>window.scrollY, getKey ? (location2, matches2)=>getScrollRestorationKey(location2, matches2, basename, getKey) : void 0);\n            return ()=>disableScrollRestoration && disableScrollRestoration();\n        }, [\n            router,\n            basename,\n            getKey\n        ]);\n        React10.useLayoutEffect(()=>{\n            if (restoreScrollPosition === false) {\n                return;\n            }\n            if (typeof restoreScrollPosition === \"number\") {\n                window.scrollTo(0, restoreScrollPosition);\n                return;\n            }\n            if (location.hash) {\n                let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n                if (el) {\n                    el.scrollIntoView();\n                    return;\n                }\n            }\n            if (preventScrollReset === true) {\n                return;\n            }\n            window.scrollTo(0, 0);\n        }, [\n            location,\n            restoreScrollPosition,\n            preventScrollReset\n        ]);\n    }\n}\nfunction useBeforeUnload(callback, options) {\n    let { capture } = options || {};\n    React10.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : void 0;\n        window.addEventListener(\"beforeunload\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\nfunction usePageHide(callback, options) {\n    let { capture } = options || {};\n    React10.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : void 0;\n        window.addEventListener(\"pagehide\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"pagehide\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\nfunction usePrompt({ when, message }) {\n    let blocker = useBlocker(when);\n    React10.useEffect(()=>{\n        if (blocker.state === \"blocked\") {\n            let proceed = window.confirm(message);\n            if (proceed) {\n                setTimeout(blocker.proceed, 0);\n            } else {\n                blocker.reset();\n            }\n        }\n    }, [\n        blocker,\n        message\n    ]);\n    React10.useEffect(()=>{\n        if (blocker.state === \"blocked\" && !when) {\n            blocker.reset();\n        }\n    }, [\n        blocker,\n        when\n    ]);\n}\nfunction useViewTransitionState(to, opts = {}) {\n    let vtContext = React10.useContext(ViewTransitionContext);\n    invariant(vtContext != null, \"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?\");\n    let { basename } = useDataRouterContext3(\"useViewTransitionState\" /* useViewTransitionState */ );\n    let path = useResolvedPath(to, {\n        relative: opts.relative\n    });\n    if (!vtContext.isTransitioning) {\n        return false;\n    }\n    let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n    let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n    return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\n}\n// lib/dom/server.tsx\nvar React11 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction StaticRouter({ basename, children, location: locationProp = \"/\" }) {\n    if (typeof locationProp === \"string\") {\n        locationProp = parsePath(locationProp);\n    }\n    let action = \"POP\" /* Pop */ ;\n    let location = {\n        pathname: locationProp.pathname || \"/\",\n        search: locationProp.search || \"\",\n        hash: locationProp.hash || \"\",\n        state: locationProp.state != null ? locationProp.state : null,\n        key: locationProp.key || \"default\"\n    };\n    let staticNavigator = getStatelessNavigator();\n    return /* @__PURE__ */ React11.createElement(Router, {\n        basename,\n        children,\n        location,\n        navigationType: action,\n        navigator: staticNavigator,\n        static: true\n    });\n}\nfunction StaticRouterProvider({ context, router, hydrate: hydrate2 = true, nonce }) {\n    invariant(router && context, \"You must provide `router` and `context` to <StaticRouterProvider>\");\n    let dataRouterContext = {\n        router,\n        navigator: getStatelessNavigator(),\n        static: true,\n        staticContext: context,\n        basename: context.basename || \"/\"\n    };\n    let fetchersContext = /* @__PURE__ */ new Map();\n    let hydrateScript = \"\";\n    if (hydrate2 !== false) {\n        let data2 = {\n            loaderData: context.loaderData,\n            actionData: context.actionData,\n            errors: serializeErrors(context.errors)\n        };\n        let json = htmlEscape(JSON.stringify(JSON.stringify(data2)));\n        hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;\n    }\n    let { state } = dataRouterContext.router;\n    return /* @__PURE__ */ React11.createElement(React11.Fragment, null, /* @__PURE__ */ React11.createElement(DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /* @__PURE__ */ React11.createElement(DataRouterStateContext.Provider, {\n        value: state\n    }, /* @__PURE__ */ React11.createElement(FetchersContext.Provider, {\n        value: fetchersContext\n    }, /* @__PURE__ */ React11.createElement(ViewTransitionContext.Provider, {\n        value: {\n            isTransitioning: false\n        }\n    }, /* @__PURE__ */ React11.createElement(Router, {\n        basename: dataRouterContext.basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: dataRouterContext.navigator,\n        static: dataRouterContext.static\n    }, /* @__PURE__ */ React11.createElement(DataRoutes2, {\n        routes: router.routes,\n        future: router.future,\n        state\n    })))))), hydrateScript ? /* @__PURE__ */ React11.createElement(\"script\", {\n        suppressHydrationWarning: true,\n        nonce,\n        dangerouslySetInnerHTML: {\n            __html: hydrateScript\n        }\n    }) : null);\n}\nfunction DataRoutes2({ routes, future, state }) {\n    return useRoutesImpl(routes, void 0, state, future);\n}\nfunction serializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        if (isRouteErrorResponse(val)) {\n            serialized[key] = {\n                ...val,\n                __type: \"RouteErrorResponse\"\n            };\n        } else if (val instanceof Error) {\n            serialized[key] = {\n                message: val.message,\n                __type: \"Error\",\n                // If this is a subclass (i.e., ReferenceError), send up the type so we\n                // can re-create the same type during hydration.\n                ...val.name !== \"Error\" ? {\n                    __subType: val.name\n                } : {}\n            };\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\nfunction getStatelessNavigator() {\n    return {\n        createHref,\n        encodeLocation,\n        push (to) {\n            throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${JSON.stringify(to)})\\` somewhere in your app.`);\n        },\n        replace (to) {\n            throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${JSON.stringify(to)}, { replace: true })\\` somewhere in your app.`);\n        },\n        go (delta) {\n            throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${delta})\\` somewhere in your app.`);\n        },\n        back () {\n            throw new Error(`You cannot use navigator.back() on the server because it is a stateless environment.`);\n        },\n        forward () {\n            throw new Error(`You cannot use navigator.forward() on the server because it is a stateless environment.`);\n        }\n    };\n}\nfunction createStaticHandler2(routes, opts) {\n    return createStaticHandler(routes, {\n        ...opts,\n        mapRouteProperties\n    });\n}\nfunction createStaticRouter(routes, context, opts = {}) {\n    let manifest = {};\n    let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, void 0, manifest);\n    let matches = context.matches.map((match)=>{\n        let route = manifest[match.route.id] || match.route;\n        return {\n            ...match,\n            route\n        };\n    });\n    let msg = (method)=>`You cannot use router.${method}() on the server because it is a stateless environment`;\n    return {\n        get basename () {\n            return context.basename;\n        },\n        get future () {\n            return {\n                unstable_middleware: false,\n                ...opts?.future\n            };\n        },\n        get state () {\n            return {\n                historyAction: \"POP\" /* Pop */ ,\n                location: context.location,\n                matches,\n                loaderData: context.loaderData,\n                actionData: context.actionData,\n                errors: context.errors,\n                initialized: true,\n                navigation: IDLE_NAVIGATION,\n                restoreScrollPosition: null,\n                preventScrollReset: false,\n                revalidation: \"idle\",\n                fetchers: /* @__PURE__ */ new Map(),\n                blockers: /* @__PURE__ */ new Map()\n            };\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        get window () {\n            return void 0;\n        },\n        initialize () {\n            throw msg(\"initialize\");\n        },\n        subscribe () {\n            throw msg(\"subscribe\");\n        },\n        enableScrollRestoration () {\n            throw msg(\"enableScrollRestoration\");\n        },\n        navigate () {\n            throw msg(\"navigate\");\n        },\n        fetch () {\n            throw msg(\"fetch\");\n        },\n        revalidate () {\n            throw msg(\"revalidate\");\n        },\n        createHref,\n        encodeLocation,\n        getFetcher () {\n            return IDLE_FETCHER;\n        },\n        deleteFetcher () {\n            throw msg(\"deleteFetcher\");\n        },\n        dispose () {\n            throw msg(\"dispose\");\n        },\n        getBlocker () {\n            return IDLE_BLOCKER;\n        },\n        deleteBlocker () {\n            throw msg(\"deleteBlocker\");\n        },\n        patchRoutes () {\n            throw msg(\"patchRoutes\");\n        },\n        _internalFetchControllers: /* @__PURE__ */ new Map(),\n        _internalSetRoutes () {\n            throw msg(\"_internalSetRoutes\");\n        }\n    };\n}\nfunction createHref(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n}\nfunction encodeLocation(to) {\n    let href2 = typeof to === \"string\" ? to : createPath(to);\n    href2 = href2.replace(/ $/, \"%20\");\n    let encoded = ABSOLUTE_URL_REGEX3.test(href2) ? new URL(href2) : new URL(href2, \"http://localhost\");\n    return {\n        pathname: encoded.pathname,\n        search: encoded.search,\n        hash: encoded.hash\n    };\n}\nvar ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar ESCAPE_LOOKUP2 = {\n    \"&\": \"\\\\u0026\",\n    \">\": \"\\\\u003e\",\n    \"<\": \"\\\\u003c\",\n    \"\\u2028\": \"\\\\u2028\",\n    \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX2 = /[&><\\u2028\\u2029]/g;\nfunction htmlEscape(str) {\n    return str.replace(ESCAPE_REGEX2, (match)=>ESCAPE_LOOKUP2[match]);\n}\n// lib/dom/ssr/server.tsx\nvar React12 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction ServerRouter({ context, url, nonce }) {\n    if (typeof url === \"string\") {\n        url = new URL(url);\n    }\n    let { manifest, routeModules, criticalCss, serverHandoffString } = context;\n    let routes = createServerRoutes(manifest.routes, routeModules, context.future, context.isSpaMode);\n    context.staticHandlerContext.loaderData = {\n        ...context.staticHandlerContext.loaderData\n    };\n    for (let match of context.staticHandlerContext.matches){\n        let routeId = match.route.id;\n        let route = routeModules[routeId];\n        let manifestRoute = context.manifest.routes[routeId];\n        if (route && manifestRoute && shouldHydrateRouteLoader(routeId, route.clientLoader, manifestRoute.hasLoader, context.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n            delete context.staticHandlerContext.loaderData[routeId];\n        }\n    }\n    let router = createStaticRouter(routes, context.staticHandlerContext);\n    return /* @__PURE__ */ React12.createElement(React12.Fragment, null, /* @__PURE__ */ React12.createElement(FrameworkContext.Provider, {\n        value: {\n            manifest,\n            routeModules,\n            criticalCss,\n            serverHandoffString,\n            future: context.future,\n            ssr: context.ssr,\n            isSpaMode: context.isSpaMode,\n            routeDiscovery: context.routeDiscovery,\n            serializeError: context.serializeError,\n            renderMeta: context.renderMeta\n        }\n    }, /* @__PURE__ */ React12.createElement(RemixErrorBoundary, {\n        location: router.state.location\n    }, /* @__PURE__ */ React12.createElement(StaticRouterProvider, {\n        router,\n        context: context.staticHandlerContext,\n        hydrate: false\n    }))), context.serverHandoffStream ? /* @__PURE__ */ React12.createElement(React12.Suspense, null, /* @__PURE__ */ React12.createElement(StreamTransfer, {\n        context,\n        identifier: 0,\n        reader: context.serverHandoffStream.getReader(),\n        textDecoder: new TextDecoder(),\n        nonce\n    })) : null);\n}\n// lib/dom/ssr/routes-test-stub.tsx\nvar React13 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction createRoutesStub(routes, unstable_getContext) {\n    return function RoutesTestStub({ initialEntries, initialIndex, hydrationData, future }) {\n        let routerRef = React13.useRef();\n        let remixContextRef = React13.useRef();\n        if (routerRef.current == null) {\n            remixContextRef.current = {\n                future: {\n                    unstable_subResourceIntegrity: future?.unstable_subResourceIntegrity === true,\n                    unstable_middleware: future?.unstable_middleware === true\n                },\n                manifest: {\n                    routes: {},\n                    entry: {\n                        imports: [],\n                        module: \"\"\n                    },\n                    url: \"\",\n                    version: \"\"\n                },\n                routeModules: {},\n                ssr: false,\n                isSpaMode: false,\n                routeDiscovery: {\n                    mode: \"lazy\",\n                    manifestPath: \"/__manifest\"\n                }\n            };\n            let patched = processRoutes(// @ts-expect-error `StubRouteObject` is stricter about `loader`/`action`\n            // types compared to `AgnosticRouteObject`\n            convertRoutesToDataRoutes(routes, (r)=>r), remixContextRef.current.manifest, remixContextRef.current.routeModules);\n            routerRef.current = createMemoryRouter(patched, {\n                unstable_getContext,\n                initialEntries,\n                initialIndex,\n                hydrationData\n            });\n        }\n        return /* @__PURE__ */ React13.createElement(FrameworkContext.Provider, {\n            value: remixContextRef.current\n        }, /* @__PURE__ */ React13.createElement(RouterProvider, {\n            router: routerRef.current\n        }));\n    };\n}\nfunction withComponentProps(Component4) {\n    return function Wrapped() {\n        return React13.createElement(Component4, {\n            params: useParams(),\n            loaderData: useLoaderData(),\n            actionData: useActionData(),\n            matches: useMatches()\n        });\n    };\n}\nfunction withHydrateFallbackProps(HydrateFallback) {\n    return function Wrapped() {\n        const props = {\n            params: useParams(),\n            loaderData: useLoaderData(),\n            actionData: useActionData()\n        };\n        return React13.createElement(HydrateFallback, props);\n    };\n}\nfunction withErrorBoundaryProps(ErrorBoundary) {\n    return function Wrapped() {\n        const props = {\n            params: useParams(),\n            loaderData: useLoaderData(),\n            actionData: useActionData(),\n            error: useRouteError()\n        };\n        return React13.createElement(ErrorBoundary, props);\n    };\n}\nfunction processRoutes(routes, manifest, routeModules, parentId) {\n    return routes.map((route)=>{\n        if (!route.id) {\n            throw new Error(\"Expected a route.id in @remix-run/testing processRoutes() function\");\n        }\n        let newRoute = {\n            id: route.id,\n            path: route.path,\n            index: route.index,\n            Component: route.Component ? withComponentProps(route.Component) : void 0,\n            HydrateFallback: route.HydrateFallback ? withHydrateFallbackProps(route.HydrateFallback) : void 0,\n            ErrorBoundary: route.ErrorBoundary ? withErrorBoundaryProps(route.ErrorBoundary) : void 0,\n            action: route.action,\n            loader: route.loader,\n            handle: route.handle,\n            shouldRevalidate: route.shouldRevalidate\n        };\n        let entryRoute = {\n            id: route.id,\n            path: route.path,\n            index: route.index,\n            parentId,\n            hasAction: route.action != null,\n            hasLoader: route.loader != null,\n            // When testing routes, you should be stubbing loader/action/middleware,\n            // not trying to re-implement the full loader/clientLoader/SSR/hydration\n            // flow. That is better tested via E2E tests.\n            hasClientAction: false,\n            hasClientLoader: false,\n            hasClientMiddleware: false,\n            hasErrorBoundary: route.ErrorBoundary != null,\n            // any need for these?\n            module: \"build/stub-path-to-module.js\",\n            clientActionModule: void 0,\n            clientLoaderModule: void 0,\n            clientMiddlewareModule: void 0,\n            hydrateFallbackModule: void 0\n        };\n        manifest.routes[newRoute.id] = entryRoute;\n        routeModules[route.id] = {\n            default: newRoute.Component || Outlet,\n            ErrorBoundary: newRoute.ErrorBoundary || void 0,\n            handle: route.handle,\n            links: route.links,\n            meta: route.meta,\n            shouldRevalidate: route.shouldRevalidate\n        };\n        if (route.children) {\n            newRoute.children = processRoutes(route.children, manifest, routeModules, newRoute.id);\n        }\n        return newRoute;\n    });\n}\n// lib/server-runtime/cookies.ts\nvar import_cookie = __webpack_require__(/*! cookie */ \"(ssr)/./node_modules/cookie/dist/index.js\");\n// lib/server-runtime/crypto.ts\nvar encoder = /* @__PURE__ */ new TextEncoder();\nvar sign = async (value, secret)=>{\n    let data2 = encoder.encode(value);\n    let key = await createKey2(secret, [\n        \"sign\"\n    ]);\n    let signature = await crypto.subtle.sign(\"HMAC\", key, data2);\n    let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, \"\");\n    return value + \".\" + hash;\n};\nvar unsign = async (cookie, secret)=>{\n    let index = cookie.lastIndexOf(\".\");\n    let value = cookie.slice(0, index);\n    let hash = cookie.slice(index + 1);\n    let data2 = encoder.encode(value);\n    let key = await createKey2(secret, [\n        \"verify\"\n    ]);\n    let signature = byteStringToUint8Array(atob(hash));\n    let valid = await crypto.subtle.verify(\"HMAC\", key, signature, data2);\n    return valid ? value : false;\n};\nvar createKey2 = async (secret, usages)=>crypto.subtle.importKey(\"raw\", encoder.encode(secret), {\n        name: \"HMAC\",\n        hash: \"SHA-256\"\n    }, false, usages);\nfunction byteStringToUint8Array(byteString) {\n    let array = new Uint8Array(byteString.length);\n    for(let i = 0; i < byteString.length; i++){\n        array[i] = byteString.charCodeAt(i);\n    }\n    return array;\n}\n// lib/server-runtime/cookies.ts\nvar createCookie = (name, cookieOptions = {})=>{\n    let { secrets = [], ...options } = {\n        path: \"/\",\n        sameSite: \"lax\",\n        ...cookieOptions\n    };\n    warnOnceAboutExpiresCookie(name, options.expires);\n    return {\n        get name () {\n            return name;\n        },\n        get isSigned () {\n            return secrets.length > 0;\n        },\n        get expires () {\n            return typeof options.maxAge !== \"undefined\" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;\n        },\n        async parse (cookieHeader, parseOptions) {\n            if (!cookieHeader) return null;\n            let cookies = (0, import_cookie.parse)(cookieHeader, {\n                ...options,\n                ...parseOptions\n            });\n            if (name in cookies) {\n                let value = cookies[name];\n                if (typeof value === \"string\" && value !== \"\") {\n                    let decoded = await decodeCookieValue(value, secrets);\n                    return decoded;\n                } else {\n                    return \"\";\n                }\n            } else {\n                return null;\n            }\n        },\n        async serialize (value, serializeOptions) {\n            return (0, import_cookie.serialize)(name, value === \"\" ? \"\" : await encodeCookieValue(value, secrets), {\n                ...options,\n                ...serializeOptions\n            });\n        }\n    };\n};\nvar isCookie = (object)=>{\n    return object != null && typeof object.name === \"string\" && typeof object.isSigned === \"boolean\" && typeof object.parse === \"function\" && typeof object.serialize === \"function\";\n};\nasync function encodeCookieValue(value, secrets) {\n    let encoded = encodeData(value);\n    if (secrets.length > 0) {\n        encoded = await sign(encoded, secrets[0]);\n    }\n    return encoded;\n}\nasync function decodeCookieValue(value, secrets) {\n    if (secrets.length > 0) {\n        for (let secret of secrets){\n            let unsignedValue = await unsign(value, secret);\n            if (unsignedValue !== false) {\n                return decodeData(unsignedValue);\n            }\n        }\n        return null;\n    }\n    return decodeData(value);\n}\nfunction encodeData(value) {\n    return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));\n}\nfunction decodeData(value) {\n    try {\n        return JSON.parse(decodeURIComponent(myEscape(atob(value))));\n    } catch (error) {\n        return {};\n    }\n}\nfunction myEscape(value) {\n    let str = value.toString();\n    let result = \"\";\n    let index = 0;\n    let chr, code;\n    while(index < str.length){\n        chr = str.charAt(index++);\n        if (/[\\w*+\\-./@]/.exec(chr)) {\n            result += chr;\n        } else {\n            code = chr.charCodeAt(0);\n            if (code < 256) {\n                result += \"%\" + hex(code, 2);\n            } else {\n                result += \"%u\" + hex(code, 4).toUpperCase();\n            }\n        }\n    }\n    return result;\n}\nfunction hex(code, length) {\n    let result = code.toString(16);\n    while(result.length < length)result = \"0\" + result;\n    return result;\n}\nfunction myUnescape(value) {\n    let str = value.toString();\n    let result = \"\";\n    let index = 0;\n    let chr, part;\n    while(index < str.length){\n        chr = str.charAt(index++);\n        if (chr === \"%\") {\n            if (str.charAt(index) === \"u\") {\n                part = str.slice(index + 1, index + 5);\n                if (/^[\\da-f]{4}$/i.exec(part)) {\n                    result += String.fromCharCode(parseInt(part, 16));\n                    index += 5;\n                    continue;\n                }\n            } else {\n                part = str.slice(index, index + 2);\n                if (/^[\\da-f]{2}$/i.exec(part)) {\n                    result += String.fromCharCode(parseInt(part, 16));\n                    index += 2;\n                    continue;\n                }\n            }\n        }\n        result += chr;\n    }\n    return result;\n}\nfunction warnOnceAboutExpiresCookie(name, expires) {\n    warnOnce(!expires, `The \"${name}\" cookie has an \"expires\" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \\`commitSession(session, { expires })\\` if using a session storage object, or \\`cookie.serialize(\"value\", { expires })\\` if you're using the cookie directly.`);\n}\n// lib/server-runtime/entry.ts\nfunction createEntryRouteModules(manifest) {\n    return Object.keys(manifest).reduce((memo2, routeId)=>{\n        let route = manifest[routeId];\n        if (route) {\n            memo2[routeId] = route.module;\n        }\n        return memo2;\n    }, {});\n}\n// lib/server-runtime/mode.ts\nvar ServerMode = /* @__PURE__ */ ((ServerMode2)=>{\n    ServerMode2[\"Development\"] = \"development\";\n    ServerMode2[\"Production\"] = \"production\";\n    ServerMode2[\"Test\"] = \"test\";\n    return ServerMode2;\n})(ServerMode || {});\nfunction isServerMode(value) {\n    return value === \"development\" /* Development */  || value === \"production\" /* Production */  || value === \"test\" /* Test */ ;\n}\n// lib/server-runtime/errors.ts\nfunction sanitizeError(error, serverMode) {\n    if (error instanceof Error && serverMode !== \"development\" /* Development */ ) {\n        let sanitized = new Error(\"Unexpected Server Error\");\n        sanitized.stack = void 0;\n        return sanitized;\n    }\n    return error;\n}\nfunction sanitizeErrors(errors, serverMode) {\n    return Object.entries(errors).reduce((acc, [routeId, error])=>{\n        return Object.assign(acc, {\n            [routeId]: sanitizeError(error, serverMode)\n        });\n    }, {});\n}\nfunction serializeError(error, serverMode) {\n    let sanitized = sanitizeError(error, serverMode);\n    return {\n        message: sanitized.message,\n        stack: sanitized.stack\n    };\n}\nfunction serializeErrors2(errors, serverMode) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        if (isRouteErrorResponse(val)) {\n            serialized[key] = {\n                ...val,\n                __type: \"RouteErrorResponse\"\n            };\n        } else if (val instanceof Error) {\n            let sanitized = sanitizeError(val, serverMode);\n            serialized[key] = {\n                message: sanitized.message,\n                stack: sanitized.stack,\n                __type: \"Error\",\n                // If this is a subclass (i.e., ReferenceError), send up the type so we\n                // can re-create the same type during hydration.  This will only apply\n                // in dev mode since all production errors are sanitized to normal\n                // Error instances\n                ...sanitized.name !== \"Error\" ? {\n                    __subType: sanitized.name\n                } : {}\n            };\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\n// lib/server-runtime/routeMatching.ts\nfunction matchServerRoutes(routes, pathname, basename) {\n    let matches = matchRoutes(routes, pathname, basename);\n    if (!matches) return null;\n    return matches.map((match)=>({\n            params: match.params,\n            pathname: match.pathname,\n            route: match.route\n        }));\n}\n// lib/server-runtime/data.ts\nasync function callRouteHandler(handler, args) {\n    let result = await handler({\n        request: stripRoutesParam(stripIndexParam2(args.request)),\n        params: args.params,\n        context: args.context\n    });\n    if (isDataWithResponseInit(result) && result.init && result.init.status && isRedirectStatusCode(result.init.status)) {\n        throw new Response(null, result.init);\n    }\n    return result;\n}\nfunction stripIndexParam2(request) {\n    let url = new URL(request.url);\n    let indexValues = url.searchParams.getAll(\"index\");\n    url.searchParams.delete(\"index\");\n    let indexValuesToKeep = [];\n    for (let indexValue of indexValues){\n        if (indexValue) {\n            indexValuesToKeep.push(indexValue);\n        }\n    }\n    for (let toKeep of indexValuesToKeep){\n        url.searchParams.append(\"index\", toKeep);\n    }\n    let init = {\n        method: request.method,\n        body: request.body,\n        headers: request.headers,\n        signal: request.signal\n    };\n    if (init.body) {\n        init.duplex = \"half\";\n    }\n    return new Request(url.href, init);\n}\nfunction stripRoutesParam(request) {\n    let url = new URL(request.url);\n    url.searchParams.delete(\"_routes\");\n    let init = {\n        method: request.method,\n        body: request.body,\n        headers: request.headers,\n        signal: request.signal\n    };\n    if (init.body) {\n        init.duplex = \"half\";\n    }\n    return new Request(url.href, init);\n}\n// lib/server-runtime/invariant.ts\nfunction invariant3(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        console.error(\"The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose\");\n        throw new Error(message);\n    }\n}\n// lib/server-runtime/dev.ts\nvar globalDevServerHooksKey = \"__reactRouterDevServerHooks\";\nfunction setDevServerHooks(devServerHooks) {\n    globalThis[globalDevServerHooksKey] = devServerHooks;\n}\nfunction getDevServerHooks() {\n    return globalThis[globalDevServerHooksKey];\n}\nfunction getBuildTimeHeader(request, headerName) {\n    if (typeof process !== \"undefined\") {\n        try {\n            if (process.env?.IS_RR_BUILD_REQUEST === \"yes\") {\n                return request.headers.get(headerName);\n            }\n        } catch (e) {}\n    }\n    return null;\n}\n// lib/server-runtime/routes.ts\nfunction groupRoutesByParentId2(manifest) {\n    let routes = {};\n    Object.values(manifest).forEach((route)=>{\n        if (route) {\n            let parentId = route.parentId || \"\";\n            if (!routes[parentId]) {\n                routes[parentId] = [];\n            }\n            routes[parentId].push(route);\n        }\n    });\n    return routes;\n}\nfunction createRoutes(manifest, parentId = \"\", routesByParentId = groupRoutesByParentId2(manifest)) {\n    return (routesByParentId[parentId] || []).map((route)=>({\n            ...route,\n            children: createRoutes(manifest, route.id, routesByParentId)\n        }));\n}\nfunction createStaticHandlerDataRoutes(manifest, future, parentId = \"\", routesByParentId = groupRoutesByParentId2(manifest)) {\n    return (routesByParentId[parentId] || []).map((route)=>{\n        let commonRoute = {\n            // Always include root due to default boundaries\n            hasErrorBoundary: route.id === \"root\" || route.module.ErrorBoundary != null,\n            id: route.id,\n            path: route.path,\n            unstable_middleware: route.module.unstable_middleware,\n            // Need to use RR's version in the param typed here to permit the optional\n            // context even though we know it'll always be provided in remix\n            loader: route.module.loader ? async (args)=>{\n                let preRenderedData = getBuildTimeHeader(args.request, \"X-React-Router-Prerender-Data\");\n                if (preRenderedData != null) {\n                    let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;\n                    invariant3(encoded, \"Missing prerendered data for route\");\n                    let uint8array = new TextEncoder().encode(encoded);\n                    let stream = new ReadableStream({\n                        start (controller) {\n                            controller.enqueue(uint8array);\n                            controller.close();\n                        }\n                    });\n                    let decoded = await decodeViaTurboStream(stream, global);\n                    let data2 = decoded.value;\n                    if (data2 && SingleFetchRedirectSymbol in data2) {\n                        let result = data2[SingleFetchRedirectSymbol];\n                        let init = {\n                            status: result.status\n                        };\n                        if (result.reload) {\n                            throw redirectDocument(result.redirect, init);\n                        } else if (result.replace) {\n                            throw replace(result.redirect, init);\n                        } else {\n                            throw redirect(result.redirect, init);\n                        }\n                    } else {\n                        invariant3(data2 && route.id in data2, \"Unable to decode prerendered data\");\n                        let result = data2[route.id];\n                        invariant3(\"data\" in result, \"Unable to process prerendered data\");\n                        return result.data;\n                    }\n                }\n                let val = await callRouteHandler(route.module.loader, args);\n                return val;\n            } : void 0,\n            action: route.module.action ? (args)=>callRouteHandler(route.module.action, args) : void 0,\n            handle: route.module.handle\n        };\n        return route.index ? {\n            index: true,\n            ...commonRoute\n        } : {\n            caseSensitive: route.caseSensitive,\n            children: createStaticHandlerDataRoutes(manifest, future, route.id, routesByParentId),\n            ...commonRoute\n        };\n    });\n}\n// lib/server-runtime/markup.ts\nvar ESCAPE_LOOKUP3 = {\n    \"&\": \"\\\\u0026\",\n    \">\": \"\\\\u003e\",\n    \"<\": \"\\\\u003c\",\n    \"\\u2028\": \"\\\\u2028\",\n    \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX3 = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml2(html) {\n    return html.replace(ESCAPE_REGEX3, (match)=>ESCAPE_LOOKUP3[match]);\n}\n// lib/server-runtime/serverHandoff.ts\nfunction createServerHandoffString(serverHandoff) {\n    return escapeHtml2(JSON.stringify(serverHandoff));\n}\n// lib/server-runtime/headers.ts\nvar import_set_cookie_parser = __webpack_require__(/*! set-cookie-parser */ \"(ssr)/./node_modules/set-cookie-parser/lib/set-cookie.js\");\nfunction getDocumentHeaders(build, context) {\n    let boundaryIdx = context.errors ? context.matches.findIndex((m)=>context.errors[m.route.id]) : -1;\n    let matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;\n    let errorHeaders;\n    if (boundaryIdx >= 0) {\n        let { actionHeaders, actionData, loaderHeaders, loaderData } = context;\n        context.matches.slice(boundaryIdx).some((match)=>{\n            let id = match.route.id;\n            if (actionHeaders[id] && (!actionData || !actionData.hasOwnProperty(id))) {\n                errorHeaders = actionHeaders[id];\n            } else if (loaderHeaders[id] && !loaderData.hasOwnProperty(id)) {\n                errorHeaders = loaderHeaders[id];\n            }\n            return errorHeaders != null;\n        });\n    }\n    return matches.reduce((parentHeaders, match, idx)=>{\n        let { id } = match.route;\n        let route = build.routes[id];\n        invariant3(route, `Route with id \"${id}\" not found in build`);\n        let routeModule = route.module;\n        let loaderHeaders = context.loaderHeaders[id] || new Headers();\n        let actionHeaders = context.actionHeaders[id] || new Headers();\n        let includeErrorHeaders = errorHeaders != null && idx === matches.length - 1;\n        let includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;\n        if (routeModule.headers == null) {\n            let headers2 = new Headers(parentHeaders);\n            if (includeErrorCookies) {\n                prependCookies(errorHeaders, headers2);\n            }\n            prependCookies(actionHeaders, headers2);\n            prependCookies(loaderHeaders, headers2);\n            return headers2;\n        }\n        let headers = new Headers(routeModule.headers ? typeof routeModule.headers === \"function\" ? routeModule.headers({\n            loaderHeaders,\n            parentHeaders,\n            actionHeaders,\n            errorHeaders: includeErrorHeaders ? errorHeaders : void 0\n        }) : routeModule.headers : void 0);\n        if (includeErrorCookies) {\n            prependCookies(errorHeaders, headers);\n        }\n        prependCookies(actionHeaders, headers);\n        prependCookies(loaderHeaders, headers);\n        prependCookies(parentHeaders, headers);\n        return headers;\n    }, new Headers());\n}\nfunction prependCookies(parentHeaders, childHeaders) {\n    let parentSetCookieString = parentHeaders.get(\"Set-Cookie\");\n    if (parentSetCookieString) {\n        let cookies = (0, import_set_cookie_parser.splitCookiesString)(parentSetCookieString);\n        let childCookies = new Set(childHeaders.getSetCookie());\n        cookies.forEach((cookie)=>{\n            if (!childCookies.has(cookie)) {\n                childHeaders.append(\"Set-Cookie\", cookie);\n            }\n        });\n    }\n}\n// lib/server-runtime/single-fetch.ts\nvar SERVER_NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([\n    ...NO_BODY_STATUS_CODES,\n    304\n]);\nasync function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n    try {\n        let respond2 = function(context) {\n            let headers = getDocumentHeaders(build, context);\n            if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n                return generateSingleFetchResponse(request, build, serverMode, {\n                    result: getSingleFetchRedirect(context.statusCode, headers, build.basename),\n                    headers,\n                    status: SINGLE_FETCH_REDIRECT_STATUS\n                });\n            }\n            if (context.errors) {\n                Object.values(context.errors).forEach((err)=>{\n                    if (!isRouteErrorResponse(err) || err.error) {\n                        handleError(err);\n                    }\n                });\n                context.errors = sanitizeErrors(context.errors, serverMode);\n            }\n            let singleFetchResult;\n            if (context.errors) {\n                singleFetchResult = {\n                    error: Object.values(context.errors)[0]\n                };\n            } else {\n                singleFetchResult = {\n                    data: Object.values(context.actionData || {})[0]\n                };\n            }\n            return generateSingleFetchResponse(request, build, serverMode, {\n                result: singleFetchResult,\n                headers,\n                status: context.statusCode\n            });\n        };\n        var respond = respond2;\n        let handlerRequest = new Request(handlerUrl, {\n            method: request.method,\n            body: request.body,\n            headers: request.headers,\n            signal: request.signal,\n            ...request.body ? {\n                duplex: \"half\"\n            } : void 0\n        });\n        let result = await staticHandler.query(handlerRequest, {\n            requestContext: loadContext,\n            skipLoaderErrorBubbling: true,\n            skipRevalidation: true,\n            unstable_respond: respond2\n        });\n        if (!isResponse(result)) {\n            result = respond2(result);\n        }\n        if (isRedirectResponse(result)) {\n            return generateSingleFetchResponse(request, build, serverMode, {\n                result: getSingleFetchRedirect(result.status, result.headers, build.basename),\n                headers: result.headers,\n                status: SINGLE_FETCH_REDIRECT_STATUS\n            });\n        }\n        return result;\n    } catch (error) {\n        handleError(error);\n        return generateSingleFetchResponse(request, build, serverMode, {\n            result: {\n                error\n            },\n            headers: new Headers(),\n            status: 500\n        });\n    }\n}\nasync function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n    try {\n        let respond2 = function(context) {\n            let headers = getDocumentHeaders(build, context);\n            if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n                return generateSingleFetchResponse(request, build, serverMode, {\n                    result: {\n                        [SingleFetchRedirectSymbol]: getSingleFetchRedirect(context.statusCode, headers, build.basename)\n                    },\n                    headers,\n                    status: SINGLE_FETCH_REDIRECT_STATUS\n                });\n            }\n            if (context.errors) {\n                Object.values(context.errors).forEach((err)=>{\n                    if (!isRouteErrorResponse(err) || err.error) {\n                        handleError(err);\n                    }\n                });\n                context.errors = sanitizeErrors(context.errors, serverMode);\n            }\n            let results = {};\n            let loadedMatches = new Set(context.matches.filter((m)=>loadRouteIds ? loadRouteIds.has(m.route.id) : m.route.loader != null).map((m)=>m.route.id));\n            if (context.errors) {\n                for (let [id, error] of Object.entries(context.errors)){\n                    results[id] = {\n                        error\n                    };\n                }\n            }\n            for (let [id, data2] of Object.entries(context.loaderData)){\n                if (!(id in results) && loadedMatches.has(id)) {\n                    results[id] = {\n                        data: data2\n                    };\n                }\n            }\n            return generateSingleFetchResponse(request, build, serverMode, {\n                result: results,\n                headers,\n                status: context.statusCode\n            });\n        };\n        var respond = respond2;\n        let handlerRequest = new Request(handlerUrl, {\n            headers: request.headers,\n            signal: request.signal\n        });\n        let routesParam = new URL(request.url).searchParams.get(\"_routes\");\n        let loadRouteIds = routesParam ? new Set(routesParam.split(\",\")) : null;\n        let result = await staticHandler.query(handlerRequest, {\n            requestContext: loadContext,\n            filterMatchesToLoad: (m)=>!loadRouteIds || loadRouteIds.has(m.route.id),\n            skipLoaderErrorBubbling: true,\n            unstable_respond: respond2\n        });\n        if (!isResponse(result)) {\n            result = respond2(result);\n        }\n        if (isRedirectResponse(result)) {\n            return generateSingleFetchResponse(request, build, serverMode, {\n                result: {\n                    [SingleFetchRedirectSymbol]: getSingleFetchRedirect(result.status, result.headers, build.basename)\n                },\n                headers: result.headers,\n                status: SINGLE_FETCH_REDIRECT_STATUS\n            });\n        }\n        return result;\n    } catch (error) {\n        handleError(error);\n        return generateSingleFetchResponse(request, build, serverMode, {\n            result: {\n                root: {\n                    error\n                }\n            },\n            headers: new Headers(),\n            status: 500\n        });\n    }\n}\nfunction generateSingleFetchResponse(request, build, serverMode, { result, headers, status }) {\n    let resultHeaders = new Headers(headers);\n    resultHeaders.set(\"X-Remix-Response\", \"yes\");\n    if (SERVER_NO_BODY_STATUS_CODES.has(status)) {\n        return new Response(null, {\n            status,\n            headers: resultHeaders\n        });\n    }\n    resultHeaders.set(\"Content-Type\", \"text/x-script\");\n    return new Response(encodeViaTurboStream(result, request.signal, build.entry.module.streamTimeout, serverMode), {\n        status: status || 200,\n        headers: resultHeaders\n    });\n}\nfunction getSingleFetchRedirect(status, headers, basename) {\n    let redirect2 = headers.get(\"Location\");\n    if (basename) {\n        redirect2 = stripBasename(redirect2, basename) || redirect2;\n    }\n    return {\n        redirect: redirect2,\n        status,\n        revalidate: // Technically X-Remix-Revalidate isn't needed here - that was an implementation\n        // detail of ?_data requests as our way to tell the front end to revalidate when\n        // we didn't have a response body to include that information in.\n        // With single fetch, we tell the front end via this revalidate boolean field.\n        // However, we're respecting it for now because it may be something folks have\n        // used in their own responses\n        // TODO(v3): Consider removing or making this official public API\n        headers.has(\"X-Remix-Revalidate\") || headers.has(\"Set-Cookie\"),\n        reload: headers.has(\"X-Remix-Reload-Document\"),\n        replace: headers.has(\"X-Remix-Replace\")\n    };\n}\nfunction encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {\n    let controller = new AbortController();\n    let timeoutId = setTimeout(()=>controller.abort(new Error(\"Server Timeout\")), typeof streamTimeout === \"number\" ? streamTimeout : 4950);\n    requestSignal.addEventListener(\"abort\", ()=>clearTimeout(timeoutId));\n    return encode(data2, {\n        signal: controller.signal,\n        plugins: [\n            (value)=>{\n                if (value instanceof Error) {\n                    let { name, message, stack } = serverMode === \"production\" /* Production */  ? sanitizeError(value, serverMode) : value;\n                    return [\n                        \"SanitizedError\",\n                        name,\n                        message,\n                        stack\n                    ];\n                }\n                if (value instanceof ErrorResponseImpl) {\n                    let { data: data3, status, statusText } = value;\n                    return [\n                        \"ErrorResponse\",\n                        data3,\n                        status,\n                        statusText\n                    ];\n                }\n                if (value && typeof value === \"object\" && SingleFetchRedirectSymbol in value) {\n                    return [\n                        \"SingleFetchRedirect\",\n                        value[SingleFetchRedirectSymbol]\n                    ];\n                }\n            }\n        ],\n        postPlugins: [\n            (value)=>{\n                if (!value) return;\n                if (typeof value !== \"object\") return;\n                return [\n                    \"SingleFetchClassInstance\",\n                    Object.fromEntries(Object.entries(value))\n                ];\n            },\n            ()=>[\n                    \"SingleFetchFallback\"\n                ]\n        ]\n    });\n}\n// lib/server-runtime/server.ts\nfunction derive(build, mode) {\n    let routes = createRoutes(build.routes);\n    let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);\n    let serverMode = isServerMode(mode) ? mode : \"production\" /* Production */ ;\n    let staticHandler = createStaticHandler(dataRoutes, {\n        basename: build.basename\n    });\n    let errorHandler = build.entry.module.handleError || ((error, { request })=>{\n        if (serverMode !== \"test\" /* Test */  && !request.signal.aborted) {\n            console.error(// @ts-expect-error This is \"private\" from users but intended for internal use\n            isRouteErrorResponse(error) && error.error ? error.error : error);\n        }\n    });\n    return {\n        routes,\n        dataRoutes,\n        serverMode,\n        staticHandler,\n        errorHandler\n    };\n}\nvar createRequestHandler = (build, mode)=>{\n    let _build;\n    let routes;\n    let serverMode;\n    let staticHandler;\n    let errorHandler;\n    return async function requestHandler(request, initialContext) {\n        _build = typeof build === \"function\" ? await build() : build;\n        if (typeof build === \"function\") {\n            let derived = derive(_build, mode);\n            routes = derived.routes;\n            serverMode = derived.serverMode;\n            staticHandler = derived.staticHandler;\n            errorHandler = derived.errorHandler;\n        } else if (!routes || !serverMode || !staticHandler || !errorHandler) {\n            let derived = derive(_build, mode);\n            routes = derived.routes;\n            serverMode = derived.serverMode;\n            staticHandler = derived.staticHandler;\n            errorHandler = derived.errorHandler;\n        }\n        let params = {};\n        let loadContext;\n        let handleError = (error)=>{\n            if (mode === \"development\" /* Development */ ) {\n                getDevServerHooks()?.processRequestError?.(error);\n            }\n            errorHandler(error, {\n                context: loadContext,\n                params,\n                request\n            });\n        };\n        if (_build.future.unstable_middleware) {\n            if (initialContext == null) {\n                loadContext = new unstable_RouterContextProvider();\n            } else {\n                try {\n                    loadContext = new unstable_RouterContextProvider(initialContext);\n                } catch (e) {\n                    let error = new Error(`Unable to create initial \\`unstable_RouterContextProvider\\` instance. Please confirm you are returning an instance of \\`Map<unstable_routerContext, unknown>\\` from your \\`getLoadContext\\` function.\n\nError: ${e instanceof Error ? e.toString() : e}`);\n                    handleError(error);\n                    return returnLastResortErrorResponse(error, serverMode);\n                }\n            }\n        } else {\n            loadContext = initialContext || {};\n        }\n        let url = new URL(request.url);\n        let normalizedBasename = _build.basename || \"/\";\n        let normalizedPath = url.pathname;\n        if (stripBasename(normalizedPath, normalizedBasename) === \"/_root.data\") {\n            normalizedPath = normalizedBasename;\n        } else if (normalizedPath.endsWith(\".data\")) {\n            normalizedPath = normalizedPath.replace(/\\.data$/, \"\");\n        }\n        if (stripBasename(normalizedPath, normalizedBasename) !== \"/\" && normalizedPath.endsWith(\"/\")) {\n            normalizedPath = normalizedPath.slice(0, -1);\n        }\n        let isSpaMode = getBuildTimeHeader(request, \"X-React-Router-SPA-Mode\") === \"yes\";\n        if (!_build.ssr) {\n            if (_build.prerender.length === 0) {\n                isSpaMode = true;\n            } else if (!_build.prerender.includes(normalizedPath) && !_build.prerender.includes(normalizedPath + \"/\")) {\n                if (url.pathname.endsWith(\".data\")) {\n                    errorHandler(new ErrorResponseImpl(404, \"Not Found\", `Refusing to SSR the path \\`${normalizedPath}\\` because \\`ssr:false\\` is set and the path is not included in the \\`prerender\\` config, so in production the path will be a 404.`), {\n                        context: loadContext,\n                        params,\n                        request\n                    });\n                    return new Response(\"Not Found\", {\n                        status: 404,\n                        statusText: \"Not Found\"\n                    });\n                } else {\n                    isSpaMode = true;\n                }\n            }\n        }\n        let manifestUrl = getManifestPath(_build.routeDiscovery.manifestPath, normalizedBasename);\n        if (url.pathname === manifestUrl) {\n            try {\n                let res = await handleManifestRequest(_build, routes, url);\n                return res;\n            } catch (e) {\n                handleError(e);\n                return new Response(\"Unknown Server Error\", {\n                    status: 500\n                });\n            }\n        }\n        let matches = matchServerRoutes(routes, normalizedPath, _build.basename);\n        if (matches && matches.length > 0) {\n            Object.assign(params, matches[0].params);\n        }\n        let response;\n        if (url.pathname.endsWith(\".data\")) {\n            let handlerUrl = new URL(request.url);\n            handlerUrl.pathname = normalizedPath;\n            let singleFetchMatches = matchServerRoutes(routes, handlerUrl.pathname, _build.basename);\n            response = await handleSingleFetchRequest(serverMode, _build, staticHandler, request, handlerUrl, loadContext, handleError);\n            if (_build.entry.module.handleDataRequest) {\n                response = await _build.entry.module.handleDataRequest(response, {\n                    context: loadContext,\n                    params: singleFetchMatches ? singleFetchMatches[0].params : {},\n                    request\n                });\n                if (isRedirectResponse(response)) {\n                    let result = getSingleFetchRedirect(response.status, response.headers, _build.basename);\n                    if (request.method === \"GET\") {\n                        result = {\n                            [SingleFetchRedirectSymbol]: result\n                        };\n                    }\n                    let headers = new Headers(response.headers);\n                    headers.set(\"Content-Type\", \"text/x-script\");\n                    return new Response(encodeViaTurboStream(result, request.signal, _build.entry.module.streamTimeout, serverMode), {\n                        status: SINGLE_FETCH_REDIRECT_STATUS,\n                        headers\n                    });\n                }\n            }\n        } else if (!isSpaMode && matches && matches[matches.length - 1].route.module.default == null && matches[matches.length - 1].route.module.ErrorBoundary == null) {\n            response = await handleResourceRequest(serverMode, _build, staticHandler, matches.slice(-1)[0].route.id, request, loadContext, handleError);\n        } else {\n            let { pathname } = url;\n            let criticalCss = void 0;\n            if (_build.unstable_getCriticalCss) {\n                criticalCss = await _build.unstable_getCriticalCss({\n                    pathname\n                });\n            } else if (mode === \"development\" /* Development */  && getDevServerHooks()?.getCriticalCss) {\n                criticalCss = await getDevServerHooks()?.getCriticalCss?.(pathname);\n            }\n            response = await handleDocumentRequest(serverMode, _build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss);\n        }\n        if (request.method === \"HEAD\") {\n            return new Response(null, {\n                headers: response.headers,\n                status: response.status,\n                statusText: response.statusText\n            });\n        }\n        return response;\n    };\n};\nasync function handleManifestRequest(build, routes, url) {\n    if (build.assets.version !== url.searchParams.get(\"version\")) {\n        return new Response(null, {\n            status: 204,\n            headers: {\n                \"X-Remix-Reload-Document\": \"true\"\n            }\n        });\n    }\n    let patches = {};\n    if (url.searchParams.has(\"p\")) {\n        let paths = /* @__PURE__ */ new Set();\n        url.searchParams.getAll(\"p\").forEach((path)=>{\n            if (!path.startsWith(\"/\")) {\n                path = `/${path}`;\n            }\n            let segments = path.split(\"/\").slice(1);\n            segments.forEach((_, i)=>{\n                let partialPath = segments.slice(0, i + 1).join(\"/\");\n                paths.add(`/${partialPath}`);\n            });\n        });\n        for (let path of paths){\n            let matches = matchServerRoutes(routes, path, build.basename);\n            if (matches) {\n                for (let match of matches){\n                    let routeId = match.route.id;\n                    let route = build.assets.routes[routeId];\n                    if (route) {\n                        patches[routeId] = route;\n                    }\n                }\n            }\n        }\n        return Response.json(patches, {\n            headers: {\n                \"Cache-Control\": \"public, max-age=31536000, immutable\"\n            }\n        });\n    }\n    return new Response(\"Invalid Request\", {\n        status: 400\n    });\n}\nasync function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {\n    let response = request.method !== \"GET\" ? await singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) : await singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError);\n    return response;\n}\nasync function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss) {\n    try {\n        let response = await staticHandler.query(request, {\n            requestContext: loadContext,\n            unstable_respond: build.future.unstable_middleware ? (ctx)=>renderHtml(ctx, isSpaMode) : void 0\n        });\n        return isResponse(response) ? response : renderHtml(response, isSpaMode);\n    } catch (error) {\n        handleError(error);\n        return new Response(null, {\n            status: 500\n        });\n    }\n    async function renderHtml(context, isSpaMode2) {\n        if (isResponse(context)) {\n            return context;\n        }\n        let headers = getDocumentHeaders(build, context);\n        if (SERVER_NO_BODY_STATUS_CODES.has(context.statusCode)) {\n            return new Response(null, {\n                status: context.statusCode,\n                headers\n            });\n        }\n        if (context.errors) {\n            Object.values(context.errors).forEach((err)=>{\n                if (!isRouteErrorResponse(err) || err.error) {\n                    handleError(err);\n                }\n            });\n            context.errors = sanitizeErrors(context.errors, serverMode);\n        }\n        let state = {\n            loaderData: context.loaderData,\n            actionData: context.actionData,\n            errors: serializeErrors2(context.errors, serverMode)\n        };\n        let baseServerHandoff = {\n            basename: build.basename,\n            future: build.future,\n            routeDiscovery: build.routeDiscovery,\n            ssr: build.ssr,\n            isSpaMode: isSpaMode2\n        };\n        let entryContext = {\n            manifest: build.assets,\n            routeModules: createEntryRouteModules(build.routes),\n            staticHandlerContext: context,\n            criticalCss,\n            serverHandoffString: createServerHandoffString({\n                ...baseServerHandoff,\n                criticalCss\n            }),\n            serverHandoffStream: encodeViaTurboStream(state, request.signal, build.entry.module.streamTimeout, serverMode),\n            renderMeta: {},\n            future: build.future,\n            ssr: build.ssr,\n            routeDiscovery: build.routeDiscovery,\n            isSpaMode: isSpaMode2,\n            serializeError: (err)=>serializeError(err, serverMode)\n        };\n        let handleDocumentRequestFunction = build.entry.module.default;\n        try {\n            return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext, loadContext);\n        } catch (error) {\n            handleError(error);\n            let errorForSecondRender = error;\n            if (isResponse(error)) {\n                try {\n                    let data2 = await unwrapResponse(error);\n                    errorForSecondRender = new ErrorResponseImpl(error.status, error.statusText, data2);\n                } catch (e) {}\n            }\n            context = getStaticContextFromError(staticHandler.dataRoutes, context, errorForSecondRender);\n            if (context.errors) {\n                context.errors = sanitizeErrors(context.errors, serverMode);\n            }\n            let state2 = {\n                loaderData: context.loaderData,\n                actionData: context.actionData,\n                errors: serializeErrors2(context.errors, serverMode)\n            };\n            entryContext = {\n                ...entryContext,\n                staticHandlerContext: context,\n                serverHandoffString: createServerHandoffString(baseServerHandoff),\n                serverHandoffStream: encodeViaTurboStream(state2, request.signal, build.entry.module.streamTimeout, serverMode),\n                renderMeta: {}\n            };\n            try {\n                return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext, loadContext);\n            } catch (error2) {\n                handleError(error2);\n                return returnLastResortErrorResponse(error2, serverMode);\n            }\n        }\n    }\n}\nasync function handleResourceRequest(serverMode, build, staticHandler, routeId, request, loadContext, handleError) {\n    try {\n        let response = await staticHandler.queryRoute(request, {\n            routeId,\n            requestContext: loadContext,\n            unstable_respond: build.future.unstable_middleware ? (ctx)=>ctx : void 0\n        });\n        if (isResponse(response)) {\n            return response;\n        }\n        if (typeof response === \"string\") {\n            return new Response(response);\n        }\n        return Response.json(response);\n    } catch (error) {\n        if (isResponse(error)) {\n            error.headers.set(\"X-Remix-Catch\", \"yes\");\n            return error;\n        }\n        if (isRouteErrorResponse(error)) {\n            if (error) {\n                handleError(error);\n            }\n            return errorResponseToJson(error, serverMode);\n        }\n        if (error instanceof Error && error.message === \"Expected a response from queryRoute\") {\n            let newError = new Error(\"Expected a Response to be returned from resource route handler\");\n            handleError(newError);\n            return returnLastResortErrorResponse(newError, serverMode);\n        }\n        handleError(error);\n        return returnLastResortErrorResponse(error, serverMode);\n    }\n}\nfunction errorResponseToJson(errorResponse, serverMode) {\n    return Response.json(serializeError(// @ts-expect-error This is \"private\" from users but intended for internal use\n    errorResponse.error || new Error(\"Unexpected Server Error\"), serverMode), {\n        status: errorResponse.status,\n        statusText: errorResponse.statusText,\n        headers: {\n            \"X-Remix-Error\": \"yes\"\n        }\n    });\n}\nfunction returnLastResortErrorResponse(error, serverMode) {\n    let message = \"Unexpected Server Error\";\n    if (serverMode !== \"production\" /* Production */ ) {\n        message += `\n\n${String(error)}`;\n    }\n    return new Response(message, {\n        status: 500,\n        headers: {\n            \"Content-Type\": \"text/plain\"\n        }\n    });\n}\nfunction unwrapResponse(response) {\n    let contentType = response.headers.get(\"Content-Type\");\n    return contentType && /\\bapplication\\/json\\b/.test(contentType) ? response.body == null ? null : response.json() : response.text();\n}\n// lib/server-runtime/sessions.ts\nfunction flash(name) {\n    return `__flash_${name}__`;\n}\nvar createSession = (initialData = {}, id = \"\")=>{\n    let map = new Map(Object.entries(initialData));\n    return {\n        get id () {\n            return id;\n        },\n        get data () {\n            return Object.fromEntries(map);\n        },\n        has (name) {\n            return map.has(name) || map.has(flash(name));\n        },\n        get (name) {\n            if (map.has(name)) return map.get(name);\n            let flashName = flash(name);\n            if (map.has(flashName)) {\n                let value = map.get(flashName);\n                map.delete(flashName);\n                return value;\n            }\n            return void 0;\n        },\n        set (name, value) {\n            map.set(name, value);\n        },\n        flash (name, value) {\n            map.set(flash(name), value);\n        },\n        unset (name) {\n            map.delete(name);\n        }\n    };\n};\nvar isSession = (object)=>{\n    return object != null && typeof object.id === \"string\" && typeof object.data !== \"undefined\" && typeof object.has === \"function\" && typeof object.get === \"function\" && typeof object.set === \"function\" && typeof object.flash === \"function\" && typeof object.unset === \"function\";\n};\nfunction createSessionStorage({ cookie: cookieArg, createData, readData, updateData, deleteData }) {\n    let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n    warnOnceAboutSigningSessionCookie(cookie);\n    return {\n        async getSession (cookieHeader, options) {\n            let id = cookieHeader && await cookie.parse(cookieHeader, options);\n            let data2 = id && await readData(id);\n            return createSession(data2 || {}, id || \"\");\n        },\n        async commitSession (session, options) {\n            let { id, data: data2 } = session;\n            let expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;\n            if (id) {\n                await updateData(id, data2, expires);\n            } else {\n                id = await createData(data2, expires);\n            }\n            return cookie.serialize(id, options);\n        },\n        async destroySession (session, options) {\n            await deleteData(session.id);\n            return cookie.serialize(\"\", {\n                ...options,\n                maxAge: void 0,\n                expires: /* @__PURE__ */ new Date(0)\n            });\n        }\n    };\n}\nfunction warnOnceAboutSigningSessionCookie(cookie) {\n    warnOnce(cookie.isSigned, `The \"${cookie.name}\" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://reactrouter.com/explanation/sessions-and-cookies#signing-cookies for more information.`);\n}\n// lib/server-runtime/sessions/cookieStorage.ts\nfunction createCookieSessionStorage({ cookie: cookieArg } = {}) {\n    let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n    warnOnceAboutSigningSessionCookie(cookie);\n    return {\n        async getSession (cookieHeader, options) {\n            return createSession(cookieHeader && await cookie.parse(cookieHeader, options) || {});\n        },\n        async commitSession (session, options) {\n            let serializedCookie = await cookie.serialize(session.data, options);\n            if (serializedCookie.length > 4096) {\n                throw new Error(\"Cookie length will exceed browser maximum. Length: \" + serializedCookie.length);\n            }\n            return serializedCookie;\n        },\n        async destroySession (_session, options) {\n            return cookie.serialize(\"\", {\n                ...options,\n                maxAge: void 0,\n                expires: /* @__PURE__ */ new Date(0)\n            });\n        }\n    };\n}\n// lib/server-runtime/sessions/memoryStorage.ts\nfunction createMemorySessionStorage({ cookie } = {}) {\n    let map = /* @__PURE__ */ new Map();\n    return createSessionStorage({\n        cookie,\n        async createData (data2, expires) {\n            let id = Math.random().toString(36).substring(2, 10);\n            map.set(id, {\n                data: data2,\n                expires\n            });\n            return id;\n        },\n        async readData (id) {\n            if (map.has(id)) {\n                let { data: data2, expires } = map.get(id);\n                if (!expires || expires > /* @__PURE__ */ new Date()) {\n                    return data2;\n                }\n                if (expires) map.delete(id);\n            }\n            return null;\n        },\n        async updateData (id, data2, expires) {\n            map.set(id, {\n                data: data2,\n                expires\n            });\n        },\n        async deleteData (id) {\n            map.delete(id);\n        }\n    });\n}\n// lib/href.ts\nfunction href(path, ...args) {\n    let params = args[0];\n    return path.split(\"/\").map((segment)=>{\n        if (segment === \"*\") {\n            return params ? params[\"*\"] : void 0;\n        }\n        const match = segment.match(/^:([\\w-]+)(\\?)?/);\n        if (!match) return segment;\n        const param = match[1];\n        const value = params ? params[param] : void 0;\n        const isRequired = match[2] === void 0;\n        if (isRequired && value === void 0) {\n            throw Error(`Path '${path}' requires param '${param}' but it was not provided`);\n        }\n        return value;\n    }).filter((segment)=>segment !== void 0).join(\"/\");\n}\n// lib/dom/ssr/errors.ts\nfunction deserializeErrors2(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        if (val && val.__type === \"RouteErrorResponse\") {\n            serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n        } else if (val && val.__type === \"Error\") {\n            if (val.__subType) {\n                let ErrorConstructor = window[val.__subType];\n                if (typeof ErrorConstructor === \"function\") {\n                    try {\n                        let error = new ErrorConstructor(val.message);\n                        error.stack = val.stack;\n                        serialized[key] = error;\n                    } catch (e) {}\n                }\n            }\n            if (serialized[key] == null) {\n                let error = new Error(val.message);\n                error.stack = val.stack;\n                serialized[key] = error;\n            }\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\n// lib/dom/ssr/hydration.tsx\nfunction getHydrationData(state, routes, getRouteInfo, location, basename, isSpaMode) {\n    let hydrationData = {\n        ...state,\n        loaderData: {\n            ...state.loaderData\n        }\n    };\n    let initialMatches = matchRoutes(routes, location, basename);\n    if (initialMatches) {\n        for (let match of initialMatches){\n            let routeId = match.route.id;\n            let routeInfo = getRouteInfo(routeId);\n            if (shouldHydrateRouteLoader(routeId, routeInfo.clientLoader, routeInfo.hasLoader, isSpaMode) && (routeInfo.hasHydrateFallback || !routeInfo.hasLoader)) {\n                delete hydrationData.loaderData[routeId];\n            } else if (!routeInfo.hasLoader) {\n                hydrationData.loaderData[routeId] = null;\n            }\n        }\n    }\n    return hydrationData;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztDQVNDLEdBQ1k7QUFDYixJQUFJQSxXQUFXQyxPQUFPQyxNQUFNO0FBQzVCLElBQUlDLFlBQVlGLE9BQU9HLGNBQWM7QUFDckMsSUFBSUMsbUJBQW1CSixPQUFPSyx3QkFBd0I7QUFDdEQsSUFBSUMsb0JBQW9CTixPQUFPTyxtQkFBbUI7QUFDbEQsSUFBSUMsZUFBZVIsT0FBT1MsY0FBYztBQUN4QyxJQUFJQyxlQUFlVixPQUFPVyxTQUFTLENBQUNDLGNBQWM7QUFDbEQsSUFBSUMsY0FBYyxDQUFDQztJQUNqQixNQUFNQyxVQUFVRDtBQUNsQjtBQUNBLElBQUlFLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDdEIsSUFBSyxJQUFJQyxRQUFRRCxJQUNmaEIsVUFBVWUsUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRUUsWUFBWTtJQUFLO0FBQy9EO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPckIsa0JBQWtCa0IsTUFDaEMsSUFBSSxDQUFDZCxhQUFha0IsSUFBSSxDQUFDTCxJQUFJSSxRQUFRQSxRQUFRRixRQUN6Q3ZCLFVBQVVxQixJQUFJSSxLQUFLO1lBQUVQLEtBQUssSUFBTUksSUFBSSxDQUFDRyxJQUFJO1lBQUVOLFlBQVksQ0FBRUssQ0FBQUEsT0FBT3RCLGlCQUFpQm9CLE1BQU1HLElBQUcsS0FBTUQsS0FBS0wsVUFBVTtRQUFDO0lBQ3RIO0lBQ0EsT0FBT0U7QUFDVDtBQUNBLElBQUlNLFVBQVUsQ0FBQ0MsS0FBS0MsWUFBWWQsU0FBWUEsQ0FBQUEsU0FBU2EsT0FBTyxPQUFPL0IsU0FBU1MsYUFBYXNCLFFBQVEsQ0FBQyxHQUFH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QUFLLElBQUk5SixTQUFTOEosZUFBZ0I7WUFDaEMsSUFBSXlILFVBQVV2UixNQUFNM0IsS0FBSyxDQUFDUSxFQUFFO1lBQzVCLElBQUl3OUMsWUFBWS9mLGFBQWEvcUI7WUFDN0IsSUFBSTllLHlCQUNGOGUsU0FDQThxQyxVQUFVdmEsWUFBWSxFQUN0QnVhLFVBQVVucEIsU0FBUyxFQUNuQjNDLGNBQ0k4ckIsQ0FBQUEsVUFBVUMsa0JBQWtCLElBQUksQ0FBQ0QsVUFBVW5wQixTQUFTLEdBQUc7Z0JBQzNELE9BQU9ycEIsY0FBYzVKLFVBQVUsQ0FBQ3NSLFFBQVE7WUFDMUMsT0FBTyxJQUFJLENBQUM4cUMsVUFBVW5wQixTQUFTLEVBQUU7Z0JBQy9CcnBCLGNBQWM1SixVQUFVLENBQUNzUixRQUFRLEdBQUc7WUFDdEM7UUFDRjtJQUNGO0lBQ0EsT0FBTzFIO0FBQ1Q7QUFDQSw2REFBNkQ7QUFDN0QsS0FBTTNTLENBQUFBLENBcUhOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmFsYW5jZS1jb2RlLWFsbGlhbmNlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L2RldmVsb3BtZW50L2luZGV4LmpzPzNjNzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiByZWFjdC1yb3V0ZXIgdjcuNi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3R5cGVFcnJvciA9IChtc2cpID0+IHtcbiAgdGhyb3cgVHlwZUVycm9yKG1zZyk7XG59O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4gbWVtYmVyLmhhcyhvYmopIHx8IF9fdHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaikpO1xudmFyIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IG1lbWJlci5oYXMob2JqKSA/IF9fdHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKSA6IG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuXG4vLyBpbmRleC50c1xudmFyIHJlYWN0X3JvdXRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChyZWFjdF9yb3V0ZXJfZXhwb3J0cywge1xuICBBd2FpdDogKCkgPT4gQXdhaXQsXG4gIEJyb3dzZXJSb3V0ZXI6ICgpID0+IEJyb3dzZXJSb3V0ZXIsXG4gIEZvcm06ICgpID0+IEZvcm0sXG4gIEhhc2hSb3V0ZXI6ICgpID0+IEhhc2hSb3V0ZXIsXG4gIElETEVfQkxPQ0tFUjogKCkgPT4gSURMRV9CTE9DS0VSLFxuICBJRExFX0ZFVENIRVI6ICgpID0+IElETEVfRkVUQ0hFUixcbiAgSURMRV9OQVZJR0FUSU9OOiAoKSA9PiBJRExFX05BVklHQVRJT04sXG4gIExpbms6ICgpID0+IExpbmssXG4gIExpbmtzOiAoKSA9PiBMaW5rcyxcbiAgTWVtb3J5Um91dGVyOiAoKSA9PiBNZW1vcnlSb3V0ZXIsXG4gIE1ldGE6ICgpID0+IE1ldGEsXG4gIE5hdkxpbms6ICgpID0+IE5hdkxpbmssXG4gIE5hdmlnYXRlOiAoKSA9PiBOYXZpZ2F0ZSxcbiAgTmF2aWdhdGlvblR5cGU6ICgpID0+IEFjdGlvbixcbiAgT3V0bGV0OiAoKSA9PiBPdXRsZXQsXG4gIFByZWZldGNoUGFnZUxpbmtzOiAoKSA9PiBQcmVmZXRjaFBhZ2VMaW5rcyxcbiAgUm91dGU6ICgpID0+IFJvdXRlLFxuICBSb3V0ZXI6ICgpID0+IFJvdXRlcixcbiAgUm91dGVyUHJvdmlkZXI6ICgpID0+IFJvdXRlclByb3ZpZGVyLFxuICBSb3V0ZXM6ICgpID0+IFJvdXRlcyxcbiAgU2NyaXB0czogKCkgPT4gU2NyaXB0cyxcbiAgU2Nyb2xsUmVzdG9yYXRpb246ICgpID0+IFNjcm9sbFJlc3RvcmF0aW9uLFxuICBTZXJ2ZXJSb3V0ZXI6ICgpID0+IFNlcnZlclJvdXRlcixcbiAgU3RhdGljUm91dGVyOiAoKSA9PiBTdGF0aWNSb3V0ZXIsXG4gIFN0YXRpY1JvdXRlclByb3ZpZGVyOiAoKSA9PiBTdGF0aWNSb3V0ZXJQcm92aWRlcixcbiAgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0OiAoKSA9PiBEYXRhUm91dGVyQ29udGV4dCxcbiAgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQ6ICgpID0+IERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIFVOU0FGRV9FcnJvclJlc3BvbnNlSW1wbDogKCkgPT4gRXJyb3JSZXNwb25zZUltcGwsXG4gIFVOU0FGRV9GZXRjaGVyc0NvbnRleHQ6ICgpID0+IEZldGNoZXJzQ29udGV4dCxcbiAgVU5TQUZFX0ZyYW1ld29ya0NvbnRleHQ6ICgpID0+IEZyYW1ld29ya0NvbnRleHQsXG4gIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQ6ICgpID0+IExvY2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0OiAoKSA9PiBOYXZpZ2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX1JlbWl4RXJyb3JCb3VuZGFyeTogKCkgPT4gUmVtaXhFcnJvckJvdW5kYXJ5LFxuICBVTlNBRkVfUm91dGVDb250ZXh0OiAoKSA9PiBSb3V0ZUNvbnRleHQsXG4gIFVOU0FGRV9TZXJ2ZXJNb2RlOiAoKSA9PiBTZXJ2ZXJNb2RlLFxuICBVTlNBRkVfU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbDogKCkgPT4gU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbCxcbiAgVU5TQUZFX1ZpZXdUcmFuc2l0aW9uQ29udGV4dDogKCkgPT4gVmlld1RyYW5zaXRpb25Db250ZXh0LFxuICBVTlNBRkVfY3JlYXRlQnJvd3Nlckhpc3Rvcnk6ICgpID0+IGNyZWF0ZUJyb3dzZXJIaXN0b3J5LFxuICBVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzOiAoKSA9PiBjcmVhdGVDbGllbnRSb3V0ZXMsXG4gIFVOU0FGRV9jcmVhdGVDbGllbnRSb3V0ZXNXaXRoSE1SUmV2YWxpZGF0aW9uT3B0T3V0OiAoKSA9PiBjcmVhdGVDbGllbnRSb3V0ZXNXaXRoSE1SUmV2YWxpZGF0aW9uT3B0T3V0LFxuICBVTlNBRkVfY3JlYXRlUm91dGVyOiAoKSA9PiBjcmVhdGVSb3V0ZXIsXG4gIFVOU0FGRV9kZWNvZGVWaWFUdXJib1N0cmVhbTogKCkgPT4gZGVjb2RlVmlhVHVyYm9TdHJlYW0sXG4gIFVOU0FGRV9kZXNlcmlhbGl6ZUVycm9yczogKCkgPT4gZGVzZXJpYWxpemVFcnJvcnMyLFxuICBVTlNBRkVfZ2V0SHlkcmF0aW9uRGF0YTogKCkgPT4gZ2V0SHlkcmF0aW9uRGF0YSxcbiAgVU5TQUZFX2dldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb246ICgpID0+IGdldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24sXG4gIFVOU0FGRV9nZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5OiAoKSA9PiBnZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5LFxuICBVTlNBRkVfaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzOiAoKSA9PiBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMsXG4gIFVOU0FGRV9pbnZhcmlhbnQ6ICgpID0+IGludmFyaWFudCxcbiAgVU5TQUZFX21hcFJvdXRlUHJvcGVydGllczogKCkgPT4gbWFwUm91dGVQcm9wZXJ0aWVzLFxuICBVTlNBRkVfc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyOiAoKSA9PiBzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIsXG4gIFVOU0FGRV91c2VGb2dPRldhckRpc2NvdmVyeTogKCkgPT4gdXNlRm9nT0ZXYXJEaXNjb3ZlcnksXG4gIFVOU0FGRV91c2VTY3JvbGxSZXN0b3JhdGlvbjogKCkgPT4gdXNlU2Nyb2xsUmVzdG9yYXRpb24sXG4gIGNyZWF0ZUJyb3dzZXJSb3V0ZXI6ICgpID0+IGNyZWF0ZUJyb3dzZXJSb3V0ZXIsXG4gIGNyZWF0ZUNvb2tpZTogKCkgPT4gY3JlYXRlQ29va2llLFxuICBjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZTogKCkgPT4gY3JlYXRlQ29va2llU2Vzc2lvblN0b3JhZ2UsXG4gIGNyZWF0ZUhhc2hSb3V0ZXI6ICgpID0+IGNyZWF0ZUhhc2hSb3V0ZXIsXG4gIGNyZWF0ZU1lbW9yeVJvdXRlcjogKCkgPT4gY3JlYXRlTWVtb3J5Um91dGVyLFxuICBjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZTogKCkgPT4gY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2UsXG4gIGNyZWF0ZVBhdGg6ICgpID0+IGNyZWF0ZVBhdGgsXG4gIGNyZWF0ZVJlcXVlc3RIYW5kbGVyOiAoKSA9PiBjcmVhdGVSZXF1ZXN0SGFuZGxlcixcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuOiAoKSA9PiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50czogKCkgPT4gY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzLFxuICBjcmVhdGVSb3V0ZXNTdHViOiAoKSA9PiBjcmVhdGVSb3V0ZXNTdHViLFxuICBjcmVhdGVTZWFyY2hQYXJhbXM6ICgpID0+IGNyZWF0ZVNlYXJjaFBhcmFtcyxcbiAgY3JlYXRlU2Vzc2lvbjogKCkgPT4gY3JlYXRlU2Vzc2lvbixcbiAgY3JlYXRlU2Vzc2lvblN0b3JhZ2U6ICgpID0+IGNyZWF0ZVNlc3Npb25TdG9yYWdlLFxuICBjcmVhdGVTdGF0aWNIYW5kbGVyOiAoKSA9PiBjcmVhdGVTdGF0aWNIYW5kbGVyMixcbiAgY3JlYXRlU3RhdGljUm91dGVyOiAoKSA9PiBjcmVhdGVTdGF0aWNSb3V0ZXIsXG4gIGRhdGE6ICgpID0+IGRhdGEsXG4gIGdlbmVyYXRlUGF0aDogKCkgPT4gZ2VuZXJhdGVQYXRoLFxuICBocmVmOiAoKSA9PiBocmVmLFxuICBpc0Nvb2tpZTogKCkgPT4gaXNDb29raWUsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlOiAoKSA9PiBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgaXNTZXNzaW9uOiAoKSA9PiBpc1Nlc3Npb24sXG4gIG1hdGNoUGF0aDogKCkgPT4gbWF0Y2hQYXRoLFxuICBtYXRjaFJvdXRlczogKCkgPT4gbWF0Y2hSb3V0ZXMsXG4gIHBhcnNlUGF0aDogKCkgPT4gcGFyc2VQYXRoLFxuICByZWRpcmVjdDogKCkgPT4gcmVkaXJlY3QsXG4gIHJlZGlyZWN0RG9jdW1lbnQ6ICgpID0+IHJlZGlyZWN0RG9jdW1lbnQsXG4gIHJlbmRlck1hdGNoZXM6ICgpID0+IHJlbmRlck1hdGNoZXMsXG4gIHJlcGxhY2U6ICgpID0+IHJlcGxhY2UsXG4gIHJlc29sdmVQYXRoOiAoKSA9PiByZXNvbHZlUGF0aCxcbiAgdW5zdGFibGVfSGlzdG9yeVJvdXRlcjogKCkgPT4gSGlzdG9yeVJvdXRlcixcbiAgdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyOiAoKSA9PiB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXIsXG4gIHVuc3RhYmxlX2NyZWF0ZUNvbnRleHQ6ICgpID0+IHVuc3RhYmxlX2NyZWF0ZUNvbnRleHQsXG4gIHVuc3RhYmxlX3NldERldlNlcnZlckhvb2tzOiAoKSA9PiBzZXREZXZTZXJ2ZXJIb29rcyxcbiAgdW5zdGFibGVfdXNlUHJvbXB0OiAoKSA9PiB1c2VQcm9tcHQsXG4gIHVzZUFjdGlvbkRhdGE6ICgpID0+IHVzZUFjdGlvbkRhdGEsXG4gIHVzZUFzeW5jRXJyb3I6ICgpID0+IHVzZUFzeW5jRXJyb3IsXG4gIHVzZUFzeW5jVmFsdWU6ICgpID0+IHVzZUFzeW5jVmFsdWUsXG4gIHVzZUJlZm9yZVVubG9hZDogKCkgPT4gdXNlQmVmb3JlVW5sb2FkLFxuICB1c2VCbG9ja2VyOiAoKSA9PiB1c2VCbG9ja2VyLFxuICB1c2VGZXRjaGVyOiAoKSA9PiB1c2VGZXRjaGVyLFxuICB1c2VGZXRjaGVyczogKCkgPT4gdXNlRmV0Y2hlcnMsXG4gIHVzZUZvcm1BY3Rpb246ICgpID0+IHVzZUZvcm1BY3Rpb24sXG4gIHVzZUhyZWY6ICgpID0+IHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dDogKCkgPT4gdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMaW5rQ2xpY2tIYW5kbGVyOiAoKSA9PiB1c2VMaW5rQ2xpY2tIYW5kbGVyLFxuICB1c2VMb2FkZXJEYXRhOiAoKSA9PiB1c2VMb2FkZXJEYXRhLFxuICB1c2VMb2NhdGlvbjogKCkgPT4gdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoOiAoKSA9PiB1c2VNYXRjaCxcbiAgdXNlTWF0Y2hlczogKCkgPT4gdXNlTWF0Y2hlcyxcbiAgdXNlTmF2aWdhdGU6ICgpID0+IHVzZU5hdmlnYXRlLFxuICB1c2VOYXZpZ2F0aW9uOiAoKSA9PiB1c2VOYXZpZ2F0aW9uLFxuICB1c2VOYXZpZ2F0aW9uVHlwZTogKCkgPT4gdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU91dGxldDogKCkgPT4gdXNlT3V0bGV0LFxuICB1c2VPdXRsZXRDb250ZXh0OiAoKSA9PiB1c2VPdXRsZXRDb250ZXh0LFxuICB1c2VQYXJhbXM6ICgpID0+IHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoOiAoKSA9PiB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJldmFsaWRhdG9yOiAoKSA9PiB1c2VSZXZhbGlkYXRvcixcbiAgdXNlUm91dGVFcnJvcjogKCkgPT4gdXNlUm91dGVFcnJvcixcbiAgdXNlUm91dGVMb2FkZXJEYXRhOiAoKSA9PiB1c2VSb3V0ZUxvYWRlckRhdGEsXG4gIHVzZVJvdXRlczogKCkgPT4gdXNlUm91dGVzLFxuICB1c2VTZWFyY2hQYXJhbXM6ICgpID0+IHVzZVNlYXJjaFBhcmFtcyxcbiAgdXNlU3VibWl0OiAoKSA9PiB1c2VTdWJtaXQsXG4gIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGU6ICgpID0+IHVzZVZpZXdUcmFuc2l0aW9uU3RhdGVcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMocmVhY3Rfcm91dGVyX2V4cG9ydHMpO1xuXG4vLyBsaWIvcm91dGVyL2hpc3RvcnkudHNcbnZhciBBY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gKChBY3Rpb24yKSA9PiB7XG4gIEFjdGlvbjJbXCJQb3BcIl0gPSBcIlBPUFwiO1xuICBBY3Rpb24yW1wiUHVzaFwiXSA9IFwiUFVTSFwiO1xuICBBY3Rpb24yW1wiUmVwbGFjZVwiXSA9IFwiUkVQTEFDRVwiO1xuICByZXR1cm4gQWN0aW9uMjtcbn0pKEFjdGlvbiB8fCB7fSk7XG52YXIgUG9wU3RhdGVFdmVudFR5cGUgPSBcInBvcHN0YXRlXCI7XG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KG9wdGlvbnMgPSB7fSkge1xuICBsZXQgeyBpbml0aWFsRW50cmllcyA9IFtcIi9cIl0sIGluaXRpYWxJbmRleCwgdjVDb21wYXQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgbGV0IGVudHJpZXM7XG4gIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoXG4gICAgKGVudHJ5LCBpbmRleDIpID0+IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKFxuICAgICAgZW50cnksXG4gICAgICB0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIgPyBudWxsIDogZW50cnkuc3RhdGUsXG4gICAgICBpbmRleDIgPT09IDAgPyBcImRlZmF1bHRcIiA6IHZvaWQgMFxuICAgIClcbiAgKTtcbiAgbGV0IGluZGV4ID0gY2xhbXBJbmRleChcbiAgICBpbml0aWFsSW5kZXggPT0gbnVsbCA/IGVudHJpZXMubGVuZ3RoIC0gMSA6IGluaXRpYWxJbmRleFxuICApO1xuICBsZXQgYWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gIGZ1bmN0aW9uIGNsYW1wSW5kZXgobikge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCAwKSwgZW50cmllcy5sZW5ndGggLSAxKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIGVudHJpZXNbaW5kZXhdO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSA9IG51bGwsIGtleSkge1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgZW50cmllcyA/IGdldEN1cnJlbnRMb2NhdGlvbigpLnBhdGhuYW1lIDogXCIvXCIsXG4gICAgICB0byxcbiAgICAgIHN0YXRlLFxuICAgICAga2V5XG4gICAgKTtcbiAgICB3YXJuaW5nKFxuICAgICAgbG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIixcbiAgICAgIGByZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3Rvcnk6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHRvXG4gICAgICApfWBcbiAgICApO1xuICAgIHJldHVybiBsb2NhdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVIcmVmMih0bykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0ge1xuICAgIGdldCBpbmRleCgpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH0sXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGdldEN1cnJlbnRMb2NhdGlvbigpO1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZjIsXG4gICAgY3JlYXRlVVJMKHRvKSB7XG4gICAgICByZXR1cm4gbmV3IFVSTChjcmVhdGVIcmVmMih0byksIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgICB9LFxuICAgIGVuY29kZUxvY2F0aW9uKHRvKSB7XG4gICAgICBsZXQgcGF0aCA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXRoLnBhdGhuYW1lIHx8IFwiXCIsXG4gICAgICAgIHNlYXJjaDogcGF0aC5zZWFyY2ggfHwgXCJcIixcbiAgICAgICAgaGFzaDogcGF0aC5oYXNoIHx8IFwiXCJcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoKHRvLCBzdGF0ZSkge1xuICAgICAgYWN0aW9uID0gXCJQVVNIXCIgLyogUHVzaCAqLztcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUpO1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCBlbnRyaWVzLmxlbmd0aCwgbmV4dExvY2F0aW9uKTtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGE6IDEgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgICAgYWN0aW9uID0gXCJSRVBMQUNFXCIgLyogUmVwbGFjZSAqLztcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUpO1xuICAgICAgZW50cmllc1tpbmRleF0gPSBuZXh0TG9jYXRpb247XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sIGRlbHRhOiAwIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ28oZGVsdGEpIHtcbiAgICAgIGFjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICAgICAgbGV0IG5leHRJbmRleCA9IGNsYW1wSW5kZXgoaW5kZXggKyBkZWx0YSk7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gZW50cmllc1tuZXh0SW5kZXhdO1xuICAgICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sIGRlbHRhIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGlzdGVuKGZuKSB7XG4gICAgICBsaXN0ZW5lciA9IGZuO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgbGlzdGVuZXIgPSBudWxsO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3Rvcnkob3B0aW9ucyA9IHt9KSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJMb2NhdGlvbih3aW5kb3cyLCBnbG9iYWxIaXN0b3J5KSB7XG4gICAgbGV0IHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9ID0gd2luZG93Mi5sb2NhdGlvbjtcbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXG4gICAgICBcIlwiLFxuICAgICAgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0sXG4gICAgICAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcbiAgICAgIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IgfHwgbnVsbCxcbiAgICAgIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkgfHwgXCJkZWZhdWx0XCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIcmVmKHdpbmRvdzIsIHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShcbiAgICBjcmVhdGVCcm93c2VyTG9jYXRpb24sXG4gICAgY3JlYXRlQnJvd3NlckhyZWYsXG4gICAgbnVsbCxcbiAgICBvcHRpb25zXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeShvcHRpb25zID0ge30pIHtcbiAgZnVuY3Rpb24gY3JlYXRlSGFzaExvY2F0aW9uKHdpbmRvdzIsIGdsb2JhbEhpc3RvcnkpIHtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgICBoYXNoID0gXCJcIlxuICAgIH0gPSBwYXJzZVBhdGgod2luZG93Mi5sb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKSk7XG4gICAgaWYgKCFwYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSAmJiAhcGF0aG5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIgKyBwYXRobmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgXCJcIixcbiAgICAgIHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9LFxuICAgICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgICBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyIHx8IG51bGwsXG4gICAgICBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5IHx8IFwiZGVmYXVsdFwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVIYXNoSHJlZih3aW5kb3cyLCB0bykge1xuICAgIGxldCBiYXNlID0gd2luZG93Mi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYmFzZVwiKTtcbiAgICBsZXQgaHJlZjIgPSBcIlwiO1xuICAgIGlmIChiYXNlICYmIGJhc2UuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSkge1xuICAgICAgbGV0IHVybCA9IHdpbmRvdzIubG9jYXRpb24uaHJlZjtcbiAgICAgIGxldCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG4gICAgICBocmVmMiA9IGhhc2hJbmRleCA9PT0gLTEgPyB1cmwgOiB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGhyZWYyICsgXCIjXCIgKyAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKSk7XG4gIH1cbiAgZnVuY3Rpb24gdmFsaWRhdGVIYXNoTG9jYXRpb24obG9jYXRpb24sIHRvKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gXCIvXCIsXG4gICAgICBgcmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGhhc2ggaGlzdG9yeS5wdXNoKCR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHRvXG4gICAgICApfSlgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZ2V0VXJsQmFzZWRIaXN0b3J5KFxuICAgIGNyZWF0ZUhhc2hMb2NhdGlvbixcbiAgICBjcmVhdGVIYXNoSHJlZixcbiAgICB2YWxpZGF0ZUhhc2hMb2NhdGlvbixcbiAgICBvcHRpb25zXG4gICk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCk7XG59XG5mdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb24sIGluZGV4KSB7XG4gIHJldHVybiB7XG4gICAgdXNyOiBsb2NhdGlvbi5zdGF0ZSxcbiAgICBrZXk6IGxvY2F0aW9uLmtleSxcbiAgICBpZHg6IGluZGV4XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihjdXJyZW50LCB0bywgc3RhdGUgPSBudWxsLCBrZXkpIHtcbiAgbGV0IGxvY2F0aW9uID0ge1xuICAgIHBhdGhuYW1lOiB0eXBlb2YgY3VycmVudCA9PT0gXCJzdHJpbmdcIiA/IGN1cnJlbnQgOiBjdXJyZW50LnBhdGhuYW1lLFxuICAgIHNlYXJjaDogXCJcIixcbiAgICBoYXNoOiBcIlwiLFxuICAgIC4uLnR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0byxcbiAgICBzdGF0ZSxcbiAgICAvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIGNsZWFuZWQgdXAuICBwdXNoL3JlcGxhY2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgdGFrZVxuICAgIC8vIGZ1bGwgTG9jYXRpb25zIG5vdyBhbmQgYXZvaWQgdGhlIG5lZWQgdG8gcnVuIHRocm91Z2ggdGhpcyBmbG93IGF0IGFsbFxuICAgIC8vIEJ1dCB0aGF0J3MgYSBwcmV0dHkgYmlnIHJlZmFjdG9yIHRvIHRoZSBjdXJyZW50IHRlc3Qgc3VpdGUgc28gZ29pbmcgdG9cbiAgICAvLyBrZWVwIGFzIGlzIGZvciB0aGUgdGltZSBiZWluZyBhbmQganVzdCBsZXQgYW55IGluY29taW5nIGtleXMgdGFrZSBwcmVjZWRlbmNlXG4gICAga2V5OiB0byAmJiB0by5rZXkgfHwga2V5IHx8IGNyZWF0ZUtleSgpXG4gIH07XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGgoe1xuICBwYXRobmFtZSA9IFwiL1wiLFxuICBzZWFyY2ggPSBcIlwiLFxuICBoYXNoID0gXCJcIlxufSkge1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gXCI/XCIpXG4gICAgcGF0aG5hbWUgKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gXCI/XCIgPyBzZWFyY2ggOiBcIj9cIiArIHNlYXJjaDtcbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gXCIjXCIpXG4gICAgcGF0aG5hbWUgKz0gaGFzaC5jaGFyQXQoMCkgPT09IFwiI1wiID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcbiAgcmV0dXJuIHBhdGhuYW1lO1xufVxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgbGV0IHBhcnNlZFBhdGggPSB7fTtcbiAgaWYgKHBhdGgpIHtcbiAgICBsZXQgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKTtcbiAgICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguaGFzaCA9IHBhdGguc3Vic3RyaW5nKGhhc2hJbmRleCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgaGFzaEluZGV4KTtcbiAgICB9XG4gICAgbGV0IHNlYXJjaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKTtcbiAgICBpZiAoc2VhcmNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5zZWFyY2ggPSBwYXRoLnN1YnN0cmluZyhzZWFyY2hJbmRleCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgc2VhcmNoSW5kZXgpO1xuICAgIH1cbiAgICBpZiAocGF0aCkge1xuICAgICAgcGFyc2VkUGF0aC5wYXRobmFtZSA9IHBhdGg7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZWRQYXRoO1xufVxuZnVuY3Rpb24gZ2V0VXJsQmFzZWRIaXN0b3J5KGdldExvY2F0aW9uLCBjcmVhdGVIcmVmMiwgdmFsaWRhdGVMb2NhdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCB7IHdpbmRvdzogd2luZG93MiA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LCB2NUNvbXBhdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBsZXQgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdzIuaGlzdG9yeTtcbiAgbGV0IGFjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICBsZXQgbGlzdGVuZXIgPSBudWxsO1xuICBsZXQgaW5kZXggPSBnZXRJbmRleCgpO1xuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIGluZGV4ID0gMDtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IC4uLmdsb2JhbEhpc3Rvcnkuc3RhdGUsIGlkeDogaW5kZXggfSwgXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SW5kZXgoKSB7XG4gICAgbGV0IHN0YXRlID0gZ2xvYmFsSGlzdG9yeS5zdGF0ZSB8fCB7IGlkeDogbnVsbCB9O1xuICAgIHJldHVybiBzdGF0ZS5pZHg7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKCkge1xuICAgIGFjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICAgIGxldCBuZXh0SW5kZXggPSBnZXRJbmRleCgpO1xuICAgIGxldCBkZWx0YSA9IG5leHRJbmRleCA9PSBudWxsID8gbnVsbCA6IG5leHRJbmRleCAtIGluZGV4O1xuICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YSB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHVzaCh0bywgc3RhdGUpIHtcbiAgICBhY3Rpb24gPSBcIlBVU0hcIiAvKiBQdXNoICovO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcbiAgICBpbmRleCA9IGdldEluZGV4KCkgKyAxO1xuICAgIGxldCBoaXN0b3J5U3RhdGUgPSBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb24sIGluZGV4KTtcbiAgICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBET01FeGNlcHRpb24gJiYgZXJyb3IubmFtZSA9PT0gXCJEYXRhQ2xvbmVFcnJvclwiKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgd2luZG93Mi5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICB9XG4gICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhOiAxIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlMih0bywgc3RhdGUpIHtcbiAgICBhY3Rpb24gPSBcIlJFUExBQ0VcIiAvKiBSZXBsYWNlICovO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcbiAgICBpbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbiwgZGVsdGE6IDAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVVSTCh0bykge1xuICAgIHJldHVybiBjcmVhdGVCcm93c2VyVVJMSW1wbCh0byk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0TG9jYXRpb24od2luZG93MiwgZ2xvYmFsSGlzdG9yeSk7XG4gICAgfSxcbiAgICBsaXN0ZW4oZm4pIHtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGhpc3Rvcnkgb25seSBhY2NlcHRzIG9uZSBhY3RpdmUgbGlzdGVuZXJcIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cyLmFkZEV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7XG4gICAgICBsaXN0ZW5lciA9IGZuO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93Mi5yZW1vdmVFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUhyZWYyKHdpbmRvdzIsIHRvKTtcbiAgICB9LFxuICAgIGNyZWF0ZVVSTCxcbiAgICBlbmNvZGVMb2NhdGlvbih0bykge1xuICAgICAgbGV0IHVybCA9IGNyZWF0ZVVSTCh0byk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2g6IHVybC5zZWFyY2gsXG4gICAgICAgIGhhc2g6IHVybC5oYXNoXG4gICAgICB9O1xuICAgIH0sXG4gICAgcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICBnbyhuKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuZnVuY3Rpb24gY3JlYXRlQnJvd3NlclVSTEltcGwodG8sIGlzQWJzb2x1dGUgPSBmYWxzZSkge1xuICBsZXQgYmFzZSA9IFwiaHR0cDovL2xvY2FsaG9zdFwiO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGJhc2UgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICE9PSBcIm51bGxcIiA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gOiB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgfVxuICBpbnZhcmlhbnQoYmFzZSwgXCJObyB3aW5kb3cubG9jYXRpb24uKG9yaWdpbnxocmVmKSBhdmFpbGFibGUgdG8gY3JlYXRlIFVSTFwiKTtcbiAgbGV0IGhyZWYyID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgaHJlZjIgPSBocmVmMi5yZXBsYWNlKC8gJC8sIFwiJTIwXCIpO1xuICBpZiAoIWlzQWJzb2x1dGUgJiYgaHJlZjIuc3RhcnRzV2l0aChcIi8vXCIpKSB7XG4gICAgaHJlZjIgPSBiYXNlICsgaHJlZjI7XG4gIH1cbiAgcmV0dXJuIG5ldyBVUkwoaHJlZjIsIGJhc2UpO1xufVxuXG4vLyBsaWIvcm91dGVyL3V0aWxzLnRzXG5mdW5jdGlvbiB1bnN0YWJsZV9jcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4geyBkZWZhdWx0VmFsdWUgfTtcbn1cbnZhciBfbWFwO1xudmFyIHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5pdCkge1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbWFwLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBpZiAoaW5pdCkge1xuICAgICAgZm9yIChsZXQgW2NvbnRleHQsIHZhbHVlXSBvZiBpbml0KSB7XG4gICAgICAgIHRoaXMuc2V0KGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0KGNvbnRleHQpIHtcbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9tYXApLmhhcyhjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwKS5nZXQoY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmRlZmF1bHRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbHVlIGZvdW5kIGZvciBjb250ZXh0XCIpO1xuICB9XG4gIHNldChjb250ZXh0LCB2YWx1ZSkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwKS5zZXQoY29udGV4dCwgdmFsdWUpO1xuICB9XG59O1xuX21hcCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgdW5zdXBwb3J0ZWRMYXp5Um91dGVPYmplY3RLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImxhenlcIixcbiAgXCJjYXNlU2Vuc2l0aXZlXCIsXG4gIFwicGF0aFwiLFxuICBcImlkXCIsXG4gIFwiaW5kZXhcIixcbiAgXCJjaGlsZHJlblwiXG5dKTtcbmZ1bmN0aW9uIGlzVW5zdXBwb3J0ZWRMYXp5Um91dGVPYmplY3RLZXkoa2V5KSB7XG4gIHJldHVybiB1bnN1cHBvcnRlZExhenlSb3V0ZU9iamVjdEtleXMuaGFzKFxuICAgIGtleVxuICApO1xufVxudmFyIHVuc3VwcG9ydGVkTGF6eVJvdXRlRnVuY3Rpb25LZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImxhenlcIixcbiAgXCJjYXNlU2Vuc2l0aXZlXCIsXG4gIFwicGF0aFwiLFxuICBcImlkXCIsXG4gIFwiaW5kZXhcIixcbiAgXCJ1bnN0YWJsZV9taWRkbGV3YXJlXCIsXG4gIFwiY2hpbGRyZW5cIlxuXSk7XG5mdW5jdGlvbiBpc1Vuc3VwcG9ydGVkTGF6eVJvdXRlRnVuY3Rpb25LZXkoa2V5KSB7XG4gIHJldHVybiB1bnN1cHBvcnRlZExhenlSb3V0ZUZ1bmN0aW9uS2V5cy5oYXMoXG4gICAga2V5XG4gICk7XG59XG5mdW5jdGlvbiBpc0luZGV4Um91dGUocm91dGUpIHtcbiAgcmV0dXJuIHJvdXRlLmluZGV4ID09PSB0cnVlO1xufVxuZnVuY3Rpb24gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhyb3V0ZXMsIG1hcFJvdXRlUHJvcGVydGllczIsIHBhcmVudFBhdGggPSBbXSwgbWFuaWZlc3QgPSB7fSkge1xuICByZXR1cm4gcm91dGVzLm1hcCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIFN0cmluZyhpbmRleCldO1xuICAgIGxldCBpZCA9IHR5cGVvZiByb3V0ZS5pZCA9PT0gXCJzdHJpbmdcIiA/IHJvdXRlLmlkIDogdHJlZVBhdGguam9pbihcIi1cIik7XG4gICAgaW52YXJpYW50KFxuICAgICAgcm91dGUuaW5kZXggIT09IHRydWUgfHwgIXJvdXRlLmNoaWxkcmVuLFxuICAgICAgYENhbm5vdCBzcGVjaWZ5IGNoaWxkcmVuIG9uIGFuIGluZGV4IHJvdXRlYFxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIW1hbmlmZXN0W2lkXSxcbiAgICAgIGBGb3VuZCBhIHJvdXRlIGlkIGNvbGxpc2lvbiBvbiBpZCBcIiR7aWR9XCIuICBSb3V0ZSBpZCdzIG11c3QgYmUgZ2xvYmFsbHkgdW5pcXVlIHdpdGhpbiBEYXRhIFJvdXRlciB1c2FnZXNgXG4gICAgKTtcbiAgICBpZiAoaXNJbmRleFJvdXRlKHJvdXRlKSkge1xuICAgICAgbGV0IGluZGV4Um91dGUgPSB7XG4gICAgICAgIC4uLnJvdXRlLFxuICAgICAgICAuLi5tYXBSb3V0ZVByb3BlcnRpZXMyKHJvdXRlKSxcbiAgICAgICAgaWRcbiAgICAgIH07XG4gICAgICBtYW5pZmVzdFtpZF0gPSBpbmRleFJvdXRlO1xuICAgICAgcmV0dXJuIGluZGV4Um91dGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXRoT3JMYXlvdXRSb3V0ZSA9IHtcbiAgICAgICAgLi4ucm91dGUsXG4gICAgICAgIC4uLm1hcFJvdXRlUHJvcGVydGllczIocm91dGUpLFxuICAgICAgICBpZCxcbiAgICAgICAgY2hpbGRyZW46IHZvaWQgMFxuICAgICAgfTtcbiAgICAgIG1hbmlmZXN0W2lkXSA9IHBhdGhPckxheW91dFJvdXRlO1xuICAgICAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICAgIHBhdGhPckxheW91dFJvdXRlLmNoaWxkcmVuID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICAgICAgICByb3V0ZS5jaGlsZHJlbixcbiAgICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICAgIHRyZWVQYXRoLFxuICAgICAgICAgIG1hbmlmZXN0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aE9yTGF5b3V0Um91dGU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb25BcmcsIGJhc2VuYW1lID0gXCIvXCIpIHtcbiAgcmV0dXJuIG1hdGNoUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnLCBiYXNlbmFtZSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gbWF0Y2hSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcsIGJhc2VuYW1lLCBhbGxvd1BhcnRpYWwpIHtcbiAgbGV0IGxvY2F0aW9uID0gdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuICBsZXQgcGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiLCBiYXNlbmFtZSk7XG4gIGlmIChwYXRobmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGJyYW5jaGVzID0gZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcyk7XG4gIGxldCBtYXRjaGVzID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IG1hdGNoZXMgPT0gbnVsbCAmJiBpIDwgYnJhbmNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgZGVjb2RlZCA9IGRlY29kZVBhdGgocGF0aG5hbWUpO1xuICAgIG1hdGNoZXMgPSBtYXRjaFJvdXRlQnJhbmNoKFxuICAgICAgYnJhbmNoZXNbaV0sXG4gICAgICBkZWNvZGVkLFxuICAgICAgYWxsb3dQYXJ0aWFsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKG1hdGNoLCBsb2FkZXJEYXRhKSB7XG4gIGxldCB7IHJvdXRlLCBwYXRobmFtZSwgcGFyYW1zIH0gPSBtYXRjaDtcbiAgcmV0dXJuIHtcbiAgICBpZDogcm91dGUuaWQsXG4gICAgcGF0aG5hbWUsXG4gICAgcGFyYW1zLFxuICAgIGRhdGE6IGxvYWRlckRhdGFbcm91dGUuaWRdLFxuICAgIGhhbmRsZTogcm91dGUuaGFuZGxlXG4gIH07XG59XG5mdW5jdGlvbiBmbGF0dGVuUm91dGVzKHJvdXRlcywgYnJhbmNoZXMgPSBbXSwgcGFyZW50c01ldGEgPSBbXSwgcGFyZW50UGF0aCA9IFwiXCIpIHtcbiAgbGV0IGZsYXR0ZW5Sb3V0ZSA9IChyb3V0ZSwgaW5kZXgsIHJlbGF0aXZlUGF0aCkgPT4ge1xuICAgIGxldCBtZXRhID0ge1xuICAgICAgcmVsYXRpdmVQYXRoOiByZWxhdGl2ZVBhdGggPT09IHZvaWQgMCA/IHJvdXRlLnBhdGggfHwgXCJcIiA6IHJlbGF0aXZlUGF0aCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09IHRydWUsXG4gICAgICBjaGlsZHJlbkluZGV4OiBpbmRleCxcbiAgICAgIHJvdXRlXG4gICAgfTtcbiAgICBpZiAobWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChwYXJlbnRQYXRoKSxcbiAgICAgICAgYEFic29sdXRlIHJvdXRlIHBhdGggXCIke21ldGEucmVsYXRpdmVQYXRofVwiIG5lc3RlZCB1bmRlciBwYXRoIFwiJHtwYXJlbnRQYXRofVwiIGlzIG5vdCB2YWxpZC4gQW4gYWJzb2x1dGUgY2hpbGQgcm91dGUgcGF0aCBtdXN0IHN0YXJ0IHdpdGggdGhlIGNvbWJpbmVkIHBhdGggb2YgYWxsIGl0cyBwYXJlbnQgcm91dGVzLmBcbiAgICAgICk7XG4gICAgICBtZXRhLnJlbGF0aXZlUGF0aCA9IG1ldGEucmVsYXRpdmVQYXRoLnNsaWNlKHBhcmVudFBhdGgubGVuZ3RoKTtcbiAgICB9XG4gICAgbGV0IHBhdGggPSBqb2luUGF0aHMoW3BhcmVudFBhdGgsIG1ldGEucmVsYXRpdmVQYXRoXSk7XG4gICAgbGV0IHJvdXRlc01ldGEgPSBwYXJlbnRzTWV0YS5jb25jYXQobWV0YSk7XG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgLy8gT3VyIHR5cGVzIGtub3cgYmV0dGVyLCBidXQgcnVudGltZSBKUyBtYXkgbm90IVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlLFxuICAgICAgICBgSW5kZXggcm91dGVzIG11c3Qgbm90IGhhdmUgY2hpbGQgcm91dGVzLiBQbGVhc2UgcmVtb3ZlIGFsbCBjaGlsZCByb3V0ZXMgZnJvbSByb3V0ZSBwYXRoIFwiJHtwYXRofVwiLmBcbiAgICAgICk7XG4gICAgICBmbGF0dGVuUm91dGVzKHJvdXRlLmNoaWxkcmVuLCBicmFuY2hlcywgcm91dGVzTWV0YSwgcGF0aCk7XG4gICAgfVxuICAgIGlmIChyb3V0ZS5wYXRoID09IG51bGwgJiYgIXJvdXRlLmluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGJyYW5jaGVzLnB1c2goe1xuICAgICAgcGF0aCxcbiAgICAgIHNjb3JlOiBjb21wdXRlU2NvcmUocGF0aCwgcm91dGUuaW5kZXgpLFxuICAgICAgcm91dGVzTWV0YVxuICAgIH0pO1xuICB9O1xuICByb3V0ZXMuZm9yRWFjaCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgaWYgKHJvdXRlLnBhdGggPT09IFwiXCIgfHwgIXJvdXRlLnBhdGg/LmluY2x1ZGVzKFwiP1wiKSkge1xuICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGV4cGxvZGVkIG9mIGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHJvdXRlLnBhdGgpKSB7XG4gICAgICAgIGZsYXR0ZW5Sb3V0ZShyb3V0ZSwgaW5kZXgsIGV4cGxvZGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYnJhbmNoZXM7XG59XG5mdW5jdGlvbiBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhwYXRoKSB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gIGxldCBbZmlyc3QsIC4uLnJlc3RdID0gc2VnbWVudHM7XG4gIGxldCBpc09wdGlvbmFsID0gZmlyc3QuZW5kc1dpdGgoXCI/XCIpO1xuICBsZXQgcmVxdWlyZWQgPSBmaXJzdC5yZXBsYWNlKC9cXD8kLywgXCJcIik7XG4gIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBpc09wdGlvbmFsID8gW3JlcXVpcmVkLCBcIlwiXSA6IFtyZXF1aXJlZF07XG4gIH1cbiAgbGV0IHJlc3RFeHBsb2RlZCA9IGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHJlc3Quam9pbihcIi9cIikpO1xuICBsZXQgcmVzdWx0ID0gW107XG4gIHJlc3VsdC5wdXNoKFxuICAgIC4uLnJlc3RFeHBsb2RlZC5tYXAoXG4gICAgICAoc3VicGF0aCkgPT4gc3VicGF0aCA9PT0gXCJcIiA/IHJlcXVpcmVkIDogW3JlcXVpcmVkLCBzdWJwYXRoXS5qb2luKFwiL1wiKVxuICAgIClcbiAgKTtcbiAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICByZXN1bHQucHVzaCguLi5yZXN0RXhwbG9kZWQpO1xuICB9XG4gIHJldHVybiByZXN1bHQubWFwKFxuICAgIChleHBsb2RlZCkgPT4gcGF0aC5zdGFydHNXaXRoKFwiL1wiKSAmJiBleHBsb2RlZCA9PT0gXCJcIiA/IFwiL1wiIDogZXhwbG9kZWRcbiAgKTtcbn1cbmZ1bmN0aW9uIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzKSB7XG4gIGJyYW5jaGVzLnNvcnQoXG4gICAgKGEsIGIpID0+IGEuc2NvcmUgIT09IGIuc2NvcmUgPyBiLnNjb3JlIC0gYS5zY29yZSA6IGNvbXBhcmVJbmRleGVzKFxuICAgICAgYS5yb3V0ZXNNZXRhLm1hcCgobWV0YSkgPT4gbWV0YS5jaGlsZHJlbkluZGV4KSxcbiAgICAgIGIucm91dGVzTWV0YS5tYXAoKG1ldGEpID0+IG1ldGEuY2hpbGRyZW5JbmRleClcbiAgICApXG4gICk7XG59XG52YXIgcGFyYW1SZSA9IC9eOltcXHctXSskLztcbnZhciBkeW5hbWljU2VnbWVudFZhbHVlID0gMztcbnZhciBpbmRleFJvdXRlVmFsdWUgPSAyO1xudmFyIGVtcHR5U2VnbWVudFZhbHVlID0gMTtcbnZhciBzdGF0aWNTZWdtZW50VmFsdWUgPSAxMDtcbnZhciBzcGxhdFBlbmFsdHkgPSAtMjtcbnZhciBpc1NwbGF0ID0gKHMpID0+IHMgPT09IFwiKlwiO1xuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKHBhdGgsIGluZGV4KSB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBsZXQgaW5pdGlhbFNjb3JlID0gc2VnbWVudHMubGVuZ3RoO1xuICBpZiAoc2VnbWVudHMuc29tZShpc1NwbGF0KSkge1xuICAgIGluaXRpYWxTY29yZSArPSBzcGxhdFBlbmFsdHk7XG4gIH1cbiAgaWYgKGluZGV4KSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IGluZGV4Um91dGVWYWx1ZTtcbiAgfVxuICByZXR1cm4gc2VnbWVudHMuZmlsdGVyKChzKSA9PiAhaXNTcGxhdChzKSkucmVkdWNlKFxuICAgIChzY29yZSwgc2VnbWVudCkgPT4gc2NvcmUgKyAocGFyYW1SZS50ZXN0KHNlZ21lbnQpID8gZHluYW1pY1NlZ21lbnRWYWx1ZSA6IHNlZ21lbnQgPT09IFwiXCIgPyBlbXB0eVNlZ21lbnRWYWx1ZSA6IHN0YXRpY1NlZ21lbnRWYWx1ZSksXG4gICAgaW5pdGlhbFNjb3JlXG4gICk7XG59XG5mdW5jdGlvbiBjb21wYXJlSW5kZXhlcyhhLCBiKSB7XG4gIGxldCBzaWJsaW5ncyA9IGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLnNsaWNlKDAsIC0xKS5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYltpXSk7XG4gIHJldHVybiBzaWJsaW5ncyA/IChcbiAgICAvLyBJZiB0d28gcm91dGVzIGFyZSBzaWJsaW5ncywgd2Ugc2hvdWxkIHRyeSB0byBtYXRjaCB0aGUgZWFybGllciBzaWJsaW5nXG4gICAgLy8gZmlyc3QuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBoYXZlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIG1hdGNoaW5nXG4gICAgLy8gYmVoYXZpb3IgYnkgc2ltcGx5IHB1dHRpbmcgcm91dGVzIHdpdGggaWRlbnRpY2FsIHBhdGhzIGluIHRoZSBvcmRlciB0aGV5XG4gICAgLy8gd2FudCB0aGVtIHRyaWVkLlxuICAgIGFbYS5sZW5ndGggLSAxXSAtIGJbYi5sZW5ndGggLSAxXVxuICApIDogKFxuICAgIC8vIE90aGVyd2lzZSwgaXQgZG9lc24ndCByZWFsbHkgbWFrZSBzZW5zZSB0byByYW5rIG5vbi1zaWJsaW5ncyBieSBpbmRleCxcbiAgICAvLyBzbyB0aGV5IHNvcnQgZXF1YWxseS5cbiAgICAwXG4gICk7XG59XG5mdW5jdGlvbiBtYXRjaFJvdXRlQnJhbmNoKGJyYW5jaCwgcGF0aG5hbWUsIGFsbG93UGFydGlhbCA9IGZhbHNlKSB7XG4gIGxldCB7IHJvdXRlc01ldGEgfSA9IGJyYW5jaDtcbiAgbGV0IG1hdGNoZWRQYXJhbXMgPSB7fTtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IFwiL1wiO1xuICBsZXQgbWF0Y2hlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlc01ldGEubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgbWV0YSA9IHJvdXRlc01ldGFbaV07XG4gICAgbGV0IGVuZCA9IGkgPT09IHJvdXRlc01ldGEubGVuZ3RoIC0gMTtcbiAgICBsZXQgcmVtYWluaW5nUGF0aG5hbWUgPSBtYXRjaGVkUGF0aG5hbWUgPT09IFwiL1wiID8gcGF0aG5hbWUgOiBwYXRobmFtZS5zbGljZShtYXRjaGVkUGF0aG5hbWUubGVuZ3RoKSB8fCBcIi9cIjtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaFBhdGgoXG4gICAgICB7IHBhdGg6IG1ldGEucmVsYXRpdmVQYXRoLCBjYXNlU2Vuc2l0aXZlOiBtZXRhLmNhc2VTZW5zaXRpdmUsIGVuZCB9LFxuICAgICAgcmVtYWluaW5nUGF0aG5hbWVcbiAgICApO1xuICAgIGxldCByb3V0ZSA9IG1ldGEucm91dGU7XG4gICAgaWYgKCFtYXRjaCAmJiBlbmQgJiYgYWxsb3dQYXJ0aWFsICYmICFyb3V0ZXNNZXRhW3JvdXRlc01ldGEubGVuZ3RoIC0gMV0ucm91dGUuaW5kZXgpIHtcbiAgICAgIG1hdGNoID0gbWF0Y2hQYXRoKFxuICAgICAgICB7XG4gICAgICAgICAgcGF0aDogbWV0YS5yZWxhdGl2ZVBhdGgsXG4gICAgICAgICAgY2FzZVNlbnNpdGl2ZTogbWV0YS5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICAgIGVuZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgcmVtYWluaW5nUGF0aG5hbWVcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XG4gICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgIC8vIFRPRE86IENhbiB0aGlzIGFzIGJlIGF2b2lkZWQ/XG4gICAgICBwYXJhbXM6IG1hdGNoZWRQYXJhbXMsXG4gICAgICBwYXRobmFtZTogam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lXSksXG4gICAgICBwYXRobmFtZUJhc2U6IG5vcm1hbGl6ZVBhdGhuYW1lKFxuICAgICAgICBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSlcbiAgICAgICksXG4gICAgICByb3V0ZVxuICAgIH0pO1xuICAgIGlmIChtYXRjaC5wYXRobmFtZUJhc2UgIT09IFwiL1wiKSB7XG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPSBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKG9yaWdpbmFsUGF0aCwgcGFyYW1zID0ge30pIHtcbiAgbGV0IHBhdGggPSBvcmlnaW5hbFBhdGg7XG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSAmJiBwYXRoICE9PSBcIipcIiAmJiAhcGF0aC5lbmRzV2l0aChcIi8qXCIpKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFJvdXRlIHBhdGggXCIke3BhdGh9XCIgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdlcmUgXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIgYmVjYXVzZSB0aGUgXFxgKlxcYCBjaGFyYWN0ZXIgbXVzdCBhbHdheXMgZm9sbG93IGEgXFxgL1xcYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIHBsZWFzZSBjaGFuZ2UgdGhlIHJvdXRlIHBhdGggdG8gXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIuYFxuICAgICk7XG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIik7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gcGF0aC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiL1wiIDogXCJcIjtcbiAgY29uc3Qgc3RyaW5naWZ5MiA9IChwKSA9PiBwID09IG51bGwgPyBcIlwiIDogdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyBwIDogU3RyaW5nKHApO1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoL1xcLysvKS5tYXAoKHNlZ21lbnQsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBpbmRleCA9PT0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICBpZiAoaXNMYXN0U2VnbWVudCAmJiBzZWdtZW50ID09PSBcIipcIikge1xuICAgICAgY29uc3Qgc3RhciA9IFwiKlwiO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeTIocGFyYW1zW3N0YXJdKTtcbiAgICB9XG4gICAgY29uc3Qga2V5TWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eOihbXFx3LV0rKShcXD8/KSQvKTtcbiAgICBpZiAoa2V5TWF0Y2gpIHtcbiAgICAgIGNvbnN0IFssIGtleSwgb3B0aW9uYWxdID0ga2V5TWF0Y2g7XG4gICAgICBsZXQgcGFyYW0gPSBwYXJhbXNba2V5XTtcbiAgICAgIGludmFyaWFudChvcHRpb25hbCA9PT0gXCI/XCIgfHwgcGFyYW0gIT0gbnVsbCwgYE1pc3NpbmcgXCI6JHtrZXl9XCIgcGFyYW1gKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnkyKHBhcmFtKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlZ21lbnQucmVwbGFjZSgvXFw/JC9nLCBcIlwiKTtcbiAgfSkuZmlsdGVyKChzZWdtZW50KSA9PiAhIXNlZ21lbnQpO1xuICByZXR1cm4gcHJlZml4ICsgc2VnbWVudHMuam9pbihcIi9cIik7XG59XG5mdW5jdGlvbiBtYXRjaFBhdGgocGF0dGVybiwgcGF0aG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgcGF0dGVybiA9IHsgcGF0aDogcGF0dGVybiwgY2FzZVNlbnNpdGl2ZTogZmFsc2UsIGVuZDogdHJ1ZSB9O1xuICB9XG4gIGxldCBbbWF0Y2hlciwgY29tcGlsZWRQYXJhbXNdID0gY29tcGlsZVBhdGgoXG4gICAgcGF0dGVybi5wYXRoLFxuICAgIHBhdHRlcm4uY2FzZVNlbnNpdGl2ZSxcbiAgICBwYXR0ZXJuLmVuZFxuICApO1xuICBsZXQgbWF0Y2ggPSBwYXRobmFtZS5tYXRjaChtYXRjaGVyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBtYXRjaFswXTtcbiAgbGV0IHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gIGxldCBjYXB0dXJlR3JvdXBzID0gbWF0Y2guc2xpY2UoMSk7XG4gIGxldCBwYXJhbXMgPSBjb21waWxlZFBhcmFtcy5yZWR1Y2UoXG4gICAgKG1lbW8yLCB7IHBhcmFtTmFtZSwgaXNPcHRpb25hbCB9LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKHBhcmFtTmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgbGV0IHNwbGF0VmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XSB8fCBcIlwiO1xuICAgICAgICBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWUuc2xpY2UoMCwgbWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCAtIHNwbGF0VmFsdWUubGVuZ3RoKS5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGNhcHR1cmVHcm91cHNbaW5kZXhdO1xuICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgIXZhbHVlKSB7XG4gICAgICAgIG1lbW8yW3BhcmFtTmFtZV0gPSB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vMltwYXJhbU5hbWVdID0gKHZhbHVlIHx8IFwiXCIpLnJlcGxhY2UoLyUyRi9nLCBcIi9cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbzI7XG4gICAgfSxcbiAgICB7fVxuICApO1xuICByZXR1cm4ge1xuICAgIHBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2hlZFBhdGhuYW1lLFxuICAgIHBhdGhuYW1lQmFzZSxcbiAgICBwYXR0ZXJuXG4gIH07XG59XG5mdW5jdGlvbiBjb21waWxlUGF0aChwYXRoLCBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsIGVuZCA9IHRydWUpIHtcbiAgd2FybmluZyhcbiAgICBwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLFxuICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgKTtcbiAgbGV0IHBhcmFtcyA9IFtdO1xuICBsZXQgcmVnZXhwU291cmNlID0gXCJeXCIgKyBwYXRoLnJlcGxhY2UoL1xcLypcXCo/JC8sIFwiXCIpLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpLnJlcGxhY2UoL1tcXFxcLiorXiR7fXwoKVtcXF1dL2csIFwiXFxcXCQmXCIpLnJlcGxhY2UoXG4gICAgL1xcLzooW1xcdy1dKykoXFw/KT8vZyxcbiAgICAoXywgcGFyYW1OYW1lLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICBwYXJhbXMucHVzaCh7IHBhcmFtTmFtZSwgaXNPcHRpb25hbDogaXNPcHRpb25hbCAhPSBudWxsIH0pO1xuICAgICAgcmV0dXJuIGlzT3B0aW9uYWwgPyBcIi8/KFteXFxcXC9dKyk/XCIgOiBcIi8oW15cXFxcL10rKVwiO1xuICAgIH1cbiAgKTtcbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpKSB7XG4gICAgcGFyYW1zLnB1c2goeyBwYXJhbU5hbWU6IFwiKlwiIH0pO1xuICAgIHJlZ2V4cFNvdXJjZSArPSBwYXRoID09PSBcIipcIiB8fCBwYXRoID09PSBcIi8qXCIgPyBcIiguKikkXCIgOiBcIig/OlxcXFwvKC4rKXxcXFxcLyopJFwiO1xuICB9IGVsc2UgaWYgKGVuZCkge1xuICAgIHJlZ2V4cFNvdXJjZSArPSBcIlxcXFwvKiRcIjtcbiAgfSBlbHNlIGlmIChwYXRoICE9PSBcIlwiICYmIHBhdGggIT09IFwiL1wiKSB7XG4gICAgcmVnZXhwU291cmNlICs9IFwiKD86KD89XFxcXC98JCkpXCI7XG4gIH0gZWxzZSB7XG4gIH1cbiAgbGV0IG1hdGNoZXIgPSBuZXcgUmVnRXhwKHJlZ2V4cFNvdXJjZSwgY2FzZVNlbnNpdGl2ZSA/IHZvaWQgMCA6IFwiaVwiKTtcbiAgcmV0dXJuIFttYXRjaGVyLCBwYXJhbXNdO1xufVxuZnVuY3Rpb24gZGVjb2RlUGF0aCh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdChcIi9cIikubWFwKCh2KSA9PiBkZWNvZGVVUklDb21wb25lbnQodikucmVwbGFjZSgvXFwvL2csIFwiJTJGXCIpKS5qb2luKFwiL1wiKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgVGhlIFVSTCBwYXRoIFwiJHt2YWx1ZX1cIiBjb3VsZCBub3QgYmUgZGVjb2RlZCBiZWNhdXNlIGl0IGlzIGEgbWFsZm9ybWVkIFVSTCBzZWdtZW50LiBUaGlzIGlzIHByb2JhYmx5IGR1ZSB0byBhIGJhZCBwZXJjZW50IGVuY29kaW5nICgke2Vycm9yfSkuYFxuICAgICk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSkge1xuICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSByZXR1cm4gcGF0aG5hbWU7XG4gIGlmICghcGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGJhc2VuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IHN0YXJ0SW5kZXggPSBiYXNlbmFtZS5lbmRzV2l0aChcIi9cIikgPyBiYXNlbmFtZS5sZW5ndGggLSAxIDogYmFzZW5hbWUubGVuZ3RoO1xuICBsZXQgbmV4dENoYXIgPSBwYXRobmFtZS5jaGFyQXQoc3RhcnRJbmRleCk7XG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcGF0aG5hbWUuc2xpY2Uoc3RhcnRJbmRleCkgfHwgXCIvXCI7XG59XG5mdW5jdGlvbiByZXNvbHZlUGF0aCh0bywgZnJvbVBhdGhuYW1lID0gXCIvXCIpIHtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogdG9QYXRobmFtZSxcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiXG4gIH0gPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG4gIGxldCBwYXRobmFtZSA9IHRvUGF0aG5hbWUgPyB0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpID8gdG9QYXRobmFtZSA6IHJlc29sdmVQYXRobmFtZSh0b1BhdGhuYW1lLCBmcm9tUGF0aG5hbWUpIDogZnJvbVBhdGhuYW1lO1xuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIHNlYXJjaDogbm9ybWFsaXplU2VhcmNoKHNlYXJjaCksXG4gICAgaGFzaDogbm9ybWFsaXplSGFzaChoYXNoKVxuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHJlbGF0aXZlUGF0aCwgZnJvbVBhdGhuYW1lKSB7XG4gIGxldCBzZWdtZW50cyA9IGZyb21QYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgbGV0IHJlbGF0aXZlU2VnbWVudHMgPSByZWxhdGl2ZVBhdGguc3BsaXQoXCIvXCIpO1xuICByZWxhdGl2ZVNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQpID0+IHtcbiAgICBpZiAoc2VnbWVudCA9PT0gXCIuLlwiKSB7XG4gICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkgc2VnbWVudHMucG9wKCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSBcIi5cIikge1xuICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID4gMSA/IHNlZ21lbnRzLmpvaW4oXCIvXCIpIDogXCIvXCI7XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkUGF0aEVycm9yKGNoYXIsIGZpZWxkLCBkZXN0LCBwYXRoKSB7XG4gIHJldHVybiBgQ2Fubm90IGluY2x1ZGUgYSAnJHtjaGFyfScgY2hhcmFjdGVyIGluIGEgbWFudWFsbHkgc3BlY2lmaWVkIFxcYHRvLiR7ZmllbGR9XFxgIGZpZWxkIFske0pTT04uc3RyaW5naWZ5KFxuICAgIHBhdGhcbiAgKX1dLiAgUGxlYXNlIHNlcGFyYXRlIGl0IG91dCB0byB0aGUgXFxgdG8uJHtkZXN0fVxcYCBmaWVsZC4gQWx0ZXJuYXRpdmVseSB5b3UgbWF5IHByb3ZpZGUgdGhlIGZ1bGwgcGF0aCBhcyBhIHN0cmluZyBpbiA8TGluayB0bz1cIi4uLlwiPiBhbmQgdGhlIHJvdXRlciB3aWxsIHBhcnNlIGl0IGZvciB5b3UuYDtcbn1cbmZ1bmN0aW9uIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpIHtcbiAgcmV0dXJuIG1hdGNoZXMuZmlsdGVyKFxuICAgIChtYXRjaCwgaW5kZXgpID0+IGluZGV4ID09PSAwIHx8IG1hdGNoLnJvdXRlLnBhdGggJiYgbWF0Y2gucm91dGUucGF0aC5sZW5ndGggPiAwXG4gICk7XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMpIHtcbiAgbGV0IHBhdGhNYXRjaGVzID0gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcyk7XG4gIHJldHVybiBwYXRoTWF0Y2hlcy5tYXAoXG4gICAgKG1hdGNoLCBpZHgpID0+IGlkeCA9PT0gcGF0aE1hdGNoZXMubGVuZ3RoIC0gMSA/IG1hdGNoLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVCYXNlXG4gICk7XG59XG5mdW5jdGlvbiByZXNvbHZlVG8odG9BcmcsIHJvdXRlUGF0aG5hbWVzLCBsb2NhdGlvblBhdGhuYW1lLCBpc1BhdGhSZWxhdGl2ZSA9IGZhbHNlKSB7XG4gIGxldCB0bztcbiAgaWYgKHR5cGVvZiB0b0FyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRvID0gcGFyc2VQYXRoKHRvQXJnKTtcbiAgfSBlbHNlIHtcbiAgICB0byA9IHsgLi4udG9BcmcgfTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhdG8ucGF0aG5hbWUgfHwgIXRvLnBhdGhuYW1lLmluY2x1ZGVzKFwiP1wiKSxcbiAgICAgIGdldEludmFsaWRQYXRoRXJyb3IoXCI/XCIsIFwicGF0aG5hbWVcIiwgXCJzZWFyY2hcIiwgdG8pXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhdG8ucGF0aG5hbWUgfHwgIXRvLnBhdGhuYW1lLmluY2x1ZGVzKFwiI1wiKSxcbiAgICAgIGdldEludmFsaWRQYXRoRXJyb3IoXCIjXCIsIFwicGF0aG5hbWVcIiwgXCJoYXNoXCIsIHRvKVxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnNlYXJjaCB8fCAhdG8uc2VhcmNoLmluY2x1ZGVzKFwiI1wiKSxcbiAgICAgIGdldEludmFsaWRQYXRoRXJyb3IoXCIjXCIsIFwic2VhcmNoXCIsIFwiaGFzaFwiLCB0bylcbiAgICApO1xuICB9XG4gIGxldCBpc0VtcHR5UGF0aCA9IHRvQXJnID09PSBcIlwiIHx8IHRvLnBhdGhuYW1lID09PSBcIlwiO1xuICBsZXQgdG9QYXRobmFtZSA9IGlzRW1wdHlQYXRoID8gXCIvXCIgOiB0by5wYXRobmFtZTtcbiAgbGV0IGZyb207XG4gIGlmICh0b1BhdGhuYW1lID09IG51bGwpIHtcbiAgICBmcm9tID0gbG9jYXRpb25QYXRobmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcm91dGVQYXRobmFtZUluZGV4ID0gcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAoIWlzUGF0aFJlbGF0aXZlICYmIHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi4uXCIpKSB7XG4gICAgICBsZXQgdG9TZWdtZW50cyA9IHRvUGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgICAgd2hpbGUgKHRvU2VnbWVudHNbMF0gPT09IFwiLi5cIikge1xuICAgICAgICB0b1NlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHJvdXRlUGF0aG5hbWVJbmRleCAtPSAxO1xuICAgICAgfVxuICAgICAgdG8ucGF0aG5hbWUgPSB0b1NlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICAgIH1cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cbiAgbGV0IHBhdGggPSByZXNvbHZlUGF0aCh0bywgZnJvbSk7XG4gIGxldCBoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggPSB0b1BhdGhuYW1lICYmIHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICBsZXQgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2ggPSAoaXNFbXB0eVBhdGggfHwgdG9QYXRobmFtZSA9PT0gXCIuXCIpICYmIGxvY2F0aW9uUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICBpZiAoIXBhdGgucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpICYmIChoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggfHwgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2gpKSB7XG4gICAgcGF0aC5wYXRobmFtZSArPSBcIi9cIjtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbnZhciBqb2luUGF0aHMgPSAocGF0aHMpID0+IHBhdGhzLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xudmFyIG5vcm1hbGl6ZVBhdGhuYW1lID0gKHBhdGhuYW1lKSA9PiBwYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xudmFyIG5vcm1hbGl6ZVNlYXJjaCA9IChzZWFyY2gpID0+ICFzZWFyY2ggfHwgc2VhcmNoID09PSBcIj9cIiA/IFwiXCIgOiBzZWFyY2guc3RhcnRzV2l0aChcIj9cIikgPyBzZWFyY2ggOiBcIj9cIiArIHNlYXJjaDtcbnZhciBub3JtYWxpemVIYXNoID0gKGhhc2gpID0+ICFoYXNoIHx8IGhhc2ggPT09IFwiI1wiID8gXCJcIiA6IGhhc2guc3RhcnRzV2l0aChcIiNcIikgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xudmFyIERhdGFXaXRoUmVzcG9uc2VJbml0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihkYXRhMiwgaW5pdCkge1xuICAgIHRoaXMudHlwZSA9IFwiRGF0YVdpdGhSZXNwb25zZUluaXRcIjtcbiAgICB0aGlzLmRhdGEgPSBkYXRhMjtcbiAgICB0aGlzLmluaXQgPSBpbml0IHx8IG51bGw7XG4gIH1cbn07XG5mdW5jdGlvbiBkYXRhKGRhdGEyLCBpbml0KSB7XG4gIHJldHVybiBuZXcgRGF0YVdpdGhSZXNwb25zZUluaXQoXG4gICAgZGF0YTIsXG4gICAgdHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIgPyB7IHN0YXR1czogaW5pdCB9IDogaW5pdFxuICApO1xufVxudmFyIHJlZGlyZWN0ID0gKHVybCwgaW5pdCA9IDMwMikgPT4ge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gaW5pdDtcbiAgaWYgKHR5cGVvZiByZXNwb25zZUluaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXNwb25zZUluaXQgPSB7IHN0YXR1czogcmVzcG9uc2VJbml0IH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdC5zdGF0dXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXNwb25zZUluaXQuc3RhdHVzID0gMzAyO1xuICB9XG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xuICBoZWFkZXJzLnNldChcIkxvY2F0aW9uXCIsIHVybCk7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyAuLi5yZXNwb25zZUluaXQsIGhlYWRlcnMgfSk7XG59O1xudmFyIHJlZGlyZWN0RG9jdW1lbnQgPSAodXJsLCBpbml0KSA9PiB7XG4gIGxldCByZXNwb25zZSA9IHJlZGlyZWN0KHVybCwgaW5pdCk7XG4gIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xudmFyIHJlcGxhY2UgPSAodXJsLCBpbml0KSA9PiB7XG4gIGxldCByZXNwb25zZSA9IHJlZGlyZWN0KHVybCwgaW5pdCk7XG4gIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZXBsYWNlXCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbnZhciBFcnJvclJlc3BvbnNlSW1wbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzLCBzdGF0dXNUZXh0LCBkYXRhMiwgaW50ZXJuYWwgPSBmYWxzZSkge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgXCJcIjtcbiAgICB0aGlzLmludGVybmFsID0gaW50ZXJuYWw7XG4gICAgaWYgKGRhdGEyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGEyLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLmVycm9yID0gZGF0YTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGEyO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvci5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGVycm9yLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLmludGVybmFsID09PSBcImJvb2xlYW5cIiAmJiBcImRhdGFcIiBpbiBlcnJvcjtcbn1cblxuLy8gbGliL3JvdXRlci9yb3V0ZXIudHNcbnZhciB2YWxpZE11dGF0aW9uTWV0aG9kc0FyciA9IFtcbiAgXCJQT1NUXCIsXG4gIFwiUFVUXCIsXG4gIFwiUEFUQ0hcIixcbiAgXCJERUxFVEVcIlxuXTtcbnZhciB2YWxpZE11dGF0aW9uTWV0aG9kcyA9IG5ldyBTZXQoXG4gIHZhbGlkTXV0YXRpb25NZXRob2RzQXJyXG4pO1xudmFyIHZhbGlkUmVxdWVzdE1ldGhvZHNBcnIgPSBbXG4gIFwiR0VUXCIsXG4gIC4uLnZhbGlkTXV0YXRpb25NZXRob2RzQXJyXG5dO1xudmFyIHZhbGlkUmVxdWVzdE1ldGhvZHMgPSBuZXcgU2V0KHZhbGlkUmVxdWVzdE1ldGhvZHNBcnIpO1xudmFyIHJlZGlyZWN0U3RhdHVzQ29kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcbnZhciByZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbMzA3LCAzMDhdKTtcbnZhciBJRExFX05BVklHQVRJT04gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgbG9jYXRpb246IHZvaWQgMCxcbiAgZm9ybU1ldGhvZDogdm9pZCAwLFxuICBmb3JtQWN0aW9uOiB2b2lkIDAsXG4gIGZvcm1FbmNUeXBlOiB2b2lkIDAsXG4gIGZvcm1EYXRhOiB2b2lkIDAsXG4gIGpzb246IHZvaWQgMCxcbiAgdGV4dDogdm9pZCAwXG59O1xudmFyIElETEVfRkVUQ0hFUiA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICBkYXRhOiB2b2lkIDAsXG4gIGZvcm1NZXRob2Q6IHZvaWQgMCxcbiAgZm9ybUFjdGlvbjogdm9pZCAwLFxuICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICBmb3JtRGF0YTogdm9pZCAwLFxuICBqc29uOiB2b2lkIDAsXG4gIHRleHQ6IHZvaWQgMFxufTtcbnZhciBJRExFX0JMT0NLRVIgPSB7XG4gIHN0YXRlOiBcInVuYmxvY2tlZFwiLFxuICBwcm9jZWVkOiB2b2lkIDAsXG4gIHJlc2V0OiB2b2lkIDAsXG4gIGxvY2F0aW9uOiB2b2lkIDBcbn07XG52YXIgQUJTT0xVVEVfVVJMX1JFR0VYID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xudmFyIGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXMgPSAocm91dGUpID0+ICh7XG4gIGhhc0Vycm9yQm91bmRhcnk6IEJvb2xlYW4ocm91dGUuaGFzRXJyb3JCb3VuZGFyeSlcbn0pO1xudmFyIFRSQU5TSVRJT05TX1NUT1JBR0VfS0VZID0gXCJyZW1peC1yb3V0ZXItdHJhbnNpdGlvbnNcIjtcbnZhciBSZXNldExvYWRlckRhdGFTeW1ib2wgPSBTeW1ib2woXCJSZXNldExvYWRlckRhdGFcIik7XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXIoaW5pdCkge1xuICBjb25zdCByb3V0ZXJXaW5kb3cgPSBpbml0LndpbmRvdyA/IGluaXQud2luZG93IDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHZvaWQgMDtcbiAgY29uc3QgaXNCcm93c2VyMiA9IHR5cGVvZiByb3V0ZXJXaW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHJvdXRlcldpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygcm91dGVyV2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG4gIGludmFyaWFudChcbiAgICBpbml0LnJvdXRlcy5sZW5ndGggPiAwLFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlUm91dGVyXCJcbiAgKTtcbiAgbGV0IGh5ZHJhdGlvblJvdXRlUHJvcGVydGllczIgPSBpbml0Lmh5ZHJhdGlvblJvdXRlUHJvcGVydGllcyB8fCBbXTtcbiAgbGV0IG1hcFJvdXRlUHJvcGVydGllczIgPSBpbml0Lm1hcFJvdXRlUHJvcGVydGllcyB8fCBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzO1xuICBsZXQgbWFuaWZlc3QgPSB7fTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIGluaXQucm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgdm9pZCAwLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGxldCBpbkZsaWdodERhdGFSb3V0ZXM7XG4gIGxldCBiYXNlbmFtZSA9IGluaXQuYmFzZW5hbWUgfHwgXCIvXCI7XG4gIGxldCBkYXRhU3RyYXRlZ3lJbXBsID0gaW5pdC5kYXRhU3RyYXRlZ3kgfHwgZGVmYXVsdERhdGFTdHJhdGVneVdpdGhNaWRkbGV3YXJlO1xuICBsZXQgZnV0dXJlID0ge1xuICAgIHVuc3RhYmxlX21pZGRsZXdhcmU6IGZhbHNlLFxuICAgIC4uLmluaXQuZnV0dXJlXG4gIH07XG4gIGxldCB1bmxpc3Rlbkhpc3RvcnkgPSBudWxsO1xuICBsZXQgc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgc2F2ZWRTY3JvbGxQb3NpdGlvbnMyID0gbnVsbDtcbiAgbGV0IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5MiA9IG51bGw7XG4gIGxldCBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gIGxldCBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbDtcbiAgbGV0IGluaXRpYWxNYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgaW5pdC5oaXN0b3J5LmxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gIGxldCBpbml0aWFsTWF0Y2hlc0lzRk9XID0gZmFsc2U7XG4gIGxldCBpbml0aWFsRXJyb3JzID0gbnVsbDtcbiAgbGV0IGluaXRpYWxpemVkO1xuICBpZiAoaW5pdGlhbE1hdGNoZXMgPT0gbnVsbCAmJiAhaW5pdC5wYXRjaFJvdXRlc09uTmF2aWdhdGlvbikge1xuICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICBwYXRobmFtZTogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgfSk7XG4gICAgbGV0IHsgbWF0Y2hlcywgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIGluaXRpYWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBpbml0aWFsRXJyb3JzID0geyBbcm91dGUuaWRdOiBlcnJvciB9O1xuICB9IGVsc2Uge1xuICAgIGlmIChpbml0aWFsTWF0Y2hlcyAmJiAhaW5pdC5oeWRyYXRpb25EYXRhKSB7XG4gICAgICBsZXQgZm9nT2ZXYXIgPSBjaGVja0ZvZ09mV2FyKFxuICAgICAgICBpbml0aWFsTWF0Y2hlcyxcbiAgICAgICAgZGF0YVJvdXRlcyxcbiAgICAgICAgaW5pdC5oaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICApO1xuICAgICAgaWYgKGZvZ09mV2FyLmFjdGl2ZSkge1xuICAgICAgICBpbml0aWFsTWF0Y2hlcyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaW5pdGlhbE1hdGNoZXMpIHtcbiAgICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICBpbml0aWFsTWF0Y2hlcyA9IFtdO1xuICAgICAgbGV0IGZvZ09mV2FyID0gY2hlY2tGb2dPZldhcihcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZGF0YVJvdXRlcyxcbiAgICAgICAgaW5pdC5oaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICApO1xuICAgICAgaWYgKGZvZ09mV2FyLmFjdGl2ZSAmJiBmb2dPZldhci5tYXRjaGVzKSB7XG4gICAgICAgIGluaXRpYWxNYXRjaGVzSXNGT1cgPSB0cnVlO1xuICAgICAgICBpbml0aWFsTWF0Y2hlcyA9IGZvZ09mV2FyLm1hdGNoZXM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbml0aWFsTWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmxhenkpKSB7XG4gICAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWluaXRpYWxNYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUubG9hZGVyKSkge1xuICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbG9hZGVyRGF0YSA9IGluaXQuaHlkcmF0aW9uRGF0YSA/IGluaXQuaHlkcmF0aW9uRGF0YS5sb2FkZXJEYXRhIDogbnVsbDtcbiAgICAgIGxldCBlcnJvcnMgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgPyBpbml0Lmh5ZHJhdGlvbkRhdGEuZXJyb3JzIDogbnVsbDtcbiAgICAgIGlmIChlcnJvcnMpIHtcbiAgICAgICAgbGV0IGlkeCA9IGluaXRpYWxNYXRjaGVzLmZpbmRJbmRleChcbiAgICAgICAgICAobSkgPT4gZXJyb3JzW20ucm91dGUuaWRdICE9PSB2b2lkIDBcbiAgICAgICAgKTtcbiAgICAgICAgaW5pdGlhbGl6ZWQgPSBpbml0aWFsTWF0Y2hlcy5zbGljZSgwLCBpZHggKyAxKS5ldmVyeShcbiAgICAgICAgICAobSkgPT4gIXNob3VsZExvYWRSb3V0ZU9uSHlkcmF0aW9uKG0ucm91dGUsIGxvYWRlckRhdGEsIGVycm9ycylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRpYWxpemVkID0gaW5pdGlhbE1hdGNoZXMuZXZlcnkoXG4gICAgICAgICAgKG0pID0+ICFzaG91bGRMb2FkUm91dGVPbkh5ZHJhdGlvbihtLnJvdXRlLCBsb2FkZXJEYXRhLCBlcnJvcnMpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCByb3V0ZXI7XG4gIGxldCBzdGF0ZSA9IHtcbiAgICBoaXN0b3J5QWN0aW9uOiBpbml0Lmhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBpbml0Lmhpc3RvcnkubG9jYXRpb24sXG4gICAgbWF0Y2hlczogaW5pdGlhbE1hdGNoZXMsXG4gICAgaW5pdGlhbGl6ZWQsXG4gICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgIC8vIERvbid0IHJlc3RvcmUgb24gaW5pdGlhbCB1cGRhdGVTdGF0ZSgpIGlmIHdlIHdlcmUgU1NSJ2RcbiAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsID8gZmFsc2UgOiBudWxsLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldDogZmFsc2UsXG4gICAgcmV2YWxpZGF0aW9uOiBcImlkbGVcIixcbiAgICBsb2FkZXJEYXRhOiBpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmxvYWRlckRhdGEgfHwge30sXG4gICAgYWN0aW9uRGF0YTogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5hY3Rpb25EYXRhIHx8IG51bGwsXG4gICAgZXJyb3JzOiBpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycyB8fCBpbml0aWFsRXJyb3JzLFxuICAgIGZldGNoZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIGJsb2NrZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gIH07XG4gIGxldCBwZW5kaW5nQWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gIGxldCBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG4gIGxldCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXI7XG4gIGxldCBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gZmFsc2U7XG4gIGxldCBhcHBsaWVkVmlld1RyYW5zaXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lciA9IG51bGw7XG4gIGxldCBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcbiAgbGV0IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgbGV0IGNhbmNlbGxlZEZldGNoZXJMb2FkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBmZXRjaENvbnRyb2xsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGluY3JlbWVudGluZ0xvYWRJZCA9IDA7XG4gIGxldCBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9IC0xO1xuICBsZXQgZmV0Y2hSZWxvYWRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgZmV0Y2hSZWRpcmVjdElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBmZXRjaExvYWRNYXRjaGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGFjdGl2ZUZldGNoZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgYmxvY2tlckZ1bmN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCB1bmJsb2NrQmxvY2tlckhpc3RvcnlVcGRhdGUgPSB2b2lkIDA7XG4gIGxldCBwZW5kaW5nUmV2YWxpZGF0aW9uRGZkID0gbnVsbDtcbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICB1bmxpc3Rlbkhpc3RvcnkgPSBpbml0Lmhpc3RvcnkubGlzdGVuKFxuICAgICAgKHsgYWN0aW9uOiBoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbiwgZGVsdGEgfSkgPT4ge1xuICAgICAgICBpZiAodW5ibG9ja0Jsb2NrZXJIaXN0b3J5VXBkYXRlKSB7XG4gICAgICAgICAgdW5ibG9ja0Jsb2NrZXJIaXN0b3J5VXBkYXRlKCk7XG4gICAgICAgICAgdW5ibG9ja0Jsb2NrZXJIaXN0b3J5VXBkYXRlID0gdm9pZCAwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCB8fCBkZWx0YSAhPSBudWxsLFxuICAgICAgICAgIFwiWW91IGFyZSB0cnlpbmcgdG8gdXNlIGEgYmxvY2tlciBvbiBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gdGhhdCB3YXMgbm90IGNyZWF0ZWQgYnkgQHJlbWl4LXJ1bi9yb3V0ZXIuIFRoaXMgd2lsbCBmYWlsIHNpbGVudGx5IGluIHByb2R1Y3Rpb24uIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgYXJlIG5hdmlnYXRpbmcgb3V0c2lkZSB0aGUgcm91dGVyIHZpYSBgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlYC9gd2luZG93LmxvY2F0aW9uLmhhc2hgIGluc3RlYWQgb2YgdXNpbmcgcm91dGVyIG5hdmlnYXRpb24gQVBJcy4gIFRoaXMgY2FuIGFsc28gaGFwcGVuIGlmIHlvdSBhcmUgdXNpbmcgY3JlYXRlSGFzaFJvdXRlciBhbmQgdGhlIHVzZXIgbWFudWFsbHkgY2hhbmdlcyB0aGUgVVJMLlwiXG4gICAgICAgICk7XG4gICAgICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaGlzdG9yeUFjdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJsb2NrZXJLZXkgJiYgZGVsdGEgIT0gbnVsbCkge1xuICAgICAgICAgIGxldCBuZXh0SGlzdG9yeVVwZGF0ZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdW5ibG9ja0Jsb2NrZXJIaXN0b3J5VXBkYXRlID0gcmVzb2x2ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEgKiAtMSk7XG4gICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIHByb2NlZWQoKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcbiAgICAgICAgICAgICAgICBwcm9jZWVkOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgcmVzZXQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbmV4dEhpc3RvcnlVcGRhdGVQcm9taXNlLnRoZW4oKCkgPT4gaW5pdC5oaXN0b3J5LmdvKGRlbHRhKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgICAgICAgICAgICBibG9ja2Vycy5zZXQoYmxvY2tlcktleSwgSURMRV9CTE9DS0VSKTtcbiAgICAgICAgICAgICAgdXBkYXRlU3RhdGUoeyBibG9ja2VycyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbik7XG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAoaXNCcm93c2VyMikge1xuICAgICAgcmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyhyb3V0ZXJXaW5kb3csIGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMpO1xuICAgICAgbGV0IF9zYXZlQXBwbGllZFRyYW5zaXRpb25zID0gKCkgPT4gcGVyc2lzdEFwcGxpZWRUcmFuc2l0aW9ucyhyb3V0ZXJXaW5kb3csIGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMpO1xuICAgICAgcm91dGVyV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyk7XG4gICAgICByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIgPSAoKSA9PiByb3V0ZXJXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9zYXZlQXBwbGllZFRyYW5zaXRpb25zKTtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgc3RhcnROYXZpZ2F0aW9uKFwiUE9QXCIgLyogUG9wICovLCBzdGF0ZS5sb2NhdGlvbiwge1xuICAgICAgICBpbml0aWFsSHlkcmF0aW9uOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdXRlcjtcbiAgfVxuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmICh1bmxpc3Rlbkhpc3RvcnkpIHtcbiAgICAgIHVubGlzdGVuSGlzdG9yeSgpO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyKSB7XG4gICAgICByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIoKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoXywga2V5KSA9PiBkZWxldGVGZXRjaGVyKGtleSkpO1xuICAgIHN0YXRlLmJsb2NrZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlQmxvY2tlcihrZXkpKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZm4pIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiBzdWJzY3JpYmVycy5kZWxldGUoZm4pO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBvcHRzID0ge30pIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLi4ubmV3U3RhdGVcbiAgICB9O1xuICAgIGxldCB1bm1vdW50ZWRGZXRjaGVycyA9IFtdO1xuICAgIGxldCBtb3VudGVkRmV0Y2hlcnMgPSBbXTtcbiAgICBzdGF0ZS5mZXRjaGVycy5mb3JFYWNoKChmZXRjaGVyLCBrZXkpID0+IHtcbiAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgICBpZiAoZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5oYXMoa2V5KSkge1xuICAgICAgICAgIHVubW91bnRlZEZldGNoZXJzLnB1c2goa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb3VudGVkRmV0Y2hlcnMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICghc3RhdGUuZmV0Y2hlcnMuaGFzKGtleSkgJiYgIWZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgdW5tb3VudGVkRmV0Y2hlcnMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFsuLi5zdWJzY3JpYmVyc10uZm9yRWFjaChcbiAgICAgIChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyKHN0YXRlLCB7XG4gICAgICAgIGRlbGV0ZWRGZXRjaGVyczogdW5tb3VudGVkRmV0Y2hlcnMsXG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0czogb3B0cy52aWV3VHJhbnNpdGlvbk9wdHMsXG4gICAgICAgIGZsdXNoU3luYzogb3B0cy5mbHVzaFN5bmMgPT09IHRydWVcbiAgICAgIH0pXG4gICAgKTtcbiAgICB1bm1vdW50ZWRGZXRjaGVycy5mb3JFYWNoKChrZXkpID0+IGRlbGV0ZUZldGNoZXIoa2V5KSk7XG4gICAgbW91bnRlZEZldGNoZXJzLmZvckVhY2goKGtleSkgPT4gc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSkpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwgbmV3U3RhdGUsIHsgZmx1c2hTeW5jIH0gPSB7fSkge1xuICAgIGxldCBpc0FjdGlvblJlbG9hZCA9IHN0YXRlLmFjdGlvbkRhdGEgIT0gbnVsbCAmJiBzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJiBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiYgc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiYgbG9jYXRpb24uc3RhdGU/Ll9pc1JlZGlyZWN0ICE9PSB0cnVlO1xuICAgIGxldCBhY3Rpb25EYXRhO1xuICAgIGlmIChuZXdTdGF0ZS5hY3Rpb25EYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMobmV3U3RhdGUuYWN0aW9uRGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICBhY3Rpb25EYXRhID0gbmV3U3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBY3Rpb25SZWxvYWQpIHtcbiAgICAgIGFjdGlvbkRhdGEgPSBzdGF0ZS5hY3Rpb25EYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IGxvYWRlckRhdGEgPSBuZXdTdGF0ZS5sb2FkZXJEYXRhID8gbWVyZ2VMb2FkZXJEYXRhKFxuICAgICAgc3RhdGUubG9hZGVyRGF0YSxcbiAgICAgIG5ld1N0YXRlLmxvYWRlckRhdGEsXG4gICAgICBuZXdTdGF0ZS5tYXRjaGVzIHx8IFtdLFxuICAgICAgbmV3U3RhdGUuZXJyb3JzXG4gICAgKSA6IHN0YXRlLmxvYWRlckRhdGE7XG4gICAgbGV0IGJsb2NrZXJzID0gc3RhdGUuYmxvY2tlcnM7XG4gICAgaWYgKGJsb2NrZXJzLnNpemUgPiAwKSB7XG4gICAgICBibG9ja2VycyA9IG5ldyBNYXAoYmxvY2tlcnMpO1xuICAgICAgYmxvY2tlcnMuZm9yRWFjaCgoXywgaykgPT4gYmxvY2tlcnMuc2V0KGssIElETEVfQkxPQ0tFUikpO1xuICAgIH1cbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID0gcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSB8fCBzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJiBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiYgbG9jYXRpb24uc3RhdGU/Ll9pc1JlZGlyZWN0ICE9PSB0cnVlO1xuICAgIGlmIChpbkZsaWdodERhdGFSb3V0ZXMpIHtcbiAgICAgIGRhdGFSb3V0ZXMgPSBpbkZsaWdodERhdGFSb3V0ZXM7XG4gICAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pIHtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IFwiUE9QXCIgLyogUG9wICovKSB7XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBcIlBVU0hcIiAvKiBQdXNoICovKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucHVzaChsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gXCJSRVBMQUNFXCIgLyogUmVwbGFjZSAqLykge1xuICAgICAgaW5pdC5oaXN0b3J5LnJlcGxhY2UobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9XG4gICAgbGV0IHZpZXdUcmFuc2l0aW9uT3B0cztcbiAgICBpZiAocGVuZGluZ0FjdGlvbiA9PT0gXCJQT1BcIiAvKiBQb3AgKi8pIHtcbiAgICAgIGxldCBwcmlvclBhdGhzID0gYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5nZXQoc3RhdGUubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgaWYgKHByaW9yUGF0aHMgJiYgcHJpb3JQYXRocy5oYXMobG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5oYXMobG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogc3RhdGUubG9jYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQpIHtcbiAgICAgIGxldCB0b1BhdGhzID0gYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5nZXQoc3RhdGUubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgaWYgKHRvUGF0aHMpIHtcbiAgICAgICAgdG9QYXRocy5hZGQobG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9QYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtsb2NhdGlvbi5wYXRobmFtZV0pO1xuICAgICAgICBhcHBsaWVkVmlld1RyYW5zaXRpb25zLnNldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSwgdG9QYXRocyk7XG4gICAgICB9XG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKFxuICAgICAge1xuICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgLy8gbWF0Y2hlcywgZXJyb3JzLCBmZXRjaGVycyBnbyB0aHJvdWdoIGFzLWlzXG4gICAgICAgIGFjdGlvbkRhdGEsXG4gICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgIGhpc3RvcnlBY3Rpb246IHBlbmRpbmdBY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgICAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgbmV3U3RhdGUubWF0Y2hlcyB8fCBzdGF0ZS5tYXRjaGVzXG4gICAgICAgICksXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgYmxvY2tlcnNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyxcbiAgICAgICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMgPT09IHRydWVcbiAgICAgIH1cbiAgICApO1xuICAgIHBlbmRpbmdBY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICBwZW5kaW5nUmV2YWxpZGF0aW9uRGZkPy5yZXNvbHZlKCk7XG4gICAgcGVuZGluZ1JldmFsaWRhdGlvbkRmZCA9IG51bGw7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbmF2aWdhdGUodG8sIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpbml0Lmhpc3RvcnkuZ28odG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVUbyhcbiAgICAgIHN0YXRlLmxvY2F0aW9uLFxuICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgdG8sXG4gICAgICBvcHRzPy5mcm9tUm91dGVJZCxcbiAgICAgIG9wdHM/LnJlbGF0aXZlXG4gICAgKTtcbiAgICBsZXQgeyBwYXRoLCBzdWJtaXNzaW9uLCBlcnJvciB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKFxuICAgICAgZmFsc2UsXG4gICAgICBub3JtYWxpemVkUGF0aCxcbiAgICAgIG9wdHNcbiAgICApO1xuICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIHBhdGgsIG9wdHMgJiYgb3B0cy5zdGF0ZSk7XG4gICAgbmV4dExvY2F0aW9uID0ge1xuICAgICAgLi4ubmV4dExvY2F0aW9uLFxuICAgICAgLi4uaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKG5leHRMb2NhdGlvbilcbiAgICB9O1xuICAgIGxldCB1c2VyUmVwbGFjZSA9IG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwgPyBvcHRzLnJlcGxhY2UgOiB2b2lkIDA7XG4gICAgbGV0IGhpc3RvcnlBY3Rpb24gPSBcIlBVU0hcIiAvKiBQdXNoICovO1xuICAgIGlmICh1c2VyUmVwbGFjZSA9PT0gdHJ1ZSkge1xuICAgICAgaGlzdG9yeUFjdGlvbiA9IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi87XG4gICAgfSBlbHNlIGlmICh1c2VyUmVwbGFjZSA9PT0gZmFsc2UpIHtcbiAgICB9IGVsc2UgaWYgKHN1Ym1pc3Npb24gIT0gbnVsbCAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkgJiYgc3VibWlzc2lvbi5mb3JtQWN0aW9uID09PSBzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSArIHN0YXRlLmxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaGlzdG9yeUFjdGlvbiA9IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi87XG4gICAgfVxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSBvcHRzICYmIFwicHJldmVudFNjcm9sbFJlc2V0XCIgaW4gb3B0cyA/IG9wdHMucHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlIDogdm9pZCAwO1xuICAgIGxldCBmbHVzaFN5bmMgPSAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWU7XG4gICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaGlzdG9yeUFjdGlvblxuICAgIH0pO1xuICAgIGlmIChibG9ja2VyS2V5KSB7XG4gICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxuICAgICAgICAgICAgcHJvY2VlZDogdm9pZCAwLFxuICAgICAgICAgICAgcmVzZXQ6IHZvaWQgMCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuYXZpZ2F0ZSh0bywgb3B0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgICAgICAgIGJsb2NrZXJzLnNldChibG9ja2VyS2V5LCBJRExFX0JMT0NLRVIpO1xuICAgICAgICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnMgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbmV4dExvY2F0aW9uLCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgLy8gU2VuZCB0aHJvdWdoIHRoZSBmb3JtRGF0YSBzZXJpYWxpemF0aW9uIGVycm9yIGlmIHdlIGhhdmUgb25lIHNvIHdlIGNhblxuICAgICAgLy8gcmVuZGVyIGF0IHRoZSByaWdodCBlcnJvciBib3VuZGFyeSBhZnRlciB3ZSBtYXRjaCByb3V0ZXNcbiAgICAgIHBlbmRpbmdFcnJvcjogZXJyb3IsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZXBsYWNlOiBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBvcHRzICYmIG9wdHMudmlld1RyYW5zaXRpb24sXG4gICAgICBmbHVzaFN5bmNcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZXZhbGlkYXRlKCkge1xuICAgIGlmICghcGVuZGluZ1JldmFsaWRhdGlvbkRmZCkge1xuICAgICAgcGVuZGluZ1JldmFsaWRhdGlvbkRmZCA9IGNyZWF0ZURlZmVycmVkKCk7XG4gICAgfVxuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgdXBkYXRlU3RhdGUoeyByZXZhbGlkYXRpb246IFwibG9hZGluZ1wiIH0pO1xuICAgIGxldCBwcm9taXNlID0gcGVuZGluZ1JldmFsaWRhdGlvbkRmZC5wcm9taXNlO1xuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcInN1Ym1pdHRpbmdcIikge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgc3RhcnROYXZpZ2F0aW9uKHN0YXRlLmhpc3RvcnlBY3Rpb24sIHN0YXRlLmxvY2F0aW9uLCB7XG4gICAgICAgIHN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgc3RhcnROYXZpZ2F0aW9uKFxuICAgICAgcGVuZGluZ0FjdGlvbiB8fCBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbixcbiAgICAgIHtcbiAgICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uOiBzdGF0ZS5uYXZpZ2F0aW9uLFxuICAgICAgICAvLyBQcm94eSB0aHJvdWdoIGFueSByZW5kaW5nIHZpZXcgdHJhbnNpdGlvblxuICAgICAgICBlbmFibGVWaWV3VHJhbnNpdGlvbjogcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9PT0gdHJ1ZVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uLCBvcHRzKSB7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgcGVuZGluZ0FjdGlvbiA9IGhpc3RvcnlBY3Rpb247XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gKG9wdHMgJiYgb3B0cy5zdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pID09PSB0cnVlO1xuICAgIHNhdmVTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcbiAgICBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gKG9wdHMgJiYgb3B0cy5lbmFibGVWaWV3VHJhbnNpdGlvbikgPT09IHRydWU7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3B0cyAmJiBvcHRzLm92ZXJyaWRlTmF2aWdhdGlvbjtcbiAgICBsZXQgbWF0Y2hlcyA9IG9wdHM/LmluaXRpYWxIeWRyYXRpb24gJiYgc3RhdGUubWF0Y2hlcyAmJiBzdGF0ZS5tYXRjaGVzLmxlbmd0aCA+IDAgJiYgIWluaXRpYWxNYXRjaGVzSXNGT1cgPyAoXG4gICAgICAvLyBgbWF0Y2hSb3V0ZXMoKWAgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgaWYgd2UncmUgaW4gaGVyZSB2aWEgYHJvdXRlci5pbml0aWFsaXplKClgXG4gICAgICBzdGF0ZS5tYXRjaGVzXG4gICAgKSA6IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIGxldCBmbHVzaFN5bmMgPSAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWU7XG4gICAgaWYgKG1hdGNoZXMgJiYgc3RhdGUuaW5pdGlhbGl6ZWQgJiYgIWlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgJiYgaXNIYXNoQ2hhbmdlT25seShzdGF0ZS5sb2NhdGlvbiwgbG9jYXRpb24pICYmICEob3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChvcHRzLnN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpKSB7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHsgbWF0Y2hlcyB9LCB7IGZsdXNoU3luYyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZvZ09mV2FyID0gY2hlY2tGb2dPZldhcihtYXRjaGVzLCByb3V0ZXNUb1VzZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIGlmIChmb2dPZldhci5hY3RpdmUgJiYgZm9nT2ZXYXIubWF0Y2hlcykge1xuICAgICAgbWF0Y2hlcyA9IGZvZ09mV2FyLm1hdGNoZXM7XG4gICAgfVxuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IHsgZXJyb3IsIG5vdEZvdW5kTWF0Y2hlcywgcm91dGUgfSA9IGhhbmRsZU5hdmlnYXRpb25hbDQwNChcbiAgICAgICAgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgcmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb25cbiAgICApO1xuICAgIGxldCBzY29wZWRDb250ZXh0ID0gbmV3IHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlcihcbiAgICAgIGluaXQudW5zdGFibGVfZ2V0Q29udGV4dCA/IGF3YWl0IGluaXQudW5zdGFibGVfZ2V0Q29udGV4dCgpIDogdm9pZCAwXG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ0FjdGlvblJlc3VsdDtcbiAgICBpZiAob3B0cyAmJiBvcHRzLnBlbmRpbmdFcnJvcikge1xuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdCA9IFtcbiAgICAgICAgZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzKS5yb3V0ZS5pZCxcbiAgICAgICAgeyB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sIGVycm9yOiBvcHRzLnBlbmRpbmdFcnJvciB9XG4gICAgICBdO1xuICAgIH0gZWxzZSBpZiAob3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChvcHRzLnN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICAgIGxldCBhY3Rpb25SZXN1bHQgPSBhd2FpdCBoYW5kbGVBY3Rpb24oXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgICAgb3B0cyAmJiBvcHRzLmluaXRpYWxIeWRyYXRpb24gPT09IHRydWUsXG4gICAgICAgIHsgcmVwbGFjZTogb3B0cy5yZXBsYWNlLCBmbHVzaFN5bmMgfVxuICAgICAgKTtcbiAgICAgIGlmIChhY3Rpb25SZXN1bHQuc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGlvblJlc3VsdC5wZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgICAgIGxldCBbcm91dGVJZCwgcmVzdWx0XSA9IGFjdGlvblJlc3VsdC5wZW5kaW5nQWN0aW9uUmVzdWx0O1xuICAgICAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpICYmIGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5lcnJvcikgJiYgcmVzdWx0LmVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcbiAgICAgICAgICAgIG1hdGNoZXM6IGFjdGlvblJlc3VsdC5tYXRjaGVzLFxuICAgICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgICAgW3JvdXRlSWRdOiByZXN1bHQuZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1hdGNoZXMgPSBhY3Rpb25SZXN1bHQubWF0Y2hlcyB8fCBtYXRjaGVzO1xuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdCA9IGFjdGlvblJlc3VsdC5wZW5kaW5nQWN0aW9uUmVzdWx0O1xuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgb3B0cy5zdWJtaXNzaW9uKTtcbiAgICAgIGZsdXNoU3luYyA9IGZhbHNlO1xuICAgICAgZm9nT2ZXYXIuYWN0aXZlID0gZmFsc2U7XG4gICAgICByZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgICAgcmVxdWVzdC51cmwsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQge1xuICAgICAgc2hvcnRDaXJjdWl0ZWQsXG4gICAgICBtYXRjaGVzOiB1cGRhdGVkTWF0Y2hlcyxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9ID0gYXdhaXQgaGFuZGxlTG9hZGVycyhcbiAgICAgIHJlcXVlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgZm9nT2ZXYXIuYWN0aXZlLFxuICAgICAgbG9hZGluZ05hdmlnYXRpb24sXG4gICAgICBvcHRzICYmIG9wdHMuc3VibWlzc2lvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5mZXRjaGVyU3VibWlzc2lvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5yZXBsYWNlLFxuICAgICAgb3B0cyAmJiBvcHRzLmluaXRpYWxIeWRyYXRpb24gPT09IHRydWUsXG4gICAgICBmbHVzaFN5bmMsXG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0XG4gICAgKTtcbiAgICBpZiAoc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcbiAgICAgIG1hdGNoZXM6IHVwZGF0ZWRNYXRjaGVzIHx8IG1hdGNoZXMsXG4gICAgICAuLi5nZXRBY3Rpb25EYXRhRm9yQ29tbWl0KHBlbmRpbmdBY3Rpb25SZXN1bHQpLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFjdGlvbihyZXF1ZXN0LCBsb2NhdGlvbiwgc3VibWlzc2lvbiwgbWF0Y2hlcywgc2NvcGVkQ29udGV4dCwgaXNGb2dPZldhciwgaW5pdGlhbEh5ZHJhdGlvbiwgb3B0cyA9IHt9KSB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICBsZXQgbmF2aWdhdGlvbiA9IGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKTtcbiAgICB1cGRhdGVTdGF0ZSh7IG5hdmlnYXRpb24gfSwgeyBmbHVzaFN5bmM6IG9wdHMuZmx1c2hTeW5jID09PSB0cnVlIH0pO1xuICAgIGlmIChpc0ZvZ09mV2FyKSB7XG4gICAgICBsZXQgZGlzY292ZXJSZXN1bHQgPSBhd2FpdCBkaXNjb3ZlclJvdXRlcyhcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsXG4gICAgICApO1xuICAgICAgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgICB9IGVsc2UgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoZGlzY292ZXJSZXN1bHQucGFydGlhbE1hdGNoZXMpLnJvdXRlLmlkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1hdGNoZXM6IGRpc2NvdmVyUmVzdWx0LnBhcnRpYWxNYXRjaGVzLFxuICAgICAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQ6IFtcbiAgICAgICAgICAgIGJvdW5kYXJ5SWQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgICAgICAgZXJyb3I6IGRpc2NvdmVyUmVzdWx0LmVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICghZGlzY292ZXJSZXN1bHQubWF0Y2hlcykge1xuICAgICAgICBsZXQgeyBub3RGb3VuZE1hdGNoZXMsIGVycm9yLCByb3V0ZSB9ID0gaGFuZGxlTmF2aWdhdGlvbmFsNDA0KFxuICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQ6IFtcbiAgICAgICAgICAgIHJvdXRlLmlkLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlcyA9IGRpc2NvdmVyUmVzdWx0Lm1hdGNoZXM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGFjdGlvbk1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWRcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkc01hdGNoZXMgPSBnZXRUYXJnZXRlZERhdGFTdHJhdGVneU1hdGNoZXMoXG4gICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBhY3Rpb25NYXRjaCxcbiAgICAgICAgaW5pdGlhbEh5ZHJhdGlvbiA/IFtdIDogaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgc2NvcGVkQ29udGV4dFxuICAgICAgKTtcbiAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgZHNNYXRjaGVzLFxuICAgICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0c1thY3Rpb25NYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdHNbbWF0Y2gucm91dGUuaWRdKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IHJlcGxhY2UyO1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwpIHtcbiAgICAgICAgcmVwbGFjZTIgPSBvcHRzLnJlcGxhY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgbG9jYXRpb24yID0gbm9ybWFsaXplUmVkaXJlY3RMb2NhdGlvbihcbiAgICAgICAgICByZXN1bHQucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKSxcbiAgICAgICAgICBuZXcgVVJMKHJlcXVlc3QudXJsKSxcbiAgICAgICAgICBiYXNlbmFtZVxuICAgICAgICApO1xuICAgICAgICByZXBsYWNlMiA9IGxvY2F0aW9uMiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXF1ZXN0LCByZXN1bHQsIHRydWUsIHtcbiAgICAgICAgc3VibWlzc2lvbixcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZTJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIGlmICgob3B0cyAmJiBvcHRzLnJlcGxhY2UpICE9PSB0cnVlKSB7XG4gICAgICAgIHBlbmRpbmdBY3Rpb24gPSBcIlBVU0hcIiAvKiBQdXNoICovO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdDogW1xuICAgICAgICAgIGJvdW5kYXJ5TWF0Y2gucm91dGUuaWQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIGFjdGlvbk1hdGNoLnJvdXRlLmlkXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdDogW2FjdGlvbk1hdGNoLnJvdXRlLmlkLCByZXN1bHRdXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJzKHJlcXVlc3QsIGxvY2F0aW9uLCBtYXRjaGVzLCBzY29wZWRDb250ZXh0LCBpc0ZvZ09mV2FyLCBvdmVycmlkZU5hdmlnYXRpb24sIHN1Ym1pc3Npb24sIGZldGNoZXJTdWJtaXNzaW9uLCByZXBsYWNlMiwgaW5pdGlhbEh5ZHJhdGlvbiwgZmx1c2hTeW5jLCBwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3ZlcnJpZGVOYXZpZ2F0aW9uIHx8IGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKTtcbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgZmV0Y2hlclN1Ym1pc3Npb24gfHwgZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKGxvYWRpbmdOYXZpZ2F0aW9uKTtcbiAgICBsZXQgc2hvdWxkVXBkYXRlTmF2aWdhdGlvblN0YXRlID0gIWlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiAmJiAhaW5pdGlhbEh5ZHJhdGlvbjtcbiAgICBpZiAoaXNGb2dPZldhcikge1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZU5hdmlnYXRpb25TdGF0ZSkge1xuICAgICAgICBsZXQgYWN0aW9uRGF0YSA9IGdldFVwZGF0ZWRBY3Rpb25EYXRhKHBlbmRpbmdBY3Rpb25SZXN1bHQpO1xuICAgICAgICB1cGRhdGVTdGF0ZShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYXZpZ2F0aW9uOiBsb2FkaW5nTmF2aWdhdGlvbixcbiAgICAgICAgICAgIC4uLmFjdGlvbkRhdGEgIT09IHZvaWQgMCA/IHsgYWN0aW9uRGF0YSB9IDoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZsdXNoU3luY1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGxldCBkaXNjb3ZlclJlc3VsdCA9IGF3YWl0IGRpc2NvdmVyUm91dGVzKFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgcmVxdWVzdC5zaWduYWxcbiAgICAgICk7XG4gICAgICBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICAgIH0gZWxzZSBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIGxldCBib3VuZGFyeUlkID0gZmluZE5lYXJlc3RCb3VuZGFyeShkaXNjb3ZlclJlc3VsdC5wYXJ0aWFsTWF0Y2hlcykucm91dGUuaWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWF0Y2hlczogZGlzY292ZXJSZXN1bHQucGFydGlhbE1hdGNoZXMsXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBbYm91bmRhcnlJZF06IGRpc2NvdmVyUmVzdWx0LmVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICghZGlzY292ZXJSZXN1bHQubWF0Y2hlcykge1xuICAgICAgICBsZXQgeyBlcnJvciwgbm90Rm91bmRNYXRjaGVzLCByb3V0ZSB9ID0gaGFuZGxlTmF2aWdhdGlvbmFsNDA0KFxuICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaGVzID0gZGlzY292ZXJSZXN1bHQubWF0Y2hlcztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IHsgZHNNYXRjaGVzLCByZXZhbGlkYXRpbmdGZXRjaGVycyB9ID0gZ2V0TWF0Y2hlc1RvTG9hZChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgYWN0aXZlU3VibWlzc2lvbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgaW5pdGlhbEh5ZHJhdGlvbiA/IFtdIDogaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIGluaXRpYWxIeWRyYXRpb24gPT09IHRydWUsXG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkLFxuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLFxuICAgICAgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbixcbiAgICAgIGZldGNoTG9hZE1hdGNoZXMsXG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLFxuICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGluaXQucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24gIT0gbnVsbCxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHRcbiAgICApO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgaWYgKCFpbml0LmRhdGFTdHJhdGVneSAmJiAhZHNNYXRjaGVzLnNvbWUoKG0pID0+IG0uc2hvdWxkTG9hZCkgJiYgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsZXQgdXBkYXRlZEZldGNoZXJzMiA9IG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIC8vIENvbW1pdCBwZW5kaW5nIGVycm9yIGlmIHdlJ3JlIHNob3J0IGNpcmN1aXRpbmdcbiAgICAgICAgICBlcnJvcnM6IHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSA/IHsgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yIH0gOiBudWxsLFxuICAgICAgICAgIC4uLmdldEFjdGlvbkRhdGFGb3JDb21taXQocGVuZGluZ0FjdGlvblJlc3VsdCksXG4gICAgICAgICAgLi4udXBkYXRlZEZldGNoZXJzMiA/IHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0gOiB7fVxuICAgICAgICB9LFxuICAgICAgICB7IGZsdXNoU3luYyB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG4gICAgaWYgKHNob3VsZFVwZGF0ZU5hdmlnYXRpb25TdGF0ZSkge1xuICAgICAgbGV0IHVwZGF0ZXMgPSB7fTtcbiAgICAgIGlmICghaXNGb2dPZldhcikge1xuICAgICAgICB1cGRhdGVzLm5hdmlnYXRpb24gPSBsb2FkaW5nTmF2aWdhdGlvbjtcbiAgICAgICAgbGV0IGFjdGlvbkRhdGEgPSBnZXRVcGRhdGVkQWN0aW9uRGF0YShwZW5kaW5nQWN0aW9uUmVzdWx0KTtcbiAgICAgICAgaWYgKGFjdGlvbkRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHVwZGF0ZXMuYWN0aW9uRGF0YSA9IGFjdGlvbkRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVwZGF0ZXMuZmV0Y2hlcnMgPSBnZXRVcGRhdGVkUmV2YWxpZGF0aW5nRmV0Y2hlcnMocmV2YWxpZGF0aW5nRmV0Y2hlcnMpO1xuICAgICAgfVxuICAgICAgdXBkYXRlU3RhdGUodXBkYXRlcywgeyBmbHVzaFN5bmMgfSk7XG4gICAgfVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiB7XG4gICAgICBhYm9ydEZldGNoZXIocmYua2V5KTtcbiAgICAgIGlmIChyZi5jb250cm9sbGVyKSB7XG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHJmLmtleSwgcmYuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyA9ICgpID0+IHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKGYpID0+IGFib3J0RmV0Y2hlcihmLmtleSkpO1xuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJhYm9ydFwiLFxuICAgICAgICBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCB7IGxvYWRlclJlc3VsdHMsIGZldGNoZXJSZXN1bHRzIH0gPSBhd2FpdCBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoXG4gICAgICBkc01hdGNoZXMsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIHJlcXVlc3QsXG4gICAgICBzY29wZWRDb250ZXh0XG4gICAgKTtcbiAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG4gICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcikge1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBcImFib3J0XCIsXG4gICAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHJmLmtleSkpO1xuICAgIGxldCByZWRpcmVjdDIgPSBmaW5kUmVkaXJlY3QobG9hZGVyUmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0Mikge1xuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24ocmVxdWVzdCwgcmVkaXJlY3QyLnJlc3VsdCwgdHJ1ZSwge1xuICAgICAgICByZXBsYWNlOiByZXBsYWNlMlxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICByZWRpcmVjdDIgPSBmaW5kUmVkaXJlY3QoZmV0Y2hlclJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdDIpIHtcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKHJlZGlyZWN0Mi5rZXkpO1xuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24ocmVxdWVzdCwgcmVkaXJlY3QyLnJlc3VsdCwgdHJ1ZSwge1xuICAgICAgICByZXBsYWNlOiByZXBsYWNlMlxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIGZldGNoZXJSZXN1bHRzXG4gICAgKTtcbiAgICBpZiAoaW5pdGlhbEh5ZHJhdGlvbiAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICAgIGVycm9ycyA9IHsgLi4uc3RhdGUuZXJyb3JzLCAuLi5lcnJvcnMgfTtcbiAgICB9XG4gICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTtcbiAgICBsZXQgZGlkQWJvcnRGZXRjaExvYWRzID0gYWJvcnRTdGFsZUZldGNoTG9hZHMocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQpO1xuICAgIGxldCBzaG91bGRVcGRhdGVGZXRjaGVycyA9IHVwZGF0ZWRGZXRjaGVycyB8fCBkaWRBYm9ydEZldGNoTG9hZHMgfHwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMDtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2hlcyxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnMsXG4gICAgICAuLi5zaG91bGRVcGRhdGVGZXRjaGVycyA/IHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0gOiB7fVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VXBkYXRlZEFjdGlvbkRhdGEocGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICAgIGlmIChwZW5kaW5nQWN0aW9uUmVzdWx0ICYmICFpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZGF0YVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmFjdGlvbkRhdGEpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhzdGF0ZS5hY3Rpb25EYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VXBkYXRlZFJldmFsaWRhdGluZ0ZldGNoZXJzKHJldmFsaWRhdGluZ0ZldGNoZXJzKSB7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IHtcbiAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHJmLmtleSk7XG4gICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGZldGNoZXIgPyBmZXRjaGVyLmRhdGEgOiB2b2lkIDBcbiAgICAgICk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQocmYua2V5LCByZXZhbGlkYXRpbmdGZXRjaGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1hcChzdGF0ZS5mZXRjaGVycyk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2gyKGtleSwgcm91dGVJZCwgaHJlZjIsIG9wdHMpIHtcbiAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKFxuICAgICAgc3RhdGUubG9jYXRpb24sXG4gICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBocmVmMixcbiAgICAgIHJvdXRlSWQsXG4gICAgICBvcHRzPy5yZWxhdGl2ZVxuICAgICk7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgbm9ybWFsaXplZFBhdGgsIGJhc2VuYW1lKTtcbiAgICBsZXQgZm9nT2ZXYXIgPSBjaGVja0ZvZ09mV2FyKG1hdGNoZXMsIHJvdXRlc1RvVXNlLCBub3JtYWxpemVkUGF0aCk7XG4gICAgaWYgKGZvZ09mV2FyLmFjdGl2ZSAmJiBmb2dPZldhci5tYXRjaGVzKSB7XG4gICAgICBtYXRjaGVzID0gZm9nT2ZXYXIubWF0Y2hlcztcbiAgICB9XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3IoXG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZCxcbiAgICAgICAgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IG5vcm1hbGl6ZWRQYXRoIH0pLFxuICAgICAgICB7IGZsdXNoU3luYyB9XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgeyBwYXRoLCBzdWJtaXNzaW9uLCBlcnJvciB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKFxuICAgICAgdHJ1ZSxcbiAgICAgIG5vcm1hbGl6ZWRQYXRoLFxuICAgICAgb3B0c1xuICAgICk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xuICAgIGxldCBzY29wZWRDb250ZXh0ID0gbmV3IHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlcihcbiAgICAgIGluaXQudW5zdGFibGVfZ2V0Q29udGV4dCA/IGF3YWl0IGluaXQudW5zdGFibGVfZ2V0Q29udGV4dCgpIDogdm9pZCAwXG4gICAgKTtcbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuICAgIGlmIChzdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgYXdhaXQgaGFuZGxlRmV0Y2hlckFjdGlvbihcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkLFxuICAgICAgICBwYXRoLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgICAgZm9nT2ZXYXIuYWN0aXZlLFxuICAgICAgICBmbHVzaFN5bmMsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgc3VibWlzc2lvblxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5zZXQoa2V5LCB7IHJvdXRlSWQsIHBhdGggfSk7XG4gICAgYXdhaXQgaGFuZGxlRmV0Y2hlckxvYWRlcihcbiAgICAgIGtleSxcbiAgICAgIHJvdXRlSWQsXG4gICAgICBwYXRoLFxuICAgICAgbWF0Y2gsXG4gICAgICBtYXRjaGVzLFxuICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgIGZsdXNoU3luYyxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHN1Ym1pc3Npb25cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJBY3Rpb24oa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgcmVxdWVzdE1hdGNoZXMsIHNjb3BlZENvbnRleHQsIGlzRm9nT2ZXYXIsIGZsdXNoU3luYywgcHJldmVudFNjcm9sbFJlc2V0LCBzdWJtaXNzaW9uKSB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICBmZXRjaExvYWRNYXRjaGVzLmRlbGV0ZShrZXkpO1xuICAgIGZ1bmN0aW9uIGRldGVjdEFuZEhhbmRsZTQwNUVycm9yKG0pIHtcbiAgICAgIGlmICghbS5yb3V0ZS5hY3Rpb24gJiYgIW0ucm91dGUubGF6eSkge1xuICAgICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgIG1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgICAgIHBhdGhuYW1lOiBwYXRoLFxuICAgICAgICAgIHJvdXRlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCB7IGZsdXNoU3luYyB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNGb2dPZldhciAmJiBkZXRlY3RBbmRIYW5kbGU0MDVFcnJvcihtYXRjaCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlciksIHtcbiAgICAgIGZsdXNoU3luY1xuICAgIH0pO1xuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgcGF0aCxcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICBzdWJtaXNzaW9uXG4gICAgKTtcbiAgICBpZiAoaXNGb2dPZldhcikge1xuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMoXG4gICAgICAgIHJlcXVlc3RNYXRjaGVzLFxuICAgICAgICBwYXRoLFxuICAgICAgICBmZXRjaFJlcXVlc3Quc2lnbmFsLFxuICAgICAgICBrZXlcbiAgICAgICk7XG4gICAgICBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZGlzY292ZXJSZXN1bHQuZXJyb3IsIHsgZmx1c2hTeW5jIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKCFkaXNjb3ZlclJlc3VsdC5tYXRjaGVzKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgcm91dGVJZCxcbiAgICAgICAgICBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogcGF0aCB9KSxcbiAgICAgICAgICB7IGZsdXNoU3luYyB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RNYXRjaGVzID0gZGlzY292ZXJSZXN1bHQubWF0Y2hlcztcbiAgICAgICAgbWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChyZXF1ZXN0TWF0Y2hlcywgcGF0aCk7XG4gICAgICAgIGlmIChkZXRlY3RBbmRIYW5kbGU0MDVFcnJvcihtYXRjaCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBhYm9ydENvbnRyb2xsZXIpO1xuICAgIGxldCBvcmlnaW5hdGluZ0xvYWRJZCA9IGluY3JlbWVudGluZ0xvYWRJZDtcbiAgICBsZXQgZmV0Y2hNYXRjaGVzID0gZ2V0VGFyZ2V0ZWREYXRhU3RyYXRlZ3lNYXRjaGVzKFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgcmVxdWVzdE1hdGNoZXMsXG4gICAgICBtYXRjaCxcbiAgICAgIGh5ZHJhdGlvblJvdXRlUHJvcGVydGllczIsXG4gICAgICBzY29wZWRDb250ZXh0XG4gICAgKTtcbiAgICBsZXQgYWN0aW9uUmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICBmZXRjaE1hdGNoZXMsXG4gICAgICBzY29wZWRDb250ZXh0LFxuICAgICAga2V5XG4gICAgKTtcbiAgICBsZXQgYWN0aW9uUmVzdWx0ID0gYWN0aW9uUmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5oYXMoa2V5KSkge1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSB8fCBpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodm9pZCAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPiBvcmlnaW5hdGluZ0xvYWRJZCkge1xuICAgICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHZvaWQgMCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24pKTtcbiAgICAgICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oZmV0Y2hSZXF1ZXN0LCBhY3Rpb25SZXN1bHQsIGZhbHNlLCB7XG4gICAgICAgICAgICBmZXRjaGVyU3VibWlzc2lvbjogc3VibWlzc2lvbixcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGFjdGlvblJlc3VsdC5lcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHRMb2NhdGlvbiA9IHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gfHwgc3RhdGUubG9jYXRpb247XG4gICAgbGV0IHJldmFsaWRhdGlvblJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICApO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBtYXRjaGVzID0gc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSAhPT0gXCJpZGxlXCIgPyBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwgYmFzZW5hbWUpIDogc3RhdGUubWF0Y2hlcztcbiAgICBpbnZhcmlhbnQobWF0Y2hlcywgXCJEaWRuJ3QgZmluZCBhbnkgbWF0Y2hlcyBhZnRlciBmZXRjaGVyIGFjdGlvblwiKTtcbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgZmV0Y2hSZWxvYWRJZHMuc2V0KGtleSwgbG9hZElkKTtcbiAgICBsZXQgbG9hZEZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xuICAgIGxldCB7IGRzTWF0Y2hlcywgcmV2YWxpZGF0aW5nRmV0Y2hlcnMgfSA9IGdldE1hdGNoZXNUb0xvYWQoXG4gICAgICByZXZhbGlkYXRpb25SZXF1ZXN0LFxuICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgZmFsc2UsXG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkLFxuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLFxuICAgICAgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbixcbiAgICAgIGZldGNoTG9hZE1hdGNoZXMsXG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLFxuICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGluaXQucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24gIT0gbnVsbCxcbiAgICAgIFttYXRjaC5yb3V0ZS5pZCwgYWN0aW9uUmVzdWx0XVxuICAgICk7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZmlsdGVyKChyZikgPT4gcmYua2V5ICE9PSBrZXkpLmZvckVhY2goKHJmKSA9PiB7XG4gICAgICBsZXQgc3RhbGVLZXkgPSByZi5rZXk7XG4gICAgICBsZXQgZXhpc3RpbmdGZXRjaGVyMiA9IHN0YXRlLmZldGNoZXJzLmdldChzdGFsZUtleSk7XG4gICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGV4aXN0aW5nRmV0Y2hlcjIgPyBleGlzdGluZ0ZldGNoZXIyLmRhdGEgOiB2b2lkIDBcbiAgICAgICk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoc3RhbGVLZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgYWJvcnRGZXRjaGVyKHN0YWxlS2V5KTtcbiAgICAgIGlmIChyZi5jb250cm9sbGVyKSB7XG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHN0YWxlS2V5LCByZi5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcbiAgICBsZXQgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zID0gKCkgPT4gcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IGFib3J0RmV0Y2hlcihyZi5rZXkpKTtcbiAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcImFib3J0XCIsXG4gICAgICBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnNcbiAgICApO1xuICAgIGxldCB7IGxvYWRlclJlc3VsdHMsIGZldGNoZXJSZXN1bHRzIH0gPSBhd2FpdCBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoXG4gICAgICBkc01hdGNoZXMsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIHJldmFsaWRhdGlvblJlcXVlc3QsXG4gICAgICBzY29wZWRDb250ZXh0XG4gICAgKTtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiYWJvcnRcIixcbiAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyKSA9PiBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShyLmtleSkpO1xuICAgIGlmIChzdGF0ZS5mZXRjaGVycy5oYXMoa2V5KSkge1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIoYWN0aW9uUmVzdWx0LmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgICBsZXQgcmVkaXJlY3QyID0gZmluZFJlZGlyZWN0KGxvYWRlclJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdDIpIHtcbiAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihcbiAgICAgICAgcmV2YWxpZGF0aW9uUmVxdWVzdCxcbiAgICAgICAgcmVkaXJlY3QyLnJlc3VsdCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHsgcHJldmVudFNjcm9sbFJlc2V0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIHJlZGlyZWN0MiA9IGZpbmRSZWRpcmVjdChmZXRjaGVyUmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0Mikge1xuICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQocmVkaXJlY3QyLmtleSk7XG4gICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oXG4gICAgICAgIHJldmFsaWRhdGlvblJlcXVlc3QsXG4gICAgICAgIHJlZGlyZWN0Mi5yZXN1bHQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB7IHByZXZlbnRTY3JvbGxSZXNldCB9XG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgZmV0Y2hlclJlc3VsdHNcbiAgICApO1xuICAgIGFib3J0U3RhbGVGZXRjaExvYWRzKGxvYWRJZCk7XG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGxvYWRJZCA+IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkKSB7XG4gICAgICBpbnZhcmlhbnQocGVuZGluZ0FjdGlvbiwgXCJFeHBlY3RlZCBwZW5kaW5nIGFjdGlvblwiKTtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGxvYWRlckRhdGE6IG1lcmdlTG9hZGVyRGF0YShcbiAgICAgICAgICBzdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBlcnJvcnNcbiAgICAgICAgKSxcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9KTtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckxvYWRlcihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzLCBzY29wZWRDb250ZXh0LCBpc0ZvZ09mV2FyLCBmbHVzaFN5bmMsIHByZXZlbnRTY3JvbGxSZXNldCwgc3VibWlzc2lvbikge1xuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICB1cGRhdGVGZXRjaGVyU3RhdGUoXG4gICAgICBrZXksXG4gICAgICBnZXRMb2FkaW5nRmV0Y2hlcihcbiAgICAgICAgc3VibWlzc2lvbixcbiAgICAgICAgZXhpc3RpbmdGZXRjaGVyID8gZXhpc3RpbmdGZXRjaGVyLmRhdGEgOiB2b2lkIDBcbiAgICAgICksXG4gICAgICB7IGZsdXNoU3luYyB9XG4gICAgKTtcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBpZiAoaXNGb2dPZldhcikge1xuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMoXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGZldGNoUmVxdWVzdC5zaWduYWwsXG4gICAgICAgIGtleVxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBkaXNjb3ZlclJlc3VsdC5lcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWRpc2NvdmVyUmVzdWx0Lm1hdGNoZXMpIHtcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBwYXRoIH0pLFxuICAgICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlcyA9IGRpc2NvdmVyUmVzdWx0Lm1hdGNoZXM7XG4gICAgICAgIG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IGRzTWF0Y2hlcyA9IGdldFRhcmdldGVkRGF0YVN0cmF0ZWd5TWF0Y2hlcyhcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYXRjaCxcbiAgICAgIGh5ZHJhdGlvblJvdXRlUHJvcGVydGllczIsXG4gICAgICBzY29wZWRDb250ZXh0XG4gICAgKTtcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICBkc01hdGNoZXMsXG4gICAgICBzY29wZWRDb250ZXh0LFxuICAgICAga2V5XG4gICAgKTtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5oYXMoa2V5KSkge1xuICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodm9pZCAwKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA+IG9yaWdpbmF0aW5nTG9hZElkKSB7XG4gICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHZvaWQgMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihmZXRjaFJlcXVlc3QsIHJlc3VsdCwgZmFsc2UsIHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgcmVzdWx0LmVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIocmVzdWx0LmRhdGEpKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXF1ZXN0LCByZWRpcmVjdDIsIGlzTmF2aWdhdGlvbiwge1xuICAgIHN1Ym1pc3Npb24sXG4gICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHJlcGxhY2U6IHJlcGxhY2UyXG4gIH0gPSB7fSkge1xuICAgIGlmIChyZWRpcmVjdDIucmVzcG9uc2UuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJldmFsaWRhdGVcIikpIHtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgbG9jYXRpb24gPSByZWRpcmVjdDIucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgICBpbnZhcmlhbnQobG9jYXRpb24sIFwiRXhwZWN0ZWQgYSBMb2NhdGlvbiBoZWFkZXIgb24gdGhlIHJlZGlyZWN0IFJlc3BvbnNlXCIpO1xuICAgIGxvY2F0aW9uID0gbm9ybWFsaXplUmVkaXJlY3RMb2NhdGlvbihcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbmV3IFVSTChyZXF1ZXN0LnVybCksXG4gICAgICBiYXNlbmFtZVxuICAgICk7XG4gICAgbGV0IHJlZGlyZWN0TG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgbG9jYXRpb24sIHtcbiAgICAgIF9pc1JlZGlyZWN0OiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKGlzQnJvd3NlcjIpIHtcbiAgICAgIGxldCBpc0RvY3VtZW50UmVsb2FkID0gZmFsc2U7XG4gICAgICBpZiAocmVkaXJlY3QyLnJlc3BvbnNlLmhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIikpIHtcbiAgICAgICAgaXNEb2N1bWVudFJlbG9hZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KGxvY2F0aW9uKSkge1xuICAgICAgICBjb25zdCB1cmwgPSBjcmVhdGVCcm93c2VyVVJMSW1wbChsb2NhdGlvbiwgdHJ1ZSk7XG4gICAgICAgIGlzRG9jdW1lbnRSZWxvYWQgPSAvLyBIYXJkIHJlbG9hZCBpZiBpdCdzIGFuIGFic29sdXRlIFVSTCB0byBhIG5ldyBvcmlnaW5cbiAgICAgICAgdXJsLm9yaWdpbiAhPT0gcm91dGVyV2luZG93LmxvY2F0aW9uLm9yaWdpbiB8fCAvLyBIYXJkIHJlbG9hZCBpZiBpdCdzIGFuIGFic29sdXRlIFVSTCB0aGF0IGRvZXMgbm90IG1hdGNoIG91ciBiYXNlbmFtZVxuICAgICAgICBzdHJpcEJhc2VuYW1lKHVybC5wYXRobmFtZSwgYmFzZW5hbWUpID09IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoaXNEb2N1bWVudFJlbG9hZCkge1xuICAgICAgICBpZiAocmVwbGFjZTIpIHtcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24ucmVwbGFjZShsb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyV2luZG93LmxvY2F0aW9uLmFzc2lnbihsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIGxldCByZWRpcmVjdE5hdmlnYXRpb25UeXBlID0gcmVwbGFjZTIgPT09IHRydWUgfHwgcmVkaXJlY3QyLnJlc3BvbnNlLmhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXBsYWNlXCIpID8gXCJSRVBMQUNFXCIgLyogUmVwbGFjZSAqLyA6IFwiUFVTSFwiIC8qIFB1c2ggKi87XG4gICAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUgfSA9IHN0YXRlLm5hdmlnYXRpb247XG4gICAgaWYgKCFzdWJtaXNzaW9uICYmICFmZXRjaGVyU3VibWlzc2lvbiAmJiBmb3JtTWV0aG9kICYmIGZvcm1BY3Rpb24gJiYgZm9ybUVuY1R5cGUpIHtcbiAgICAgIHN1Ym1pc3Npb24gPSBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24oc3RhdGUubmF2aWdhdGlvbik7XG4gICAgfVxuICAgIGxldCBhY3RpdmVTdWJtaXNzaW9uID0gc3VibWlzc2lvbiB8fCBmZXRjaGVyU3VibWlzc2lvbjtcbiAgICBpZiAocmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzLmhhcyhyZWRpcmVjdDIucmVzcG9uc2Uuc3RhdHVzKSAmJiBhY3RpdmVTdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2QoYWN0aXZlU3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0TmF2aWdhdGlvblR5cGUsIHJlZGlyZWN0TG9jYXRpb24sIHtcbiAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgIC4uLmFjdGl2ZVN1Ym1pc3Npb24sXG4gICAgICAgICAgZm9ybUFjdGlvbjogbG9jYXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgLy8gUHJlc2VydmUgdGhlc2UgZmxhZ3MgYWNyb3NzIHJlZGlyZWN0c1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IHByZXZlbnRTY3JvbGxSZXNldCB8fCBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBlbmFibGVWaWV3VHJhbnNpdGlvbjogaXNOYXZpZ2F0aW9uID8gcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBvdmVycmlkZU5hdmlnYXRpb24gPSBnZXRMb2FkaW5nTmF2aWdhdGlvbihcbiAgICAgICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgICAgc3VibWlzc2lvblxuICAgICAgKTtcbiAgICAgIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihyZWRpcmVjdE5hdmlnYXRpb25UeXBlLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbixcbiAgICAgICAgLy8gU2VuZCBmZXRjaGVyIHN1Ym1pc3Npb25zIHRocm91Z2ggZm9yIHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoZXNlIGZsYWdzIGFjcm9zcyByZWRpcmVjdHNcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBwcmV2ZW50U2Nyb2xsUmVzZXQgfHwgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgZW5hYmxlVmlld1RyYW5zaXRpb246IGlzTmF2aWdhdGlvbiA/IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjYWxsRGF0YVN0cmF0ZWd5KHJlcXVlc3QsIG1hdGNoZXMsIHNjb3BlZENvbnRleHQsIGZldGNoZXJLZXkpIHtcbiAgICBsZXQgcmVzdWx0cztcbiAgICBsZXQgZGF0YVJlc3VsdHMgPSB7fTtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3lJbXBsKFxuICAgICAgICBkYXRhU3RyYXRlZ3lJbXBsLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBmZXRjaGVyS2V5LFxuICAgICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBtYXRjaGVzLmZpbHRlcigobSkgPT4gbS5zaG91bGRMb2FkKS5mb3JFYWNoKChtKSA9PiB7XG4gICAgICAgIGRhdGFSZXN1bHRzW20ucm91dGUuaWRdID0ge1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgICBlcnJvcjogZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGF0YVJlc3VsdHM7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gZGF0YVJlc3VsdHM7XG4gICAgfVxuICAgIGZvciAobGV0IFtyb3V0ZUlkLCByZXN1bHRdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3VsdHMpKSB7XG4gICAgICBpZiAoaXNSZWRpcmVjdERhdGFTdHJhdGVneVJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgIGRhdGFSZXN1bHRzW3JvdXRlSWRdID0ge1xuICAgICAgICAgIHR5cGU6IFwicmVkaXJlY3RcIiAvKiByZWRpcmVjdCAqLyxcbiAgICAgICAgICByZXNwb25zZTogbm9ybWFsaXplUmVsYXRpdmVSb3V0aW5nUmVkaXJlY3RSZXNwb25zZShcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHJvdXRlSWQsXG4gICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgYmFzZW5hbWVcbiAgICAgICAgICApXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhUmVzdWx0c1tyb3V0ZUlkXSA9IGF3YWl0IGNvbnZlcnREYXRhU3RyYXRlZ3lSZXN1bHRUb0RhdGFSZXN1bHQoXG4gICAgICAgICAgcmVzdWx0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhUmVzdWx0cztcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEobWF0Y2hlcywgZmV0Y2hlcnNUb0xvYWQsIHJlcXVlc3QsIHNjb3BlZENvbnRleHQpIHtcbiAgICBsZXQgbG9hZGVyUmVzdWx0c1Byb21pc2UgPSBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgbGV0IGZldGNoZXJSZXN1bHRzUHJvbWlzZSA9IFByb21pc2UuYWxsKFxuICAgICAgZmV0Y2hlcnNUb0xvYWQubWFwKGFzeW5jIChmKSA9PiB7XG4gICAgICAgIGlmIChmLm1hdGNoZXMgJiYgZi5tYXRjaCAmJiBmLnJlcXVlc3QgJiYgZi5jb250cm9sbGVyKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgICAgICAgZi5yZXF1ZXN0LFxuICAgICAgICAgICAgZi5tYXRjaGVzLFxuICAgICAgICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgICAgICAgIGYua2V5XG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tmLm1hdGNoLnJvdXRlLmlkXTtcbiAgICAgICAgICByZXR1cm4geyBbZi5rZXldOiByZXN1bHQgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIFtmLmtleV06IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZTogZi5wYXRoXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICBsZXQgbG9hZGVyUmVzdWx0cyA9IGF3YWl0IGxvYWRlclJlc3VsdHNQcm9taXNlO1xuICAgIGxldCBmZXRjaGVyUmVzdWx0cyA9IChhd2FpdCBmZXRjaGVyUmVzdWx0c1Byb21pc2UpLnJlZHVjZShcbiAgICAgIChhY2MsIHIpID0+IE9iamVjdC5hc3NpZ24oYWNjLCByKSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIGZldGNoZXJSZXN1bHRzXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpIHtcbiAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcbiAgICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLmFkZChrZXkpO1xuICAgICAgfVxuICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZmV0Y2hlciwgb3B0cyA9IHt9KSB7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoXG4gICAgICB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9LFxuICAgICAgeyBmbHVzaFN5bmM6IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZSB9XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgb3B0cyA9IHt9KSB7XG4gICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xuICAgIGRlbGV0ZUZldGNoZXIoa2V5KTtcbiAgICB1cGRhdGVTdGF0ZShcbiAgICAgIHtcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiBlcnJvclxuICAgICAgICB9LFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0sXG4gICAgICB7IGZsdXNoU3luYzogKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlIH1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZldGNoZXIoa2V5KSB7XG4gICAgYWN0aXZlRmV0Y2hlcnMuc2V0KGtleSwgKGFjdGl2ZUZldGNoZXJzLmdldChrZXkpIHx8IDApICsgMSk7XG4gICAgaWYgKGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uaGFzKGtleSkpIHtcbiAgICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KSB8fCBJRExFX0ZFVENIRVI7XG4gIH1cbiAgZnVuY3Rpb24gZGVsZXRlRmV0Y2hlcihrZXkpIHtcbiAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpICYmICEoZmV0Y2hlciAmJiBmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJiBmZXRjaFJlbG9hZElkcy5oYXMoa2V5KSkpIHtcbiAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIH1cbiAgICBmZXRjaExvYWRNYXRjaGVzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5kZWxldGUoa2V5KTtcbiAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcXVldWVGZXRjaGVyRm9yRGVsZXRpb24oa2V5KSB7XG4gICAgbGV0IGNvdW50ID0gKGFjdGl2ZUZldGNoZXJzLmdldChrZXkpIHx8IDApIC0gMTtcbiAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgYWN0aXZlRmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmFkZChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3RpdmVGZXRjaGVycy5zZXQoa2V5LCBjb3VudCk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFib3J0RmV0Y2hlcihrZXkpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSk7XG4gICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaGVyc0RvbmUoa2V5cykge1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IGdldEZldGNoZXIoa2V5KTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGZldGNoZXIuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKSB7XG4gICAgbGV0IGRvbmVLZXlzID0gW107XG4gICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBmZXRjaFJlZGlyZWN0SWRzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgaW52YXJpYW50KGZldGNoZXIsIGBFeHBlY3RlZCBmZXRjaGVyOiAke2tleX1gKTtcbiAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICBkb25lS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHVwZGF0ZWRGZXRjaGVycyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoZG9uZUtleXMpO1xuICAgIHJldHVybiB1cGRhdGVkRmV0Y2hlcnM7XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnRTdGFsZUZldGNoTG9hZHMobGFuZGVkSWQpIHtcbiAgICBsZXQgeWVldGVkS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IFtrZXksIGlkXSBvZiBmZXRjaFJlbG9hZElkcykge1xuICAgICAgaWYgKGlkIDwgbGFuZGVkSWQpIHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgICAgaW52YXJpYW50KGZldGNoZXIsIGBFeHBlY3RlZCBmZXRjaGVyOiAke2tleX1gKTtcbiAgICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICAgICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWVldGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZSh5ZWV0ZWRLZXlzKTtcbiAgICByZXR1cm4geWVldGVkS2V5cy5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIGdldEJsb2NrZXIoa2V5LCBmbikge1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLmdldChrZXkpICE9PSBmbikge1xuICAgICAgYmxvY2tlckZ1bmN0aW9ucy5zZXQoa2V5LCBmbik7XG4gICAgfVxuICAgIHJldHVybiBibG9ja2VyO1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZUJsb2NrZXIoa2V5KSB7XG4gICAgc3RhdGUuYmxvY2tlcnMuZGVsZXRlKGtleSk7XG4gICAgYmxvY2tlckZ1bmN0aW9ucy5kZWxldGUoa2V5KTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVCbG9ja2VyKGtleSwgbmV3QmxvY2tlcikge1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuICAgIGludmFyaWFudChcbiAgICAgIGJsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiB8fCBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiLFxuICAgICAgYEludmFsaWQgYmxvY2tlciBzdGF0ZSB0cmFuc2l0aW9uOiAke2Jsb2NrZXIuc3RhdGV9IC0+ICR7bmV3QmxvY2tlci5zdGF0ZX1gXG4gICAgKTtcbiAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICBibG9ja2Vycy5zZXQoa2V5LCBuZXdCbG9ja2VyKTtcbiAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgY3VycmVudExvY2F0aW9uLFxuICAgIG5leHRMb2NhdGlvbixcbiAgICBoaXN0b3J5QWN0aW9uXG4gIH0pIHtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPiAxKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCBcIkEgcm91dGVyIG9ubHkgc3VwcG9ydHMgb25lIGJsb2NrZXIgYXQgYSB0aW1lXCIpO1xuICAgIH1cbiAgICBsZXQgZW50cmllcyA9IEFycmF5LmZyb20oYmxvY2tlckZ1bmN0aW9ucy5lbnRyaWVzKCkpO1xuICAgIGxldCBbYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uXSA9IGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXTtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChibG9ja2VyS2V5KTtcbiAgICBpZiAoYmxvY2tlciAmJiBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9uKHsgY3VycmVudExvY2F0aW9uLCBuZXh0TG9jYXRpb24sIGhpc3RvcnlBY3Rpb24gfSkpIHtcbiAgICAgIHJldHVybiBibG9ja2VyS2V5O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOYXZpZ2F0aW9uYWw0MDQocGF0aG5hbWUpIHtcbiAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZSB9KTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgeyBtYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhyb3V0ZXNUb1VzZSk7XG4gICAgcmV0dXJuIHsgbm90Rm91bmRNYXRjaGVzOiBtYXRjaGVzLCByb3V0ZSwgZXJyb3IgfTtcbiAgfVxuICBmdW5jdGlvbiBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbihwb3NpdGlvbnMsIGdldFBvc2l0aW9uLCBnZXRLZXkpIHtcbiAgICBzYXZlZFNjcm9sbFBvc2l0aW9uczIgPSBwb3NpdGlvbnM7XG4gICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBnZXRQb3NpdGlvbjtcbiAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIgPSBnZXRLZXkgfHwgbnVsbDtcbiAgICBpZiAoIWluaXRpYWxTY3JvbGxSZXN0b3JlZCAmJiBzdGF0ZS5uYXZpZ2F0aW9uID09PSBJRExFX05BVklHQVRJT04pIHtcbiAgICAgIGluaXRpYWxTY3JvbGxSZXN0b3JlZCA9IHRydWU7XG4gICAgICBsZXQgeSA9IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oc3RhdGUubG9jYXRpb24sIHN0YXRlLm1hdGNoZXMpO1xuICAgICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTdGF0ZSh7IHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogeSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zMiA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5Mikge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5MihcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXMubWFwKChtKSA9PiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBzdGF0ZS5sb2FkZXJEYXRhKSlcbiAgICAgICk7XG4gICAgICByZXR1cm4ga2V5IHx8IGxvY2F0aW9uLmtleTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2F0aW9uLmtleTtcbiAgfVxuICBmdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBpZiAoc2F2ZWRTY3JvbGxQb3NpdGlvbnMyICYmIGdldFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zMltrZXldID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9uczIpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgbGV0IHkgPSBzYXZlZFNjcm9sbFBvc2l0aW9uczJba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tGb2dPZldhcihtYXRjaGVzLCByb3V0ZXNUb1VzZSwgcGF0aG5hbWUpIHtcbiAgICBpZiAoaW5pdC5wYXRjaFJvdXRlc09uTmF2aWdhdGlvbikge1xuICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIGxldCBmb2dNYXRjaGVzID0gbWF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIGJhc2VuYW1lLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHsgYWN0aXZlOiB0cnVlLCBtYXRjaGVzOiBmb2dNYXRjaGVzIHx8IFtdIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMobWF0Y2hlc1swXS5wYXJhbXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZXQgcGFydGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlc0ltcGwoXG4gICAgICAgICAgICByb3V0ZXNUb1VzZSxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4geyBhY3RpdmU6IHRydWUsIG1hdGNoZXM6IHBhcnRpYWxNYXRjaGVzIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYWN0aXZlOiBmYWxzZSwgbWF0Y2hlczogbnVsbCB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRpc2NvdmVyUm91dGVzKG1hdGNoZXMsIHBhdGhuYW1lLCBzaWduYWwsIGZldGNoZXJLZXkpIHtcbiAgICBpZiAoIWluaXQucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24pIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXRjaGVzIH07XG4gICAgfVxuICAgIGxldCBwYXJ0aWFsTWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBpc05vbkhNUiA9IGluRmxpZ2h0RGF0YVJvdXRlcyA9PSBudWxsO1xuICAgICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgICBsZXQgbG9jYWxNYW5pZmVzdCA9IG1hbmlmZXN0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgaW5pdC5wYXRjaFJvdXRlc09uTmF2aWdhdGlvbih7XG4gICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgIHBhdGg6IHBhdGhuYW1lLFxuICAgICAgICAgIG1hdGNoZXM6IHBhcnRpYWxNYXRjaGVzLFxuICAgICAgICAgIGZldGNoZXJLZXksXG4gICAgICAgICAgcGF0Y2g6IChyb3V0ZUlkLCBjaGlsZHJlbikgPT4ge1xuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgICAgICBwYXRjaFJvdXRlc0ltcGwoXG4gICAgICAgICAgICAgIHJvdXRlSWQsXG4gICAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgICByb3V0ZXNUb1VzZSxcbiAgICAgICAgICAgICAgbG9jYWxNYW5pZmVzdCxcbiAgICAgICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiBlLCBwYXJ0aWFsTWF0Y2hlcyB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGlzTm9uSE1SICYmICFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIGRhdGFSb3V0ZXMgPSBbLi4uZGF0YVJvdXRlc107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImFib3J0ZWRcIiB9O1xuICAgICAgfVxuICAgICAgbGV0IG5ld01hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgcGF0aG5hbWUsIGJhc2VuYW1lKTtcbiAgICAgIGlmIChuZXdNYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXRjaGVzOiBuZXdNYXRjaGVzIH07XG4gICAgICB9XG4gICAgICBsZXQgbmV3UGFydGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlc0ltcGwoXG4gICAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgICBpZiAoIW5ld1BhcnRpYWxNYXRjaGVzIHx8IHBhcnRpYWxNYXRjaGVzLmxlbmd0aCA9PT0gbmV3UGFydGlhbE1hdGNoZXMubGVuZ3RoICYmIHBhcnRpYWxNYXRjaGVzLmV2ZXJ5KFxuICAgICAgICAobSwgaSkgPT4gbS5yb3V0ZS5pZCA9PT0gbmV3UGFydGlhbE1hdGNoZXNbaV0ucm91dGUuaWRcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hdGNoZXM6IG51bGwgfTtcbiAgICAgIH1cbiAgICAgIHBhcnRpYWxNYXRjaGVzID0gbmV3UGFydGlhbE1hdGNoZXM7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9pbnRlcm5hbFNldFJvdXRlcyhuZXdSb3V0ZXMpIHtcbiAgICBtYW5pZmVzdCA9IHt9O1xuICAgIGluRmxpZ2h0RGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgICBuZXdSb3V0ZXMsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgdm9pZCAwLFxuICAgICAgbWFuaWZlc3RcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHBhdGNoUm91dGVzKHJvdXRlSWQsIGNoaWxkcmVuKSB7XG4gICAgbGV0IGlzTm9uSE1SID0gaW5GbGlnaHREYXRhUm91dGVzID09IG51bGw7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgcGF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgcm91dGVJZCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczJcbiAgICApO1xuICAgIGlmIChpc05vbkhNUikge1xuICAgICAgZGF0YVJvdXRlcyA9IFsuLi5kYXRhUm91dGVzXTtcbiAgICAgIHVwZGF0ZVN0YXRlKHt9KTtcbiAgICB9XG4gIH1cbiAgcm91dGVyID0ge1xuICAgIGdldCBiYXNlbmFtZSgpIHtcbiAgICAgIHJldHVybiBiYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBmdXR1cmUoKSB7XG4gICAgICByZXR1cm4gZnV0dXJlO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG4gICAgZ2V0IHdpbmRvdygpIHtcbiAgICAgIHJldHVybiByb3V0ZXJXaW5kb3c7XG4gICAgfSxcbiAgICBpbml0aWFsaXplLFxuICAgIHN1YnNjcmliZSxcbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbixcbiAgICBuYXZpZ2F0ZSxcbiAgICBmZXRjaDogZmV0Y2gyLFxuICAgIHJldmFsaWRhdGUsXG4gICAgLy8gUGFzc3Rocm91Z2ggdG8gaGlzdG9yeS1hd2FyZSBjcmVhdGVIcmVmIHVzZWQgYnkgdXNlSHJlZiBzbyB3ZSBnZXQgcHJvcGVyXG4gICAgLy8gaGFzaC1hd2FyZSBVUkxzIGluIERPTSBwYXRoc1xuICAgIGNyZWF0ZUhyZWY6ICh0bykgPT4gaW5pdC5oaXN0b3J5LmNyZWF0ZUhyZWYodG8pLFxuICAgIGVuY29kZUxvY2F0aW9uOiAodG8pID0+IGluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbih0byksXG4gICAgZ2V0RmV0Y2hlcixcbiAgICBkZWxldGVGZXRjaGVyOiBxdWV1ZUZldGNoZXJGb3JEZWxldGlvbixcbiAgICBkaXNwb3NlLFxuICAgIGdldEJsb2NrZXIsXG4gICAgZGVsZXRlQmxvY2tlcixcbiAgICBwYXRjaFJvdXRlcyxcbiAgICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBmZXRjaENvbnRyb2xsZXJzLFxuICAgIC8vIFRPRE86IFJlbW92ZSBzZXRSb3V0ZXMsIGl0J3MgdGVtcG9yYXJ5IHRvIGF2b2lkIGRlYWxpbmcgd2l0aFxuICAgIC8vIHVwZGF0aW5nIHRoZSB0cmVlIHdoaWxlIHZhbGlkYXRpbmcgdGhlIHVwZGF0ZSBhbGdvcml0aG0uXG4gICAgX2ludGVybmFsU2V0Um91dGVzXG4gIH07XG4gIHJldHVybiByb3V0ZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyKHJvdXRlcywgb3B0cykge1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVzLmxlbmd0aCA+IDAsXG4gICAgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVTdGF0aWNIYW5kbGVyXCJcbiAgKTtcbiAgbGV0IG1hbmlmZXN0ID0ge307XG4gIGxldCBiYXNlbmFtZSA9IChvcHRzID8gb3B0cy5iYXNlbmFtZSA6IG51bGwpIHx8IFwiL1wiO1xuICBsZXQgbWFwUm91dGVQcm9wZXJ0aWVzMiA9IG9wdHM/Lm1hcFJvdXRlUHJvcGVydGllcyB8fCBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzO1xuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgdm9pZCAwLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5KHJlcXVlc3QsIHtcbiAgICByZXF1ZXN0Q29udGV4dCxcbiAgICBmaWx0ZXJNYXRjaGVzVG9Mb2FkLFxuICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLFxuICAgIHNraXBSZXZhbGlkYXRpb24sXG4gICAgZGF0YVN0cmF0ZWd5LFxuICAgIHVuc3RhYmxlX3Jlc3BvbmQ6IHJlc3BvbmRcbiAgfSA9IHt9KSB7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgcmVxdWVzdENvbnRleHQgPSByZXF1ZXN0Q29udGV4dCAhPSBudWxsID8gcmVxdWVzdENvbnRleHQgOiBuZXcgdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyKCk7XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kIH0pO1xuICAgICAgbGV0IHsgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsIHJvdXRlIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgICAgbGV0IHN0YXRpY0NvbnRleHQgPSB7XG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXNwb25kID8gcmVzcG9uZChzdGF0aWNDb250ZXh0KSA6IHN0YXRpY0NvbnRleHQ7XG4gICAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgICAgbGV0IHsgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIGxldCBzdGF0aWNDb250ZXh0ID0ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3BvbmQgPyByZXNwb25kKHN0YXRpY0NvbnRleHQpIDogc3RhdGljQ29udGV4dDtcbiAgICB9XG4gICAgaWYgKHJlc3BvbmQgJiYgbWF0Y2hlcy5zb21lKFxuICAgICAgKG0pID0+IG0ucm91dGUudW5zdGFibGVfbWlkZGxld2FyZSB8fCB0eXBlb2YgbS5yb3V0ZS5sYXp5ID09PSBcIm9iamVjdFwiICYmIG0ucm91dGUubGF6eS51bnN0YWJsZV9taWRkbGV3YXJlXG4gICAgKSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICByZXF1ZXN0Q29udGV4dCBpbnN0YW5jZW9mIHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlcixcbiAgICAgICAgXCJXaGVuIHVzaW5nIG1pZGRsZXdhcmUgaW4gYHN0YXRpY0hhbmRsZXIucXVlcnkoKWAsIGFueSBwcm92aWRlZCBgcmVxdWVzdENvbnRleHRgIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgYHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlcmBcIlxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGxvYWRMYXp5TWlkZGxld2FyZUZvck1hdGNoZXMoXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyXG4gICAgICAgICk7XG4gICAgICAgIGxldCByZW5kZXJlZFN0YXRpY0NvbnRleHQ7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHJ1bk1pZGRsZXdhcmVQaXBlbGluZShcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgIHBhcmFtczogbWF0Y2hlc1swXS5wYXJhbXMsXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBjYWxsaW5nIG1pZGRsZXdhcmUgdGhlbiBpdCBtdXN0IGJlIGVuYWJsZWQgc28gd2UgY2FuIGNhc3RcbiAgICAgICAgICAgIC8vIHRoaXMgdG8gdGhlIHByb3BlciB0eXBlIGtub3dpbmcgaXQncyBub3QgYW4gYEFwcExvYWRDb250ZXh0YFxuICAgICAgICAgICAgY29udGV4dDogcmVxdWVzdENvbnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDIgPSBhd2FpdCBxdWVyeUltcGwoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgICAgICAgZGF0YVN0cmF0ZWd5IHx8IG51bGwsXG4gICAgICAgICAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nID09PSB0cnVlLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBmaWx0ZXJNYXRjaGVzVG9Mb2FkIHx8IG51bGwsXG4gICAgICAgICAgICAgIHNraXBSZXZhbGlkYXRpb24gPT09IHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlcmVkU3RhdGljQ29udGV4dCA9IHsgbG9jYXRpb24sIGJhc2VuYW1lLCAuLi5yZXN1bHQyIH07XG4gICAgICAgICAgICBsZXQgcmVzID0gYXdhaXQgcmVzcG9uZChyZW5kZXJlZFN0YXRpY0NvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFzeW5jIChlcnJvciwgcm91dGVJZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZW5kZXJlZFN0YXRpY0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgaWYgKHJvdXRlSWQgaW4gcmVuZGVyZWRTdGF0aWNDb250ZXh0LmxvYWRlckRhdGEpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFN0YXRpY0NvbnRleHQubG9hZGVyRGF0YVtyb3V0ZUlkXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uZChcbiAgICAgICAgICAgICAgICBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yKFxuICAgICAgICAgICAgICAgICAgZGF0YVJvdXRlcyxcbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVkU3RhdGljQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcgPyByb3V0ZUlkIDogZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCByb3V0ZUlkKS5yb3V0ZS5pZFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxldCBib3VuZGFyeVJvdXRlSWQgPSBza2lwTG9hZGVyRXJyb3JCdWJibGluZyA/IHJvdXRlSWQgOiBmaW5kTmVhcmVzdEJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5maW5kKFxuICAgICAgICAgICAgICAgICAgKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQgfHwgbS5yb3V0ZS5sb2FkZXJcbiAgICAgICAgICAgICAgICApPy5yb3V0ZS5pZCB8fCByb3V0ZUlkXG4gICAgICAgICAgICAgICkucm91dGUuaWQ7XG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25kKHtcbiAgICAgICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGJhc2VuYW1lLFxuICAgICAgICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICAgICAgICBbYm91bmRhcnlSb3V0ZUlkXTogZXJyb3JcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSA/IGVycm9yLnN0YXR1cyA6IDUwMCxcbiAgICAgICAgICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGludmFyaWFudChpc1Jlc3BvbnNlKHJlc3BvbnNlKSwgXCJFeHBlY3RlZCBhIHJlc3BvbnNlIGluIHF1ZXJ5KClcIik7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGlzUmVzcG9uc2UoZSkpIHtcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnlJbXBsKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgZGF0YVN0cmF0ZWd5IHx8IG51bGwsXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyA9PT0gdHJ1ZSxcbiAgICAgIG51bGwsXG4gICAgICBmaWx0ZXJNYXRjaGVzVG9Mb2FkIHx8IG51bGwsXG4gICAgICBza2lwUmV2YWxpZGF0aW9uID09PSB0cnVlXG4gICAgKTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4geyBsb2NhdGlvbiwgYmFzZW5hbWUsIC4uLnJlc3VsdCB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5Um91dGUocmVxdWVzdCwge1xuICAgIHJvdXRlSWQsXG4gICAgcmVxdWVzdENvbnRleHQsXG4gICAgZGF0YVN0cmF0ZWd5LFxuICAgIHVuc3RhYmxlX3Jlc3BvbmQ6IHJlc3BvbmRcbiAgfSA9IHt9KSB7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgcmVxdWVzdENvbnRleHQgPSByZXF1ZXN0Q29udGV4dCAhPSBudWxsID8gcmVxdWVzdENvbnRleHQgOiBuZXcgdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyKCk7XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcIkhFQURcIiAmJiBtZXRob2QgIT09IFwiT1BUSU9OU1wiKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwgeyBtZXRob2QgfSk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgIH1cbiAgICBsZXQgbWF0Y2ggPSByb3V0ZUlkID8gbWF0Y2hlcy5maW5kKChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSA6IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcbiAgICBpZiAocm91dGVJZCAmJiAhbWF0Y2gpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAzLCB7XG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbmQgJiYgbWF0Y2hlcy5zb21lKFxuICAgICAgKG0pID0+IG0ucm91dGUudW5zdGFibGVfbWlkZGxld2FyZSB8fCB0eXBlb2YgbS5yb3V0ZS5sYXp5ID09PSBcIm9iamVjdFwiICYmIG0ucm91dGUubGF6eS51bnN0YWJsZV9taWRkbGV3YXJlXG4gICAgKSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICByZXF1ZXN0Q29udGV4dCBpbnN0YW5jZW9mIHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlcixcbiAgICAgICAgXCJXaGVuIHVzaW5nIG1pZGRsZXdhcmUgaW4gYHN0YXRpY0hhbmRsZXIucXVlcnlSb3V0ZSgpYCwgYW55IHByb3ZpZGVkIGByZXF1ZXN0Q29udGV4dGAgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBgdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyYFwiXG4gICAgICApO1xuICAgICAgYXdhaXQgbG9hZExhenlNaWRkbGV3YXJlRm9yTWF0Y2hlcyhtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzMik7XG4gICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBydW5NaWRkbGV3YXJlUGlwZWxpbmUoXG4gICAgICAgIHtcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgcGFyYW1zOiBtYXRjaGVzWzBdLnBhcmFtcyxcbiAgICAgICAgICAvLyBJZiB3ZSdyZSBjYWxsaW5nIG1pZGRsZXdhcmUgdGhlbiBpdCBtdXN0IGJlIGVuYWJsZWQgc28gd2UgY2FuIGNhc3RcbiAgICAgICAgICAvLyB0aGlzIHRvIHRoZSBwcm9wZXIgdHlwZSBrbm93aW5nIGl0J3Mgbm90IGFuIGBBcHBMb2FkQ29udGV4dGBcbiAgICAgICAgICBjb250ZXh0OiByZXF1ZXN0Q29udGV4dFxuICAgICAgICB9LFxuICAgICAgICB0cnVlLFxuICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgbGV0IHJlc3VsdDIgPSBhd2FpdCBxdWVyeUltcGwoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgICAgICBkYXRhU3RyYXRlZ3kgfHwgbnVsbCxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdDIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uZChyZXN1bHQyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGVycm9yMiA9IHJlc3VsdDIuZXJyb3JzID8gT2JqZWN0LnZhbHVlcyhyZXN1bHQyLmVycm9ycylbMF0gOiB2b2lkIDA7XG4gICAgICAgICAgaWYgKGVycm9yMiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB2YWx1ZSA9IHJlc3VsdDIuYWN0aW9uRGF0YSA/IE9iamVjdC52YWx1ZXMocmVzdWx0Mi5hY3Rpb25EYXRhKVswXSA6IE9iamVjdC52YWx1ZXMocmVzdWx0Mi5sb2FkZXJEYXRhKVswXTtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gbmV3IFJlc3BvbnNlKHZhbHVlKSA6IFJlc3BvbnNlLmpzb24odmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyb3IyKSA9PiB7XG4gICAgICAgICAgaWYgKGlzUmVzcG9uc2UoZXJyb3IyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbmQoZXJyb3IyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShTdHJpbmcoZXJyb3IyKSwge1xuICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIGRhdGFTdHJhdGVneSB8fCBudWxsLFxuICAgICAgZmFsc2UsXG4gICAgICBtYXRjaCxcbiAgICAgIG51bGwsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9ycyA/IE9iamVjdC52YWx1ZXMocmVzdWx0LmVycm9ycylbMF0gOiB2b2lkIDA7XG4gICAgaWYgKGVycm9yICE9PSB2b2lkIDApIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmFjdGlvbkRhdGEpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlc3VsdC5hY3Rpb25EYXRhKVswXTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sb2FkZXJEYXRhKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXN1bHQubG9hZGVyRGF0YSlbMF07XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlJbXBsKHJlcXVlc3QsIGxvY2F0aW9uLCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCwgZGF0YVN0cmF0ZWd5LCBza2lwTG9hZGVyRXJyb3JCdWJibGluZywgcm91dGVNYXRjaCwgZmlsdGVyTWF0Y2hlc1RvTG9hZCwgc2tpcFJldmFsaWRhdGlvbikge1xuICAgIGludmFyaWFudChcbiAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgXCJxdWVyeSgpL3F1ZXJ5Um91dGUoKSByZXF1ZXN0cyBtdXN0IGNvbnRhaW4gYW4gQWJvcnRDb250cm9sbGVyIHNpZ25hbFwiXG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgaWYgKGlzTXV0YXRpb25NZXRob2QocmVxdWVzdC5tZXRob2QpKSB7XG4gICAgICAgIGxldCByZXN1bHQyID0gYXdhaXQgc3VibWl0KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICByb3V0ZU1hdGNoIHx8IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKSxcbiAgICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgICBkYXRhU3RyYXRlZ3ksXG4gICAgICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgICAgICAgcm91dGVNYXRjaCAhPSBudWxsLFxuICAgICAgICAgIGZpbHRlck1hdGNoZXNUb0xvYWQsXG4gICAgICAgICAgc2tpcFJldmFsaWRhdGlvblxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgZGF0YVN0cmF0ZWd5LFxuICAgICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICAgICAgcm91dGVNYXRjaCxcbiAgICAgICAgZmlsdGVyTWF0Y2hlc1RvTG9hZFxuICAgICAgKTtcbiAgICAgIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQgOiB7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge31cbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGlzRGF0YVN0cmF0ZWd5UmVzdWx0KGUpICYmIGlzUmVzcG9uc2UoZS5yZXN1bHQpKSB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwiZXJyb3JcIiAvKiBlcnJvciAqLykge1xuICAgICAgICAgIHRocm93IGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlLnJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UoZSkpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdWJtaXQocmVxdWVzdCwgbWF0Y2hlcywgYWN0aW9uTWF0Y2gsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCBpc1JvdXRlUmVxdWVzdCwgZmlsdGVyTWF0Y2hlc1RvTG9hZCwgc2tpcFJldmFsaWRhdGlvbikge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKCFhY3Rpb25NYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIWFjdGlvbk1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBuZXcgVVJMKHJlcXVlc3QudXJsKS5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWRcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgIGVycm9yXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZHNNYXRjaGVzID0gZ2V0VGFyZ2V0ZWREYXRhU3RyYXRlZ3lNYXRjaGVzKFxuICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgYWN0aW9uTWF0Y2gsXG4gICAgICAgIFtdLFxuICAgICAgICByZXF1ZXN0Q29udGV4dFxuICAgICAgKTtcbiAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgZHNNYXRjaGVzLFxuICAgICAgICBpc1JvdXRlUmVxdWVzdCxcbiAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgIGRhdGFTdHJhdGVneVxuICAgICAgKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdHNbYWN0aW9uTWF0Y2gucm91dGUuaWRdO1xuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgdGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yKHJlcXVlc3QsIGlzUm91dGVSZXF1ZXN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgc3RhdHVzOiByZXN1bHQucmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IHJlc3VsdC5yZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlczogW2FjdGlvbk1hdGNoXSxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGEgfSxcbiAgICAgICAgZXJyb3JzOiBudWxsLFxuICAgICAgICAvLyBOb3RlOiBzdGF0dXNDb2RlICsgaGVhZGVycyBhcmUgdW51c2VkIGhlcmUgc2luY2UgcXVlcnlSb3V0ZSB3aWxsXG4gICAgICAgIC8vIHJldHVybiB0aGUgcmF3IFJlc3BvbnNlIG9yIHZhbHVlXG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2tpcFJldmFsaWRhdGlvbikge1xuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nID8gYWN0aW9uTWF0Y2ggOiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IHJlc3VsdC5zdGF0dXNDb2RlICE9IG51bGwgPyByZXN1bHQuc3RhdHVzQ29kZSA6IDUwMCxcbiAgICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICAgIGFjdGlvbkhlYWRlcnM6IHtcbiAgICAgICAgICAgIC4uLnJlc3VsdC5oZWFkZXJzID8geyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuaGVhZGVycyB9IDoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgbG9hZGVySGVhZGVyczoge31cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFjdGlvbkhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzID8geyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuaGVhZGVycyB9IDoge30sXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICBlcnJvcnM6IG51bGwsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1c0NvZGUgfHwgMjAwLFxuICAgICAgICAgIGxvYWRlckhlYWRlcnM6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBsb2FkZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHJlZGlyZWN0OiByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICAgIH0pO1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gc2tpcExvYWRlckVycm9yQnViYmxpbmcgPyBhY3Rpb25NYXRjaCA6IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgYWN0aW9uTWF0Y2gucm91dGUuaWQpO1xuICAgICAgbGV0IGhhbmRsZXJDb250ZXh0MiA9IGF3YWl0IGxvYWRSb3V0ZURhdGEoXG4gICAgICAgIGxvYWRlclJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICBkYXRhU3RyYXRlZ3ksXG4gICAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLFxuICAgICAgICBudWxsLFxuICAgICAgICBmaWx0ZXJNYXRjaGVzVG9Mb2FkLFxuICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZCwgcmVzdWx0XVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmhhbmRsZXJDb250ZXh0MixcbiAgICAgICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKSA/IHJlc3VsdC5lcnJvci5zdGF0dXMgOiByZXN1bHQuc3RhdHVzQ29kZSAhPSBudWxsID8gcmVzdWx0LnN0YXR1c0NvZGUgOiA1MDAsXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5yZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBoYW5kbGVyQ29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEoXG4gICAgICBsb2FkZXJSZXF1ZXN0LFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgZGF0YVN0cmF0ZWd5LFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgICBudWxsLFxuICAgICAgZmlsdGVyTWF0Y2hlc1RvTG9hZFxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmhhbmRsZXJDb250ZXh0LFxuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YVxuICAgICAgfSxcbiAgICAgIC8vIGFjdGlvbiBzdGF0dXMgY29kZXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgbG9hZGVyIHN0YXR1cyBjb2Rlc1xuICAgICAgLi4ucmVzdWx0LnN0YXR1c0NvZGUgPyB7IHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXNDb2RlIH0gOiB7fSxcbiAgICAgIGFjdGlvbkhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzID8geyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuaGVhZGVycyB9IDoge31cbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZURhdGEocmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIGRhdGFTdHJhdGVneSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcsIHJvdXRlTWF0Y2gsIGZpbHRlck1hdGNoZXNUb0xvYWQsIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICBsZXQgaXNSb3V0ZVJlcXVlc3QgPSByb3V0ZU1hdGNoICE9IG51bGw7XG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0ICYmICFyb3V0ZU1hdGNoPy5yb3V0ZS5sb2FkZXIgJiYgIXJvdXRlTWF0Y2g/LnJvdXRlLmxhenkpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7XG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBuZXcgVVJMKHJlcXVlc3QudXJsKS5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZDogcm91dGVNYXRjaD8ucm91dGUuaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgZHNNYXRjaGVzO1xuICAgIGlmIChyb3V0ZU1hdGNoKSB7XG4gICAgICBkc01hdGNoZXMgPSBnZXRUYXJnZXRlZERhdGFTdHJhdGVneU1hdGNoZXMoXG4gICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByb3V0ZU1hdGNoLFxuICAgICAgICBbXSxcbiAgICAgICAgcmVxdWVzdENvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtYXhJZHggPSBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyAoXG4gICAgICAgIC8vIFVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIHRoZSBib3VuZGFyeVxuICAgICAgICBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcGVuZGluZ0FjdGlvblJlc3VsdFswXSkgLSAxXG4gICAgICApIDogdm9pZCAwO1xuICAgICAgZHNNYXRjaGVzID0gbWF0Y2hlcy5tYXAoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAobWF4SWR4ICE9IG51bGwgJiYgaW5kZXggPiBtYXhJZHgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RGF0YVN0cmF0ZWd5TWF0Y2goXG4gICAgICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICBbXSxcbiAgICAgICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXREYXRhU3RyYXRlZ3lNYXRjaChcbiAgICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgW10sXG4gICAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgICAgKG1hdGNoLnJvdXRlLmxvYWRlciB8fCBtYXRjaC5yb3V0ZS5sYXp5KSAhPSBudWxsICYmICghZmlsdGVyTWF0Y2hlc1RvTG9hZCB8fCBmaWx0ZXJNYXRjaGVzVG9Mb2FkKG1hdGNoKSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWRhdGFTdHJhdGVneSAmJiAhZHNNYXRjaGVzLnNvbWUoKG0pID0+IG0uc2hvdWxkTG9hZCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBlcnJvcnM6IHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSA/IHtcbiAgICAgICAgICBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZXJyb3JcbiAgICAgICAgfSA6IG51bGwsXG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge31cbiAgICAgIH07XG4gICAgfVxuICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgIHJlcXVlc3QsXG4gICAgICBkc01hdGNoZXMsXG4gICAgICBpc1JvdXRlUmVxdWVzdCxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgZGF0YVN0cmF0ZWd5XG4gICAgKTtcbiAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgdGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yKHJlcXVlc3QsIGlzUm91dGVSZXF1ZXN0KTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZXJDb250ZXh0ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXN1bHRzLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdCxcbiAgICAgIHRydWUsXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZ1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmhhbmRsZXJDb250ZXh0LFxuICAgICAgbWF0Y2hlc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY2FsbERhdGFTdHJhdGVneShyZXF1ZXN0LCBtYXRjaGVzLCBpc1JvdXRlUmVxdWVzdCwgcmVxdWVzdENvbnRleHQsIGRhdGFTdHJhdGVneSkge1xuICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneUltcGwoXG4gICAgICBkYXRhU3RyYXRlZ3kgfHwgZGVmYXVsdERhdGFTdHJhdGVneSxcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbnVsbCxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgbGV0IGRhdGFSZXN1bHRzID0ge307XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBtYXRjaGVzLm1hcChhc3luYyAobWF0Y2gpID0+IHtcbiAgICAgICAgaWYgKCEobWF0Y2gucm91dGUuaWQgaW4gcmVzdWx0cykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgICBpZiAoaXNSZWRpcmVjdERhdGFTdHJhdGVneVJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICB0aHJvdyBub3JtYWxpemVSZWxhdGl2ZVJvdXRpbmdSZWRpcmVjdFJlc3BvbnNlKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgbWF0Y2gucm91dGUuaWQsXG4gICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgYmFzZW5hbWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpICYmIGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGRhdGFSZXN1bHRzW21hdGNoLnJvdXRlLmlkXSA9IGF3YWl0IGNvbnZlcnREYXRhU3RyYXRlZ3lSZXN1bHRUb0RhdGFSZXN1bHQocmVzdWx0KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4gZGF0YVJlc3VsdHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhUm91dGVzLFxuICAgIHF1ZXJ5LFxuICAgIHF1ZXJ5Um91dGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN0YXRpY0NvbnRleHRGcm9tRXJyb3Iocm91dGVzLCBoYW5kbGVyQ29udGV4dCwgZXJyb3IsIGJvdW5kYXJ5SWQpIHtcbiAgbGV0IGVycm9yQm91bmRhcnlJZCA9IGJvdW5kYXJ5SWQgfHwgaGFuZGxlckNvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgfHwgcm91dGVzWzBdLmlkO1xuICByZXR1cm4ge1xuICAgIC4uLmhhbmRsZXJDb250ZXh0LFxuICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSA/IGVycm9yLnN0YXR1cyA6IDUwMCxcbiAgICBlcnJvcnM6IHtcbiAgICAgIFtlcnJvckJvdW5kYXJ5SWRdOiBlcnJvclxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRocm93U3RhdGljSGFuZGxlckFib3J0ZWRFcnJvcihyZXF1ZXN0LCBpc1JvdXRlUmVxdWVzdCkge1xuICBpZiAocmVxdWVzdC5zaWduYWwucmVhc29uICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyByZXF1ZXN0LnNpZ25hbC5yZWFzb247XG4gIH1cbiAgbGV0IG1ldGhvZCA9IGlzUm91dGVSZXF1ZXN0ID8gXCJxdWVyeVJvdXRlXCIgOiBcInF1ZXJ5XCI7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgJHttZXRob2R9KCkgY2FsbCBhYm9ydGVkIHdpdGhvdXQgYW4gXFxgQWJvcnRTaWduYWwucmVhc29uXFxgOiAke3JlcXVlc3QubWV0aG9kfSAke3JlcXVlc3QudXJsfWBcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzU3VibWlzc2lvbk5hdmlnYXRpb24ob3B0cykge1xuICByZXR1cm4gb3B0cyAhPSBudWxsICYmIChcImZvcm1EYXRhXCIgaW4gb3B0cyAmJiBvcHRzLmZvcm1EYXRhICE9IG51bGwgfHwgXCJib2R5XCIgaW4gb3B0cyAmJiBvcHRzLmJvZHkgIT09IHZvaWQgMCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUbyhsb2NhdGlvbiwgbWF0Y2hlcywgYmFzZW5hbWUsIHRvLCBmcm9tUm91dGVJZCwgcmVsYXRpdmUpIHtcbiAgbGV0IGNvbnRleHR1YWxNYXRjaGVzO1xuICBsZXQgYWN0aXZlUm91dGVNYXRjaDtcbiAgaWYgKGZyb21Sb3V0ZUlkKSB7XG4gICAgY29udGV4dHVhbE1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICBjb250ZXh0dWFsTWF0Y2hlcy5wdXNoKG1hdGNoKTtcbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCA9PT0gZnJvbVJvdXRlSWQpIHtcbiAgICAgICAgYWN0aXZlUm91dGVNYXRjaCA9IG1hdGNoO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dHVhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIH1cbiAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgdG8gPyB0byA6IFwiLlwiLFxuICAgIGdldFJlc29sdmVUb01hdGNoZXMoY29udGV4dHVhbE1hdGNoZXMpLFxuICAgIHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICByZWxhdGl2ZSA9PT0gXCJwYXRoXCJcbiAgKTtcbiAgaWYgKHRvID09IG51bGwpIHtcbiAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICBwYXRoLmhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICB9XG4gIGlmICgodG8gPT0gbnVsbCB8fCB0byA9PT0gXCJcIiB8fCB0byA9PT0gXCIuXCIpICYmIGFjdGl2ZVJvdXRlTWF0Y2gpIHtcbiAgICBsZXQgbmFrZWRJbmRleCA9IGhhc05ha2VkSW5kZXhRdWVyeShwYXRoLnNlYXJjaCk7XG4gICAgaWYgKGFjdGl2ZVJvdXRlTWF0Y2gucm91dGUuaW5kZXggJiYgIW5ha2VkSW5kZXgpIHtcbiAgICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgICB9IGVsc2UgaWYgKCFhY3RpdmVSb3V0ZU1hdGNoLnJvdXRlLmluZGV4ICYmIG5ha2VkSW5kZXgpIHtcbiAgICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGguc2VhcmNoKTtcbiAgICAgIGxldCBpbmRleFZhbHVlcyA9IHBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKTtcbiAgICAgIHBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgICAgIGluZGV4VmFsdWVzLmZpbHRlcigodikgPT4gdikuZm9yRWFjaCgodikgPT4gcGFyYW1zLmFwcGVuZChcImluZGV4XCIsIHYpKTtcbiAgICAgIGxldCBxcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICAgICAgcGF0aC5zZWFyY2ggPSBxcyA/IGA/JHtxc31gIDogXCJcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIHBhdGgucGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKGlzRmV0Y2hlciwgcGF0aCwgb3B0cykge1xuICBpZiAoIW9wdHMgfHwgIWlzU3VibWlzc2lvbk5hdmlnYXRpb24ob3B0cykpIHtcbiAgICByZXR1cm4geyBwYXRoIH07XG4gIH1cbiAgaWYgKG9wdHMuZm9ybU1ldGhvZCAmJiAhaXNWYWxpZE1ldGhvZChvcHRzLmZvcm1NZXRob2QpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kOiBvcHRzLmZvcm1NZXRob2QgfSlcbiAgICB9O1xuICB9XG4gIGxldCBnZXRJbnZhbGlkQm9keUVycm9yID0gKCkgPT4gKHtcbiAgICBwYXRoLFxuICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImludmFsaWQtYm9keVwiIH0pXG4gIH0pO1xuICBsZXQgcmF3Rm9ybU1ldGhvZCA9IG9wdHMuZm9ybU1ldGhvZCB8fCBcImdldFwiO1xuICBsZXQgZm9ybU1ldGhvZCA9IHJhd0Zvcm1NZXRob2QudG9VcHBlckNhc2UoKTtcbiAgbGV0IGZvcm1BY3Rpb24gPSBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKTtcbiAgaWYgKG9wdHMuYm9keSAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKG9wdHMuZm9ybUVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICBpZiAoIWlzTXV0YXRpb25NZXRob2QoZm9ybU1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIGxldCB0ZXh0ID0gdHlwZW9mIG9wdHMuYm9keSA9PT0gXCJzdHJpbmdcIiA/IG9wdHMuYm9keSA6IG9wdHMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhIHx8IG9wdHMuYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IChcbiAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjcGxhaW4tdGV4dC1mb3JtLWRhdGFcbiAgICAgICAgQXJyYXkuZnJvbShvcHRzLmJvZHkuZW50cmllcygpKS5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgW25hbWUsIHZhbHVlXSkgPT4gYCR7YWNjfSR7bmFtZX09JHt2YWx1ZX1cbmAsXG4gICAgICAgICAgXCJcIlxuICAgICAgICApXG4gICAgICApIDogU3RyaW5nKG9wdHMuYm9keSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRzLmZvcm1FbmNUeXBlLFxuICAgICAgICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAgICAgICAganNvbjogdm9pZCAwLFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICBpZiAoIWlzTXV0YXRpb25NZXRob2QoZm9ybU1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBqc29uID0gdHlwZW9mIG9wdHMuYm9keSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2Uob3B0cy5ib2R5KSA6IG9wdHMuYm9keTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIHRleHQ6IHZvaWQgMFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW52YXJpYW50KFxuICAgIHR5cGVvZiBGb3JtRGF0YSA9PT0gXCJmdW5jdGlvblwiLFxuICAgIFwiRm9ybURhdGEgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50XCJcbiAgKTtcbiAgbGV0IHNlYXJjaFBhcmFtcztcbiAgbGV0IGZvcm1EYXRhO1xuICBpZiAob3B0cy5mb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuZm9ybURhdGEpO1xuICAgIGZvcm1EYXRhID0gb3B0cy5mb3JtRGF0YTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmJvZHk7XG4gIH0gZWxzZSBpZiAob3B0cy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gb3B0cy5ib2R5O1xuICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgPT0gbnVsbCkge1xuICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgICBmb3JtRGF0YSA9IGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgbGV0IHN1Ym1pc3Npb24gPSB7XG4gICAgZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBvcHRzICYmIG9wdHMuZm9ybUVuY1R5cGUgfHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgICBmb3JtRGF0YSxcbiAgICBqc29uOiB2b2lkIDAsXG4gICAgdGV4dDogdm9pZCAwXG4gIH07XG4gIGlmIChpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICByZXR1cm4geyBwYXRoLCBzdWJtaXNzaW9uIH07XG4gIH1cbiAgbGV0IHBhcnNlZFBhdGggPSBwYXJzZVBhdGgocGF0aCk7XG4gIGlmIChpc0ZldGNoZXIgJiYgcGFyc2VkUGF0aC5zZWFyY2ggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHBhcnNlZFBhdGguc2VhcmNoKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCBcIlwiKTtcbiAgfVxuICBwYXJzZWRQYXRoLnNlYXJjaCA9IGA/JHtzZWFyY2hQYXJhbXN9YDtcbiAgcmV0dXJuIHsgcGF0aDogY3JlYXRlUGF0aChwYXJzZWRQYXRoKSwgc3VibWlzc2lvbiB9O1xufVxuZnVuY3Rpb24gZ2V0TWF0Y2hlc1RvTG9hZChyZXF1ZXN0LCBzY29wZWRDb250ZXh0LCBtYXBSb3V0ZVByb3BlcnRpZXMyLCBtYW5pZmVzdCwgaGlzdG9yeSwgc3RhdGUsIG1hdGNoZXMsIHN1Ym1pc3Npb24sIGxvY2F0aW9uLCBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLCBpbml0aWFsSHlkcmF0aW9uLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24sIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwgaGFzUGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24sIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgbGV0IGFjdGlvblJlc3VsdCA9IHBlbmRpbmdBY3Rpb25SZXN1bHQgPyBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8gcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5lcnJvciA6IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZGF0YSA6IHZvaWQgMDtcbiAgbGV0IGN1cnJlbnRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdGF0ZS5sb2NhdGlvbik7XG4gIGxldCBuZXh0VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuICBsZXQgbWF4SWR4O1xuICBpZiAoaW5pdGlhbEh5ZHJhdGlvbiAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IE9iamVjdC5rZXlzKHN0YXRlLmVycm9ycylbMF07XG4gICAgbWF4SWR4ID0gbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IGJvdW5kYXJ5SWQpO1xuICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSkge1xuICAgIGxldCBib3VuZGFyeUlkID0gcGVuZGluZ0FjdGlvblJlc3VsdFswXTtcbiAgICBtYXhJZHggPSBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gYm91bmRhcnlJZCkgLSAxO1xuICB9XG4gIGxldCBhY3Rpb25TdGF0dXMgPSBwZW5kaW5nQWN0aW9uUmVzdWx0ID8gcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5zdGF0dXNDb2RlIDogdm9pZCAwO1xuICBsZXQgc2hvdWxkU2tpcFJldmFsaWRhdGlvbiA9IGFjdGlvblN0YXR1cyAmJiBhY3Rpb25TdGF0dXMgPj0gNDAwO1xuICBsZXQgYmFzZVNob3VsZFJldmFsaWRhdGVBcmdzID0ge1xuICAgIGN1cnJlbnRVcmwsXG4gICAgY3VycmVudFBhcmFtczogc3RhdGUubWF0Y2hlc1swXT8ucGFyYW1zIHx8IHt9LFxuICAgIG5leHRVcmwsXG4gICAgbmV4dFBhcmFtczogbWF0Y2hlc1swXS5wYXJhbXMsXG4gICAgLi4uc3VibWlzc2lvbixcbiAgICBhY3Rpb25SZXN1bHQsXG4gICAgYWN0aW9uU3RhdHVzXG4gIH07XG4gIGxldCBkc01hdGNoZXMgPSBtYXRjaGVzLm1hcCgobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgbGV0IHsgcm91dGUgfSA9IG1hdGNoO1xuICAgIGxldCBmb3JjZVNob3VsZExvYWQgPSBudWxsO1xuICAgIGlmIChtYXhJZHggIT0gbnVsbCAmJiBpbmRleCA+IG1heElkeCkge1xuICAgICAgZm9yY2VTaG91bGRMb2FkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChyb3V0ZS5sYXp5KSB7XG4gICAgICBmb3JjZVNob3VsZExvYWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAocm91dGUubG9hZGVyID09IG51bGwpIHtcbiAgICAgIGZvcmNlU2hvdWxkTG9hZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaW5pdGlhbEh5ZHJhdGlvbikge1xuICAgICAgZm9yY2VTaG91bGRMb2FkID0gc2hvdWxkTG9hZFJvdXRlT25IeWRyYXRpb24oXG4gICAgICAgIHJvdXRlLFxuICAgICAgICBzdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgICBzdGF0ZS5lcnJvcnNcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc05ld0xvYWRlcihzdGF0ZS5sb2FkZXJEYXRhLCBzdGF0ZS5tYXRjaGVzW2luZGV4XSwgbWF0Y2gpKSB7XG4gICAgICBmb3JjZVNob3VsZExvYWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZm9yY2VTaG91bGRMb2FkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZ2V0RGF0YVN0cmF0ZWd5TWF0Y2goXG4gICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCxcbiAgICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgICAgZm9yY2VTaG91bGRMb2FkXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgZGVmYXVsdFNob3VsZFJldmFsaWRhdGUgPSBzaG91bGRTa2lwUmV2YWxpZGF0aW9uID8gZmFsc2UgOiAoXG4gICAgICAvLyBGb3JjZWQgcmV2YWxpZGF0aW9uIGR1ZSB0byBzdWJtaXNzaW9uLCB1c2VSZXZhbGlkYXRvciwgb3IgWC1SZW1peC1SZXZhbGlkYXRlXG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkIHx8IGN1cnJlbnRVcmwucGF0aG5hbWUgKyBjdXJyZW50VXJsLnNlYXJjaCA9PT0gbmV4dFVybC5wYXRobmFtZSArIG5leHRVcmwuc2VhcmNoIHx8IC8vIFNlYXJjaCBwYXJhbXMgYWZmZWN0IGFsbCBsb2FkZXJzXG4gICAgICBjdXJyZW50VXJsLnNlYXJjaCAhPT0gbmV4dFVybC5zZWFyY2ggfHwgaXNOZXdSb3V0ZUluc3RhbmNlKHN0YXRlLm1hdGNoZXNbaW5kZXhdLCBtYXRjaClcbiAgICApO1xuICAgIGxldCBzaG91bGRSZXZhbGlkYXRlQXJncyA9IHtcbiAgICAgIC4uLmJhc2VTaG91bGRSZXZhbGlkYXRlQXJncyxcbiAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlXG4gICAgfTtcbiAgICBsZXQgc2hvdWxkTG9hZCA9IHNob3VsZFJldmFsaWRhdGVMb2FkZXIobWF0Y2gsIHNob3VsZFJldmFsaWRhdGVBcmdzKTtcbiAgICByZXR1cm4gZ2V0RGF0YVN0cmF0ZWd5TWF0Y2goXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICByZXF1ZXN0LFxuICAgICAgbWF0Y2gsXG4gICAgICBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLFxuICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgIHNob3VsZExvYWQsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlQXJnc1xuICAgICk7XG4gIH0pO1xuICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlcnMgPSBbXTtcbiAgZmV0Y2hMb2FkTWF0Y2hlcy5mb3JFYWNoKChmLCBrZXkpID0+IHtcbiAgICBpZiAoaW5pdGlhbEh5ZHJhdGlvbiB8fCAhbWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmlkID09PSBmLnJvdXRlSWQpIHx8IGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uaGFzKGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgaXNNaWRJbml0aWFsTG9hZCA9IGZldGNoZXIgJiYgZmV0Y2hlci5zdGF0ZSAhPT0gXCJpZGxlXCIgJiYgZmV0Y2hlci5kYXRhID09PSB2b2lkIDA7XG4gICAgbGV0IGZldGNoZXJNYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGYucGF0aCwgYmFzZW5hbWUpO1xuICAgIGlmICghZmV0Y2hlck1hdGNoZXMpIHtcbiAgICAgIGlmIChoYXNQYXRjaFJvdXRlc09uTmF2aWdhdGlvbiAmJiBpc01pZEluaXRpYWxMb2FkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQ6IGYucm91dGVJZCxcbiAgICAgICAgcGF0aDogZi5wYXRoLFxuICAgICAgICBtYXRjaGVzOiBudWxsLFxuICAgICAgICBtYXRjaDogbnVsbCxcbiAgICAgICAgcmVxdWVzdDogbnVsbCxcbiAgICAgICAgY29udHJvbGxlcjogbnVsbFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmZXRjaFJlZGlyZWN0SWRzLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBmZXRjaGVyTWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChmZXRjaGVyTWF0Y2hlcywgZi5wYXRoKTtcbiAgICBsZXQgZmV0Y2hDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGhpc3RvcnksXG4gICAgICBmLnBhdGgsXG4gICAgICBmZXRjaENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBsZXQgZmV0Y2hlckRzTWF0Y2hlcyA9IG51bGw7XG4gICAgaWYgKGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5oYXMoa2V5KSkge1xuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLmRlbGV0ZShrZXkpO1xuICAgICAgZmV0Y2hlckRzTWF0Y2hlcyA9IGdldFRhcmdldGVkRGF0YVN0cmF0ZWd5TWF0Y2hlcyhcbiAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgICAgZmV0Y2hlck1hdGNoZXMsXG4gICAgICAgIGZldGNoZXJNYXRjaCxcbiAgICAgICAgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCxcbiAgICAgICAgc2NvcGVkQ29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzTWlkSW5pdGlhbExvYWQpIHtcbiAgICAgIGlmIChpc1JldmFsaWRhdGlvblJlcXVpcmVkKSB7XG4gICAgICAgIGZldGNoZXJEc01hdGNoZXMgPSBnZXRUYXJnZXRlZERhdGFTdHJhdGVneU1hdGNoZXMoXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICAgICAgZmV0Y2hlck1hdGNoZXMsXG4gICAgICAgICAgZmV0Y2hlck1hdGNoLFxuICAgICAgICAgIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAsXG4gICAgICAgICAgc2NvcGVkQ29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc2hvdWxkUmV2YWxpZGF0ZUFyZ3MgPSB7XG4gICAgICAgIC4uLmJhc2VTaG91bGRSZXZhbGlkYXRlQXJncyxcbiAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IHNob3VsZFNraXBSZXZhbGlkYXRpb24gPyBmYWxzZSA6IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWRcbiAgICAgIH07XG4gICAgICBpZiAoc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihmZXRjaGVyTWF0Y2gsIHNob3VsZFJldmFsaWRhdGVBcmdzKSkge1xuICAgICAgICBmZXRjaGVyRHNNYXRjaGVzID0gZ2V0VGFyZ2V0ZWREYXRhU3RyYXRlZ3lNYXRjaGVzKFxuICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgICAgIGZldGNoZXJNYXRjaGVzLFxuICAgICAgICAgIGZldGNoZXJNYXRjaCxcbiAgICAgICAgICBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLFxuICAgICAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICAgICAgc2hvdWxkUmV2YWxpZGF0ZUFyZ3NcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZldGNoZXJEc01hdGNoZXMpIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQ6IGYucm91dGVJZCxcbiAgICAgICAgcGF0aDogZi5wYXRoLFxuICAgICAgICBtYXRjaGVzOiBmZXRjaGVyRHNNYXRjaGVzLFxuICAgICAgICBtYXRjaDogZmV0Y2hlck1hdGNoLFxuICAgICAgICByZXF1ZXN0OiBmZXRjaFJlcXVlc3QsXG4gICAgICAgIGNvbnRyb2xsZXI6IGZldGNoQ29udHJvbGxlclxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHsgZHNNYXRjaGVzLCByZXZhbGlkYXRpbmdGZXRjaGVycyB9O1xufVxuZnVuY3Rpb24gc2hvdWxkTG9hZFJvdXRlT25IeWRyYXRpb24ocm91dGUsIGxvYWRlckRhdGEsIGVycm9ycykge1xuICBpZiAocm91dGUubGF6eSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghcm91dGUubG9hZGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBoYXNEYXRhID0gbG9hZGVyRGF0YSAhPSBudWxsICYmIHJvdXRlLmlkIGluIGxvYWRlckRhdGE7XG4gIGxldCBoYXNFcnJvciA9IGVycm9ycyAhPSBudWxsICYmIGVycm9yc1tyb3V0ZS5pZF0gIT09IHZvaWQgMDtcbiAgaWYgKCFoYXNEYXRhICYmIGhhc0Vycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2Ygcm91dGUubG9hZGVyID09PSBcImZ1bmN0aW9uXCIgJiYgcm91dGUubG9hZGVyLmh5ZHJhdGUgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gIWhhc0RhdGEgJiYgIWhhc0Vycm9yO1xufVxuZnVuY3Rpb24gaXNOZXdMb2FkZXIoY3VycmVudExvYWRlckRhdGEsIGN1cnJlbnRNYXRjaCwgbWF0Y2gpIHtcbiAgbGV0IGlzTmV3ID0gKFxuICAgIC8vIFthXSAtPiBbYSwgYl1cbiAgICAhY3VycmVudE1hdGNoIHx8IC8vIFthLCBiXSAtPiBbYSwgY11cbiAgICBtYXRjaC5yb3V0ZS5pZCAhPT0gY3VycmVudE1hdGNoLnJvdXRlLmlkXG4gICk7XG4gIGxldCBpc01pc3NpbmdEYXRhID0gIWN1cnJlbnRMb2FkZXJEYXRhLmhhc093blByb3BlcnR5KG1hdGNoLnJvdXRlLmlkKTtcbiAgcmV0dXJuIGlzTmV3IHx8IGlzTWlzc2luZ0RhdGE7XG59XG5mdW5jdGlvbiBpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudE1hdGNoLCBtYXRjaCkge1xuICBsZXQgY3VycmVudFBhdGggPSBjdXJyZW50TWF0Y2gucm91dGUucGF0aDtcbiAgcmV0dXJuIChcbiAgICAvLyBwYXJhbSBjaGFuZ2UgZm9yIHRoaXMgbWF0Y2gsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxuICAgIGN1cnJlbnRNYXRjaC5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHwgLy8gc3BsYXQgcGFyYW0gY2hhbmdlZCwgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gbWF0Y2gucGF0aFxuICAgIC8vIGUuZy4gL2ZpbGVzL2ltYWdlcy9hdmF0YXIuanBnIC0+IGZpbGVzL2ZpbmFuY2VzLnhsc1xuICAgIGN1cnJlbnRQYXRoICE9IG51bGwgJiYgY3VycmVudFBhdGguZW5kc1dpdGgoXCIqXCIpICYmIGN1cnJlbnRNYXRjaC5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdXG4gICk7XG59XG5mdW5jdGlvbiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKGxvYWRlck1hdGNoLCBhcmcpIHtcbiAgaWYgKGxvYWRlck1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICBsZXQgcm91dGVDaG9pY2UgPSBsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKGFyZyk7XG4gICAgaWYgKHR5cGVvZiByb3V0ZUNob2ljZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiByb3V0ZUNob2ljZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyZy5kZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTtcbn1cbmZ1bmN0aW9uIHBhdGNoUm91dGVzSW1wbChyb3V0ZUlkLCBjaGlsZHJlbiwgcm91dGVzVG9Vc2UsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMyKSB7XG4gIGxldCBjaGlsZHJlblRvUGF0Y2g7XG4gIGlmIChyb3V0ZUlkKSB7XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3Rbcm91dGVJZF07XG4gICAgaW52YXJpYW50KFxuICAgICAgcm91dGUsXG4gICAgICBgTm8gcm91dGUgZm91bmQgdG8gcGF0Y2ggY2hpbGRyZW4gaW50bzogcm91dGVJZCA9ICR7cm91dGVJZH1gXG4gICAgKTtcbiAgICBpZiAoIXJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICByb3V0ZS5jaGlsZHJlbiA9IFtdO1xuICAgIH1cbiAgICBjaGlsZHJlblRvUGF0Y2ggPSByb3V0ZS5jaGlsZHJlbjtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZHJlblRvUGF0Y2ggPSByb3V0ZXNUb1VzZTtcbiAgfVxuICBsZXQgdW5pcXVlQ2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoXG4gICAgKG5ld1JvdXRlKSA9PiAhY2hpbGRyZW5Ub1BhdGNoLnNvbWUoXG4gICAgICAoZXhpc3RpbmdSb3V0ZSkgPT4gaXNTYW1lUm91dGUobmV3Um91dGUsIGV4aXN0aW5nUm91dGUpXG4gICAgKVxuICApO1xuICBsZXQgbmV3Um91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICB1bmlxdWVDaGlsZHJlbixcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgIFtyb3V0ZUlkIHx8IFwiX1wiLCBcInBhdGNoXCIsIFN0cmluZyhjaGlsZHJlblRvUGF0Y2g/Lmxlbmd0aCB8fCBcIjBcIildLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGNoaWxkcmVuVG9QYXRjaC5wdXNoKC4uLm5ld1JvdXRlcyk7XG59XG5mdW5jdGlvbiBpc1NhbWVSb3V0ZShuZXdSb3V0ZSwgZXhpc3RpbmdSb3V0ZSkge1xuICBpZiAoXCJpZFwiIGluIG5ld1JvdXRlICYmIFwiaWRcIiBpbiBleGlzdGluZ1JvdXRlICYmIG5ld1JvdXRlLmlkID09PSBleGlzdGluZ1JvdXRlLmlkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCEobmV3Um91dGUuaW5kZXggPT09IGV4aXN0aW5nUm91dGUuaW5kZXggJiYgbmV3Um91dGUucGF0aCA9PT0gZXhpc3RpbmdSb3V0ZS5wYXRoICYmIG5ld1JvdXRlLmNhc2VTZW5zaXRpdmUgPT09IGV4aXN0aW5nUm91dGUuY2FzZVNlbnNpdGl2ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCghbmV3Um91dGUuY2hpbGRyZW4gfHwgbmV3Um91dGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSAmJiAoIWV4aXN0aW5nUm91dGUuY2hpbGRyZW4gfHwgZXhpc3RpbmdSb3V0ZS5jaGlsZHJlbi5sZW5ndGggPT09IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG5ld1JvdXRlLmNoaWxkcmVuLmV2ZXJ5KFxuICAgIChhQ2hpbGQsIGkpID0+IGV4aXN0aW5nUm91dGUuY2hpbGRyZW4/LnNvbWUoKGJDaGlsZCkgPT4gaXNTYW1lUm91dGUoYUNoaWxkLCBiQ2hpbGQpKVxuICApO1xufVxudmFyIGxhenlSb3V0ZVByb3BlcnR5Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBsb2FkTGF6eVJvdXRlUHJvcGVydHkgPSAoe1xuICBrZXksXG4gIHJvdXRlLFxuICBtYW5pZmVzdCxcbiAgbWFwUm91dGVQcm9wZXJ0aWVzOiBtYXBSb3V0ZVByb3BlcnRpZXMyXG59KSA9PiB7XG4gIGxldCByb3V0ZVRvVXBkYXRlID0gbWFuaWZlc3Rbcm91dGUuaWRdO1xuICBpbnZhcmlhbnQocm91dGVUb1VwZGF0ZSwgXCJObyByb3V0ZSBmb3VuZCBpbiBtYW5pZmVzdFwiKTtcbiAgaWYgKCFyb3V0ZVRvVXBkYXRlLmxhenkgfHwgdHlwZW9mIHJvdXRlVG9VcGRhdGUubGF6eSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbGF6eUZuID0gcm91dGVUb1VwZGF0ZS5sYXp5W2tleV07XG4gIGlmICghbGF6eUZuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBjYWNoZSA9IGxhenlSb3V0ZVByb3BlcnR5Q2FjaGUuZ2V0KHJvdXRlVG9VcGRhdGUpO1xuICBpZiAoIWNhY2hlKSB7XG4gICAgY2FjaGUgPSB7fTtcbiAgICBsYXp5Um91dGVQcm9wZXJ0eUNhY2hlLnNldChyb3V0ZVRvVXBkYXRlLCBjYWNoZSk7XG4gIH1cbiAgbGV0IGNhY2hlZFByb21pc2UgPSBjYWNoZVtrZXldO1xuICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICB9XG4gIGxldCBwcm9wZXJ0eVByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgIGxldCBpc1Vuc3VwcG9ydGVkID0gaXNVbnN1cHBvcnRlZExhenlSb3V0ZU9iamVjdEtleShrZXkpO1xuICAgIGxldCBzdGF0aWNSb3V0ZVZhbHVlID0gcm91dGVUb1VwZGF0ZVtrZXldO1xuICAgIGxldCBpc1N0YXRpY2FsbHlEZWZpbmVkID0gc3RhdGljUm91dGVWYWx1ZSAhPT0gdm9pZCAwICYmIGtleSAhPT0gXCJoYXNFcnJvckJvdW5kYXJ5XCI7XG4gICAgaWYgKGlzVW5zdXBwb3J0ZWQpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICFpc1Vuc3VwcG9ydGVkLFxuICAgICAgICBcIlJvdXRlIHByb3BlcnR5IFwiICsga2V5ICsgXCIgaXMgbm90IGEgc3VwcG9ydGVkIGxhenkgcm91dGUgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICApO1xuICAgICAgY2FjaGVba2V5XSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0gZWxzZSBpZiAoaXNTdGF0aWNhbGx5RGVmaW5lZCkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGBSb3V0ZSBcIiR7cm91dGVUb1VwZGF0ZS5pZH1cIiBoYXMgYSBzdGF0aWMgcHJvcGVydHkgXCIke2tleX1cIiBkZWZpbmVkLiBUaGUgbGF6eSBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuYFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHZhbHVlID0gYXdhaXQgbGF6eUZuKCk7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIHsgW2tleV06IHZhbHVlIH0pO1xuICAgICAgICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIG1hcFJvdXRlUHJvcGVydGllczIocm91dGVUb1VwZGF0ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHJvdXRlVG9VcGRhdGUubGF6eSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcm91dGVUb1VwZGF0ZS5sYXp5W2tleV0gPSB2b2lkIDA7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhyb3V0ZVRvVXBkYXRlLmxhenkpLmV2ZXJ5KCh2YWx1ZSkgPT4gdmFsdWUgPT09IHZvaWQgMCkpIHtcbiAgICAgICAgcm91dGVUb1VwZGF0ZS5sYXp5ID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfSkoKTtcbiAgY2FjaGVba2V5XSA9IHByb3BlcnR5UHJvbWlzZTtcbiAgcmV0dXJuIHByb3BlcnR5UHJvbWlzZTtcbn07XG52YXIgbGF6eVJvdXRlRnVuY3Rpb25DYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbG9hZExhenlSb3V0ZShyb3V0ZSwgdHlwZSwgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllczIsIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXApIHtcbiAgbGV0IHJvdXRlVG9VcGRhdGUgPSBtYW5pZmVzdFtyb3V0ZS5pZF07XG4gIGludmFyaWFudChyb3V0ZVRvVXBkYXRlLCBcIk5vIHJvdXRlIGZvdW5kIGluIG1hbmlmZXN0XCIpO1xuICBpZiAoIXJvdXRlLmxhenkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGF6eVJvdXRlUHJvbWlzZTogdm9pZCAwLFxuICAgICAgbGF6eUhhbmRsZXJQcm9taXNlOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2Ygcm91dGUubGF6eSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgbGV0IGNhY2hlZFByb21pc2UgPSBsYXp5Um91dGVGdW5jdGlvbkNhY2hlLmdldChyb3V0ZVRvVXBkYXRlKTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGF6eVJvdXRlUHJvbWlzZTogY2FjaGVkUHJvbWlzZSxcbiAgICAgICAgbGF6eUhhbmRsZXJQcm9taXNlOiBjYWNoZWRQcm9taXNlXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgbGF6eVJvdXRlUHJvbWlzZTIgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICB0eXBlb2Ygcm91dGUubGF6eSA9PT0gXCJmdW5jdGlvblwiLFxuICAgICAgICBcIk5vIGxhenkgcm91dGUgZnVuY3Rpb24gZm91bmRcIlxuICAgICAgKTtcbiAgICAgIGxldCBsYXp5Um91dGUgPSBhd2FpdCByb3V0ZS5sYXp5KCk7XG4gICAgICBsZXQgcm91dGVVcGRhdGVzID0ge307XG4gICAgICBmb3IgKGxldCBsYXp5Um91dGVQcm9wZXJ0eSBpbiBsYXp5Um91dGUpIHtcbiAgICAgICAgbGV0IGxhenlWYWx1ZSA9IGxhenlSb3V0ZVtsYXp5Um91dGVQcm9wZXJ0eV07XG4gICAgICAgIGlmIChsYXp5VmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpc1Vuc3VwcG9ydGVkID0gaXNVbnN1cHBvcnRlZExhenlSb3V0ZUZ1bmN0aW9uS2V5KGxhenlSb3V0ZVByb3BlcnR5KTtcbiAgICAgICAgbGV0IHN0YXRpY1JvdXRlVmFsdWUgPSByb3V0ZVRvVXBkYXRlW2xhenlSb3V0ZVByb3BlcnR5XTtcbiAgICAgICAgbGV0IGlzU3RhdGljYWxseURlZmluZWQgPSBzdGF0aWNSb3V0ZVZhbHVlICE9PSB2b2lkIDAgJiYgLy8gVGhpcyBwcm9wZXJ0eSBpc24ndCBzdGF0aWMgc2luY2UgaXQgc2hvdWxkIGFsd2F5cyBiZSB1cGRhdGVkIGJhc2VkXG4gICAgICAgIC8vIG9uIHRoZSByb3V0ZSB1cGRhdGVzXG4gICAgICAgIGxhenlSb3V0ZVByb3BlcnR5ICE9PSBcImhhc0Vycm9yQm91bmRhcnlcIjtcbiAgICAgICAgaWYgKGlzVW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgIWlzVW5zdXBwb3J0ZWQsXG4gICAgICAgICAgICBcIlJvdXRlIHByb3BlcnR5IFwiICsgbGF6eVJvdXRlUHJvcGVydHkgKyBcIiBpcyBub3QgYSBzdXBwb3J0ZWQgcHJvcGVydHkgdG8gYmUgcmV0dXJuZWQgZnJvbSBhIGxhenkgcm91dGUgZnVuY3Rpb24uIFRoaXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0YXRpY2FsbHlEZWZpbmVkKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICFpc1N0YXRpY2FsbHlEZWZpbmVkLFxuICAgICAgICAgICAgYFJvdXRlIFwiJHtyb3V0ZVRvVXBkYXRlLmlkfVwiIGhhcyBhIHN0YXRpYyBwcm9wZXJ0eSBcIiR7bGF6eVJvdXRlUHJvcGVydHl9XCIgZGVmaW5lZCBidXQgaXRzIGxhenkgZnVuY3Rpb24gaXMgYWxzbyByZXR1cm5pbmcgYSB2YWx1ZSBmb3IgdGhpcyBwcm9wZXJ0eS4gVGhlIGxhenkgcm91dGUgcHJvcGVydHkgXCIke2xhenlSb3V0ZVByb3BlcnR5fVwiIHdpbGwgYmUgaWdub3JlZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZVVwZGF0ZXNbbGF6eVJvdXRlUHJvcGVydHldID0gbGF6eVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIHJvdXRlVXBkYXRlcyk7XG4gICAgICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIHtcbiAgICAgICAgLy8gVG8ga2VlcCB0aGluZ3MgZnJhbWV3b3JrIGFnbm9zdGljLCB3ZSB1c2UgdGhlIHByb3ZpZGVkIGBtYXBSb3V0ZVByb3BlcnRpZXNgXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRvIHNldCB0aGUgZnJhbWV3b3JrLWF3YXJlIHByb3BlcnRpZXMgKGBlbGVtZW50YC9gaGFzRXJyb3JCb3VuZGFyeWApXG4gICAgICAgIC8vIHNpbmNlIHRoZSBsb2dpYyB3aWxsIGRpZmZlciBiZXR3ZWVuIGZyYW1ld29ya3MuXG4gICAgICAgIC4uLm1hcFJvdXRlUHJvcGVydGllczIocm91dGVUb1VwZGF0ZSksXG4gICAgICAgIGxhenk6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgICBsYXp5Um91dGVGdW5jdGlvbkNhY2hlLnNldChyb3V0ZVRvVXBkYXRlLCBsYXp5Um91dGVQcm9taXNlMik7XG4gICAgbGF6eVJvdXRlUHJvbWlzZTIuY2F0Y2goKCkgPT4ge1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBsYXp5Um91dGVQcm9taXNlOiBsYXp5Um91dGVQcm9taXNlMixcbiAgICAgIGxhenlIYW5kbGVyUHJvbWlzZTogbGF6eVJvdXRlUHJvbWlzZTJcbiAgICB9O1xuICB9XG4gIGxldCBsYXp5S2V5cyA9IE9iamVjdC5rZXlzKHJvdXRlLmxhenkpO1xuICBsZXQgbGF6eVByb3BlcnR5UHJvbWlzZXMgPSBbXTtcbiAgbGV0IGxhenlIYW5kbGVyUHJvbWlzZSA9IHZvaWQgMDtcbiAgZm9yIChsZXQga2V5IG9mIGxhenlLZXlzKSB7XG4gICAgaWYgKGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAgJiYgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IHByb21pc2UgPSBsb2FkTGF6eVJvdXRlUHJvcGVydHkoe1xuICAgICAga2V5LFxuICAgICAgcm91dGUsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczogbWFwUm91dGVQcm9wZXJ0aWVzMlxuICAgIH0pO1xuICAgIGlmIChwcm9taXNlKSB7XG4gICAgICBsYXp5UHJvcGVydHlQcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgaWYgKGtleSA9PT0gdHlwZSkge1xuICAgICAgICBsYXp5SGFuZGxlclByb21pc2UgPSBwcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgbGF6eVJvdXRlUHJvbWlzZSA9IGxhenlQcm9wZXJ0eVByb21pc2VzLmxlbmd0aCA+IDAgPyBQcm9taXNlLmFsbChsYXp5UHJvcGVydHlQcm9taXNlcykudGhlbigoKSA9PiB7XG4gIH0pIDogdm9pZCAwO1xuICBsYXp5Um91dGVQcm9taXNlPy5jYXRjaCgoKSA9PiB7XG4gIH0pO1xuICBsYXp5SGFuZGxlclByb21pc2U/LmNhdGNoKCgpID0+IHtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbGF6eVJvdXRlUHJvbWlzZSxcbiAgICBsYXp5SGFuZGxlclByb21pc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzTm9uTnVsbGFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBsb2FkTGF6eU1pZGRsZXdhcmVGb3JNYXRjaGVzKG1hdGNoZXMsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMyKSB7XG4gIGxldCBwcm9taXNlcyA9IG1hdGNoZXMubWFwKCh7IHJvdXRlIH0pID0+IHtcbiAgICBpZiAodHlwZW9mIHJvdXRlLmxhenkgIT09IFwib2JqZWN0XCIgfHwgIXJvdXRlLmxhenkudW5zdGFibGVfbWlkZGxld2FyZSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGxvYWRMYXp5Um91dGVQcm9wZXJ0eSh7XG4gICAgICBrZXk6IFwidW5zdGFibGVfbWlkZGxld2FyZVwiLFxuICAgICAgcm91dGUsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczogbWFwUm91dGVQcm9wZXJ0aWVzMlxuICAgIH0pO1xuICB9KS5maWx0ZXIoaXNOb25OdWxsYWJsZSk7XG4gIHJldHVybiBwcm9taXNlcy5sZW5ndGggPiAwID8gUHJvbWlzZS5hbGwocHJvbWlzZXMpIDogdm9pZCAwO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVmYXVsdERhdGFTdHJhdGVneShhcmdzKSB7XG4gIGxldCBtYXRjaGVzVG9Mb2FkID0gYXJncy5tYXRjaGVzLmZpbHRlcigobSkgPT4gbS5zaG91bGRMb2FkKTtcbiAgbGV0IGtleWVkUmVzdWx0cyA9IHt9O1xuICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKG1hdGNoZXNUb0xvYWQubWFwKChtKSA9PiBtLnJlc29sdmUoKSkpO1xuICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCwgaSkgPT4ge1xuICAgIGtleWVkUmVzdWx0c1ttYXRjaGVzVG9Mb2FkW2ldLnJvdXRlLmlkXSA9IHJlc3VsdDtcbiAgfSk7XG4gIHJldHVybiBrZXllZFJlc3VsdHM7XG59XG5hc3luYyBmdW5jdGlvbiBkZWZhdWx0RGF0YVN0cmF0ZWd5V2l0aE1pZGRsZXdhcmUoYXJncykge1xuICBpZiAoIWFyZ3MubWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLnVuc3RhYmxlX21pZGRsZXdhcmUpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHREYXRhU3RyYXRlZ3koYXJncyk7XG4gIH1cbiAgcmV0dXJuIHJ1bk1pZGRsZXdhcmVQaXBlbGluZShcbiAgICBhcmdzLFxuICAgIGZhbHNlLFxuICAgICgpID0+IGRlZmF1bHREYXRhU3RyYXRlZ3koYXJncyksXG4gICAgKGVycm9yLCByb3V0ZUlkKSA9PiAoeyBbcm91dGVJZF06IHsgdHlwZTogXCJlcnJvclwiLCByZXN1bHQ6IGVycm9yIH0gfSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJ1bk1pZGRsZXdhcmVQaXBlbGluZShhcmdzLCBwcm9wYWdhdGVSZXN1bHQsIGhhbmRsZXIsIGVycm9ySGFuZGxlcikge1xuICBsZXQgeyBtYXRjaGVzLCByZXF1ZXN0LCBwYXJhbXMsIGNvbnRleHQgfSA9IGFyZ3M7XG4gIGxldCBtaWRkbGV3YXJlU3RhdGUgPSB7XG4gICAgaGFuZGxlclJlc3VsdDogdm9pZCAwXG4gIH07XG4gIHRyeSB7XG4gICAgbGV0IHR1cGxlcyA9IG1hdGNoZXMuZmxhdE1hcChcbiAgICAgIChtKSA9PiBtLnJvdXRlLnVuc3RhYmxlX21pZGRsZXdhcmUgPyBtLnJvdXRlLnVuc3RhYmxlX21pZGRsZXdhcmUubWFwKChmbikgPT4gW20ucm91dGUuaWQsIGZuXSkgOiBbXVxuICAgICk7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNhbGxSb3V0ZU1pZGRsZXdhcmUoXG4gICAgICB7IHJlcXVlc3QsIHBhcmFtcywgY29udGV4dCB9LFxuICAgICAgdHVwbGVzLFxuICAgICAgcHJvcGFnYXRlUmVzdWx0LFxuICAgICAgbWlkZGxld2FyZVN0YXRlLFxuICAgICAgaGFuZGxlclxuICAgICk7XG4gICAgcmV0dXJuIHByb3BhZ2F0ZVJlc3VsdCA/IHJlc3VsdCA6IG1pZGRsZXdhcmVTdGF0ZS5oYW5kbGVyUmVzdWx0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKCFtaWRkbGV3YXJlU3RhdGUubWlkZGxld2FyZUVycm9yKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgZXJyb3JIYW5kbGVyKFxuICAgICAgbWlkZGxld2FyZVN0YXRlLm1pZGRsZXdhcmVFcnJvci5lcnJvcixcbiAgICAgIG1pZGRsZXdhcmVTdGF0ZS5taWRkbGV3YXJlRXJyb3Iucm91dGVJZFxuICAgICk7XG4gICAgaWYgKHByb3BhZ2F0ZVJlc3VsdCB8fCAhbWlkZGxld2FyZVN0YXRlLmhhbmRsZXJSZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG1pZGRsZXdhcmVTdGF0ZS5oYW5kbGVyUmVzdWx0LCByZXN1bHQpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBjYWxsUm91dGVNaWRkbGV3YXJlKGFyZ3MsIG1pZGRsZXdhcmVzLCBwcm9wYWdhdGVSZXN1bHQsIG1pZGRsZXdhcmVTdGF0ZSwgaGFuZGxlciwgaWR4ID0gMCkge1xuICBsZXQgeyByZXF1ZXN0IH0gPSBhcmdzO1xuICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5yZWFzb24pIHtcbiAgICAgIHRocm93IHJlcXVlc3Quc2lnbmFsLnJlYXNvbjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFJlcXVlc3QgYWJvcnRlZCB3aXRob3V0IGFuIFxcYEFib3J0U2lnbmFsLnJlYXNvblxcYDogJHtyZXF1ZXN0Lm1ldGhvZH0gJHtyZXF1ZXN0LnVybH1gXG4gICAgKTtcbiAgfVxuICBsZXQgdHVwbGUgPSBtaWRkbGV3YXJlc1tpZHhdO1xuICBpZiAoIXR1cGxlKSB7XG4gICAgbWlkZGxld2FyZVN0YXRlLmhhbmRsZXJSZXN1bHQgPSBhd2FpdCBoYW5kbGVyKCk7XG4gICAgcmV0dXJuIG1pZGRsZXdhcmVTdGF0ZS5oYW5kbGVyUmVzdWx0O1xuICB9XG4gIGxldCBbcm91dGVJZCwgbWlkZGxld2FyZV0gPSB0dXBsZTtcbiAgbGV0IG5leHRDYWxsZWQgPSBmYWxzZTtcbiAgbGV0IG5leHRSZXN1bHQgPSB2b2lkIDA7XG4gIGxldCBuZXh0ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChuZXh0Q2FsbGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbWF5IG9ubHkgY2FsbCBgbmV4dCgpYCBvbmNlIHBlciBtaWRkbGV3YXJlXCIpO1xuICAgIH1cbiAgICBuZXh0Q2FsbGVkID0gdHJ1ZTtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbFJvdXRlTWlkZGxld2FyZShcbiAgICAgIGFyZ3MsXG4gICAgICBtaWRkbGV3YXJlcyxcbiAgICAgIHByb3BhZ2F0ZVJlc3VsdCxcbiAgICAgIG1pZGRsZXdhcmVTdGF0ZSxcbiAgICAgIGhhbmRsZXIsXG4gICAgICBpZHggKyAxXG4gICAgKTtcbiAgICBpZiAocHJvcGFnYXRlUmVzdWx0KSB7XG4gICAgICBuZXh0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgcmV0dXJuIG5leHRSZXN1bHQ7XG4gICAgfVxuICB9O1xuICB0cnkge1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBtaWRkbGV3YXJlKFxuICAgICAge1xuICAgICAgICByZXF1ZXN0OiBhcmdzLnJlcXVlc3QsXG4gICAgICAgIHBhcmFtczogYXJncy5wYXJhbXMsXG4gICAgICAgIGNvbnRleHQ6IGFyZ3MuY29udGV4dFxuICAgICAgfSxcbiAgICAgIG5leHRcbiAgICApO1xuICAgIGlmIChuZXh0Q2FsbGVkKSB7XG4gICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG5leHRSZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoIW1pZGRsZXdhcmVTdGF0ZS5taWRkbGV3YXJlRXJyb3IpIHtcbiAgICAgIG1pZGRsZXdhcmVTdGF0ZS5taWRkbGV3YXJlRXJyb3IgPSB7IHJvdXRlSWQsIGVycm9yIH07XG4gICAgfSBlbHNlIGlmIChtaWRkbGV3YXJlU3RhdGUubWlkZGxld2FyZUVycm9yLmVycm9yICE9PSBlcnJvcikge1xuICAgICAgbWlkZGxld2FyZVN0YXRlLm1pZGRsZXdhcmVFcnJvciA9IHsgcm91dGVJZCwgZXJyb3IgfTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERhdGFTdHJhdGVneU1hdGNoTGF6eVByb21pc2VzKG1hcFJvdXRlUHJvcGVydGllczIsIG1hbmlmZXN0LCByZXF1ZXN0LCBtYXRjaCwgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCkge1xuICBsZXQgbGF6eU1pZGRsZXdhcmVQcm9taXNlID0gbG9hZExhenlSb3V0ZVByb3BlcnR5KHtcbiAgICBrZXk6IFwidW5zdGFibGVfbWlkZGxld2FyZVwiLFxuICAgIHJvdXRlOiBtYXRjaC5yb3V0ZSxcbiAgICBtYW5pZmVzdCxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXM6IG1hcFJvdXRlUHJvcGVydGllczJcbiAgfSk7XG4gIGxldCBsYXp5Um91dGVQcm9taXNlcyA9IGxvYWRMYXp5Um91dGUoXG4gICAgbWF0Y2gucm91dGUsXG4gICAgaXNNdXRhdGlvbk1ldGhvZChyZXF1ZXN0Lm1ldGhvZCkgPyBcImFjdGlvblwiIDogXCJsb2FkZXJcIixcbiAgICBtYW5pZmVzdCxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXBcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlOiBsYXp5TWlkZGxld2FyZVByb21pc2UsXG4gICAgcm91dGU6IGxhenlSb3V0ZVByb21pc2VzLmxhenlSb3V0ZVByb21pc2UsXG4gICAgaGFuZGxlcjogbGF6eVJvdXRlUHJvbWlzZXMubGF6eUhhbmRsZXJQcm9taXNlXG4gIH07XG59XG5mdW5jdGlvbiBnZXREYXRhU3RyYXRlZ3lNYXRjaChtYXBSb3V0ZVByb3BlcnRpZXMyLCBtYW5pZmVzdCwgcmVxdWVzdCwgbWF0Y2gsIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAsIHNjb3BlZENvbnRleHQsIHNob3VsZExvYWQsIHVuc3RhYmxlX3Nob3VsZFJldmFsaWRhdGVBcmdzID0gbnVsbCkge1xuICBsZXQgaXNVc2luZ05ld0FwaSA9IGZhbHNlO1xuICBsZXQgX2xhenlQcm9taXNlcyA9IGdldERhdGFTdHJhdGVneU1hdGNoTGF6eVByb21pc2VzKFxuICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgbWFuaWZlc3QsXG4gICAgcmVxdWVzdCxcbiAgICBtYXRjaCxcbiAgICBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwXG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4ubWF0Y2gsXG4gICAgX2xhenlQcm9taXNlcyxcbiAgICBzaG91bGRMb2FkLFxuICAgIHVuc3RhYmxlX3Nob3VsZFJldmFsaWRhdGVBcmdzLFxuICAgIHVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyKGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICBpc1VzaW5nTmV3QXBpID0gdHJ1ZTtcbiAgICAgIGlmICghdW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHNob3VsZExvYWQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihtYXRjaCwge1xuICAgICAgICAgIC4uLnVuc3RhYmxlX3Nob3VsZFJldmFsaWRhdGVBcmdzLFxuICAgICAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNob3VsZFJldmFsaWRhdGVMb2FkZXIobWF0Y2gsIHVuc3RhYmxlX3Nob3VsZFJldmFsaWRhdGVBcmdzKTtcbiAgICB9LFxuICAgIHJlc29sdmUoaGFuZGxlck92ZXJyaWRlKSB7XG4gICAgICBpZiAoaXNVc2luZ05ld0FwaSB8fCBzaG91bGRMb2FkIHx8IGhhbmRsZXJPdmVycmlkZSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gXCJHRVRcIiAmJiAobWF0Y2gucm91dGUubGF6eSB8fCBtYXRjaC5yb3V0ZS5sb2FkZXIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsTG9hZGVyT3JBY3Rpb24oe1xuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgbGF6eUhhbmRsZXJQcm9taXNlOiBfbGF6eVByb21pc2VzPy5oYW5kbGVyLFxuICAgICAgICAgIGxhenlSb3V0ZVByb21pc2U6IF9sYXp5UHJvbWlzZXM/LnJvdXRlLFxuICAgICAgICAgIGhhbmRsZXJPdmVycmlkZSxcbiAgICAgICAgICBzY29wZWRDb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHR5cGU6IFwiZGF0YVwiIC8qIGRhdGEgKi8sIHJlc3VsdDogdm9pZCAwIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldGVkRGF0YVN0cmF0ZWd5TWF0Y2hlcyhtYXBSb3V0ZVByb3BlcnRpZXMyLCBtYW5pZmVzdCwgcmVxdWVzdCwgbWF0Y2hlcywgdGFyZ2V0TWF0Y2gsIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAsIHNjb3BlZENvbnRleHQsIHNob3VsZFJldmFsaWRhdGVBcmdzID0gbnVsbCkge1xuICByZXR1cm4gbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG4gICAgaWYgKG1hdGNoLnJvdXRlLmlkICE9PSB0YXJnZXRNYXRjaC5yb3V0ZS5pZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWF0Y2gsXG4gICAgICAgIHNob3VsZExvYWQ6IGZhbHNlLFxuICAgICAgICB1bnN0YWJsZV9zaG91bGRSZXZhbGlkYXRlQXJnczogc2hvdWxkUmV2YWxpZGF0ZUFyZ3MsXG4gICAgICAgIHVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyOiAoKSA9PiBmYWxzZSxcbiAgICAgICAgX2xhenlQcm9taXNlczogZ2V0RGF0YVN0cmF0ZWd5TWF0Y2hMYXp5UHJvbWlzZXMoXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXBcbiAgICAgICAgKSxcbiAgICAgICAgcmVzb2x2ZTogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgdHlwZTogXCJkYXRhXCIsIHJlc3VsdDogdm9pZCAwIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RGF0YVN0cmF0ZWd5TWF0Y2goXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICByZXF1ZXN0LFxuICAgICAgbWF0Y2gsXG4gICAgICBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLFxuICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgIHRydWUsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlQXJnc1xuICAgICk7XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FsbERhdGFTdHJhdGVneUltcGwoZGF0YVN0cmF0ZWd5SW1wbCwgcmVxdWVzdCwgbWF0Y2hlcywgZmV0Y2hlcktleSwgc2NvcGVkQ29udGV4dCwgaXNTdGF0aWNIYW5kbGVyKSB7XG4gIGlmIChtYXRjaGVzLnNvbWUoKG0pID0+IG0uX2xhenlQcm9taXNlcz8ubWlkZGxld2FyZSkpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChtYXRjaGVzLm1hcCgobSkgPT4gbS5fbGF6eVByb21pc2VzPy5taWRkbGV3YXJlKSk7XG4gIH1cbiAgbGV0IGRhdGFTdHJhdGVneUFyZ3MgPSB7XG4gICAgcmVxdWVzdCxcbiAgICBwYXJhbXM6IG1hdGNoZXNbMF0ucGFyYW1zLFxuICAgIGNvbnRleHQ6IHNjb3BlZENvbnRleHQsXG4gICAgbWF0Y2hlc1xuICB9O1xuICBsZXQgdW5zdGFibGVfcnVuQ2xpZW50TWlkZGxld2FyZSA9IGlzU3RhdGljSGFuZGxlciA/ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW5ub3QgY2FsbCBgdW5zdGFibGVfcnVuQ2xpZW50TWlkZGxld2FyZSgpYCBmcm9tIGEgc3RhdGljIGhhbmRsZXIgYGRhdGFTdHJhdGVneWAuIE1pZGRsZXdhcmUgaXMgcnVuIG91dHNpZGUgb2YgYGRhdGFTdHJhdGVneWAgZHVyaW5nIFNTUiBpbiBvcmRlciB0byBidWJibGUgdXAgdGhlIFJlc3BvbnNlLiAgWW91IGNhbiBlbmFibGUgbWlkZGxld2FyZSB2aWEgdGhlIGByZXNwb25kYCBBUEkgaW4gYHF1ZXJ5YC9gcXVlcnlSb3V0ZWBcIlxuICAgICk7XG4gIH0gOiAoY2IpID0+IHtcbiAgICBsZXQgdHlwZWREYXRhU3RyYXRlZ3lBcmdzID0gZGF0YVN0cmF0ZWd5QXJncztcbiAgICByZXR1cm4gcnVuTWlkZGxld2FyZVBpcGVsaW5lKFxuICAgICAgdHlwZWREYXRhU3RyYXRlZ3lBcmdzLFxuICAgICAgZmFsc2UsXG4gICAgICAoKSA9PiBjYih7XG4gICAgICAgIC4uLnR5cGVkRGF0YVN0cmF0ZWd5QXJncyxcbiAgICAgICAgZmV0Y2hlcktleSxcbiAgICAgICAgdW5zdGFibGVfcnVuQ2xpZW50TWlkZGxld2FyZTogKCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiQ2Fubm90IGNhbGwgYHVuc3RhYmxlX3J1bkNsaWVudE1pZGRsZXdhcmUoKWAgZnJvbSB3aXRoaW4gYW4gYHVuc3RhYmxlX3J1bkNsaWVudE1pZGRsZXdhcmVgIGhhbmRsZXJcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgKGVycm9yLCByb3V0ZUlkKSA9PiAoe1xuICAgICAgICBbcm91dGVJZF06IHsgdHlwZTogXCJlcnJvclwiLCByZXN1bHQ6IGVycm9yIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcbiAgbGV0IHJlc3VsdHMgPSBhd2FpdCBkYXRhU3RyYXRlZ3lJbXBsKHtcbiAgICAuLi5kYXRhU3RyYXRlZ3lBcmdzLFxuICAgIGZldGNoZXJLZXksXG4gICAgdW5zdGFibGVfcnVuQ2xpZW50TWlkZGxld2FyZVxuICB9KTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIG1hdGNoZXMuZmxhdE1hcCgobSkgPT4gW20uX2xhenlQcm9taXNlcz8uaGFuZGxlciwgbS5fbGF6eVByb21pc2VzPy5yb3V0ZV0pXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlck9yQWN0aW9uKHtcbiAgcmVxdWVzdCxcbiAgbWF0Y2gsXG4gIGxhenlIYW5kbGVyUHJvbWlzZSxcbiAgbGF6eVJvdXRlUHJvbWlzZSxcbiAgaGFuZGxlck92ZXJyaWRlLFxuICBzY29wZWRDb250ZXh0XG59KSB7XG4gIGxldCByZXN1bHQ7XG4gIGxldCBvblJlamVjdDtcbiAgbGV0IGlzQWN0aW9uID0gaXNNdXRhdGlvbk1ldGhvZChyZXF1ZXN0Lm1ldGhvZCk7XG4gIGxldCB0eXBlID0gaXNBY3Rpb24gPyBcImFjdGlvblwiIDogXCJsb2FkZXJcIjtcbiAgbGV0IHJ1bkhhbmRsZXIgPSAoaGFuZGxlcikgPT4ge1xuICAgIGxldCByZWplY3Q7XG4gICAgbGV0IGFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiByZWplY3QgPSByKTtcbiAgICBvblJlamVjdCA9ICgpID0+IHJlamVjdCgpO1xuICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgbGV0IGFjdHVhbEhhbmRsZXIgPSAoY3R4KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFlvdSBjYW5ub3QgY2FsbCB0aGUgaGFuZGxlciBmb3IgYSByb3V0ZSB3aGljaCBkZWZpbmVzIGEgYm9vbGVhbiBcIiR7dHlwZX1cIiBbcm91dGVJZDogJHttYXRjaC5yb3V0ZS5pZH1dYFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYW5kbGVyKFxuICAgICAgICB7XG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgICAgICBjb250ZXh0OiBzY29wZWRDb250ZXh0XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmN0eCAhPT0gdm9pZCAwID8gW2N0eF0gOiBbXVxuICAgICAgKTtcbiAgICB9O1xuICAgIGxldCBoYW5kbGVyUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgdmFsID0gYXdhaXQgKGhhbmRsZXJPdmVycmlkZSA/IGhhbmRsZXJPdmVycmlkZSgoY3R4KSA9PiBhY3R1YWxIYW5kbGVyKGN0eCkpIDogYWN0dWFsSGFuZGxlcigpKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIsIHJlc3VsdDogdmFsIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcmVzdWx0OiBlIH07XG4gICAgICB9XG4gICAgfSkoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtoYW5kbGVyUHJvbWlzZSwgYWJvcnRQcm9taXNlXSk7XG4gIH07XG4gIHRyeSB7XG4gICAgbGV0IGhhbmRsZXIgPSBpc0FjdGlvbiA/IG1hdGNoLnJvdXRlLmFjdGlvbiA6IG1hdGNoLnJvdXRlLmxvYWRlcjtcbiAgICBpZiAobGF6eUhhbmRsZXJQcm9taXNlIHx8IGxhenlSb3V0ZVByb21pc2UpIHtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGxldCBoYW5kbGVyRXJyb3I7XG4gICAgICAgIGxldCBbdmFsdWVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIC8vIElmIHRoZSBoYW5kbGVyIHRocm93cywgZG9uJ3QgbGV0IGl0IGltbWVkaWF0ZWx5IGJ1YmJsZSBvdXQsXG4gICAgICAgICAgLy8gc2luY2Ugd2UgbmVlZCB0byBsZXQgdGhlIGxhenkoKSBleGVjdXRpb24gZmluaXNoIHNvIHdlIGtub3cgaWYgdGhpc1xuICAgICAgICAgIC8vIHJvdXRlIGhhcyBhIGJvdW5kYXJ5IHRoYXQgY2FuIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgICAgICBydW5IYW5kbGVyKGhhbmRsZXIpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVyRXJyb3IgPSBlO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8vIEVuc3VyZSBhbGwgbGF6eSByb3V0ZSBwcm9taXNlcyBhcmUgcmVzb2x2ZWQgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgICAgICBsYXp5SGFuZGxlclByb21pc2UsXG4gICAgICAgICAgbGF6eVJvdXRlUHJvbWlzZVxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGhhbmRsZXJFcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgaGFuZGxlckVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgbGF6eUhhbmRsZXJQcm9taXNlO1xuICAgICAgICBsZXQgaGFuZGxlcjIgPSBpc0FjdGlvbiA/IG1hdGNoLnJvdXRlLmFjdGlvbiA6IG1hdGNoLnJvdXRlLmxvYWRlcjtcbiAgICAgICAgaWYgKGhhbmRsZXIyKSB7XG4gICAgICAgICAgW3Jlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbcnVuSGFuZGxlcihoYW5kbGVyMiksIGxhenlSb3V0ZVByb21pc2VdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImFjdGlvblwiKSB7XG4gICAgICAgICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgICAgIGxldCBwYXRobmFtZSA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2g7XG4gICAgICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHJvdXRlSWQ6IG1hdGNoLnJvdXRlLmlkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIgLyogZGF0YSAqLywgcmVzdWx0OiB2b2lkIDAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgIGxldCBwYXRobmFtZSA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2g7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICBwYXRobmFtZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bkhhbmRsZXIoaGFuZGxlcik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLCByZXN1bHQ6IGUgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAob25SZWplY3QpIHtcbiAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0RGF0YVN0cmF0ZWd5UmVzdWx0VG9EYXRhUmVzdWx0KGRhdGFTdHJhdGVneVJlc3VsdCkge1xuICBsZXQgeyByZXN1bHQsIHR5cGUgfSA9IGRhdGFTdHJhdGVneVJlc3VsdDtcbiAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgIGxldCBkYXRhMjtcbiAgICB0cnkge1xuICAgICAgbGV0IGNvbnRlbnRUeXBlID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgIGlmIChyZXN1bHQuYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgZGF0YTIgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEyID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YTIgPSBhd2FpdCByZXN1bHQudGV4dCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLywgZXJyb3I6IGUgfTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiZXJyb3JcIiAvKiBlcnJvciAqLykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICBlcnJvcjogbmV3IEVycm9yUmVzcG9uc2VJbXBsKHJlc3VsdC5zdGF0dXMsIHJlc3VsdC5zdGF0dXNUZXh0LCBkYXRhMiksXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXMsXG4gICAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkYXRhXCIgLyogZGF0YSAqLyxcbiAgICAgIGRhdGE6IGRhdGEyLFxuICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1cyxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovKSB7XG4gICAgaWYgKGlzRGF0YVdpdGhSZXNwb25zZUluaXQocmVzdWx0KSkge1xuICAgICAgaWYgKHJlc3VsdC5kYXRhIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgICAgZXJyb3I6IHJlc3VsdC5kYXRhLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5pbml0Py5zdGF0dXMsXG4gICAgICAgICAgaGVhZGVyczogcmVzdWx0LmluaXQ/LmhlYWRlcnMgPyBuZXcgSGVhZGVycyhyZXN1bHQuaW5pdC5oZWFkZXJzKSA6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICBlcnJvcjogbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICAgIHJlc3VsdC5pbml0Py5zdGF0dXMgfHwgNTAwLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICByZXN1bHQuZGF0YVxuICAgICAgICApLFxuICAgICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQpID8gcmVzdWx0LnN0YXR1cyA6IHZvaWQgMCxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmluaXQ/LmhlYWRlcnMgPyBuZXcgSGVhZGVycyhyZXN1bHQuaW5pdC5oZWFkZXJzKSA6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgIGVycm9yOiByZXN1bHQsXG4gICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQpID8gcmVzdWx0LnN0YXR1cyA6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgaWYgKGlzRGF0YVdpdGhSZXNwb25zZUluaXQocmVzdWx0KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLFxuICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuaW5pdD8uc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmluaXQ/LmhlYWRlcnMgPyBuZXcgSGVhZGVycyhyZXN1bHQuaW5pdC5oZWFkZXJzKSA6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIgLyogZGF0YSAqLywgZGF0YTogcmVzdWx0IH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVSZWxhdGl2ZVJvdXRpbmdSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlLCByZXF1ZXN0LCByb3V0ZUlkLCBtYXRjaGVzLCBiYXNlbmFtZSkge1xuICBsZXQgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICBpbnZhcmlhbnQoXG4gICAgbG9jYXRpb24sXG4gICAgXCJSZWRpcmVjdHMgcmV0dXJuZWQvdGhyb3duIGZyb20gbG9hZGVycy9hY3Rpb25zIG11c3QgaGF2ZSBhIExvY2F0aW9uIGhlYWRlclwiXG4gICk7XG4gIGlmICghQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QobG9jYXRpb24pKSB7XG4gICAgbGV0IHRyaW1tZWRNYXRjaGVzID0gbWF0Y2hlcy5zbGljZShcbiAgICAgIDAsXG4gICAgICBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgKyAxXG4gICAgKTtcbiAgICBsb2NhdGlvbiA9IG5vcm1hbGl6ZVRvKFxuICAgICAgbmV3IFVSTChyZXF1ZXN0LnVybCksXG4gICAgICB0cmltbWVkTWF0Y2hlcyxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgbG9jYXRpb25cbiAgICApO1xuICAgIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgbG9jYXRpb24pO1xuICB9XG4gIHJldHVybiByZXNwb25zZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24sIGN1cnJlbnRVcmwsIGJhc2VuYW1lKSB7XG4gIGlmIChBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICBsZXQgbm9ybWFsaXplZExvY2F0aW9uID0gbG9jYXRpb247XG4gICAgbGV0IHVybCA9IG5vcm1hbGl6ZWRMb2NhdGlvbi5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyBub3JtYWxpemVkTG9jYXRpb24pIDogbmV3IFVSTChub3JtYWxpemVkTG9jYXRpb24pO1xuICAgIGxldCBpc1NhbWVCYXNlbmFtZSA9IHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgIT0gbnVsbDtcbiAgICBpZiAodXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgaXNTYW1lQmFzZW5hbWUpIHtcbiAgICAgIHJldHVybiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2g7XG4gICAgfVxuICB9XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGhpc3RvcnksIGxvY2F0aW9uLCBzaWduYWwsIHN1Ym1pc3Npb24pIHtcbiAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKHN0cmlwSGFzaEZyb21QYXRoKGxvY2F0aW9uKSkudG9TdHJpbmcoKTtcbiAgbGV0IGluaXQgPSB7IHNpZ25hbCB9O1xuICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICBsZXQgeyBmb3JtTWV0aG9kLCBmb3JtRW5jVHlwZSB9ID0gc3VibWlzc2lvbjtcbiAgICBpbml0Lm1ldGhvZCA9IGZvcm1NZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICBpbml0LmhlYWRlcnMgPSBuZXcgSGVhZGVycyh7IFwiQ29udGVudC1UeXBlXCI6IGZvcm1FbmNUeXBlIH0pO1xuICAgICAgaW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoc3VibWlzc2lvbi5qc29uKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1FbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi50ZXh0O1xuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgJiYgc3VibWlzc2lvbi5mb3JtRGF0YSkge1xuICAgICAgaW5pdC5ib2R5ID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoc3VibWlzc2lvbi5mb3JtRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXQuYm9keSA9IHN1Ym1pc3Npb24uZm9ybURhdGE7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwsIGluaXQpO1xufVxuZnVuY3Rpb24gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoZm9ybURhdGEpIHtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IHZhbHVlLm5hbWUpO1xuICB9XG4gIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG5mdW5jdGlvbiBjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YShzZWFyY2hQYXJhbXMpIHtcbiAgbGV0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBzZWFyY2hQYXJhbXMuZW50cmllcygpKSB7XG4gICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmb3JtRGF0YTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEobWF0Y2hlcywgcmVzdWx0cywgcGVuZGluZ0FjdGlvblJlc3VsdCwgaXNTdGF0aWNIYW5kbGVyID0gZmFsc2UsIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nID0gZmFsc2UpIHtcbiAgbGV0IGxvYWRlckRhdGEgPSB7fTtcbiAgbGV0IGVycm9ycyA9IG51bGw7XG4gIGxldCBzdGF0dXNDb2RlO1xuICBsZXQgZm91bmRFcnJvciA9IGZhbHNlO1xuICBsZXQgbG9hZGVySGVhZGVycyA9IHt9O1xuICBsZXQgcGVuZGluZ0Vycm9yID0gcGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8gcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5lcnJvciA6IHZvaWQgMDtcbiAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgIGlmICghKG1hdGNoLnJvdXRlLmlkIGluIHJlc3VsdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBpZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2lkXTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpLFxuICAgICAgXCJDYW5ub3QgaGFuZGxlIHJlZGlyZWN0IHJlc3VsdHMgaW4gcHJvY2Vzc0xvYWRlckRhdGFcIlxuICAgICk7XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9yO1xuICAgICAgaWYgKHBlbmRpbmdFcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGVycm9yID0gcGVuZGluZ0Vycm9yO1xuICAgICAgICBwZW5kaW5nRXJyb3IgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBlcnJvcnMgPSBlcnJvcnMgfHwge307XG4gICAgICBpZiAoc2tpcExvYWRlckVycm9yQnViYmxpbmcpIHtcbiAgICAgICAgZXJyb3JzW2lkXSA9IGVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGlkKTtcbiAgICAgICAgaWYgKGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTdGF0aWNIYW5kbGVyKSB7XG4gICAgICAgIGxvYWRlckRhdGFbaWRdID0gUmVzZXRMb2FkZXJEYXRhU3ltYm9sO1xuICAgICAgfVxuICAgICAgaWYgKCFmb3VuZEVycm9yKSB7XG4gICAgICAgIGZvdW5kRXJyb3IgPSB0cnVlO1xuICAgICAgICBzdGF0dXNDb2RlID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKSA/IHJlc3VsdC5lcnJvci5zdGF0dXMgOiA1MDA7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZGVyRGF0YVtpZF0gPSByZXN1bHQuZGF0YTtcbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzQ29kZSAmJiByZXN1bHQuc3RhdHVzQ29kZSAhPT0gMjAwICYmICFmb3VuZEVycm9yKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSByZXN1bHQuc3RhdHVzQ29kZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChwZW5kaW5nRXJyb3IgIT09IHZvaWQgMCAmJiBwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgZXJyb3JzID0geyBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdFcnJvciB9O1xuICAgIGlmIChwZW5kaW5nQWN0aW9uUmVzdWx0WzJdKSB7XG4gICAgICBsb2FkZXJEYXRhW3BlbmRpbmdBY3Rpb25SZXN1bHRbMl1dID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGxvYWRlckRhdGEsXG4gICAgZXJyb3JzLFxuICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUgfHwgMjAwLFxuICAgIGxvYWRlckhlYWRlcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NMb2FkZXJEYXRhKHN0YXRlLCBtYXRjaGVzLCByZXN1bHRzLCBwZW5kaW5nQWN0aW9uUmVzdWx0LCByZXZhbGlkYXRpbmdGZXRjaGVycywgZmV0Y2hlclJlc3VsdHMpIHtcbiAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKFxuICAgIG1hdGNoZXMsXG4gICAgcmVzdWx0cyxcbiAgICBwZW5kaW5nQWN0aW9uUmVzdWx0XG4gICk7XG4gIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZpbHRlcigoZikgPT4gIWYubWF0Y2hlcyB8fCBmLm1hdGNoZXMuc29tZSgobSkgPT4gbS5zaG91bGRMb2FkKSkuZm9yRWFjaCgocmYpID0+IHtcbiAgICBsZXQgeyBrZXksIG1hdGNoLCBjb250cm9sbGVyIH0gPSByZjtcbiAgICBsZXQgcmVzdWx0ID0gZmV0Y2hlclJlc3VsdHNba2V5XTtcbiAgICBpbnZhcmlhbnQocmVzdWx0LCBcIkRpZCBub3QgZmluZCBjb3JyZXNwb25kaW5nIGZldGNoZXIgcmVzdWx0XCIpO1xuICAgIGlmIChjb250cm9sbGVyICYmIGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIG1hdGNoPy5yb3V0ZS5pZCk7XG4gICAgICBpZiAoIShlcnJvcnMgJiYgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdKSkge1xuICAgICAgICBlcnJvcnMgPSB7XG4gICAgICAgICAgLi4uZXJyb3JzLFxuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2UgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCBcIlVuaGFuZGxlZCBmZXRjaGVyIHJldmFsaWRhdGlvbiByZWRpcmVjdFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIocmVzdWx0LmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7IGxvYWRlckRhdGEsIGVycm9ycyB9O1xufVxuZnVuY3Rpb24gbWVyZ2VMb2FkZXJEYXRhKGxvYWRlckRhdGEsIG5ld0xvYWRlckRhdGEsIG1hdGNoZXMsIGVycm9ycykge1xuICBsZXQgbWVyZ2VkTG9hZGVyRGF0YSA9IE9iamVjdC5lbnRyaWVzKG5ld0xvYWRlckRhdGEpLmZpbHRlcigoWywgdl0pID0+IHYgIT09IFJlc2V0TG9hZGVyRGF0YVN5bWJvbCkucmVkdWNlKChtZXJnZWQsIFtrLCB2XSkgPT4ge1xuICAgIG1lcmdlZFtrXSA9IHY7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pO1xuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgaWYgKCFuZXdMb2FkZXJEYXRhLmhhc093blByb3BlcnR5KGlkKSAmJiBsb2FkZXJEYXRhLmhhc093blByb3BlcnR5KGlkKSAmJiBtYXRjaC5yb3V0ZS5sb2FkZXIpIHtcbiAgICAgIG1lcmdlZExvYWRlckRhdGFbaWRdID0gbG9hZGVyRGF0YVtpZF07XG4gICAgfVxuICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRMb2FkZXJEYXRhO1xufVxuZnVuY3Rpb24gZ2V0QWN0aW9uRGF0YUZvckNvbW1pdChwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gIGlmICghcGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSA/IHtcbiAgICAvLyBDbGVhciBvdXQgcHJpb3IgYWN0aW9uRGF0YSBvbiBlcnJvcnNcbiAgICBhY3Rpb25EYXRhOiB7fVxuICB9IDoge1xuICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgIFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5kYXRhXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCByb3V0ZUlkKSB7XG4gIGxldCBlbGlnaWJsZU1hdGNoZXMgPSByb3V0ZUlkID8gbWF0Y2hlcy5zbGljZSgwLCBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgKyAxKSA6IFsuLi5tYXRjaGVzXTtcbiAgcmV0dXJuIGVsaWdpYmxlTWF0Y2hlcy5yZXZlcnNlKCkuZmluZCgobSkgPT4gbS5yb3V0ZS5oYXNFcnJvckJvdW5kYXJ5ID09PSB0cnVlKSB8fCBtYXRjaGVzWzBdO1xufVxuZnVuY3Rpb24gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhyb3V0ZXMpIHtcbiAgbGV0IHJvdXRlID0gcm91dGVzLmxlbmd0aCA9PT0gMSA/IHJvdXRlc1swXSA6IHJvdXRlcy5maW5kKChyKSA9PiByLmluZGV4IHx8ICFyLnBhdGggfHwgci5wYXRoID09PSBcIi9cIikgfHwge1xuICAgIGlkOiBgX19zaGltLWVycm9yLXJvdXRlX19gXG4gIH07XG4gIHJldHVybiB7XG4gICAgbWF0Y2hlczogW1xuICAgICAge1xuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBwYXRobmFtZTogXCJcIixcbiAgICAgICAgcGF0aG5hbWVCYXNlOiBcIlwiLFxuICAgICAgICByb3V0ZVxuICAgICAgfVxuICAgIF0sXG4gICAgcm91dGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEludGVybmFsUm91dGVyRXJyb3Ioc3RhdHVzLCB7XG4gIHBhdGhuYW1lLFxuICByb3V0ZUlkLFxuICBtZXRob2QsXG4gIHR5cGUsXG4gIG1lc3NhZ2Vcbn0gPSB7fSkge1xuICBsZXQgc3RhdHVzVGV4dCA9IFwiVW5rbm93biBTZXJ2ZXIgRXJyb3JcIjtcbiAgbGV0IGVycm9yTWVzc2FnZSA9IFwiVW5rbm93biBAcmVtaXgtcnVuL3JvdXRlciBlcnJvclwiO1xuICBpZiAoc3RhdHVzID09PSA0MDApIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJCYWQgUmVxdWVzdFwiO1xuICAgIGlmIChtZXRob2QgJiYgcGF0aG5hbWUgJiYgcm91dGVJZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYFlvdSBtYWRlIGEgJHttZXRob2R9IHJlcXVlc3QgdG8gXCIke3BhdGhuYW1lfVwiIGJ1dCBkaWQgbm90IHByb3ZpZGUgYSBcXGBsb2FkZXJcXGAgZm9yIHJvdXRlIFwiJHtyb3V0ZUlkfVwiLCBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSByZXF1ZXN0LmA7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImludmFsaWQtYm9keVwiKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIlVuYWJsZSB0byBlbmNvZGUgc3VibWlzc2lvbiBib2R5XCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiRm9yYmlkZGVuXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gYFJvdXRlIFwiJHtyb3V0ZUlkfVwiIGRvZXMgbm90IG1hdGNoIFVSTCBcIiR7cGF0aG5hbWV9XCJgO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTm90IEZvdW5kXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gYE5vIHJvdXRlIG1hdGNoZXMgVVJMIFwiJHtwYXRobmFtZX1cImA7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDUpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJNZXRob2QgTm90IEFsbG93ZWRcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBZb3UgbWFkZSBhICR7bWV0aG9kLnRvVXBwZXJDYXNlKCl9IHJlcXVlc3QgdG8gXCIke3BhdGhuYW1lfVwiIGJ1dCBkaWQgbm90IHByb3ZpZGUgYW4gXFxgYWN0aW9uXFxgIGZvciByb3V0ZSBcIiR7cm91dGVJZH1cIiwgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5gO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBgSW52YWxpZCByZXF1ZXN0IG1ldGhvZCBcIiR7bWV0aG9kLnRvVXBwZXJDYXNlKCl9XCJgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgIHN0YXR1cyB8fCA1MDAsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSxcbiAgICB0cnVlXG4gICk7XG59XG5mdW5jdGlvbiBmaW5kUmVkaXJlY3QocmVzdWx0cykge1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHJlc3VsdHMpO1xuICBmb3IgKGxldCBpID0gZW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGxldCBba2V5LCByZXN1bHRdID0gZW50cmllc1tpXTtcbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXR1cm4geyBrZXksIHJlc3VsdCB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3RyaXBIYXNoRnJvbVBhdGgocGF0aCkge1xuICBsZXQgcGFyc2VkUGF0aCA9IHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHBhdGgpIDogcGF0aDtcbiAgcmV0dXJuIGNyZWF0ZVBhdGgoeyAuLi5wYXJzZWRQYXRoLCBoYXNoOiBcIlwiIH0pO1xufVxuZnVuY3Rpb24gaXNIYXNoQ2hhbmdlT25seShhLCBiKSB7XG4gIGlmIChhLnBhdGhuYW1lICE9PSBiLnBhdGhuYW1lIHx8IGEuc2VhcmNoICE9PSBiLnNlYXJjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYS5oYXNoID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGIuaGFzaCAhPT0gXCJcIjtcbiAgfSBlbHNlIGlmIChhLmhhc2ggPT09IGIuaGFzaCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGIuaGFzaCAhPT0gXCJcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzRGF0YVN0cmF0ZWd5UmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiByZXN1bHQgJiYgXCJyZXN1bHRcIiBpbiByZXN1bHQgJiYgKHJlc3VsdC50eXBlID09PSBcImRhdGFcIiAvKiBkYXRhICovIHx8IHJlc3VsdC50eXBlID09PSBcImVycm9yXCIgLyogZXJyb3IgKi8pO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdERhdGFTdHJhdGVneVJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0LnJlc3VsdCkgJiYgcmVkaXJlY3RTdGF0dXNDb2Rlcy5oYXMocmVzdWx0LnJlc3VsdC5zdGF0dXMpO1xufVxuZnVuY3Rpb24gaXNFcnJvclJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBcImVycm9yXCIgLyogZXJyb3IgKi87XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gKHJlc3VsdCAmJiByZXN1bHQudHlwZSkgPT09IFwicmVkaXJlY3RcIiAvKiByZWRpcmVjdCAqLztcbn1cbmZ1bmN0aW9uIGlzRGF0YVdpdGhSZXNwb25zZUluaXQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPSBudWxsICYmIFwidHlwZVwiIGluIHZhbHVlICYmIFwiZGF0YVwiIGluIHZhbHVlICYmIFwiaW5pdFwiIGluIHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwiRGF0YVdpdGhSZXNwb25zZUluaXRcIjtcbn1cbmZ1bmN0aW9uIGlzUmVzcG9uc2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdmFsdWUuc3RhdHVzVGV4dCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgdmFsdWUuaGVhZGVycyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUuYm9keSAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3RTdGF0dXNDb2RlKHN0YXR1c0NvZGUpIHtcbiAgcmV0dXJuIHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHN0YXR1c0NvZGUpO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3VsdCkge1xuICByZXR1cm4gaXNSZXNwb25zZShyZXN1bHQpICYmIGlzUmVkaXJlY3RTdGF0dXNDb2RlKHJlc3VsdC5zdGF0dXMpICYmIHJlc3VsdC5oZWFkZXJzLmhhcyhcIkxvY2F0aW9uXCIpO1xufVxuZnVuY3Rpb24gaXNWYWxpZE1ldGhvZChtZXRob2QpIHtcbiAgcmV0dXJuIHZhbGlkUmVxdWVzdE1ldGhvZHMuaGFzKG1ldGhvZC50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGlzTXV0YXRpb25NZXRob2QobWV0aG9kKSB7XG4gIHJldHVybiB2YWxpZE11dGF0aW9uTWV0aG9kcy5oYXMobWV0aG9kLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaCkge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2gpLmdldEFsbChcImluZGV4XCIpLnNvbWUoKHYpID0+IHYgPT09IFwiXCIpO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pIHtcbiAgbGV0IHNlYXJjaCA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbikuc2VhcmNoIDogbG9jYXRpb24uc2VhcmNoO1xuICBpZiAobWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmluZGV4ICYmIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2ggfHwgXCJcIikpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGxldCBwYXRoTWF0Y2hlcyA9IGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpO1xuICByZXR1cm4gcGF0aE1hdGNoZXNbcGF0aE1hdGNoZXMubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24obmF2aWdhdGlvbikge1xuICBsZXQgeyBmb3JtTWV0aG9kLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSwgdGV4dCwgZm9ybURhdGEsIGpzb24gfSA9IG5hdmlnYXRpb247XG4gIGlmICghZm9ybU1ldGhvZCB8fCAhZm9ybUFjdGlvbiB8fCAhZm9ybUVuY1R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgIHRleHRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZvcm1EYXRhICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhLFxuICAgICAganNvbjogdm9pZCAwLFxuICAgICAgdGV4dDogdm9pZCAwXG4gICAgfTtcbiAgfSBlbHNlIGlmIChqc29uICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAgICBqc29uLFxuICAgICAgdGV4dDogdm9pZCAwXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgbmF2aWdhdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dFxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRpb247XG4gIH0gZWxzZSB7XG4gICAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZvcm1NZXRob2Q6IHZvaWQgMCxcbiAgICAgIGZvcm1BY3Rpb246IHZvaWQgMCxcbiAgICAgIGZvcm1FbmNUeXBlOiB2b2lkIDAsXG4gICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAganNvbjogdm9pZCAwLFxuICAgICAgdGV4dDogdm9pZCAwXG4gICAgfTtcbiAgICByZXR1cm4gbmF2aWdhdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3VibWl0dGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pIHtcbiAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgIGxvY2F0aW9uLFxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dFxuICB9O1xuICByZXR1cm4gbmF2aWdhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGRhdGEyKSB7XG4gIGlmIChzdWJtaXNzaW9uKSB7XG4gICAgbGV0IGZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICAgICAgZGF0YTogZGF0YTJcbiAgICB9O1xuICAgIHJldHVybiBmZXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIGxldCBmZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgZm9ybU1ldGhvZDogdm9pZCAwLFxuICAgICAgZm9ybUFjdGlvbjogdm9pZCAwLFxuICAgICAgZm9ybUVuY1R5cGU6IHZvaWQgMCxcbiAgICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAgICBqc29uOiB2b2lkIDAsXG4gICAgICB0ZXh0OiB2b2lkIDAsXG4gICAgICBkYXRhOiBkYXRhMlxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlcikge1xuICBsZXQgZmV0Y2hlciA9IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICAgIGRhdGE6IGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdm9pZCAwXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuZnVuY3Rpb24gZ2V0RG9uZUZldGNoZXIoZGF0YTIpIHtcbiAgbGV0IGZldGNoZXIgPSB7XG4gICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgIGZvcm1NZXRob2Q6IHZvaWQgMCxcbiAgICBmb3JtQWN0aW9uOiB2b2lkIDAsXG4gICAgZm9ybUVuY1R5cGU6IHZvaWQgMCxcbiAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgIGpzb246IHZvaWQgMCxcbiAgICB0ZXh0OiB2b2lkIDAsXG4gICAgZGF0YTogZGF0YTJcbiAgfTtcbiAgcmV0dXJuIGZldGNoZXI7XG59XG5mdW5jdGlvbiByZXN0b3JlQXBwbGllZFRyYW5zaXRpb25zKF93aW5kb3csIHRyYW5zaXRpb25zKSB7XG4gIHRyeSB7XG4gICAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBfd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXG4gICAgICBUUkFOU0lUSU9OU19TVE9SQUdFX0tFWVxuICAgICk7XG4gICAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcbiAgICAgIGxldCBqc29uID0gSlNPTi5wYXJzZShzZXNzaW9uUG9zaXRpb25zKTtcbiAgICAgIGZvciAobGV0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhqc29uIHx8IHt9KSkge1xuICAgICAgICBpZiAodiAmJiBBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbnMuc2V0KGssIG5ldyBTZXQodiB8fCBbXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cbmZ1bmN0aW9uIHBlcnNpc3RBcHBsaWVkVHJhbnNpdGlvbnMoX3dpbmRvdywgdHJhbnNpdGlvbnMpIHtcbiAgaWYgKHRyYW5zaXRpb25zLnNpemUgPiAwKSB7XG4gICAgbGV0IGpzb24gPSB7fTtcbiAgICBmb3IgKGxldCBbaywgdl0gb2YgdHJhbnNpdGlvbnMpIHtcbiAgICAgIGpzb25ba10gPSBbLi4udl07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBfd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgIFRSQU5TSVRJT05TX1NUT1JBR0VfS0VZLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShqc29uKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGBGYWlsZWQgdG8gc2F2ZSBhcHBsaWVkIHZpZXcgdHJhbnNpdGlvbnMgaW4gc2Vzc2lvblN0b3JhZ2UgKCR7ZXJyb3J9KS5gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWQoKSB7XG4gIGxldCByZXNvbHZlO1xuICBsZXQgcmVqZWN0O1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSBhc3luYyAodmFsKSA9PiB7XG4gICAgICByZXModmFsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWplY3QgPSBhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgIHJlaihlcnJvcik7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgLy9AdHMtaWdub3JlXG4gICAgcmVzb2x2ZSxcbiAgICAvL0B0cy1pZ25vcmVcbiAgICByZWplY3RcbiAgfTtcbn1cblxuLy8gbGliL2NvbXBvbmVudHMudHN4XG52YXIgUmVhY3QzID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuXG4vLyBsaWIvY29udGV4dC50c1xudmFyIFJlYWN0ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIERhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkRhdGFSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEYXRhUm91dGVyXCI7XG52YXIgRGF0YVJvdXRlclN0YXRlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5EYXRhUm91dGVyU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEYXRhUm91dGVyU3RhdGVcIjtcbnZhciBWaWV3VHJhbnNpdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZVxufSk7XG5WaWV3VHJhbnNpdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlZpZXdUcmFuc2l0aW9uXCI7XG52YXIgRmV0Y2hlcnNDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChcbiAgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuKTtcbkZldGNoZXJzQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRmV0Y2hlcnNcIjtcbnZhciBBd2FpdENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuQXdhaXRDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJBd2FpdFwiO1xudmFyIE5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChcbiAgbnVsbFxuKTtcbk5hdmlnYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJOYXZpZ2F0aW9uXCI7XG52YXIgTG9jYXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChcbiAgbnVsbFxuKTtcbkxvY2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTG9jYXRpb25cIjtcbnZhciBSb3V0ZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgb3V0bGV0OiBudWxsLFxuICBtYXRjaGVzOiBbXSxcbiAgaXNEYXRhUm91dGU6IGZhbHNlXG59KTtcblJvdXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVcIjtcbnZhciBSb3V0ZUVycm9yQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5Sb3V0ZUVycm9yQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVFcnJvclwiO1xudmFyIEVOQUJMRV9ERVZfV0FSTklOR1MgPSB0cnVlO1xuXG4vLyBsaWIvaG9va3MudHN4XG52YXIgUmVhY3QyID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuZnVuY3Rpb24gdXNlSHJlZih0bywgeyByZWxhdGl2ZSB9ID0ge30pIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlSHJlZigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuICBsZXQgeyBiYXNlbmFtZSwgbmF2aWdhdG9yIH0gPSBSZWFjdDIudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IGhhc2gsIHBhdGhuYW1lLCBzZWFyY2ggfSA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZSB9KTtcbiAgbGV0IGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWU7XG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aG5hbWVdKTtcbiAgfVxuICByZXR1cm4gbmF2aWdhdG9yLmNyZWF0ZUhyZWYoeyBwYXRobmFtZTogam9pbmVkUGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9KTtcbn1cbmZ1bmN0aW9uIHVzZUluUm91dGVyQ29udGV4dCgpIHtcbiAgcmV0dXJuIFJlYWN0Mi51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHVzZUxvY2F0aW9uKCkge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VMb2NhdGlvbigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuICByZXR1cm4gUmVhY3QyLnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5sb2NhdGlvbjtcbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb25UeXBlKCkge1xuICByZXR1cm4gUmVhY3QyLnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5uYXZpZ2F0aW9uVHlwZTtcbn1cbmZ1bmN0aW9uIHVzZU1hdGNoKHBhdHRlcm4pIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTWF0Y2goKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcbiAgbGV0IHsgcGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIHJldHVybiBSZWFjdDIudXNlTWVtbyhcbiAgICAoKSA9PiBtYXRjaFBhdGgocGF0dGVybiwgZGVjb2RlUGF0aChwYXRobmFtZSkpLFxuICAgIFtwYXRobmFtZSwgcGF0dGVybl1cbiAgKTtcbn1cbnZhciBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcgPSBgWW91IHNob3VsZCBjYWxsIG5hdmlnYXRlKCkgaW4gYSBSZWFjdC51c2VFZmZlY3QoKSwgbm90IHdoZW4geW91ciBjb21wb25lbnQgaXMgZmlyc3QgcmVuZGVyZWQuYDtcbmZ1bmN0aW9uIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoY2IpIHtcbiAgbGV0IGlzU3RhdGljID0gUmVhY3QyLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpLnN0YXRpYztcbiAgaWYgKCFpc1N0YXRpYykge1xuICAgIFJlYWN0Mi51c2VMYXlvdXRFZmZlY3QoY2IpO1xuICB9XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZSgpIHtcbiAgbGV0IHsgaXNEYXRhUm91dGUgfSA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIHJldHVybiBpc0RhdGFSb3V0ZSA/IHVzZU5hdmlnYXRlU3RhYmxlKCkgOiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCk7XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCkge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VOYXZpZ2F0ZSgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdDIudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGxldCB7IGJhc2VuYW1lLCBuYXZpZ2F0b3IgfSA9IFJlYWN0Mi51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHsgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShnZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMpKTtcbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0Mi51c2VSZWYoZmFsc2UpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gIH0pO1xuICBsZXQgbmF2aWdhdGUgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgKHRvLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIHdhcm5pbmcoYWN0aXZlUmVmLmN1cnJlbnQsIG5hdmlnYXRlRWZmZWN0V2FybmluZyk7XG4gICAgICBpZiAoIWFjdGl2ZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG5hdmlnYXRvci5nbyh0byk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgICAgICB0byxcbiAgICAgICAgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLFxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgICBvcHRpb25zLnJlbGF0aXZlID09PSBcInBhdGhcIlxuICAgICAgKTtcbiAgICAgIGlmIChkYXRhUm91dGVyQ29udGV4dCA9PSBudWxsICYmIGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgICAgIH1cbiAgICAgICghIW9wdGlvbnMucmVwbGFjZSA/IG5hdmlnYXRvci5yZXBsYWNlIDogbmF2aWdhdG9yLnB1c2gpKFxuICAgICAgICBwYXRoLFxuICAgICAgICBvcHRpb25zLnN0YXRlLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH0sXG4gICAgW1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBuYXZpZ2F0b3IsXG4gICAgICByb3V0ZVBhdGhuYW1lc0pzb24sXG4gICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgZGF0YVJvdXRlckNvbnRleHRcbiAgICBdXG4gICk7XG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cbnZhciBPdXRsZXRDb250ZXh0ID0gUmVhY3QyLmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiB1c2VPdXRsZXRDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QyLnVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VPdXRsZXQoY29udGV4dCkge1xuICBsZXQgb3V0bGV0ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KS5vdXRsZXQ7XG4gIGlmIChvdXRsZXQpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KE91dGxldENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQgfSwgb3V0bGV0KTtcbiAgfVxuICByZXR1cm4gb3V0bGV0O1xufVxuZnVuY3Rpb24gdXNlUGFyYW1zKCkge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xufVxuZnVuY3Rpb24gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlIH0gPSB7fSkge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KGdldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcykpO1xuICByZXR1cm4gUmVhY3QyLnVzZU1lbW8oXG4gICAgKCkgPT4gcmVzb2x2ZVRvKFxuICAgICAgdG8sXG4gICAgICBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksXG4gICAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgICAgcmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICAgKSxcbiAgICBbdG8sIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmVdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbkFyZykge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnKTtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZywgZGF0YVJvdXRlclN0YXRlLCBmdXR1cmUpIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlUm91dGVzKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIGxldCB7IG5hdmlnYXRvciB9ID0gUmVhY3QyLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IHBhcmVudE1hdGNoZXNbcGFyZW50TWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgbGV0IHBhcmVudFBhcmFtcyA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xuICBsZXQgcGFyZW50UGF0aG5hbWUgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50UGF0aG5hbWVCYXNlID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWVCYXNlIDogXCIvXCI7XG4gIGxldCBwYXJlbnRSb3V0ZSA9IHJvdXRlTWF0Y2ggJiYgcm91dGVNYXRjaC5yb3V0ZTtcbiAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MpIHtcbiAgICBsZXQgcGFyZW50UGF0aCA9IHBhcmVudFJvdXRlICYmIHBhcmVudFJvdXRlLnBhdGggfHwgXCJcIjtcbiAgICB3YXJuaW5nT25jZShcbiAgICAgIHBhcmVudFBhdGhuYW1lLFxuICAgICAgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqP1wiKSxcbiAgICAgIGBZb3UgcmVuZGVyZWQgZGVzY2VuZGFudCA8Um91dGVzPiAob3IgY2FsbGVkIFxcYHVzZVJvdXRlcygpXFxgKSBhdCBcIiR7cGFyZW50UGF0aG5hbWV9XCIgKHVuZGVyIDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRofVwiPikgYnV0IHRoZSBwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXCIqXCIuIFRoaXMgbWVhbnMgaWYgeW91IG5hdmlnYXRlIGRlZXBlciwgdGhlIHBhcmVudCB3b24ndCBtYXRjaCBhbnltb3JlIGFuZCB0aGVyZWZvcmUgdGhlIGNoaWxkIHJvdXRlcyB3aWxsIG5ldmVyIHJlbmRlci5cblxuUGxlYXNlIGNoYW5nZSB0aGUgcGFyZW50IDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRofVwiPiB0byA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aCA9PT0gXCIvXCIgPyBcIipcIiA6IGAke3BhcmVudFBhdGh9LypgfVwiPi5gXG4gICAgKTtcbiAgfVxuICBsZXQgbG9jYXRpb25Gcm9tQ29udGV4dCA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBsb2NhdGlvbjtcbiAgaWYgKGxvY2F0aW9uQXJnKSB7XG4gICAgbGV0IHBhcnNlZExvY2F0aW9uQXJnID0gdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHwgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWU/LnN0YXJ0c1dpdGgocGFyZW50UGF0aG5hbWVCYXNlKSxcbiAgICAgIGBXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIFxcYDxSb3V0ZXMgbG9jYXRpb24+XFxgIG9yIFxcYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKVxcYCwgdGhlIGxvY2F0aW9uIHBhdGhuYW1lIG11c3QgYmVnaW4gd2l0aCB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQgYnkgYWxsIHBhcmVudCByb3V0ZXMuIFRoZSBjdXJyZW50IHBhdGhuYW1lIGJhc2UgaXMgXCIke3BhcmVudFBhdGhuYW1lQmFzZX1cIiBidXQgcGF0aG5hbWUgXCIke3BhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lfVwiIHdhcyBnaXZlbiBpbiB0aGUgXFxgbG9jYXRpb25cXGAgcHJvcC5gXG4gICAgKTtcbiAgICBsb2NhdGlvbiA9IHBhcnNlZExvY2F0aW9uQXJnO1xuICB9IGVsc2Uge1xuICAgIGxvY2F0aW9uID0gbG9jYXRpb25Gcm9tQ29udGV4dDtcbiAgfVxuICBsZXQgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIjtcbiAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWU7XG4gIGlmIChwYXJlbnRQYXRobmFtZUJhc2UgIT09IFwiL1wiKSB7XG4gICAgbGV0IHBhcmVudFNlZ21lbnRzID0gcGFyZW50UGF0aG5hbWVCYXNlLnJlcGxhY2UoL15cXC8vLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgbGV0IHNlZ21lbnRzID0gcGF0aG5hbWUucmVwbGFjZSgvXlxcLy8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICByZW1haW5pbmdQYXRobmFtZSA9IFwiL1wiICsgc2VnbWVudHMuc2xpY2UocGFyZW50U2VnbWVudHMubGVuZ3RoKS5qb2luKFwiL1wiKTtcbiAgfVxuICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlcywgeyBwYXRobmFtZTogcmVtYWluaW5nUGF0aG5hbWUgfSk7XG4gIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTKSB7XG4gICAgd2FybmluZyhcbiAgICAgIHBhcmVudFJvdXRlIHx8IG1hdGNoZXMgIT0gbnVsbCxcbiAgICAgIGBObyByb3V0ZXMgbWF0Y2hlZCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGBcbiAgICApO1xuICAgIHdhcm5pbmcoXG4gICAgICBtYXRjaGVzID09IG51bGwgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmVsZW1lbnQgIT09IHZvaWQgMCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuQ29tcG9uZW50ICE9PSB2b2lkIDAgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmxhenkgIT09IHZvaWQgMCxcbiAgICAgIGBNYXRjaGVkIGxlYWYgcm91dGUgYXQgbG9jYXRpb24gXCIke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofSR7bG9jYXRpb24uaGFzaH1cIiBkb2VzIG5vdCBoYXZlIGFuIGVsZW1lbnQgb3IgQ29tcG9uZW50LiBUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIG51bGwgdmFsdWUgYnkgZGVmYXVsdCByZXN1bHRpbmcgaW4gYW4gXCJlbXB0eVwiIHBhZ2UuYFxuICAgICk7XG4gIH1cbiAgbGV0IHJlbmRlcmVkTWF0Y2hlcyA9IF9yZW5kZXJNYXRjaGVzKFxuICAgIG1hdGNoZXMgJiYgbWF0Y2hlcy5tYXAoXG4gICAgICAobWF0Y2gpID0+IE9iamVjdC5hc3NpZ24oe30sIG1hdGNoLCB7XG4gICAgICAgIHBhcmFtczogT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50UGFyYW1zLCBtYXRjaC5wYXJhbXMpLFxuICAgICAgICBwYXRobmFtZTogam9pblBhdGhzKFtcbiAgICAgICAgICBwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgICAgICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICAgICAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWUpLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVcbiAgICAgICAgXSksXG4gICAgICAgIHBhdGhuYW1lQmFzZTogbWF0Y2gucGF0aG5hbWVCYXNlID09PSBcIi9cIiA/IHBhcmVudFBhdGhuYW1lQmFzZSA6IGpvaW5QYXRocyhbXG4gICAgICAgICAgcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgICAgICAgIC8vIFJlLWVuY29kZSBwYXRobmFtZXMgdGhhdCB3ZXJlIGRlY29kZWQgaW5zaWRlIG1hdGNoUm91dGVzXG4gICAgICAgICAgbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKG1hdGNoLnBhdGhuYW1lQmFzZSkucGF0aG5hbWUgOiBtYXRjaC5wYXRobmFtZUJhc2VcbiAgICAgICAgXSlcbiAgICAgIH0pXG4gICAgKSxcbiAgICBwYXJlbnRNYXRjaGVzLFxuICAgIGRhdGFSb3V0ZXJTdGF0ZSxcbiAgICBmdXR1cmVcbiAgKTtcbiAgaWYgKGxvY2F0aW9uQXJnICYmIHJlbmRlcmVkTWF0Y2hlcykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBcIi9cIixcbiAgICAgICAgICAgIHNlYXJjaDogXCJcIixcbiAgICAgICAgICAgIGhhc2g6IFwiXCIsXG4gICAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAgICAgICAgICAgIGtleTogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAuLi5sb2NhdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF2aWdhdGlvblR5cGU6IFwiUE9QXCIgLyogUG9wICovXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW5kZXJlZE1hdGNoZXNcbiAgICApO1xuICB9XG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXM7XG59XG5mdW5jdGlvbiBEZWZhdWx0RXJyb3JDb21wb25lbnQoKSB7XG4gIGxldCBlcnJvciA9IHVzZVJvdXRlRXJyb3IoKTtcbiAgbGV0IG1lc3NhZ2UgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBgJHtlcnJvci5zdGF0dXN9ICR7ZXJyb3Iuc3RhdHVzVGV4dH1gIDogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG4gIGxldCBzdGFjayA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IG51bGw7XG4gIGxldCBsaWdodGdyZXkgPSBcInJnYmEoMjAwLDIwMCwyMDAsIDAuNSlcIjtcbiAgbGV0IHByZVN0eWxlcyA9IHsgcGFkZGluZzogXCIwLjVyZW1cIiwgYmFja2dyb3VuZENvbG9yOiBsaWdodGdyZXkgfTtcbiAgbGV0IGNvZGVTdHlsZXMgPSB7IHBhZGRpbmc6IFwiMnB4IDRweFwiLCBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleSB9O1xuICBsZXQgZGV2SW5mbyA9IG51bGw7XG4gIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiRXJyb3IgaGFuZGxlZCBieSBSZWFjdCBSb3V0ZXIgZGVmYXVsdCBFcnJvckJvdW5kYXJ5OlwiLFxuICAgICAgZXJyb3JcbiAgICApO1xuICAgIGRldkluZm8gPSAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUmVhY3QyLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiXFx1ezFGNEJGfSBIZXkgZGV2ZWxvcGVyIFxcdXsxRjQ0Qn1cIiksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgXCJZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnMgYnkgcHJvdmlkaW5nIHlvdXIgb3duIFwiLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHsgc3R5bGU6IGNvZGVTdHlsZXMgfSwgXCJFcnJvckJvdW5kYXJ5XCIpLCBcIiBvclwiLCBcIiBcIiwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7IHN0eWxlOiBjb2RlU3R5bGVzIH0sIFwiZXJyb3JFbGVtZW50XCIpLCBcIiBwcm9wIG9uIHlvdXIgcm91dGUuXCIpKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJlYWN0Mi5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiaDJcIiwgbnVsbCwgXCJVbmV4cGVjdGVkIEFwcGxpY2F0aW9uIEVycm9yIVwiKSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiaDNcIiwgeyBzdHlsZTogeyBmb250U3R5bGU6IFwiaXRhbGljXCIgfSB9LCBtZXNzYWdlKSwgc3RhY2sgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgeyBzdHlsZTogcHJlU3R5bGVzIH0sIHN0YWNrKSA6IG51bGwsIGRldkluZm8pO1xufVxudmFyIGRlZmF1bHRFcnJvckVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoRGVmYXVsdEVycm9yQ29tcG9uZW50LCBudWxsKTtcbnZhciBSZW5kZXJFcnJvckJvdW5kYXJ5ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdDIuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uLFxuICAgICAgZXJyb3I6IHByb3BzLmVycm9yXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24gfHwgc3RhdGUucmV2YWxpZGF0aW9uICE9PSBcImlkbGVcIiAmJiBwcm9wcy5yZXZhbGlkYXRpb24gPT09IFwiaWRsZVwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogcHJvcHMuZXJyb3IsXG4gICAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3IgIT09IHZvaWQgMCA/IHByb3BzLmVycm9yIDogc3RhdGUuZXJyb3IsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbiB8fCBzdGF0ZS5yZXZhbGlkYXRpb25cbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJSZWFjdCBSb3V0ZXIgY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLFxuICAgICAgZXJyb3IsXG4gICAgICBlcnJvckluZm9cbiAgICApO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvciAhPT0gdm9pZCAwID8gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJvdXRlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5wcm9wcy5yb3V0ZUNvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgUm91dGVFcnJvckNvbnRleHQuUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLmVycm9yLFxuICAgICAgICBjaGlsZHJlbjogdGhpcy5wcm9wcy5jb21wb25lbnRcbiAgICAgIH1cbiAgICApKSA6IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn07XG5mdW5jdGlvbiBSZW5kZXJlZFJvdXRlKHsgcm91dGVDb250ZXh0LCBtYXRjaCwgY2hpbGRyZW4gfSkge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdDIudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGlmIChkYXRhUm91dGVyQ29udGV4dCAmJiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWMgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dCAmJiAobWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkpKSB7XG4gICAgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUm91dGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiByb3V0ZUNvbnRleHQgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gX3JlbmRlck1hdGNoZXMobWF0Y2hlcywgcGFyZW50TWF0Y2hlcyA9IFtdLCBkYXRhUm91dGVyU3RhdGUgPSBudWxsLCBmdXR1cmUgPSBudWxsKSB7XG4gIGlmIChtYXRjaGVzID09IG51bGwpIHtcbiAgICBpZiAoIWRhdGFSb3V0ZXJTdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhUm91dGVyU3RhdGUuZXJyb3JzKSB7XG4gICAgICBtYXRjaGVzID0gZGF0YVJvdXRlclN0YXRlLm1hdGNoZXM7XG4gICAgfSBlbHNlIGlmIChwYXJlbnRNYXRjaGVzLmxlbmd0aCA9PT0gMCAmJiAhZGF0YVJvdXRlclN0YXRlLmluaXRpYWxpemVkICYmIGRhdGFSb3V0ZXJTdGF0ZS5tYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1hdGNoZXMgPSBkYXRhUm91dGVyU3RhdGUubWF0Y2hlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBtYXRjaGVzO1xuICBsZXQgZXJyb3JzID0gZGF0YVJvdXRlclN0YXRlPy5lcnJvcnM7XG4gIGlmIChlcnJvcnMgIT0gbnVsbCkge1xuICAgIGxldCBlcnJvckluZGV4ID0gcmVuZGVyZWRNYXRjaGVzLmZpbmRJbmRleChcbiAgICAgIChtKSA9PiBtLnJvdXRlLmlkICYmIGVycm9ycz8uW20ucm91dGUuaWRdICE9PSB2b2lkIDBcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgIGVycm9ySW5kZXggPj0gMCxcbiAgICAgIGBDb3VsZCBub3QgZmluZCBhIG1hdGNoaW5nIHJvdXRlIGZvciBlcnJvcnMgb24gcm91dGUgSURzOiAke09iamVjdC5rZXlzKFxuICAgICAgICBlcnJvcnNcbiAgICAgICkuam9pbihcIixcIil9YFxuICAgICk7XG4gICAgcmVuZGVyZWRNYXRjaGVzID0gcmVuZGVyZWRNYXRjaGVzLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIE1hdGgubWluKHJlbmRlcmVkTWF0Y2hlcy5sZW5ndGgsIGVycm9ySW5kZXggKyAxKVxuICAgICk7XG4gIH1cbiAgbGV0IHJlbmRlckZhbGxiYWNrID0gZmFsc2U7XG4gIGxldCBmYWxsYmFja0luZGV4ID0gLTE7XG4gIGlmIChkYXRhUm91dGVyU3RhdGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcmVkTWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG1hdGNoID0gcmVuZGVyZWRNYXRjaGVzW2ldO1xuICAgICAgaWYgKG1hdGNoLnJvdXRlLkh5ZHJhdGVGYWxsYmFjayB8fCBtYXRjaC5yb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50KSB7XG4gICAgICAgIGZhbGxiYWNrSW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLnJvdXRlLmlkKSB7XG4gICAgICAgIGxldCB7IGxvYWRlckRhdGEsIGVycm9yczogZXJyb3JzMiB9ID0gZGF0YVJvdXRlclN0YXRlO1xuICAgICAgICBsZXQgbmVlZHNUb1J1bkxvYWRlciA9IG1hdGNoLnJvdXRlLmxvYWRlciAmJiAhbG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShtYXRjaC5yb3V0ZS5pZCkgJiYgKCFlcnJvcnMyIHx8IGVycm9yczJbbWF0Y2gucm91dGUuaWRdID09PSB2b2lkIDApO1xuICAgICAgICBpZiAobWF0Y2gucm91dGUubGF6eSB8fCBuZWVkc1RvUnVuTG9hZGVyKSB7XG4gICAgICAgICAgcmVuZGVyRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgIGlmIChmYWxsYmFja0luZGV4ID49IDApIHtcbiAgICAgICAgICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBmYWxsYmFja0luZGV4ICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcmVkTWF0Y2hlcyA9IFtyZW5kZXJlZE1hdGNoZXNbMF1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyZWRNYXRjaGVzLnJlZHVjZVJpZ2h0KChvdXRsZXQsIG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGxldCBlcnJvcjtcbiAgICBsZXQgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gZmFsc2U7XG4gICAgbGV0IGVycm9yRWxlbWVudCA9IG51bGw7XG4gICAgbGV0IGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBudWxsO1xuICAgIGlmIChkYXRhUm91dGVyU3RhdGUpIHtcbiAgICAgIGVycm9yID0gZXJyb3JzICYmIG1hdGNoLnJvdXRlLmlkID8gZXJyb3JzW21hdGNoLnJvdXRlLmlkXSA6IHZvaWQgMDtcbiAgICAgIGVycm9yRWxlbWVudCA9IG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBkZWZhdWx0RXJyb3JFbGVtZW50O1xuICAgICAgaWYgKHJlbmRlckZhbGxiYWNrKSB7XG4gICAgICAgIGlmIChmYWxsYmFja0luZGV4IDwgMCAmJiBpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHdhcm5pbmdPbmNlKFxuICAgICAgICAgICAgXCJyb3V0ZS1mYWxsYmFja1wiLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBcIk5vIGBIeWRyYXRlRmFsbGJhY2tgIGVsZW1lbnQgcHJvdmlkZWQgdG8gcmVuZGVyIGR1cmluZyBpbml0aWFsIGh5ZHJhdGlvblwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZhbGxiYWNrSW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50ID0gbWF0Y2gucm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBtYXRjaGVzMiA9IHBhcmVudE1hdGNoZXMuY29uY2F0KHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBpbmRleCArIDEpKTtcbiAgICBsZXQgZ2V0Q2hpbGRyZW4gPSAoKSA9PiB7XG4gICAgICBsZXQgY2hpbGRyZW47XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBlcnJvckVsZW1lbnQ7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjaykge1xuICAgICAgICBjaGlsZHJlbiA9IGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLkNvbXBvbmVudCkge1xuICAgICAgICBjaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChtYXRjaC5yb3V0ZS5Db21wb25lbnQsIG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC5yb3V0ZS5lbGVtZW50KSB7XG4gICAgICAgIGNoaWxkcmVuID0gbWF0Y2gucm91dGUuZWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuID0gb3V0bGV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgICAgUmVuZGVyZWRSb3V0ZSxcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIHJvdXRlQ29udGV4dDoge1xuICAgICAgICAgICAgb3V0bGV0LFxuICAgICAgICAgICAgbWF0Y2hlczogbWF0Y2hlczIsXG4gICAgICAgICAgICBpc0RhdGFSb3V0ZTogZGF0YVJvdXRlclN0YXRlICE9IG51bGxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gZGF0YVJvdXRlclN0YXRlICYmIChtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5IHx8IG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBpbmRleCA9PT0gMCkgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBSZW5kZXJFcnJvckJvdW5kYXJ5LFxuICAgICAge1xuICAgICAgICBsb2NhdGlvbjogZGF0YVJvdXRlclN0YXRlLmxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRpb246IGRhdGFSb3V0ZXJTdGF0ZS5yZXZhbGlkYXRpb24sXG4gICAgICAgIGNvbXBvbmVudDogZXJyb3JFbGVtZW50LFxuICAgICAgICBlcnJvcixcbiAgICAgICAgY2hpbGRyZW46IGdldENoaWxkcmVuKCksXG4gICAgICAgIHJvdXRlQ29udGV4dDogeyBvdXRsZXQ6IG51bGwsIG1hdGNoZXM6IG1hdGNoZXMyLCBpc0RhdGFSb3V0ZTogdHJ1ZSB9XG4gICAgICB9XG4gICAgKSA6IGdldENoaWxkcmVuKCk7XG4gIH0sIG51bGwpO1xufVxuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkge1xuICByZXR1cm4gYCR7aG9va05hbWV9IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9lbi9tYWluL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5gO1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWUpIHtcbiAgbGV0IGN0eCA9IFJlYWN0Mi51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaW52YXJpYW50KGN0eCwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlKGhvb2tOYW1lKSB7XG4gIGxldCBzdGF0ZSA9IFJlYWN0Mi51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQoc3RhdGUsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlUm91dGVDb250ZXh0KGhvb2tOYW1lKSB7XG4gIGxldCByb3V0ZSA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGludmFyaWFudChyb3V0ZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gcm91dGU7XG59XG5mdW5jdGlvbiB1c2VDdXJyZW50Um91dGVJZChob29rTmFtZSkge1xuICBsZXQgcm91dGUgPSB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWUpO1xuICBsZXQgdGhpc1JvdXRlID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBpbnZhcmlhbnQoXG4gICAgdGhpc1JvdXRlLnJvdXRlLmlkLFxuICAgIGAke2hvb2tOYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIHJvdXRlcyB0aGF0IGNvbnRhaW4gYSB1bmlxdWUgXCJpZFwiYFxuICApO1xuICByZXR1cm4gdGhpc1JvdXRlLnJvdXRlLmlkO1xufVxuZnVuY3Rpb24gdXNlUm91dGVJZCgpIHtcbiAgcmV0dXJuIHVzZUN1cnJlbnRSb3V0ZUlkKFwidXNlUm91dGVJZFwiIC8qIFVzZVJvdXRlSWQgKi8pO1xufVxuZnVuY3Rpb24gdXNlTmF2aWdhdGlvbigpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlTmF2aWdhdGlvblwiIC8qIFVzZU5hdmlnYXRpb24gKi8pO1xuICByZXR1cm4gc3RhdGUubmF2aWdhdGlvbjtcbn1cbmZ1bmN0aW9uIHVzZVJldmFsaWRhdG9yKCkge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSB1c2VEYXRhUm91dGVyQ29udGV4dChcInVzZVJldmFsaWRhdG9yXCIgLyogVXNlUmV2YWxpZGF0b3IgKi8pO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VSZXZhbGlkYXRvclwiIC8qIFVzZVJldmFsaWRhdG9yICovKTtcbiAgbGV0IHJldmFsaWRhdGUgPSBSZWFjdDIudXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5yZXZhbGlkYXRlKCk7XG4gIH0sIFtkYXRhUm91dGVyQ29udGV4dC5yb3V0ZXJdKTtcbiAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+ICh7IHJldmFsaWRhdGUsIHN0YXRlOiBzdGF0ZS5yZXZhbGlkYXRpb24gfSksXG4gICAgW3JldmFsaWRhdGUsIHN0YXRlLnJldmFsaWRhdGlvbl1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU1hdGNoZXMoKSB7XG4gIGxldCB7IG1hdGNoZXMsIGxvYWRlckRhdGEgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcbiAgICBcInVzZU1hdGNoZXNcIiAvKiBVc2VNYXRjaGVzICovXG4gICk7XG4gIHJldHVybiBSZWFjdDIudXNlTWVtbyhcbiAgICAoKSA9PiBtYXRjaGVzLm1hcCgobSkgPT4gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobSwgbG9hZGVyRGF0YSkpLFxuICAgIFttYXRjaGVzLCBsb2FkZXJEYXRhXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTG9hZGVyRGF0YSgpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlTG9hZGVyRGF0YVwiIC8qIFVzZUxvYWRlckRhdGEgKi8pO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKFwidXNlTG9hZGVyRGF0YVwiIC8qIFVzZUxvYWRlckRhdGEgKi8pO1xuICByZXR1cm4gc3RhdGUubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlTG9hZGVyRGF0YShyb3V0ZUlkKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZVJvdXRlTG9hZGVyRGF0YVwiIC8qIFVzZVJvdXRlTG9hZGVyRGF0YSAqLyk7XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuZnVuY3Rpb24gdXNlQWN0aW9uRGF0YSgpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlQWN0aW9uRGF0YVwiIC8qIFVzZUFjdGlvbkRhdGEgKi8pO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKFwidXNlTG9hZGVyRGF0YVwiIC8qIFVzZUxvYWRlckRhdGEgKi8pO1xuICByZXR1cm4gc3RhdGUuYWN0aW9uRGF0YSA/IHN0YXRlLmFjdGlvbkRhdGFbcm91dGVJZF0gOiB2b2lkIDA7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZUVycm9yKCkge1xuICBsZXQgZXJyb3IgPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUVycm9yQ29udGV4dCk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZVJvdXRlRXJyb3JcIiAvKiBVc2VSb3V0ZUVycm9yICovKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChcInVzZVJvdXRlRXJyb3JcIiAvKiBVc2VSb3V0ZUVycm9yICovKTtcbiAgaWYgKGVycm9yICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmVycm9ycz8uW3JvdXRlSWRdO1xufVxuZnVuY3Rpb24gdXNlQXN5bmNWYWx1ZSgpIHtcbiAgbGV0IHZhbHVlID0gUmVhY3QyLnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlPy5fZGF0YTtcbn1cbmZ1bmN0aW9uIHVzZUFzeW5jRXJyb3IoKSB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0Mi51c2VDb250ZXh0KEF3YWl0Q29udGV4dCk7XG4gIHJldHVybiB2YWx1ZT8uX2Vycm9yO1xufVxudmFyIGJsb2NrZXJJZCA9IDA7XG5mdW5jdGlvbiB1c2VCbG9ja2VyKHNob3VsZEJsb2NrKSB7XG4gIGxldCB7IHJvdXRlciwgYmFzZW5hbWUgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KFwidXNlQmxvY2tlclwiIC8qIFVzZUJsb2NrZXIgKi8pO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VCbG9ja2VyXCIgLyogVXNlQmxvY2tlciAqLyk7XG4gIGxldCBbYmxvY2tlcktleSwgc2V0QmxvY2tlcktleV0gPSBSZWFjdDIudXNlU3RhdGUoXCJcIik7XG4gIGxldCBibG9ja2VyRnVuY3Rpb24gPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgKGFyZykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBzaG91bGRCbG9jayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiAhIXNob3VsZEJsb2NrO1xuICAgICAgfVxuICAgICAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikge1xuICAgICAgICByZXR1cm4gc2hvdWxkQmxvY2soYXJnKTtcbiAgICAgIH1cbiAgICAgIGxldCB7IGN1cnJlbnRMb2NhdGlvbiwgbmV4dExvY2F0aW9uLCBoaXN0b3J5QWN0aW9uIH0gPSBhcmc7XG4gICAgICByZXR1cm4gc2hvdWxkQmxvY2soe1xuICAgICAgICBjdXJyZW50TG9jYXRpb246IHtcbiAgICAgICAgICAuLi5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgcGF0aG5hbWU6IHN0cmlwQmFzZW5hbWUoY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgIH0sXG4gICAgICAgIG5leHRMb2NhdGlvbjoge1xuICAgICAgICAgIC4uLm5leHRMb2NhdGlvbixcbiAgICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShuZXh0TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBuZXh0TG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgaGlzdG9yeUFjdGlvblxuICAgICAgfSk7XG4gICAgfSxcbiAgICBbYmFzZW5hbWUsIHNob3VsZEJsb2NrXVxuICApO1xuICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQga2V5ID0gU3RyaW5nKCsrYmxvY2tlcklkKTtcbiAgICBzZXRCbG9ja2VyS2V5KGtleSk7XG4gICAgcmV0dXJuICgpID0+IHJvdXRlci5kZWxldGVCbG9ja2VyKGtleSk7XG4gIH0sIFtyb3V0ZXJdKTtcbiAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXJLZXkgIT09IFwiXCIpIHtcbiAgICAgIHJvdXRlci5nZXRCbG9ja2VyKGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbik7XG4gICAgfVxuICB9LCBbcm91dGVyLCBibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dKTtcbiAgcmV0dXJuIGJsb2NrZXJLZXkgJiYgc3RhdGUuYmxvY2tlcnMuaGFzKGJsb2NrZXJLZXkpID8gc3RhdGUuYmxvY2tlcnMuZ2V0KGJsb2NrZXJLZXkpIDogSURMRV9CTE9DS0VSO1xufVxuZnVuY3Rpb24gdXNlTmF2aWdhdGVTdGFibGUoKSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoXCJ1c2VOYXZpZ2F0ZVwiIC8qIFVzZU5hdmlnYXRlU3RhYmxlICovKTtcbiAgbGV0IGlkID0gdXNlQ3VycmVudFJvdXRlSWQoXCJ1c2VOYXZpZ2F0ZVwiIC8qIFVzZU5hdmlnYXRlU3RhYmxlICovKTtcbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0Mi51c2VSZWYoZmFsc2UpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gIH0pO1xuICBsZXQgbmF2aWdhdGUgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHRvLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIHdhcm5pbmcoYWN0aXZlUmVmLmN1cnJlbnQsIG5hdmlnYXRlRWZmZWN0V2FybmluZyk7XG4gICAgICBpZiAoIWFjdGl2ZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCByb3V0ZXIubmF2aWdhdGUodG8sIHsgZnJvbVJvdXRlSWQ6IGlkLCAuLi5vcHRpb25zIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3JvdXRlciwgaWRdXG4gICk7XG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cbnZhciBhbHJlYWR5V2FybmVkID0ge307XG5mdW5jdGlvbiB3YXJuaW5nT25jZShrZXksIGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kICYmICFhbHJlYWR5V2FybmVkW2tleV0pIHtcbiAgICBhbHJlYWR5V2FybmVkW2tleV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpO1xuICB9XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS93YXJuaW5ncy50c1xudmFyIGFscmVhZHlXYXJuZWQyID0ge307XG5mdW5jdGlvbiB3YXJuT25jZShjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24gJiYgIWFscmVhZHlXYXJuZWQyW21lc3NhZ2VdKSB7XG4gICAgYWxyZWFkeVdhcm5lZDJbbWVzc2FnZV0gPSB0cnVlO1xuICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgfVxufVxuXG4vLyBsaWIvY29tcG9uZW50cy50c3hcbmZ1bmN0aW9uIG1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSkge1xuICBsZXQgdXBkYXRlcyA9IHtcbiAgICAvLyBOb3RlOiB0aGlzIGNoZWNrIGFsc28gb2NjdXJzIGluIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiBzbyB1cGRhdGVcbiAgICAvLyB0aGVyZSBpZiB5b3UgY2hhbmdlIHRoaXMgLS0gcGxlYXNlIGFuZCB0aGFuayB5b3UhXG4gICAgaGFzRXJyb3JCb3VuZGFyeTogcm91dGUuaGFzRXJyb3JCb3VuZGFyeSB8fCByb3V0ZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgcm91dGUuZXJyb3JFbGVtZW50ICE9IG51bGxcbiAgfTtcbiAgaWYgKHJvdXRlLkNvbXBvbmVudCkge1xuICAgIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTKSB7XG4gICAgICBpZiAocm91dGUuZWxlbWVudCkge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBDb21wb25lbnRgIGFuZCBgZWxlbWVudGAgb24geW91ciByb3V0ZSAtIGBDb21wb25lbnRgIHdpbGwgYmUgdXNlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGVsZW1lbnQ6IFJlYWN0My5jcmVhdGVFbGVtZW50KHJvdXRlLkNvbXBvbmVudCksXG4gICAgICBDb21wb25lbnQ6IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIGlmIChyb3V0ZS5IeWRyYXRlRmFsbGJhY2spIHtcbiAgICBpZiAoRU5BQkxFX0RFVl9XQVJOSU5HUykge1xuICAgICAgaWYgKHJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgSHlkcmF0ZUZhbGxiYWNrYCBhbmQgYGh5ZHJhdGVGYWxsYmFja0VsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBgSHlkcmF0ZUZhbGxiYWNrYCB3aWxsIGJlIHVzZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50OiBSZWFjdDMuY3JlYXRlRWxlbWVudChyb3V0ZS5IeWRyYXRlRmFsbGJhY2spLFxuICAgICAgSHlkcmF0ZUZhbGxiYWNrOiB2b2lkIDBcbiAgICB9KTtcbiAgfVxuICBpZiAocm91dGUuRXJyb3JCb3VuZGFyeSkge1xuICAgIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTKSB7XG4gICAgICBpZiAocm91dGUuZXJyb3JFbGVtZW50KSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYEVycm9yQm91bmRhcnlgIGFuZCBgZXJyb3JFbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gYEVycm9yQm91bmRhcnlgIHdpbGwgYmUgdXNlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGVycm9yRWxlbWVudDogUmVhY3QzLmNyZWF0ZUVsZW1lbnQocm91dGUuRXJyb3JCb3VuZGFyeSksXG4gICAgICBFcnJvckJvdW5kYXJ5OiB2b2lkIDBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdXBkYXRlcztcbn1cbnZhciBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMgPSBbXG4gIFwiSHlkcmF0ZUZhbGxiYWNrXCIsXG4gIFwiaHlkcmF0ZUZhbGxiYWNrRWxlbWVudFwiXG5dO1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5Um91dGVyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cz8uYmFzZW5hbWUsXG4gICAgdW5zdGFibGVfZ2V0Q29udGV4dDogb3B0cz8udW5zdGFibGVfZ2V0Q29udGV4dCxcbiAgICBmdXR1cmU6IG9wdHM/LmZ1dHVyZSxcbiAgICBoaXN0b3J5OiBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzOiBvcHRzPy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleDogb3B0cz8uaW5pdGlhbEluZGV4XG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cz8uaHlkcmF0aW9uRGF0YSxcbiAgICByb3V0ZXMsXG4gICAgaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICBkYXRhU3RyYXRlZ3k6IG9wdHM/LmRhdGFTdHJhdGVneSxcbiAgICBwYXRjaFJvdXRlc09uTmF2aWdhdGlvbjogb3B0cz8ucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25cbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxudmFyIERlZmVycmVkID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBcInJlc29sdmVkXCI7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnJlamVjdCA9IChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gUm91dGVyUHJvdmlkZXIoe1xuICByb3V0ZXIsXG4gIGZsdXNoU3luYzogcmVhY3REb21GbHVzaFN5bmNJbXBsXG59KSB7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdDMudXNlU3RhdGUocm91dGVyLnN0YXRlKTtcbiAgbGV0IFtwZW5kaW5nU3RhdGUsIHNldFBlbmRpbmdTdGF0ZV0gPSBSZWFjdDMudXNlU3RhdGUoKTtcbiAgbGV0IFt2dENvbnRleHQsIHNldFZ0Q29udGV4dF0gPSBSZWFjdDMudXNlU3RhdGUoe1xuICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2VcbiAgfSk7XG4gIGxldCBbcmVuZGVyRGZkLCBzZXRSZW5kZXJEZmRdID0gUmVhY3QzLnVzZVN0YXRlKCk7XG4gIGxldCBbdHJhbnNpdGlvbiwgc2V0VHJhbnNpdGlvbl0gPSBSZWFjdDMudXNlU3RhdGUoKTtcbiAgbGV0IFtpbnRlcnJ1cHRpb24sIHNldEludGVycnVwdGlvbl0gPSBSZWFjdDMudXNlU3RhdGUoKTtcbiAgbGV0IGZldGNoZXJEYXRhID0gUmVhY3QzLnVzZVJlZigvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgIChuZXdTdGF0ZSwgeyBkZWxldGVkRmV0Y2hlcnMsIGZsdXNoU3luYywgdmlld1RyYW5zaXRpb25PcHRzIH0pID0+IHtcbiAgICAgIG5ld1N0YXRlLmZldGNoZXJzLmZvckVhY2goKGZldGNoZXIsIGtleSkgPT4ge1xuICAgICAgICBpZiAoZmV0Y2hlci5kYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBmZXRjaGVyRGF0YS5jdXJyZW50LnNldChrZXksIGZldGNoZXIuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZGVsZXRlZEZldGNoZXJzLmZvckVhY2goKGtleSkgPT4gZmV0Y2hlckRhdGEuY3VycmVudC5kZWxldGUoa2V5KSk7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgZmx1c2hTeW5jID09PSBmYWxzZSB8fCByZWFjdERvbUZsdXNoU3luY0ltcGwgIT0gbnVsbCxcbiAgICAgICAgJ1lvdSBwcm92aWRlZCB0aGUgYGZsdXNoU3luY2Agb3B0aW9uIHRvIGEgcm91dGVyIHVwZGF0ZSwgYnV0IHlvdSBhcmUgbm90IHVzaW5nIHRoZSBgPFJvdXRlclByb3ZpZGVyPmAgZnJvbSBgcmVhY3Qtcm91dGVyL2RvbWAgc28gYFJlYWN0RE9NLmZsdXNoU3luYygpYCBpcyB1bmF2YWlsYWJsZS4gIFBsZWFzZSB1cGRhdGUgeW91ciBhcHAgdG8gYGltcG9ydCB7IFJvdXRlclByb3ZpZGVyIH0gZnJvbSBcInJlYWN0LXJvdXRlci9kb21cImAgYW5kIGVuc3VyZSB5b3UgaGF2ZSBgcmVhY3QtZG9tYCBpbnN0YWxsZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHVzZSB0aGUgYGZsdXNoU3luY2Agb3B0aW9uLidcbiAgICAgICk7XG4gICAgICBsZXQgaXNWaWV3VHJhbnNpdGlvbkF2YWlsYWJsZSA9IHJvdXRlci53aW5kb3cgIT0gbnVsbCAmJiByb3V0ZXIud2luZG93LmRvY3VtZW50ICE9IG51bGwgJiYgdHlwZW9mIHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbiA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9PSBudWxsIHx8IGlzVmlld1RyYW5zaXRpb25BdmFpbGFibGUsXG4gICAgICAgIFwiWW91IHByb3ZpZGVkIHRoZSBgdmlld1RyYW5zaXRpb25gIG9wdGlvbiB0byBhIHJvdXRlciB1cGRhdGUsIGJ1dCB5b3UgZG8gbm90IGFwcGVhciB0byBiZSBydW5uaW5nIGluIGEgRE9NIGVudmlyb25tZW50IGFzIGB3aW5kb3cuc3RhcnRWaWV3VHJhbnNpdGlvbmAgaXMgbm90IGF2YWlsYWJsZS5cIlxuICAgICAgKTtcbiAgICAgIGlmICghdmlld1RyYW5zaXRpb25PcHRzIHx8ICFpc1ZpZXdUcmFuc2l0aW9uQXZhaWxhYmxlKSB7XG4gICAgICAgIGlmIChyZWFjdERvbUZsdXNoU3luY0ltcGwgJiYgZmx1c2hTeW5jKSB7XG4gICAgICAgICAgcmVhY3REb21GbHVzaFN5bmNJbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJlYWN0My5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWN0RG9tRmx1c2hTeW5jSW1wbCAmJiBmbHVzaFN5bmMpIHtcbiAgICAgICAgcmVhY3REb21GbHVzaFN5bmNJbXBsKCgpID0+IHtcbiAgICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgICAgcmVuZGVyRGZkICYmIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLnNraXBUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgICAgICBmbHVzaFN5bmM6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0ID0gcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICByZWFjdERvbUZsdXNoU3luY0ltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0LmZpbmlzaGVkLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCgoKSA9PiB7XG4gICAgICAgICAgICBzZXRSZW5kZXJEZmQodm9pZCAwKTtcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb24odm9pZCAwKTtcbiAgICAgICAgICAgIHNldFBlbmRpbmdTdGF0ZSh2b2lkIDApO1xuICAgICAgICAgICAgc2V0VnRDb250ZXh0KHsgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCgoKSA9PiBzZXRUcmFuc2l0aW9uKHQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgcmVuZGVyRGZkICYmIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgICAgIHRyYW5zaXRpb24uc2tpcFRyYW5zaXRpb24oKTtcbiAgICAgICAgc2V0SW50ZXJydXB0aW9uKHtcbiAgICAgICAgICBzdGF0ZTogbmV3U3RhdGUsXG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFBlbmRpbmdTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICAgIGZsdXNoU3luYzogZmFsc2UsXG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtyb3V0ZXIud2luZG93LCByZWFjdERvbUZsdXNoU3luY0ltcGwsIHRyYW5zaXRpb24sIHJlbmRlckRmZF1cbiAgKTtcbiAgUmVhY3QzLnVzZUxheW91dEVmZmVjdCgoKSA9PiByb3V0ZXIuc3Vic2NyaWJlKHNldFN0YXRlKSwgW3JvdXRlciwgc2V0U3RhdGVdKTtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHZ0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcgJiYgIXZ0Q29udGV4dC5mbHVzaFN5bmMpIHtcbiAgICAgIHNldFJlbmRlckRmZChuZXcgRGVmZXJyZWQoKSk7XG4gICAgfVxuICB9LCBbdnRDb250ZXh0XSk7XG4gIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHJvdXRlci53aW5kb3cpIHtcbiAgICAgIGxldCBuZXdTdGF0ZSA9IHBlbmRpbmdTdGF0ZTtcbiAgICAgIGxldCByZW5kZXJQcm9taXNlID0gcmVuZGVyRGZkLnByb21pc2U7XG4gICAgICBsZXQgdHJhbnNpdGlvbjIgPSByb3V0ZXIud2luZG93LmRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICBSZWFjdDMuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgICBhd2FpdCByZW5kZXJQcm9taXNlO1xuICAgICAgfSk7XG4gICAgICB0cmFuc2l0aW9uMi5maW5pc2hlZC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgc2V0UmVuZGVyRGZkKHZvaWQgMCk7XG4gICAgICAgIHNldFRyYW5zaXRpb24odm9pZCAwKTtcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlKHZvaWQgMCk7XG4gICAgICAgIHNldFZ0Q29udGV4dCh7IGlzVHJhbnNpdGlvbmluZzogZmFsc2UgfSk7XG4gICAgICB9KTtcbiAgICAgIHNldFRyYW5zaXRpb24odHJhbnNpdGlvbjIpO1xuICAgIH1cbiAgfSwgW3BlbmRpbmdTdGF0ZSwgcmVuZGVyRGZkLCByb3V0ZXIud2luZG93XSk7XG4gIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHN0YXRlLmxvY2F0aW9uLmtleSA9PT0gcGVuZGluZ1N0YXRlLmxvY2F0aW9uLmtleSkge1xuICAgICAgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIFtyZW5kZXJEZmQsIHRyYW5zaXRpb24sIHN0YXRlLmxvY2F0aW9uLCBwZW5kaW5nU3RhdGVdKTtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nICYmIGludGVycnVwdGlvbikge1xuICAgICAgc2V0UGVuZGluZ1N0YXRlKGludGVycnVwdGlvbi5zdGF0ZSk7XG4gICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgIGZsdXNoU3luYzogZmFsc2UsXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogaW50ZXJydXB0aW9uLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiBpbnRlcnJ1cHRpb24ubmV4dExvY2F0aW9uXG4gICAgICB9KTtcbiAgICAgIHNldEludGVycnVwdGlvbih2b2lkIDApO1xuICAgIH1cbiAgfSwgW3Z0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcsIGludGVycnVwdGlvbl0pO1xuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QzLnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVIcmVmOiByb3V0ZXIuY3JlYXRlSHJlZixcbiAgICAgIGVuY29kZUxvY2F0aW9uOiByb3V0ZXIuZW5jb2RlTG9jYXRpb24sXG4gICAgICBnbzogKG4pID0+IHJvdXRlci5uYXZpZ2F0ZShuKSxcbiAgICAgIHB1c2g6ICh0bywgc3RhdGUyLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgc3RhdGU6IHN0YXRlMixcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzPy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pLFxuICAgICAgcmVwbGFjZTogKHRvLCBzdGF0ZTIsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICBzdGF0ZTogc3RhdGUyLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHM/LnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSlcbiAgICB9O1xuICB9LCBbcm91dGVyXSk7XG4gIGxldCBiYXNlbmFtZSA9IHJvdXRlci5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QzLnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIHJvdXRlcixcbiAgICAgIG5hdmlnYXRvcixcbiAgICAgIHN0YXRpYzogZmFsc2UsXG4gICAgICBiYXNlbmFtZVxuICAgIH0pLFxuICAgIFtyb3V0ZXIsIG5hdmlnYXRvciwgYmFzZW5hbWVdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoUmVhY3QzLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGRhdGFSb3V0ZXJDb250ZXh0IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzdGF0ZSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoRmV0Y2hlcnNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBmZXRjaGVyRGF0YS5jdXJyZW50IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChWaWV3VHJhbnNpdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHZ0Q29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmhpc3RvcnlBY3Rpb24sXG4gICAgICBuYXZpZ2F0b3JcbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcbiAgICAgIE1lbW9pemVkRGF0YVJvdXRlcyxcbiAgICAgIHtcbiAgICAgICAgcm91dGVzOiByb3V0ZXIucm91dGVzLFxuICAgICAgICBmdXR1cmU6IHJvdXRlci5mdXR1cmUsXG4gICAgICAgIHN0YXRlXG4gICAgICB9XG4gICAgKVxuICApKSkpKSwgbnVsbCk7XG59XG52YXIgTWVtb2l6ZWREYXRhUm91dGVzID0gUmVhY3QzLm1lbW8oRGF0YVJvdXRlcyk7XG5mdW5jdGlvbiBEYXRhUm91dGVzKHtcbiAgcm91dGVzLFxuICBmdXR1cmUsXG4gIHN0YXRlXG59KSB7XG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgdm9pZCAwLCBzdGF0ZSwgZnV0dXJlKTtcbn1cbmZ1bmN0aW9uIE1lbW9yeVJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgaW5pdGlhbEVudHJpZXMsXG4gIGluaXRpYWxJbmRleFxufSkge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0My51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdDMudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0My51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUpID0+IHtcbiAgICAgIFJlYWN0My5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsXVxuICApO1xuICBSZWFjdDMudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gTmF2aWdhdGUoe1xuICB0byxcbiAgcmVwbGFjZTogcmVwbGFjZTIsXG4gIHN0YXRlLFxuICByZWxhdGl2ZVxufSkge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2ZcbiAgICAvLyB0aGUgcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGA8TmF2aWdhdGU+IG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuICBsZXQgeyBzdGF0aWM6IGlzU3RhdGljIH0gPSBSZWFjdDMudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIHdhcm5pbmcoXG4gICAgIWlzU3RhdGljLFxuICAgIGA8TmF2aWdhdGU+IG11c3Qgbm90IGJlIHVzZWQgb24gdGhlIGluaXRpYWwgcmVuZGVyIGluIGEgPFN0YXRpY1JvdXRlcj4uIFRoaXMgaXMgYSBuby1vcCwgYnV0IHlvdSBzaG91bGQgbW9kaWZ5IHlvdXIgY29kZSBzbyB0aGUgPE5hdmlnYXRlPiBpcyBvbmx5IGV2ZXIgcmVuZGVyZWQgaW4gcmVzcG9uc2UgdG8gc29tZSB1c2VyIGludGVyYWN0aW9uIG9yIHN0YXRlIGNoYW5nZS5gXG4gICk7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0My51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgcGF0aCA9IHJlc29sdmVUbyhcbiAgICB0byxcbiAgICBnZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMpLFxuICAgIGxvY2F0aW9uUGF0aG5hbWUsXG4gICAgcmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICk7XG4gIGxldCBqc29uUGF0aCA9IEpTT04uc3RyaW5naWZ5KHBhdGgpO1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBuYXZpZ2F0ZShKU09OLnBhcnNlKGpzb25QYXRoKSwgeyByZXBsYWNlOiByZXBsYWNlMiwgc3RhdGUsIHJlbGF0aXZlIH0pO1xuICB9LCBbbmF2aWdhdGUsIGpzb25QYXRoLCByZWxhdGl2ZSwgcmVwbGFjZTIsIHN0YXRlXSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gT3V0bGV0KHByb3BzKSB7XG4gIHJldHVybiB1c2VPdXRsZXQocHJvcHMuY29udGV4dCk7XG59XG5mdW5jdGlvbiBSb3V0ZShfcHJvcHMpIHtcbiAgaW52YXJpYW50KFxuICAgIGZhbHNlLFxuICAgIGBBIDxSb3V0ZT4gaXMgb25seSBldmVyIHRvIGJlIHVzZWQgYXMgdGhlIGNoaWxkIG9mIDxSb3V0ZXM+IGVsZW1lbnQsIG5ldmVyIHJlbmRlcmVkIGRpcmVjdGx5LiBQbGVhc2Ugd3JhcCB5b3VyIDxSb3V0ZT4gaW4gYSA8Um91dGVzPi5gXG4gICk7XG59XG5mdW5jdGlvbiBSb3V0ZXIoe1xuICBiYXNlbmFtZTogYmFzZW5hbWVQcm9wID0gXCIvXCIsXG4gIGNoaWxkcmVuID0gbnVsbCxcbiAgbG9jYXRpb246IGxvY2F0aW9uUHJvcCxcbiAgbmF2aWdhdGlvblR5cGUgPSBcIlBPUFwiIC8qIFBvcCAqLyxcbiAgbmF2aWdhdG9yLFxuICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZVxufSkge1xuICBpbnZhcmlhbnQoXG4gICAgIXVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIGBZb3UgY2Fubm90IHJlbmRlciBhIDxSb3V0ZXI+IGluc2lkZSBhbm90aGVyIDxSb3V0ZXI+LiBZb3Ugc2hvdWxkIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBpbiB5b3VyIGFwcC5gXG4gICk7XG4gIGxldCBiYXNlbmFtZSA9IGJhc2VuYW1lUHJvcC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbiAgbGV0IG5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QzLnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgbmF2aWdhdG9yLFxuICAgICAgc3RhdGljOiBzdGF0aWNQcm9wLFxuICAgICAgZnV0dXJlOiB7fVxuICAgIH0pLFxuICAgIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWNQcm9wXVxuICApO1xuICBpZiAodHlwZW9mIGxvY2F0aW9uUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2F0aW9uUHJvcCA9IHBhcnNlUGF0aChsb2NhdGlvblByb3ApO1xuICB9XG4gIGxldCB7XG4gICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICAgIHN0YXRlID0gbnVsbCxcbiAgICBrZXkgPSBcImRlZmF1bHRcIlxuICB9ID0gbG9jYXRpb25Qcm9wO1xuICBsZXQgbG9jYXRpb25Db250ZXh0ID0gUmVhY3QzLnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCB0cmFpbGluZ1BhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShwYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgIGlmICh0cmFpbGluZ1BhdGhuYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgcGF0aG5hbWU6IHRyYWlsaW5nUGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCxcbiAgICAgICAgaGFzaCxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGtleVxuICAgICAgfSxcbiAgICAgIG5hdmlnYXRpb25UeXBlXG4gICAgfTtcbiAgfSwgW2Jhc2VuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBzdGF0ZSwga2V5LCBuYXZpZ2F0aW9uVHlwZV0pO1xuICB3YXJuaW5nKFxuICAgIGxvY2F0aW9uQ29udGV4dCAhPSBudWxsLFxuICAgIGA8Um91dGVyIGJhc2VuYW1lPVwiJHtiYXNlbmFtZX1cIj4gaXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIFVSTCBcIiR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofVwiIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgYmFzZW5hbWUsIHNvIHRoZSA8Um91dGVyPiB3b24ndCByZW5kZXIgYW55dGhpbmcuYFxuICApO1xuICBpZiAobG9jYXRpb25Db250ZXh0ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KE5hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBuYXZpZ2F0aW9uQ29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7IGNoaWxkcmVuLCB2YWx1ZTogbG9jYXRpb25Db250ZXh0IH0pKTtcbn1cbmZ1bmN0aW9uIFJvdXRlcyh7XG4gIGNoaWxkcmVuLFxuICBsb2NhdGlvblxufSkge1xuICByZXR1cm4gdXNlUm91dGVzKGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiksIGxvY2F0aW9uKTtcbn1cbmZ1bmN0aW9uIEF3YWl0KHtcbiAgY2hpbGRyZW4sXG4gIGVycm9yRWxlbWVudCxcbiAgcmVzb2x2ZVxufSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KEF3YWl0RXJyb3JCb3VuZGFyeSwgeyByZXNvbHZlLCBlcnJvckVsZW1lbnQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFJlc29sdmVBd2FpdCwgbnVsbCwgY2hpbGRyZW4pKTtcbn1cbnZhciBBd2FpdEVycm9yQm91bmRhcnkgPSBjbGFzcyBleHRlbmRzIFJlYWN0My5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0geyBlcnJvcjogbnVsbCB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvciB9O1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCI8QXdhaXQ+IGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIixcbiAgICAgIGVycm9yLFxuICAgICAgZXJyb3JJbmZvXG4gICAgKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgY2hpbGRyZW4sIGVycm9yRWxlbWVudCwgcmVzb2x2ZSB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgcHJvbWlzZSA9IG51bGw7XG4gICAgbGV0IHN0YXR1cyA9IDAgLyogcGVuZGluZyAqLztcbiAgICBpZiAoIShyZXNvbHZlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgIHN0YXR1cyA9IDEgLyogc3VjY2VzcyAqLztcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2RhdGFcIiwgeyBnZXQ6ICgpID0+IHJlc29sdmUgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICBzdGF0dXMgPSAyIC8qIGVycm9yICovO1xuICAgICAgbGV0IHJlbmRlckVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdCgpLmNhdGNoKCgpID0+IHtcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IHJlbmRlckVycm9yIH0pO1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZS5fdHJhY2tlZCkge1xuICAgICAgcHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICBzdGF0dXMgPSBcIl9lcnJvclwiIGluIHByb21pc2UgPyAyIC8qIGVycm9yICovIDogXCJfZGF0YVwiIGluIHByb21pc2UgPyAxIC8qIHN1Y2Nlc3MgKi8gOiAwIC8qIHBlbmRpbmcgKi87XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXR1cyA9IDAgLyogcGVuZGluZyAqLztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgICAgcHJvbWlzZSA9IHJlc29sdmUudGhlbihcbiAgICAgICAgKGRhdGEyKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZGF0YVwiLCB7IGdldDogKCkgPT4gZGF0YTIgfSksXG4gICAgICAgIChlcnJvcikgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2Vycm9yXCIsIHsgZ2V0OiAoKSA9PiBlcnJvciB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gMiAvKiBlcnJvciAqLyAmJiAhZXJyb3JFbGVtZW50KSB7XG4gICAgICB0aHJvdyBwcm9taXNlLl9lcnJvcjtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gMiAvKiBlcnJvciAqLykge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChBd2FpdENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHByb21pc2UsIGNoaWxkcmVuOiBlcnJvckVsZW1lbnQgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IDEgLyogc3VjY2VzcyAqLykge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChBd2FpdENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHByb21pc2UsIGNoaWxkcmVuIH0pO1xuICAgIH1cbiAgICB0aHJvdyBwcm9taXNlO1xuICB9XG59O1xuZnVuY3Rpb24gUmVzb2x2ZUF3YWl0KHtcbiAgY2hpbGRyZW5cbn0pIHtcbiAgbGV0IGRhdGEyID0gdXNlQXN5bmNWYWx1ZSgpO1xuICBsZXQgdG9SZW5kZXIgPSB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKGRhdGEyKSA6IGNoaWxkcmVuO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFJlYWN0My5GcmFnbWVudCwgbnVsbCwgdG9SZW5kZXIpO1xufVxuZnVuY3Rpb24gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRQYXRoID0gW10pIHtcbiAgbGV0IHJvdXRlcyA9IFtdO1xuICBSZWFjdDMuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFSZWFjdDMuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSZWFjdDMuRnJhZ21lbnQpIHtcbiAgICAgIHJvdXRlcy5wdXNoLmFwcGx5KFxuICAgICAgICByb3V0ZXMsXG4gICAgICAgIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuLCB0cmVlUGF0aClcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGVsZW1lbnQudHlwZSA9PT0gUm91dGUsXG4gICAgICBgWyR7dHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnQudHlwZSA6IGVsZW1lbnQudHlwZS5uYW1lfV0gaXMgbm90IGEgPFJvdXRlPiBjb21wb25lbnQuIEFsbCBjb21wb25lbnQgY2hpbGRyZW4gb2YgPFJvdXRlcz4gbXVzdCBiZSBhIDxSb3V0ZT4gb3IgPFJlYWN0LkZyYWdtZW50PmBcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICFlbGVtZW50LnByb3BzLmluZGV4IHx8ICFlbGVtZW50LnByb3BzLmNoaWxkcmVuLFxuICAgICAgXCJBbiBpbmRleCByb3V0ZSBjYW5ub3QgaGF2ZSBjaGlsZCByb3V0ZXMuXCJcbiAgICApO1xuICAgIGxldCByb3V0ZSA9IHtcbiAgICAgIGlkOiBlbGVtZW50LnByb3BzLmlkIHx8IHRyZWVQYXRoLmpvaW4oXCItXCIpLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogZWxlbWVudC5wcm9wcy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgZWxlbWVudDogZWxlbWVudC5wcm9wcy5lbGVtZW50LFxuICAgICAgQ29tcG9uZW50OiBlbGVtZW50LnByb3BzLkNvbXBvbmVudCxcbiAgICAgIGluZGV4OiBlbGVtZW50LnByb3BzLmluZGV4LFxuICAgICAgcGF0aDogZWxlbWVudC5wcm9wcy5wYXRoLFxuICAgICAgbG9hZGVyOiBlbGVtZW50LnByb3BzLmxvYWRlcixcbiAgICAgIGFjdGlvbjogZWxlbWVudC5wcm9wcy5hY3Rpb24sXG4gICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50OiBlbGVtZW50LnByb3BzLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQsXG4gICAgICBIeWRyYXRlRmFsbGJhY2s6IGVsZW1lbnQucHJvcHMuSHlkcmF0ZUZhbGxiYWNrLFxuICAgICAgZXJyb3JFbGVtZW50OiBlbGVtZW50LnByb3BzLmVycm9yRWxlbWVudCxcbiAgICAgIEVycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSxcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuaGFzRXJyb3JCb3VuZGFyeSA9PT0gdHJ1ZSB8fCBlbGVtZW50LnByb3BzLkVycm9yQm91bmRhcnkgIT0gbnVsbCB8fCBlbGVtZW50LnByb3BzLmVycm9yRWxlbWVudCAhPSBudWxsLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogZWxlbWVudC5wcm9wcy5zaG91bGRSZXZhbGlkYXRlLFxuICAgICAgaGFuZGxlOiBlbGVtZW50LnByb3BzLmhhbmRsZSxcbiAgICAgIGxhenk6IGVsZW1lbnQucHJvcHMubGF6eVxuICAgIH07XG4gICAgaWYgKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgIHJvdXRlLmNoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKFxuICAgICAgICBlbGVtZW50LnByb3BzLmNoaWxkcmVuLFxuICAgICAgICB0cmVlUGF0aFxuICAgICAgKTtcbiAgICB9XG4gICAgcm91dGVzLnB1c2gocm91dGUpO1xuICB9KTtcbiAgcmV0dXJuIHJvdXRlcztcbn1cbnZhciBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMgPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW47XG5mdW5jdGlvbiByZW5kZXJNYXRjaGVzKG1hdGNoZXMpIHtcbiAgcmV0dXJuIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMpO1xufVxuXG4vLyBsaWIvZG9tL2xpYi50c3hcbnZhciBSZWFjdDEwID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuXG4vLyBsaWIvZG9tL2RvbS50c1xudmFyIGRlZmF1bHRNZXRob2QgPSBcImdldFwiO1xudmFyIGRlZmF1bHRFbmNUeXBlID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnRhZ05hbWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0J1dHRvbkVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbn1cbmZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmb3JtXCI7XG59XG5mdW5jdGlvbiBpc0lucHV0RWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCI7XG59XG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDAgJiYgLy8gSWdub3JlIGV2ZXJ5dGhpbmcgYnV0IGxlZnQgY2xpY2tzXG4gICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJiAvLyBMZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAhaXNNb2RpZmllZEV2ZW50KGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhcmFtcyhpbml0ID0gXCJcIikge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhcbiAgICB0eXBlb2YgaW5pdCA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KGluaXQpIHx8IGluaXQgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBpbml0IDogT2JqZWN0LmtleXMoaW5pdCkucmVkdWNlKChtZW1vMiwga2V5KSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBpbml0W2tleV07XG4gICAgICByZXR1cm4gbWVtbzIuY29uY2F0KFxuICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgodikgPT4gW2tleSwgdl0pIDogW1trZXksIHZhbHVlXV1cbiAgICAgICk7XG4gICAgfSwgW10pXG4gICk7XG59XG5mdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihsb2NhdGlvblNlYXJjaCwgZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKGxvY2F0aW9uU2VhcmNoKTtcbiAgaWYgKGRlZmF1bHRTZWFyY2hQYXJhbXMpIHtcbiAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKCFzZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5nZXRBbGwoa2V5KS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG52YXIgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBudWxsO1xuZnVuY3Rpb24gaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpIHtcbiAgaWYgKF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID09PSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGb3JtRGF0YShcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaWYgRm9ybURhdGEgc3VwcG9ydHMgdGhlIHN1Ym1pdHRlciBwYXJhbWV0ZXIsIHRoaXMgd2lsbCB0aHJvd1xuICAgICAgICAwXG4gICAgICApO1xuICAgICAgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlcjtcbn1cbnZhciBzdXBwb3J0ZWRGb3JtRW5jVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLFxuICBcInRleHQvcGxhaW5cIlxuXSk7XG5mdW5jdGlvbiBnZXRGb3JtRW5jVHlwZShlbmNUeXBlKSB7XG4gIGlmIChlbmNUeXBlICE9IG51bGwgJiYgIXN1cHBvcnRlZEZvcm1FbmNUeXBlcy5oYXMoZW5jVHlwZSkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgXCIke2VuY1R5cGV9XCIgaXMgbm90IGEgdmFsaWQgXFxgZW5jVHlwZVxcYCBmb3IgXFxgPEZvcm0+XFxgL1xcYDxmZXRjaGVyLkZvcm0+XFxgIGFuZCB3aWxsIGRlZmF1bHQgdG8gXCIke2RlZmF1bHRFbmNUeXBlfVwiYFxuICAgICk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGVuY1R5cGU7XG59XG5mdW5jdGlvbiBnZXRGb3JtU3VibWlzc2lvbkluZm8odGFyZ2V0LCBiYXNlbmFtZSkge1xuICBsZXQgbWV0aG9kO1xuICBsZXQgYWN0aW9uO1xuICBsZXQgZW5jVHlwZTtcbiAgbGV0IGZvcm1EYXRhO1xuICBsZXQgYm9keTtcbiAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID0gZ2V0Rm9ybUVuY1R5cGUodGFyZ2V0LmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8IGRlZmF1bHRFbmNUeXBlO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHwgaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJiAodGFyZ2V0LnR5cGUgPT09IFwic3VibWl0XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwiaW1hZ2VcIikpIHtcbiAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuICAgIGlmIChmb3JtID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzdWJtaXQgYSA8YnV0dG9uPiBvciA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiPiB3aXRob3V0IGEgPGZvcm0+YFxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpIHx8IGRlZmF1bHRNZXRob2Q7XG4gICAgZW5jVHlwZSA9IGdldEZvcm1FbmNUeXBlKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSkgfHwgZ2V0Rm9ybUVuY1R5cGUoZm9ybS5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpKSB8fCBkZWZhdWx0RW5jVHlwZTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtLCB0YXJnZXQpO1xuICAgIGlmICghaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpKSB7XG4gICAgICBsZXQgeyBuYW1lLCB0eXBlLCB2YWx1ZSB9ID0gdGFyZ2V0O1xuICAgICAgaWYgKHR5cGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICBsZXQgcHJlZml4ID0gbmFtZSA/IGAke25hbWV9LmAgOiBcIlwiO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7cHJlZml4fXhgLCBcIjBcIik7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtwcmVmaXh9eWAsIFwiMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2Fubm90IHN1Ym1pdCBlbGVtZW50IHRoYXQgaXMgbm90IDxmb3JtPiwgPGJ1dHRvbj4sIG9yIDxpbnB1dCB0eXBlPVwic3VibWl0fGltYWdlXCI+YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZDtcbiAgICBhY3Rpb24gPSBudWxsO1xuICAgIGVuY1R5cGUgPSBkZWZhdWx0RW5jVHlwZTtcbiAgICBib2R5ID0gdGFyZ2V0O1xuICB9XG4gIGlmIChmb3JtRGF0YSAmJiBlbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgIGJvZHkgPSBmb3JtRGF0YTtcbiAgICBmb3JtRGF0YSA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4geyBhY3Rpb24sIG1ldGhvZDogbWV0aG9kLnRvTG93ZXJDYXNlKCksIGVuY1R5cGUsIGZvcm1EYXRhLCBib2R5IH07XG59XG5cbi8vIGxpYi9kb20vc3NyL2NvbXBvbmVudHMudHN4XG52YXIgUmVhY3Q5ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuXG4vLyBsaWIvZG9tL3Nzci9pbnZhcmlhbnQudHNcbmZ1bmN0aW9uIGludmFyaWFudDIodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuLy8gbGliL2RvbS9zc3Ivcm91dGVNb2R1bGVzLnRzXG5hc3luYyBmdW5jdGlvbiBsb2FkUm91dGVNb2R1bGUocm91dGUsIHJvdXRlTW9kdWxlc0NhY2hlKSB7XG4gIGlmIChyb3V0ZS5pZCBpbiByb3V0ZU1vZHVsZXNDYWNoZSkge1xuICAgIHJldHVybiByb3V0ZU1vZHVsZXNDYWNoZVtyb3V0ZS5pZF07XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgcm91dGVNb2R1bGUgPSBhd2FpdCBpbXBvcnQoXG4gICAgICAvKiBAdml0ZS1pZ25vcmUgKi9cbiAgICAgIC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi9cbiAgICAgIHJvdXRlLm1vZHVsZVxuICAgICk7XG4gICAgcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdID0gcm91dGVNb2R1bGU7XG4gICAgcmV0dXJuIHJvdXRlTW9kdWxlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBgRXJyb3IgbG9hZGluZyByb3V0ZSBtb2R1bGUgXFxgJHtyb3V0ZS5tb2R1bGV9XFxgLCByZWxvYWRpbmcgcGFnZS4uLmBcbiAgICApO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIGlmICh3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQgJiYgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0LmlzU3BhTW9kZSAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgdm9pZCAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gbGliL2RvbS9zc3IvbGlua3MudHNcbmZ1bmN0aW9uIGdldEtleWVkTGlua3NGb3JNYXRjaGVzKG1hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3QpIHtcbiAgbGV0IGRlc2NyaXB0b3JzID0gbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG4gICAgbGV0IG1vZHVsZTIgPSByb3V0ZU1vZHVsZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgcmV0dXJuIFtcbiAgICAgIHJvdXRlICYmIHJvdXRlLmNzcyA/IHJvdXRlLmNzcy5tYXAoKGhyZWYyKSA9PiAoeyByZWw6IFwic3R5bGVzaGVldFwiLCBocmVmOiBocmVmMiB9KSkgOiBbXSxcbiAgICAgIG1vZHVsZTI/LmxpbmtzPy4oKSB8fCBbXVxuICAgIF07XG4gIH0pLmZsYXQoMik7XG4gIGxldCBwcmVsb2FkcyA9IGdldE1vZHVsZUxpbmtIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdCk7XG4gIHJldHVybiBkZWR1cGVMaW5rRGVzY3JpcHRvcnMoZGVzY3JpcHRvcnMsIHByZWxvYWRzKTtcbn1cbmZ1bmN0aW9uIGdldFJvdXRlQ3NzRGVzY3JpcHRvcnMocm91dGUpIHtcbiAgaWYgKCFyb3V0ZS5jc3MpIHJldHVybiBbXTtcbiAgcmV0dXJuIHJvdXRlLmNzcy5tYXAoKGhyZWYyKSA9PiAoeyByZWw6IFwic3R5bGVzaGVldFwiLCBocmVmOiBocmVmMiB9KSk7XG59XG5hc3luYyBmdW5jdGlvbiBwcmVmZXRjaFJvdXRlQ3NzKHJvdXRlKSB7XG4gIGlmICghcm91dGUuY3NzKSByZXR1cm47XG4gIGxldCBkZXNjcmlwdG9ycyA9IGdldFJvdXRlQ3NzRGVzY3JpcHRvcnMocm91dGUpO1xuICBhd2FpdCBQcm9taXNlLmFsbChkZXNjcmlwdG9ycy5tYXAocHJlZmV0Y2hTdHlsZUxpbmspKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU3R5bGVMaW5rcyhyb3V0ZSwgcm91dGVNb2R1bGUpIHtcbiAgaWYgKCFyb3V0ZS5jc3MgJiYgIXJvdXRlTW9kdWxlLmxpbmtzIHx8ICFpc1ByZWxvYWRTdXBwb3J0ZWQoKSkgcmV0dXJuO1xuICBsZXQgZGVzY3JpcHRvcnMgPSBbXTtcbiAgaWYgKHJvdXRlLmNzcykge1xuICAgIGRlc2NyaXB0b3JzLnB1c2goLi4uZ2V0Um91dGVDc3NEZXNjcmlwdG9ycyhyb3V0ZSkpO1xuICB9XG4gIGlmIChyb3V0ZU1vZHVsZS5saW5rcykge1xuICAgIGRlc2NyaXB0b3JzLnB1c2goLi4ucm91dGVNb2R1bGUubGlua3MoKSk7XG4gIH1cbiAgaWYgKGRlc2NyaXB0b3JzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICBsZXQgc3R5bGVMaW5rcyA9IFtdO1xuICBmb3IgKGxldCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgaWYgKCFpc1BhZ2VMaW5rRGVzY3JpcHRvcihkZXNjcmlwdG9yKSAmJiBkZXNjcmlwdG9yLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIpIHtcbiAgICAgIHN0eWxlTGlua3MucHVzaCh7XG4gICAgICAgIC4uLmRlc2NyaXB0b3IsXG4gICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgIGFzOiBcInN0eWxlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhd2FpdCBQcm9taXNlLmFsbChzdHlsZUxpbmtzLm1hcChwcmVmZXRjaFN0eWxlTGluaykpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZUxpbmsoZGVzY3JpcHRvcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBpZiAoZGVzY3JpcHRvci5tZWRpYSAmJiAhd2luZG93Lm1hdGNoTWVkaWEoZGVzY3JpcHRvci5tZWRpYSkubWF0Y2hlcyB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgYGxpbmtbcmVsPVwic3R5bGVzaGVldFwiXVtocmVmPVwiJHtkZXNjcmlwdG9yLmhyZWZ9XCJdYFxuICAgICkpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgfVxuICAgIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgT2JqZWN0LmFzc2lnbihsaW5rLCBkZXNjcmlwdG9yKTtcbiAgICBmdW5jdGlvbiByZW1vdmVMaW5rKCkge1xuICAgICAgaWYgKGRvY3VtZW50LmhlYWQuY29udGFpbnMobGluaykpIHtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGluay5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICByZW1vdmVMaW5rKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBsaW5rLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICByZW1vdmVMaW5rKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzUGFnZUxpbmtEZXNjcmlwdG9yKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC5wYWdlID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNIdG1sTGlua0Rlc2NyaXB0b3Iob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAob2JqZWN0LmhyZWYgPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmplY3QucmVsID09PSBcInByZWxvYWRcIiAmJiB0eXBlb2Ygb2JqZWN0LmltYWdlU3JjU2V0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvYmplY3QuaW1hZ2VTaXplcyA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICByZXR1cm4gdHlwZW9mIG9iamVjdC5yZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iamVjdC5ocmVmID09PSBcInN0cmluZ1wiO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0S2V5ZWRQcmVmZXRjaExpbmtzKG1hdGNoZXMsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IGxpbmtzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgbWF0Y2hlcy5tYXAoYXN5bmMgKG1hdGNoKSA9PiB7XG4gICAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgIGxldCBtb2QgPSBhd2FpdCBsb2FkUm91dGVNb2R1bGUocm91dGUsIHJvdXRlTW9kdWxlcyk7XG4gICAgICAgIHJldHVybiBtb2QubGlua3MgPyBtb2QubGlua3MoKSA6IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0pXG4gICk7XG4gIHJldHVybiBkZWR1cGVMaW5rRGVzY3JpcHRvcnMoXG4gICAgbGlua3MuZmxhdCgxKS5maWx0ZXIoaXNIdG1sTGlua0Rlc2NyaXB0b3IpLmZpbHRlcigobGluaykgPT4gbGluay5yZWwgPT09IFwic3R5bGVzaGVldFwiIHx8IGxpbmsucmVsID09PSBcInByZWxvYWRcIikubWFwKFxuICAgICAgKGxpbmspID0+IGxpbmsucmVsID09PSBcInN0eWxlc2hlZXRcIiA/IHsgLi4ubGluaywgcmVsOiBcInByZWZldGNoXCIsIGFzOiBcInN0eWxlXCIgfSA6IHsgLi4ubGluaywgcmVsOiBcInByZWZldGNoXCIgfVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE5ld01hdGNoZXNGb3JMaW5rcyhwYWdlLCBuZXh0TWF0Y2hlcywgY3VycmVudE1hdGNoZXMsIG1hbmlmZXN0LCBsb2NhdGlvbiwgbW9kZSkge1xuICBsZXQgaXNOZXcgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFjdXJyZW50TWF0Y2hlc1tpbmRleF0pIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBtYXRjaC5yb3V0ZS5pZCAhPT0gY3VycmVudE1hdGNoZXNbaW5kZXhdLnJvdXRlLmlkO1xuICB9O1xuICBsZXQgbWF0Y2hQYXRoQ2hhbmdlZCA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gcGFyYW0gY2hhbmdlLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICAgIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHwgLy8gc3BsYXQgcGFyYW0gY2hhbmdlZCwgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gbWF0Y2gucGF0aFxuICAgICAgLy8gZS5nLiAvZmlsZXMvaW1hZ2VzL2F2YXRhci5qcGcgLT4gZmlsZXMvZmluYW5jZXMueGxzXG4gICAgICBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucm91dGUucGF0aD8uZW5kc1dpdGgoXCIqXCIpICYmIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdXG4gICAgKTtcbiAgfTtcbiAgaWYgKG1vZGUgPT09IFwiYXNzZXRzXCIpIHtcbiAgICByZXR1cm4gbmV4dE1hdGNoZXMuZmlsdGVyKFxuICAgICAgKG1hdGNoLCBpbmRleCkgPT4gaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleClcbiAgICApO1xuICB9XG4gIGlmIChtb2RlID09PSBcImRhdGFcIikge1xuICAgIHJldHVybiBuZXh0TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IG1hbmlmZXN0Um91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaWYgKCFtYW5pZmVzdFJvdXRlIHx8ICFtYW5pZmVzdFJvdXRlLmhhc0xvYWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgICBsZXQgcm91dGVDaG9pY2UgPSBtYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKHtcbiAgICAgICAgICBjdXJyZW50VXJsOiBuZXcgVVJMKFxuICAgICAgICAgICAgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoLFxuICAgICAgICAgICAgd2luZG93Lm9yaWdpblxuICAgICAgICAgICksXG4gICAgICAgICAgY3VycmVudFBhcmFtczogY3VycmVudE1hdGNoZXNbMF0/LnBhcmFtcyB8fCB7fSxcbiAgICAgICAgICBuZXh0VXJsOiBuZXcgVVJMKHBhZ2UsIHdpbmRvdy5vcmlnaW4pLFxuICAgICAgICAgIG5leHRQYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiByb3V0ZUNob2ljZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGdldE1vZHVsZUxpbmtIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdCwgeyBpbmNsdWRlSHlkcmF0ZUZhbGxiYWNrIH0gPSB7fSkge1xuICByZXR1cm4gZGVkdXBlSHJlZnMoXG4gICAgbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG4gICAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaWYgKCFyb3V0ZSkgcmV0dXJuIFtdO1xuICAgICAgbGV0IGhyZWZzID0gW3JvdXRlLm1vZHVsZV07XG4gICAgICBpZiAocm91dGUuY2xpZW50QWN0aW9uTW9kdWxlKSB7XG4gICAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmNsaWVudEFjdGlvbk1vZHVsZSk7XG4gICAgICB9XG4gICAgICBpZiAocm91dGUuY2xpZW50TG9hZGVyTW9kdWxlKSB7XG4gICAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmNsaWVudExvYWRlck1vZHVsZSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZUh5ZHJhdGVGYWxsYmFjayAmJiByb3V0ZS5oeWRyYXRlRmFsbGJhY2tNb2R1bGUpIHtcbiAgICAgICAgaHJlZnMgPSBocmVmcy5jb25jYXQocm91dGUuaHlkcmF0ZUZhbGxiYWNrTW9kdWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyb3V0ZS5pbXBvcnRzKSB7XG4gICAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmltcG9ydHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhyZWZzO1xuICAgIH0pLmZsYXQoMSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGRlZHVwZUhyZWZzKGhyZWZzKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChocmVmcyldO1xufVxuZnVuY3Rpb24gc29ydEtleXMob2JqKSB7XG4gIGxldCBzb3J0ZWQgPSB7fTtcbiAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopLnNvcnQoKTtcbiAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICBzb3J0ZWRba2V5XSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiBzb3J0ZWQ7XG59XG5mdW5jdGlvbiBkZWR1cGVMaW5rRGVzY3JpcHRvcnMoZGVzY3JpcHRvcnMsIHByZWxvYWRzKSB7XG4gIGxldCBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgcHJlbG9hZHNTZXQgPSBuZXcgU2V0KHByZWxvYWRzKTtcbiAgcmV0dXJuIGRlc2NyaXB0b3JzLnJlZHVjZSgoZGVkdXBlZCwgZGVzY3JpcHRvcikgPT4ge1xuICAgIGxldCBhbHJlYWR5TW9kdWxlUHJlbG9hZCA9IHByZWxvYWRzICYmICFpc1BhZ2VMaW5rRGVzY3JpcHRvcihkZXNjcmlwdG9yKSAmJiBkZXNjcmlwdG9yLmFzID09PSBcInNjcmlwdFwiICYmIGRlc2NyaXB0b3IuaHJlZiAmJiBwcmVsb2Fkc1NldC5oYXMoZGVzY3JpcHRvci5ocmVmKTtcbiAgICBpZiAoYWxyZWFkeU1vZHVsZVByZWxvYWQpIHtcbiAgICAgIHJldHVybiBkZWR1cGVkO1xuICAgIH1cbiAgICBsZXQga2V5ID0gSlNPTi5zdHJpbmdpZnkoc29ydEtleXMoZGVzY3JpcHRvcikpO1xuICAgIGlmICghc2V0LmhhcyhrZXkpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgICBkZWR1cGVkLnB1c2goeyBrZXksIGxpbms6IGRlc2NyaXB0b3IgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWR1cGVkO1xuICB9LCBbXSk7XG59XG52YXIgX2lzUHJlbG9hZFN1cHBvcnRlZDtcbmZ1bmN0aW9uIGlzUHJlbG9hZFN1cHBvcnRlZCgpIHtcbiAgaWYgKF9pc1ByZWxvYWRTdXBwb3J0ZWQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBfaXNQcmVsb2FkU3VwcG9ydGVkO1xuICB9XG4gIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICBfaXNQcmVsb2FkU3VwcG9ydGVkID0gZWwucmVsTGlzdC5zdXBwb3J0cyhcInByZWxvYWRcIik7XG4gIGVsID0gbnVsbDtcbiAgcmV0dXJuIF9pc1ByZWxvYWRTdXBwb3J0ZWQ7XG59XG5cbi8vIGxpYi9kb20vc3NyL21hcmt1cC50c1xudmFyIEVTQ0FQRV9MT09LVVAgPSB7XG4gIFwiJlwiOiBcIlxcXFx1MDAyNlwiLFxuICBcIj5cIjogXCJcXFxcdTAwM2VcIixcbiAgXCI8XCI6IFwiXFxcXHUwMDNjXCIsXG4gIFwiXFx1MjAyOFwiOiBcIlxcXFx1MjAyOFwiLFxuICBcIlxcdTIwMjlcIjogXCJcXFxcdTIwMjlcIlxufTtcbnZhciBFU0NBUEVfUkVHRVggPSAvWyY+PFxcdTIwMjhcXHUyMDI5XS9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbChodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCAobWF0Y2gpID0+IEVTQ0FQRV9MT09LVVBbbWF0Y2hdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh0bWwoaHRtbCkge1xuICByZXR1cm4geyBfX2h0bWw6IGh0bWwgfTtcbn1cblxuLy8gbGliL2RvbS9zc3Ivc2luZ2xlLWZldGNoLnRzeFxudmFyIFJlYWN0NCA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcblxuLy8gdmVuZG9yL3R1cmJvLXN0cmVhbS12Mi91dGlscy50c1xudmFyIEhPTEUgPSAtMTtcbnZhciBOQU4gPSAtMjtcbnZhciBORUdBVElWRV9JTkZJTklUWSA9IC0zO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAtNDtcbnZhciBOVUxMID0gLTU7XG52YXIgUE9TSVRJVkVfSU5GSU5JVFkgPSAtNjtcbnZhciBVTkRFRklORUQgPSAtNztcbnZhciBUWVBFX0JJR0lOVCA9IFwiQlwiO1xudmFyIFRZUEVfREFURSA9IFwiRFwiO1xudmFyIFRZUEVfRVJST1IgPSBcIkVcIjtcbnZhciBUWVBFX01BUCA9IFwiTVwiO1xudmFyIFRZUEVfTlVMTF9PQkpFQ1QgPSBcIk5cIjtcbnZhciBUWVBFX1BST01JU0UgPSBcIlBcIjtcbnZhciBUWVBFX1JFR0VYUCA9IFwiUlwiO1xudmFyIFRZUEVfU0VUID0gXCJTXCI7XG52YXIgVFlQRV9TWU1CT0wgPSBcIllcIjtcbnZhciBUWVBFX1VSTCA9IFwiVVwiO1xudmFyIFRZUEVfUFJFVklPVVNfUkVTT0xWRUQgPSBcIlpcIjtcbnZhciBEZWZlcnJlZDIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUxpbmVTcGxpdHRpbmdUcmFuc2Zvcm0oKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgbGV0IGxlZnRvdmVyID0gXCJcIjtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3Qgc3RyID0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgY29uc3QgcGFydHMgPSAobGVmdG92ZXIgKyBzdHIpLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgbGVmdG92ZXIgPSBwYXJ0cy5wb3AoKSB8fCBcIlwiO1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChsZWZ0b3Zlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUobGVmdG92ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHZlbmRvci90dXJiby1zdHJlYW0tdjIvZmxhdHRlbi50c1xuZnVuY3Rpb24gZmxhdHRlbihpbnB1dCkge1xuICBjb25zdCB7IGluZGljZXMgfSA9IHRoaXM7XG4gIGNvbnN0IGV4aXN0aW5nID0gaW5kaWNlcy5nZXQoaW5wdXQpO1xuICBpZiAoZXhpc3RpbmcpIHJldHVybiBbZXhpc3RpbmddO1xuICBpZiAoaW5wdXQgPT09IHZvaWQgMCkgcmV0dXJuIFVOREVGSU5FRDtcbiAgaWYgKGlucHV0ID09PSBudWxsKSByZXR1cm4gTlVMTDtcbiAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIHJldHVybiBOQU47XG4gIGlmIChpbnB1dCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSByZXR1cm4gUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGlmIChpbnB1dCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSByZXR1cm4gTkVHQVRJVkVfSU5GSU5JVFk7XG4gIGlmIChpbnB1dCA9PT0gMCAmJiAxIC8gaW5wdXQgPCAwKSByZXR1cm4gTkVHQVRJVkVfWkVSTztcbiAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gIGluZGljZXMuc2V0KGlucHV0LCBpbmRleCk7XG4gIHN0cmluZ2lmeS5jYWxsKHRoaXMsIGlucHV0LCBpbmRleCk7XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShpbnB1dCwgaW5kZXgpIHtcbiAgY29uc3QgeyBkZWZlcnJlZCwgcGx1Z2lucywgcG9zdFBsdWdpbnMgfSA9IHRoaXM7XG4gIGNvbnN0IHN0ciA9IHRoaXMuc3RyaW5naWZpZWQ7XG4gIGNvbnN0IHN0YWNrID0gW1tpbnB1dCwgaW5kZXhdXTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBbaW5wdXQyLCBpbmRleDJdID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgcGFydHNGb3JPYmogPSAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopLm1hcCgoaykgPT4gYFwiXyR7ZmxhdHRlbi5jYWxsKHRoaXMsIGspfVwiOiR7ZmxhdHRlbi5jYWxsKHRoaXMsIG9ialtrXSl9YCkuam9pbihcIixcIik7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBzd2l0Y2ggKHR5cGVvZiBpbnB1dDIpIHtcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIHN0cltpbmRleDJdID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9CSUdJTlR9XCIsXCIke2lucHV0Mn1cIl1gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzeW1ib2xcIjoge1xuICAgICAgICBjb25zdCBrZXlGb3IgPSBTeW1ib2wua2V5Rm9yKGlucHV0Mik7XG4gICAgICAgIGlmICgha2V5Rm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBlbmNvZGUgc3ltYm9sIHVubGVzcyBjcmVhdGVkIHdpdGggU3ltYm9sLmZvcigpXCJcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9TWU1CT0x9XCIsJHtKU09OLnN0cmluZ2lmeShrZXlGb3IpfV1gO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgIGlmICghaW5wdXQyKSB7XG4gICAgICAgICAgc3RyW2luZGV4Ml0gPSBgJHtOVUxMfWA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5wdXQyKTtcbiAgICAgICAgbGV0IHBsdWdpbkhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFpc0FycmF5ICYmIHBsdWdpbnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5SZXN1bHQgPSBwbHVnaW4oaW5wdXQyKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgcGx1Z2luSGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnN0IFtwbHVnaW5JZGVudGlmaWVyLCAuLi5yZXN0XSA9IHBsdWdpblJlc3VsdDtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgWyR7SlNPTi5zdHJpbmdpZnkocGx1Z2luSWRlbnRpZmllcil9YDtcbiAgICAgICAgICAgICAgaWYgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IGAsJHtyZXN0Lm1hcCgodikgPT4gZmxhdHRlbi5jYWxsKHRoaXMsIHYpKS5qb2luKFwiLFwiKX1gO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IFwiXVwiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwbHVnaW5IYW5kbGVkKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGlzQXJyYXkgPyBcIltcIiA6IFwie1wiO1xuICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Mi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IChpID8gXCIsXCIgOiBcIlwiKSArIChpIGluIGlucHV0MiA/IGZsYXR0ZW4uY2FsbCh0aGlzLCBpbnB1dDJbaV0pIDogSE9MRSk7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGAke3Jlc3VsdH1dYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9EQVRFfVwiLCR7aW5wdXQyLmdldFRpbWUoKX1dYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX1VSTH1cIiwke0pTT04uc3RyaW5naWZ5KGlucHV0Mi5ocmVmKX1dYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX1JFR0VYUH1cIiwke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICBpbnB1dDIuc291cmNlXG4gICAgICAgICAgICApfSwke0pTT04uc3RyaW5naWZ5KGlucHV0Mi5mbGFncyl9XWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dDIuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX1NFVH1cIiwke1suLi5pbnB1dDJdLm1hcCgodmFsKSA9PiBmbGF0dGVuLmNhbGwodGhpcywgdmFsKSkuam9pbihcIixcIil9XWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfU0VUfVwiXWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGlmIChpbnB1dDIuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX01BUH1cIiwke1suLi5pbnB1dDJdLmZsYXRNYXAoKFtrLCB2XSkgPT4gW1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4uY2FsbCh0aGlzLCBrKSxcbiAgICAgICAgICAgICAgICBmbGF0dGVuLmNhbGwodGhpcywgdilcbiAgICAgICAgICAgICAgXSkuam9pbihcIixcIil9XWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfTUFQfVwiXWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfUFJPTUlTRX1cIiwke2luZGV4Mn1dYDtcbiAgICAgICAgICAgIGRlZmVycmVkW2luZGV4Ml0gPSBpbnB1dDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX0VSUk9SfVwiLCR7SlNPTi5zdHJpbmdpZnkoaW5wdXQyLm1lc3NhZ2UpfWA7XG4gICAgICAgICAgICBpZiAoaW5wdXQyLm5hbWUgIT09IFwiRXJyb3JcIikge1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBgLCR7SlNPTi5zdHJpbmdpZnkoaW5wdXQyLm5hbWUpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBcIl1cIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnB1dDIpID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfTlVMTF9PQkpFQ1R9XCIseyR7cGFydHNGb3JPYmooaW5wdXQyKX19XWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGlucHV0MikpIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYHske3BhcnRzRm9yT2JqKGlucHV0Mil9fWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IGVuY29kZSBvYmplY3Qgd2l0aCBwcm90b3R5cGVcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbnB1dDIpO1xuICAgICAgICBsZXQgcGx1Z2luSGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWlzQXJyYXkgJiYgcGx1Z2lucykge1xuICAgICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsdWdpblJlc3VsdCA9IHBsdWdpbihpbnB1dDIpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2luUmVzdWx0KSkge1xuICAgICAgICAgICAgICBwbHVnaW5IYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc3QgW3BsdWdpbklkZW50aWZpZXIsIC4uLnJlc3RdID0gcGx1Z2luUmVzdWx0O1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbJHtKU09OLnN0cmluZ2lmeShwbHVnaW5JZGVudGlmaWVyKX1gO1xuICAgICAgICAgICAgICBpZiAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gYCwke3Jlc3QubWFwKCh2KSA9PiBmbGF0dGVuLmNhbGwodGhpcywgdikpLmpvaW4oXCIsXCIpfWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gXCJdXCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsdWdpbkhhbmRsZWQpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCBlbmNvZGUgZnVuY3Rpb24gb3IgdW5leHBlY3RlZCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlcnJvcikge1xuICAgICAgbGV0IHBsdWdpbkhhbmRsZWQgPSBmYWxzZTtcbiAgICAgIGlmIChwb3N0UGx1Z2lucykge1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwb3N0UGx1Z2lucykge1xuICAgICAgICAgIGNvbnN0IHBsdWdpblJlc3VsdCA9IHBsdWdpbihpbnB1dDIpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpblJlc3VsdCkpIHtcbiAgICAgICAgICAgIHBsdWdpbkhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgW3BsdWdpbklkZW50aWZpZXIsIC4uLnJlc3RdID0gcGx1Z2luUmVzdWx0O1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgWyR7SlNPTi5zdHJpbmdpZnkocGx1Z2luSWRlbnRpZmllcil9YDtcbiAgICAgICAgICAgIGlmIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gYCwke3Jlc3QubWFwKCh2KSA9PiBmbGF0dGVuLmNhbGwodGhpcywgdikpLmpvaW4oXCIsXCIpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBcIl1cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwbHVnaW5IYW5kbGVkKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxudmFyIG9iamVjdFByb3RvTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QucHJvdG90eXBlKS5zb3J0KCkuam9pbihcIlxcMFwiKTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodGhpbmcpIHtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpbmcpO1xuICByZXR1cm4gcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUgfHwgcHJvdG8gPT09IG51bGwgfHwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLnNvcnQoKS5qb2luKFwiXFwwXCIpID09PSBvYmplY3RQcm90b05hbWVzO1xufVxuXG4vLyB2ZW5kb3IvdHVyYm8tc3RyZWFtLXYyL3VuZmxhdHRlbi50c1xudmFyIGdsb2JhbE9iaiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB2b2lkIDA7XG5mdW5jdGlvbiB1bmZsYXR0ZW4ocGFyc2VkKSB7XG4gIGNvbnN0IHsgaHlkcmF0ZWQsIHZhbHVlcyB9ID0gdGhpcztcbiAgaWYgKHR5cGVvZiBwYXJzZWQgPT09IFwibnVtYmVyXCIpIHJldHVybiBoeWRyYXRlLmNhbGwodGhpcywgcGFyc2VkKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnNlZCkgfHwgIXBhcnNlZC5sZW5ndGgpIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICBjb25zdCBzdGFydEluZGV4ID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBwYXJzZWQpIHtcbiAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gIH1cbiAgaHlkcmF0ZWQubGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGh5ZHJhdGUuY2FsbCh0aGlzLCBzdGFydEluZGV4KTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGUoaW5kZXgpIHtcbiAgY29uc3QgeyBoeWRyYXRlZCwgdmFsdWVzLCBkZWZlcnJlZCwgcGx1Z2lucyB9ID0gdGhpcztcbiAgbGV0IHJlc3VsdDtcbiAgY29uc3Qgc3RhY2sgPSBbXG4gICAgW1xuICAgICAgaW5kZXgsXG4gICAgICAodikgPT4ge1xuICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgfVxuICAgIF1cbiAgXTtcbiAgbGV0IHBvc3RSdW4gPSBbXTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBbaW5kZXgyLCBzZXRdID0gc3RhY2sucG9wKCk7XG4gICAgc3dpdGNoIChpbmRleDIpIHtcbiAgICAgIGNhc2UgVU5ERUZJTkVEOlxuICAgICAgICBzZXQodm9pZCAwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIE5VTEw6XG4gICAgICAgIHNldChudWxsKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIE5BTjpcbiAgICAgICAgc2V0KE5hTik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSBQT1NJVElWRV9JTkZJTklUWTpcbiAgICAgICAgc2V0KEluZmluaXR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIE5FR0FUSVZFX0lORklOSVRZOlxuICAgICAgICBzZXQoLUluZmluaXR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIE5FR0FUSVZFX1pFUk86XG4gICAgICAgIHNldCgtMCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaHlkcmF0ZWRbaW5kZXgyXSkge1xuICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4Ml07XG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSB2YWx1ZTtcbiAgICAgIHNldCh2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBiLCBjXSA9IHZhbHVlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFRZUEVfREFURTpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gbmV3IERhdGUoYikpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX1VSTDpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gbmV3IFVSTChiKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfQklHSU5UOlxuICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBCaWdJbnQoYikpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX1JFR0VYUDpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gbmV3IFJlZ0V4cChiLCBjKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfU1lNQk9MOlxuICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBTeW1ib2wuZm9yKGIpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9TRVQ6XG4gICAgICAgICAgICBjb25zdCBuZXdTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IG5ld1NldDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB2YWx1ZS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKVxuICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAodikgPT4ge1xuICAgICAgICAgICAgICAgICAgbmV3U2V0LmFkZCh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgc2V0KG5ld1NldCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfTUFQOlxuICAgICAgICAgICAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSBtYXA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdmFsdWUubGVuZ3RoIC0gMjsgaSA+IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgICAgICAgIHZhbHVlW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAodikgPT4ge1xuICAgICAgICAgICAgICAgICAgclsxXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgICAgICAgdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgKGspID0+IHtcbiAgICAgICAgICAgICAgICAgIHJbMF0gPSBrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHBvc3RSdW4ucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWFwLnNldChyWzBdLCByWzFdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXQobWFwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9OVUxMX09CSkVDVDpcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IG9iajtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGIpLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgICAgICAgIGJba2V5XSxcbiAgICAgICAgICAgICAgICAodikgPT4ge1xuICAgICAgICAgICAgICAgICAgclsxXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgICAgICAgTnVtYmVyKGtleS5zbGljZSgxKSksXG4gICAgICAgICAgICAgICAgKGspID0+IHtcbiAgICAgICAgICAgICAgICAgIHJbMF0gPSBrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHBvc3RSdW4ucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb2JqW3JbMF1dID0gclsxXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXQob2JqKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9QUk9NSVNFOlxuICAgICAgICAgICAgaWYgKGh5ZHJhdGVkW2JdKSB7XG4gICAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gaHlkcmF0ZWRbYl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgZCA9IG5ldyBEZWZlcnJlZDIoKTtcbiAgICAgICAgICAgICAgZGVmZXJyZWRbYl0gPSBkO1xuICAgICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IGQucHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfRVJST1I6XG4gICAgICAgICAgICBjb25zdCBbLCBtZXNzYWdlLCBlcnJvclR5cGVdID0gdmFsdWU7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBlcnJvclR5cGUgJiYgZ2xvYmFsT2JqICYmIGdsb2JhbE9ialtlcnJvclR5cGVdID8gbmV3IGdsb2JhbE9ialtlcnJvclR5cGVdKG1lc3NhZ2UpIDogbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IGVycm9yO1xuICAgICAgICAgICAgc2V0KGVycm9yKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9QUkVWSU9VU19SRVNPTFZFRDpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gaHlkcmF0ZWRbYl0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpbnMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgICAgICAgICAgY29uc3QgdmFscyA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsc1tpXTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICAgIHYsXG4gICAgICAgICAgICAgICAgICAodjIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcltpXSA9IHYyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBvc3RSdW4ucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0MiA9IHBsdWdpbih2YWx1ZVswXSwgLi4ucik7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Mikge1xuICAgICAgICAgICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IHJlc3VsdDIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IGFycmF5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbiA9IHZhbHVlW2ldO1xuICAgICAgICAgIGlmIChuICE9PSBIT0xFKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXQoYXJyYXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG4gICAgICBoeWRyYXRlZFtpbmRleDJdID0gb2JqZWN0O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUpLnJldmVyc2UoKSkge1xuICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgIHZhbHVlW2tleV0sXG4gICAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICAgIHJbMV0gPSB2O1xuICAgICAgICAgIH1cbiAgICAgICAgXSk7XG4gICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgIE51bWJlcihrZXkuc2xpY2UoMSkpLFxuICAgICAgICAgIChrKSA9PiB7XG4gICAgICAgICAgICByWzBdID0gaztcbiAgICAgICAgICB9XG4gICAgICAgIF0pO1xuICAgICAgICBwb3N0UnVuLnB1c2goKCkgPT4ge1xuICAgICAgICAgIG9iamVjdFtyWzBdXSA9IHJbMV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc2V0KG9iamVjdCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHBvc3RSdW4ubGVuZ3RoID4gMCkge1xuICAgIHBvc3RSdW4ucG9wKCkoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyB2ZW5kb3IvdHVyYm8tc3RyZWFtLXYyL3R1cmJvLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gZGVjb2RlKHJlYWRhYmxlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgcGx1Z2lucyB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgY29uc3QgZG9uZSA9IG5ldyBEZWZlcnJlZDIoKTtcbiAgY29uc3QgcmVhZGVyID0gcmVhZGFibGUucGlwZVRocm91Z2goY3JlYXRlTGluZVNwbGl0dGluZ1RyYW5zZm9ybSgpKS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IHtcbiAgICB2YWx1ZXM6IFtdLFxuICAgIGh5ZHJhdGVkOiBbXSxcbiAgICBkZWZlcnJlZDoge30sXG4gICAgcGx1Z2luc1xuICB9O1xuICBjb25zdCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlSW5pdGlhbC5jYWxsKGRlY29kZXIsIHJlYWRlcik7XG4gIGxldCBkb25lUHJvbWlzZSA9IGRvbmUucHJvbWlzZTtcbiAgaWYgKGRlY29kZWQuZG9uZSkge1xuICAgIGRvbmUucmVzb2x2ZSgpO1xuICB9IGVsc2Uge1xuICAgIGRvbmVQcm9taXNlID0gZGVjb2RlRGVmZXJyZWQuY2FsbChkZWNvZGVyLCByZWFkZXIpLnRoZW4oZG9uZS5yZXNvbHZlKS5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGRlZmVycmVkIG9mIE9iamVjdC52YWx1ZXMoZGVjb2Rlci5kZWZlcnJlZCkpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgICB9XG4gICAgICBkb25lLnJlamVjdChyZWFzb24pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZG9uZTogZG9uZVByb21pc2UudGhlbigoKSA9PiByZWFkZXIuY2xvc2VkKSxcbiAgICB2YWx1ZTogZGVjb2RlZC52YWx1ZVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlSW5pdGlhbChyZWFkZXIpIHtcbiAgY29uc3QgcmVhZCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gIGlmICghcmVhZC52YWx1ZSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICB9XG4gIGxldCBsaW5lO1xuICB0cnkge1xuICAgIGxpbmUgPSBKU09OLnBhcnNlKHJlYWQudmFsdWUpO1xuICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRvbmU6IHJlYWQuZG9uZSxcbiAgICB2YWx1ZTogdW5mbGF0dGVuLmNhbGwodGhpcywgbGluZSlcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY29kZURlZmVycmVkKHJlYWRlcikge1xuICBsZXQgcmVhZCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gIHdoaWxlICghcmVhZC5kb25lKSB7XG4gICAgaWYgKCFyZWFkLnZhbHVlKSBjb250aW51ZTtcbiAgICBjb25zdCBsaW5lID0gcmVhZC52YWx1ZTtcbiAgICBzd2l0Y2ggKGxpbmVbMF0pIHtcbiAgICAgIGNhc2UgVFlQRV9QUk9NSVNFOiB7XG4gICAgICAgIGNvbnN0IGNvbG9uSW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZElkID0gTnVtYmVyKGxpbmUuc2xpY2UoMSwgY29sb25JbmRleCkpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuZGVmZXJyZWRbZGVmZXJyZWRJZF07XG4gICAgICAgIGlmICghZGVmZXJyZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlZmVycmVkIElEICR7ZGVmZXJyZWRJZH0gbm90IGZvdW5kIGluIHN0cmVhbWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVEYXRhID0gbGluZS5zbGljZShjb2xvbkluZGV4ICsgMSk7XG4gICAgICAgIGxldCBqc29uTGluZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBqc29uTGluZSA9IEpTT04ucGFyc2UobGluZURhdGEpO1xuICAgICAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHVuZmxhdHRlbi5jYWxsKHRoaXMsIGpzb25MaW5lKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBUWVBFX0VSUk9SOiB7XG4gICAgICAgIGNvbnN0IGNvbG9uSW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZElkID0gTnVtYmVyKGxpbmUuc2xpY2UoMSwgY29sb25JbmRleCkpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuZGVmZXJyZWRbZGVmZXJyZWRJZF07XG4gICAgICAgIGlmICghZGVmZXJyZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlZmVycmVkIElEICR7ZGVmZXJyZWRJZH0gbm90IGZvdW5kIGluIHN0cmVhbWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVEYXRhID0gbGluZS5zbGljZShjb2xvbkluZGV4ICsgMSk7XG4gICAgICAgIGxldCBqc29uTGluZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBqc29uTGluZSA9IEpTT04ucGFyc2UobGluZURhdGEpO1xuICAgICAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHVuZmxhdHRlbi5jYWxsKHRoaXMsIGpzb25MaW5lKTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICB9XG4gICAgcmVhZCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCB7IHBsdWdpbnMsIHBvc3RQbHVnaW5zLCBzaWduYWwgfSA9IG9wdGlvbnMgPz8ge307XG4gIGNvbnN0IGVuY29kZXIyID0ge1xuICAgIGRlZmVycmVkOiB7fSxcbiAgICBpbmRleDogMCxcbiAgICBpbmRpY2VzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHN0cmluZ2lmaWVkOiBbXSxcbiAgICBwbHVnaW5zLFxuICAgIHBvc3RQbHVnaW5zLFxuICAgIHNpZ25hbFxuICB9O1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgbGFzdFNlbnRJbmRleCA9IDA7XG4gIGNvbnN0IHJlYWRhYmxlID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBpZCA9IGZsYXR0ZW4uY2FsbChlbmNvZGVyMiwgaW5wdXQpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpZCA8IDApIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShgJHtpZH1cbmApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoYFske2VuY29kZXIyLnN0cmluZ2lmaWVkLmpvaW4oXCIsXCIpfV1cbmApXG4gICAgICAgICk7XG4gICAgICAgIGxhc3RTZW50SW5kZXggPSBlbmNvZGVyMi5zdHJpbmdpZmllZC5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VlblByb21pc2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoZW5jb2RlcjIuZGVmZXJyZWQpLmxlbmd0aCkge1xuICAgICAgICBsZXQgcmFjZURvbmU7XG4gICAgICAgIGNvbnN0IHJhY2VQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJhY2VEb25lID0gcmVzb2x2ZTtcbiAgICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBjb25zdCByZWplY3RQcm9taXNlID0gKCkgPT4gcmVqZWN0KHNpZ25hbC5yZWFzb24gfHwgbmV3IEVycm9yKFwiU2lnbmFsIHdhcyBhYm9ydGVkLlwiKSk7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChPYmplY3Qua2V5cyhlbmNvZGVyMi5kZWZlcnJlZCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAoY29uc3QgW2RlZmVycmVkSWQsIGRlZmVycmVkXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgICAgICAgIGVuY29kZXIyLmRlZmVycmVkXG4gICAgICAgICAgKSkge1xuICAgICAgICAgICAgaWYgKHNlZW5Qcm9taXNlcy5oYXMoZGVmZXJyZWQpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHNlZW5Qcm9taXNlcy5hZGQoXG4gICAgICAgICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9Bc3NpZ25JbkV4cHJlc3Npb25zOiA8ZXhwbGFuYXRpb24+XG4gICAgICAgICAgICAgIGVuY29kZXIyLmRlZmVycmVkW051bWJlcihkZWZlcnJlZElkKV0gPSBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIHJhY2VQcm9taXNlLFxuICAgICAgICAgICAgICAgIGRlZmVycmVkXG4gICAgICAgICAgICAgIF0pLnRoZW4oXG4gICAgICAgICAgICAgICAgKHJlc29sdmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBpZDIgPSBmbGF0dGVuLmNhbGwoZW5jb2RlcjIsIHJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkMikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke1RZUEVfUFJPTUlTRX0ke2RlZmVycmVkSWR9OltbXCIke1RZUEVfUFJFVklPVVNfUkVTT0xWRUR9XCIsJHtpZDJbMF19XV1cbmBcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZXIyLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7VFlQRV9QUk9NSVNFfSR7ZGVmZXJyZWRJZH06JHtpZDJ9XG5gXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZW5jb2RlcjIuc3RyaW5naWZpZWQuc2xpY2UobGFzdFNlbnRJbmRleCArIDEpLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7VFlQRV9QUk9NSVNFfSR7ZGVmZXJyZWRJZH06WyR7dmFsdWVzfV1cbmBcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXggPSBlbmNvZGVyMi5zdHJpbmdpZmllZC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKCFyZWFzb24gfHwgdHlwZW9mIHJlYXNvbiAhPT0gXCJvYmplY3RcIiB8fCAhKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBuZXcgRXJyb3IoXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29uc3QgaWQyID0gZmxhdHRlbi5jYWxsKGVuY29kZXIyLCByZWFzb24pO1xuICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7VFlQRV9FUlJPUn0ke2RlZmVycmVkSWR9OltbXCIke1RZUEVfUFJFVklPVVNfUkVTT0xWRUR9XCIsJHtpZDJbMF19XV1cbmBcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZXIyLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGAke1RZUEVfRVJST1J9JHtkZWZlcnJlZElkfToke2lkMn1cbmApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBlbmNvZGVyMi5zdHJpbmdpZmllZC5zbGljZShsYXN0U2VudEluZGV4ICsgMSkuam9pbihcIixcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtUWVBFX0VSUk9SfSR7ZGVmZXJyZWRJZH06WyR7dmFsdWVzfV1cbmBcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXggPSBlbmNvZGVyMi5zdHJpbmdpZmllZC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZW5jb2RlcjIuZGVmZXJyZWRbTnVtYmVyKGRlZmVycmVkSWQpXTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UucmFjZShPYmplY3QudmFsdWVzKGVuY29kZXIyLmRlZmVycmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmFjZURvbmUoKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXMoZW5jb2RlcjIuZGVmZXJyZWQpKTtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVhZGFibGU7XG59XG5cbi8vIGxpYi9kb20vc3NyL2RhdGEudHNcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RJbml0KHJlcXVlc3QpIHtcbiAgbGV0IGluaXQgPSB7IHNpZ25hbDogcmVxdWVzdC5zaWduYWwgfTtcbiAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSBcIkdFVFwiKSB7XG4gICAgaW5pdC5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgY29udGVudFR5cGUgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgaW5pdC5oZWFkZXJzID0geyBcIkNvbnRlbnQtVHlwZVwiOiBjb250ZW50VHlwZSB9O1xuICAgICAgaW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYXdhaXQgcmVxdWVzdC5qc29uKCkpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudFR5cGUgJiYgL1xcYnRleHRcXC9wbGFpblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgIGluaXQuaGVhZGVycyA9IHsgXCJDb250ZW50LVR5cGVcIjogY29udGVudFR5cGUgfTtcbiAgICAgIGluaXQuYm9keSA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwveC13d3ctZm9ybS11cmxlbmNvZGVkXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgaW5pdC5ib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhhd2FpdCByZXF1ZXN0LnRleHQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXQuYm9keSA9IGF3YWl0IHJlcXVlc3QuZm9ybURhdGEoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluaXQ7XG59XG5cbi8vIGxpYi9kb20vc3NyL3NpbmdsZS1mZXRjaC50c3hcbnZhciBTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sID0gU3ltYm9sKFwiU2luZ2xlRmV0Y2hSZWRpcmVjdFwiKTtcbnZhciBTaW5nbGVGZXRjaE5vUmVzdWx0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbn07XG52YXIgU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVUyA9IDIwMjtcbnZhciBOT19CT0RZX1NUQVRVU19DT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsxMDAsIDEwMSwgMjA0LCAyMDVdKTtcbmZ1bmN0aW9uIFN0cmVhbVRyYW5zZmVyKHtcbiAgY29udGV4dCxcbiAgaWRlbnRpZmllcixcbiAgcmVhZGVyLFxuICB0ZXh0RGVjb2RlcixcbiAgbm9uY2Vcbn0pIHtcbiAgaWYgKCFjb250ZXh0LnJlbmRlck1ldGEgfHwgIWNvbnRleHQucmVuZGVyTWV0YS5kaWRSZW5kZXJTY3JpcHRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFjb250ZXh0LnJlbmRlck1ldGEuc3RyZWFtQ2FjaGUpIHtcbiAgICBjb250ZXh0LnJlbmRlck1ldGEuc3RyZWFtQ2FjaGUgPSB7fTtcbiAgfVxuICBsZXQgeyBzdHJlYW1DYWNoZSB9ID0gY29udGV4dC5yZW5kZXJNZXRhO1xuICBsZXQgcHJvbWlzZSA9IHN0cmVhbUNhY2hlW2lkZW50aWZpZXJdO1xuICBpZiAoIXByb21pc2UpIHtcbiAgICBwcm9taXNlID0gc3RyZWFtQ2FjaGVbaWRlbnRpZmllcl0gPSByZWFkZXIucmVhZCgpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgc3RyZWFtQ2FjaGVbaWRlbnRpZmllcl0ucmVzdWx0ID0ge1xuICAgICAgICBkb25lOiByZXN1bHQuZG9uZSxcbiAgICAgICAgdmFsdWU6IHRleHREZWNvZGVyLmRlY29kZShyZXN1bHQudmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgICB9O1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBzdHJlYW1DYWNoZVtpZGVudGlmaWVyXS5lcnJvciA9IGU7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21pc2UuZXJyb3IpIHtcbiAgICB0aHJvdyBwcm9taXNlLmVycm9yO1xuICB9XG4gIGlmIChwcm9taXNlLnJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxuICBsZXQgeyBkb25lLCB2YWx1ZSB9ID0gcHJvbWlzZS5yZXN1bHQ7XG4gIGxldCBzY3JpcHRUYWcgPSB2YWx1ZSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIG5vbmNlLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0LnN0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSgke2VzY2FwZUh0bWwoXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgICAgICl9KTtgXG4gICAgICB9XG4gICAgfVxuICApIDogbnVsbDtcbiAgaWYgKGRvbmUpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFJlYWN0NC5GcmFnbWVudCwgbnVsbCwgc2NyaXB0VGFnLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInNjcmlwdFwiLFxuICAgICAge1xuICAgICAgICBub25jZSxcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICBfX2h0bWw6IGB3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO2BcbiAgICAgICAgfVxuICAgICAgfVxuICAgICkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoUmVhY3Q0LkZyYWdtZW50LCBudWxsLCBzY3JpcHRUYWcsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChSZWFjdDQuU3VzcGVuc2UsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChcbiAgICAgIFN0cmVhbVRyYW5zZmVyLFxuICAgICAge1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyICsgMSxcbiAgICAgICAgcmVhZGVyLFxuICAgICAgICB0ZXh0RGVjb2RlcixcbiAgICAgICAgbm9uY2VcbiAgICAgIH1cbiAgICApKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFR1cmJvU3RyZWFtU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3koZ2V0Um91dGVyLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBzc3IsIGJhc2VuYW1lKSB7XG4gIGxldCBkYXRhU3RyYXRlZ3kgPSBnZXRTaW5nbGVGZXRjaERhdGFTdHJhdGVneUltcGwoXG4gICAgZ2V0Um91dGVyLFxuICAgIChtYXRjaCkgPT4ge1xuICAgICAgbGV0IG1hbmlmZXN0Um91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaW52YXJpYW50MihtYW5pZmVzdFJvdXRlLCBcIlJvdXRlIG5vdCBmb3VuZCBpbiBtYW5pZmVzdFwiKTtcbiAgICAgIGxldCByb3V0ZU1vZHVsZSA9IHJvdXRlTW9kdWxlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNMb2FkZXI6IG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyLFxuICAgICAgICBoYXNDbGllbnRMb2FkZXI6IG1hbmlmZXN0Um91dGUuaGFzQ2xpZW50TG9hZGVyLFxuICAgICAgICBoYXNTaG91bGRSZXZhbGlkYXRlOiBCb29sZWFuKHJvdXRlTW9kdWxlPy5zaG91bGRSZXZhbGlkYXRlKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGZldGNoQW5kRGVjb2RlVmlhVHVyYm9TdHJlYW0sXG4gICAgc3NyLFxuICAgIGJhc2VuYW1lXG4gICk7XG4gIHJldHVybiBhc3luYyAoYXJncykgPT4gYXJncy51bnN0YWJsZV9ydW5DbGllbnRNaWRkbGV3YXJlKGRhdGFTdHJhdGVneSk7XG59XG5mdW5jdGlvbiBnZXRTaW5nbGVGZXRjaERhdGFTdHJhdGVneUltcGwoZ2V0Um91dGVyLCBnZXRSb3V0ZUluZm8sIGZldGNoQW5kRGVjb2RlLCBzc3IsIGJhc2VuYW1lKSB7XG4gIHJldHVybiBhc3luYyAoYXJncykgPT4ge1xuICAgIGxldCB7IHJlcXVlc3QsIG1hdGNoZXMsIGZldGNoZXJLZXkgfSA9IGFyZ3M7XG4gICAgbGV0IHJvdXRlciA9IGdldFJvdXRlcigpO1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gXCJHRVRcIikge1xuICAgICAgcmV0dXJuIHNpbmdsZUZldGNoQWN0aW9uU3RyYXRlZ3koYXJncywgZmV0Y2hBbmREZWNvZGUsIGJhc2VuYW1lKTtcbiAgICB9XG4gICAgbGV0IGZvdW5kUmV2YWxpZGF0aW5nU2VydmVyTG9hZGVyID0gbWF0Y2hlcy5zb21lKChtKSA9PiB7XG4gICAgICBsZXQgeyBoYXNMb2FkZXIsIGhhc0NsaWVudExvYWRlciB9ID0gZ2V0Um91dGVJbmZvKG0pO1xuICAgICAgcmV0dXJuIG0udW5zdGFibGVfc2hvdWxkQ2FsbEhhbmRsZXIoKSAmJiBoYXNMb2FkZXIgJiYgIWhhc0NsaWVudExvYWRlcjtcbiAgICB9KTtcbiAgICBpZiAoIXNzciAmJiAhZm91bmRSZXZhbGlkYXRpbmdTZXJ2ZXJMb2FkZXIpIHtcbiAgICAgIHJldHVybiBub25Tc3JTdHJhdGVneShhcmdzLCBnZXRSb3V0ZUluZm8sIGZldGNoQW5kRGVjb2RlLCBiYXNlbmFtZSk7XG4gICAgfVxuICAgIGlmIChmZXRjaGVyS2V5KSB7XG4gICAgICByZXR1cm4gc2luZ2xlRmV0Y2hMb2FkZXJGZXRjaGVyU3RyYXRlZ3koYXJncywgZmV0Y2hBbmREZWNvZGUsIGJhc2VuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZUZldGNoTG9hZGVyTmF2aWdhdGlvblN0cmF0ZWd5KFxuICAgICAgYXJncyxcbiAgICAgIHJvdXRlcixcbiAgICAgIGdldFJvdXRlSW5mbyxcbiAgICAgIGZldGNoQW5kRGVjb2RlLFxuICAgICAgc3NyLFxuICAgICAgYmFzZW5hbWVcbiAgICApO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gc2luZ2xlRmV0Y2hBY3Rpb25TdHJhdGVneShhcmdzLCBmZXRjaEFuZERlY29kZSwgYmFzZW5hbWUpIHtcbiAgbGV0IGFjdGlvbk1hdGNoID0gYXJncy5tYXRjaGVzLmZpbmQoKG0pID0+IG0udW5zdGFibGVfc2hvdWxkQ2FsbEhhbmRsZXIoKSk7XG4gIGludmFyaWFudDIoYWN0aW9uTWF0Y2gsIFwiTm8gYWN0aW9uIG1hdGNoIGZvdW5kXCIpO1xuICBsZXQgYWN0aW9uU3RhdHVzID0gdm9pZCAwO1xuICBsZXQgcmVzdWx0ID0gYXdhaXQgYWN0aW9uTWF0Y2gucmVzb2x2ZShhc3luYyAoaGFuZGxlcikgPT4ge1xuICAgIGxldCByZXN1bHQyID0gYXdhaXQgaGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgeyBkYXRhOiBkYXRhMiwgc3RhdHVzIH0gPSBhd2FpdCBmZXRjaEFuZERlY29kZShhcmdzLCBiYXNlbmFtZSwgW1xuICAgICAgICBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgXSk7XG4gICAgICBhY3Rpb25TdGF0dXMgPSBzdGF0dXM7XG4gICAgICByZXR1cm4gdW53cmFwU2luZ2xlRmV0Y2hSZXN1bHQoZGF0YTIsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfSk7XG4gIGlmIChpc1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpIHx8IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5yZXN1bHQpIHx8IGlzRGF0YVdpdGhSZXNwb25zZUluaXQocmVzdWx0LnJlc3VsdCkpIHtcbiAgICByZXR1cm4geyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHtcbiAgICAgIHR5cGU6IHJlc3VsdC50eXBlLFxuICAgICAgcmVzdWx0OiBkYXRhKHJlc3VsdC5yZXN1bHQsIGFjdGlvblN0YXR1cylcbiAgICB9XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBub25Tc3JTdHJhdGVneShhcmdzLCBnZXRSb3V0ZUluZm8sIGZldGNoQW5kRGVjb2RlLCBiYXNlbmFtZSkge1xuICBsZXQgbWF0Y2hlc1RvTG9hZCA9IGFyZ3MubWF0Y2hlcy5maWx0ZXIoXG4gICAgKG0pID0+IG0udW5zdGFibGVfc2hvdWxkQ2FsbEhhbmRsZXIoKVxuICApO1xuICBsZXQgcmVzdWx0cyA9IHt9O1xuICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBtYXRjaGVzVG9Mb2FkLm1hcChcbiAgICAgIChtKSA9PiBtLnJlc29sdmUoYXN5bmMgKGhhbmRsZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgeyBoYXNDbGllbnRMb2FkZXIgfSA9IGdldFJvdXRlSW5mbyhtKTtcbiAgICAgICAgICBsZXQgcm91dGVJZCA9IG0ucm91dGUuaWQ7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGhhc0NsaWVudExvYWRlciA/IGF3YWl0IGhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZGF0YTogZGF0YTIgfSA9IGF3YWl0IGZldGNoQW5kRGVjb2RlKGFyZ3MsIGJhc2VuYW1lLCBbcm91dGVJZF0pO1xuICAgICAgICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0KGRhdGEyLCByb3V0ZUlkKTtcbiAgICAgICAgICB9KSA6IGF3YWl0IGhhbmRsZXIoKTtcbiAgICAgICAgICByZXN1bHRzW20ucm91dGUuaWRdID0geyB0eXBlOiBcImRhdGFcIiwgcmVzdWx0IH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXN1bHRzW20ucm91dGUuaWRdID0geyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZSB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5hc3luYyBmdW5jdGlvbiBzaW5nbGVGZXRjaExvYWRlck5hdmlnYXRpb25TdHJhdGVneShhcmdzLCByb3V0ZXIsIGdldFJvdXRlSW5mbywgZmV0Y2hBbmREZWNvZGUsIHNzciwgYmFzZW5hbWUpIHtcbiAgbGV0IHJvdXRlc1BhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBmb3VuZE9wdE91dFJvdXRlID0gZmFsc2U7XG4gIGxldCByb3V0ZURmZHMgPSBhcmdzLm1hdGNoZXMubWFwKCgpID0+IGNyZWF0ZURlZmVycmVkMigpKTtcbiAgbGV0IHNpbmdsZUZldGNoRGZkID0gY3JlYXRlRGVmZXJyZWQyKCk7XG4gIGxldCByZXN1bHRzID0ge307XG4gIGxldCByZXNvbHZlUHJvbWlzZSA9IFByb21pc2UuYWxsKFxuICAgIGFyZ3MubWF0Y2hlcy5tYXAoXG4gICAgICBhc3luYyAobSwgaSkgPT4gbS5yZXNvbHZlKGFzeW5jIChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHJvdXRlRGZkc1tpXS5yZXNvbHZlKCk7XG4gICAgICAgIGxldCByb3V0ZUlkID0gbS5yb3V0ZS5pZDtcbiAgICAgICAgbGV0IHsgaGFzTG9hZGVyLCBoYXNDbGllbnRMb2FkZXIsIGhhc1Nob3VsZFJldmFsaWRhdGUgfSA9IGdldFJvdXRlSW5mbyhtKTtcbiAgICAgICAgbGV0IGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlID0gIW0udW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MgfHwgbS51bnN0YWJsZV9zaG91bGRSZXZhbGlkYXRlQXJncy5hY3Rpb25TdGF0dXMgPT0gbnVsbCB8fCBtLnVuc3RhYmxlX3Nob3VsZFJldmFsaWRhdGVBcmdzLmFjdGlvblN0YXR1cyA8IDQwMDtcbiAgICAgICAgbGV0IHNob3VsZENhbGwgPSBtLnVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyKGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlKTtcbiAgICAgICAgaWYgKCFzaG91bGRDYWxsKSB7XG4gICAgICAgICAgZm91bmRPcHRPdXRSb3V0ZSB8fCAoZm91bmRPcHRPdXRSb3V0ZSA9IG0udW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MgIT0gbnVsbCAmJiAvLyBUaGlzIGlzIGEgcmV2YWxpZGF0aW9uLFxuICAgICAgICAgIGhhc0xvYWRlciAmJiAvLyBmb3IgYSByb3V0ZSB3aXRoIGEgc2VydmVyIGxvYWRlcixcbiAgICAgICAgICBoYXNTaG91bGRSZXZhbGlkYXRlID09PSB0cnVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0NsaWVudExvYWRlcikge1xuICAgICAgICAgIGlmIChoYXNMb2FkZXIpIHtcbiAgICAgICAgICAgIGZvdW5kT3B0T3V0Um91dGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBsZXQgeyBkYXRhOiBkYXRhMiB9ID0gYXdhaXQgZmV0Y2hBbmREZWNvZGUoYXJncywgYmFzZW5hbWUsIFtyb3V0ZUlkXSk7XG4gICAgICAgICAgICAgIHJldHVybiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChkYXRhMiwgcm91dGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdHNbcm91dGVJZF0gPSB7IHR5cGU6IFwiZGF0YVwiLCByZXN1bHQgfTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXN1bHRzW3JvdXRlSWRdID0geyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0xvYWRlcikge1xuICAgICAgICAgIHJvdXRlc1BhcmFtcy5hZGQocm91dGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YTIgPSBhd2FpdCBzaW5nbGVGZXRjaERmZC5wcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0KGRhdGEyLCByb3V0ZUlkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXN1bHRzW3JvdXRlSWRdID0geyB0eXBlOiBcImRhdGFcIiwgcmVzdWx0IH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXN1bHRzW3JvdXRlSWRdID0geyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZSB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwocm91dGVEZmRzLm1hcCgoZCkgPT4gZC5wcm9taXNlKSk7XG4gIGxldCBpc0luaXRpYWxMb2FkID0gIXJvdXRlci5zdGF0ZS5pbml0aWFsaXplZCAmJiByb3V0ZXIuc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCI7XG4gIGlmICgoaXNJbml0aWFsTG9hZCB8fCByb3V0ZXNQYXJhbXMuc2l6ZSA9PT0gMCkgJiYgIXdpbmRvdy5fX3JlYWN0Um91dGVySGRyQWN0aXZlKSB7XG4gICAgc2luZ2xlRmV0Y2hEZmQucmVzb2x2ZSh7IHJvdXRlczoge30gfSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHRhcmdldFJvdXRlcyA9IHNzciAmJiBmb3VuZE9wdE91dFJvdXRlICYmIHJvdXRlc1BhcmFtcy5zaXplID4gMCA/IFsuLi5yb3V0ZXNQYXJhbXMua2V5cygpXSA6IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgbGV0IGRhdGEyID0gYXdhaXQgZmV0Y2hBbmREZWNvZGUoYXJncywgYmFzZW5hbWUsIHRhcmdldFJvdXRlcyk7XG4gICAgICBzaW5nbGVGZXRjaERmZC5yZXNvbHZlKGRhdGEyLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNpbmdsZUZldGNoRGZkLnJlamVjdChlKTtcbiAgICB9XG4gIH1cbiAgYXdhaXQgcmVzb2x2ZVByb21pc2U7XG4gIGF3YWl0IGJ1YmJsZU1pZGRsZXdhcmVFcnJvcnMoXG4gICAgc2luZ2xlRmV0Y2hEZmQucHJvbWlzZSxcbiAgICBhcmdzLm1hdGNoZXMsXG4gICAgcm91dGVzUGFyYW1zLFxuICAgIHJlc3VsdHNcbiAgKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5hc3luYyBmdW5jdGlvbiBidWJibGVNaWRkbGV3YXJlRXJyb3JzKHNpbmdsZUZldGNoUHJvbWlzZSwgbWF0Y2hlcywgcm91dGVzUGFyYW1zLCByZXN1bHRzKSB7XG4gIHRyeSB7XG4gICAgbGV0IG1pZGRsZXdhcmVFcnJvcjtcbiAgICBsZXQgZmV0Y2hlZERhdGEgPSBhd2FpdCBzaW5nbGVGZXRjaFByb21pc2U7XG4gICAgaWYgKFwicm91dGVzXCIgaW4gZmV0Y2hlZERhdGEpIHtcbiAgICAgIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG1hdGNoLnJvdXRlLmlkIGluIGZldGNoZWREYXRhLnJvdXRlcykge1xuICAgICAgICAgIGxldCByb3V0ZVJlc3VsdCA9IGZldGNoZWREYXRhLnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiByb3V0ZVJlc3VsdCkge1xuICAgICAgICAgICAgbWlkZGxld2FyZUVycm9yID0gcm91dGVSZXN1bHQuZXJyb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pZGRsZXdhcmVFcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICBBcnJheS5mcm9tKHJvdXRlc1BhcmFtcy52YWx1ZXMoKSkuZm9yRWFjaCgocm91dGVJZCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0c1tyb3V0ZUlkXS5yZXN1bHQgaW5zdGFuY2VvZiBTaW5nbGVGZXRjaE5vUmVzdWx0RXJyb3IpIHtcbiAgICAgICAgICByZXN1bHRzW3JvdXRlSWRdLnJlc3VsdCA9IG1pZGRsZXdhcmVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoTG9hZGVyRmV0Y2hlclN0cmF0ZWd5KGFyZ3MsIGZldGNoQW5kRGVjb2RlLCBiYXNlbmFtZSkge1xuICBsZXQgZmV0Y2hlck1hdGNoID0gYXJncy5tYXRjaGVzLmZpbmQoKG0pID0+IG0udW5zdGFibGVfc2hvdWxkQ2FsbEhhbmRsZXIoKSk7XG4gIGludmFyaWFudDIoZmV0Y2hlck1hdGNoLCBcIk5vIGZldGNoZXIgbWF0Y2ggZm91bmRcIik7XG4gIGxldCByb3V0ZUlkID0gZmV0Y2hlck1hdGNoLnJvdXRlLmlkO1xuICBsZXQgcmVzdWx0ID0gYXdhaXQgZmV0Y2hlck1hdGNoLnJlc29sdmUoXG4gICAgYXN5bmMgKGhhbmRsZXIpID0+IGhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHsgZGF0YTogZGF0YTIgfSA9IGF3YWl0IGZldGNoQW5kRGVjb2RlKGFyZ3MsIGJhc2VuYW1lLCBbcm91dGVJZF0pO1xuICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0KGRhdGEyLCByb3V0ZUlkKTtcbiAgICB9KVxuICApO1xuICByZXR1cm4geyBbZmV0Y2hlck1hdGNoLnJvdXRlLmlkXTogcmVzdWx0IH07XG59XG5mdW5jdGlvbiBzdHJpcEluZGV4UGFyYW0odXJsKSB7XG4gIGxldCBpbmRleFZhbHVlcyA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIik7XG4gIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gIGxldCBpbmRleFZhbHVlc1RvS2VlcCA9IFtdO1xuICBmb3IgKGxldCBpbmRleFZhbHVlIG9mIGluZGV4VmFsdWVzKSB7XG4gICAgaWYgKGluZGV4VmFsdWUpIHtcbiAgICAgIGluZGV4VmFsdWVzVG9LZWVwLnB1c2goaW5kZXhWYWx1ZSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IHRvS2VlcCBvZiBpbmRleFZhbHVlc1RvS2VlcCkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgdG9LZWVwKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gc2luZ2xlRmV0Y2hVcmwocmVxVXJsLCBiYXNlbmFtZSkge1xuICBsZXQgdXJsID0gdHlwZW9mIHJlcVVybCA9PT0gXCJzdHJpbmdcIiA/IG5ldyBVUkwoXG4gICAgcmVxVXJsLFxuICAgIC8vIFRoaXMgY2FuIGJlIGNhbGxlZCBkdXJpbmcgdGhlIFNTUiBmbG93IHZpYSBQcmVmZXRjaFBhZ2VMaW5rc0ltcGwgc29cbiAgICAvLyBkb24ndCBhc3N1bWUgd2luZG93IGlzIGF2YWlsYWJsZVxuICAgIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInNlcnZlcjovL3NpbmdsZWZldGNoL1wiIDogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICApIDogcmVxVXJsO1xuICBpZiAodXJsLnBhdGhuYW1lID09PSBcIi9cIikge1xuICAgIHVybC5wYXRobmFtZSA9IFwiX3Jvb3QuZGF0YVwiO1xuICB9IGVsc2UgaWYgKGJhc2VuYW1lICYmIHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgPT09IFwiL1wiKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gYCR7YmFzZW5hbWUucmVwbGFjZSgvXFwvJC8sIFwiXCIpfS9fcm9vdC5kYXRhYDtcbiAgfSBlbHNlIHtcbiAgICB1cmwucGF0aG5hbWUgPSBgJHt1cmwucGF0aG5hbWUucmVwbGFjZSgvXFwvJC8sIFwiXCIpfS5kYXRhYDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmREZWNvZGVWaWFUdXJib1N0cmVhbShhcmdzLCBiYXNlbmFtZSwgdGFyZ2V0Um91dGVzKSB7XG4gIGxldCB7IHJlcXVlc3QgfSA9IGFyZ3M7XG4gIGxldCB1cmwgPSBzaW5nbGVGZXRjaFVybChyZXF1ZXN0LnVybCwgYmFzZW5hbWUpO1xuICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICB1cmwgPSBzdHJpcEluZGV4UGFyYW0odXJsKTtcbiAgICBpZiAodGFyZ2V0Um91dGVzKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcIl9yb3V0ZXNcIiwgdGFyZ2V0Um91dGVzLmpvaW4oXCIsXCIpKTtcbiAgICB9XG4gIH1cbiAgbGV0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgYXdhaXQgY3JlYXRlUmVxdWVzdEluaXQocmVxdWVzdCkpO1xuICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0ICYmICFyZXMuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlc3BvbnNlXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2VJbXBsKDQwNCwgXCJOb3QgRm91bmRcIiwgdHJ1ZSk7XG4gIH1cbiAgaWYgKHJlcy5zdGF0dXMgPT09IDIwNCAmJiByZXMuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlZGlyZWN0XCIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVUyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVkaXJlY3Q6IHtcbiAgICAgICAgICByZWRpcmVjdDogcmVzLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZWRpcmVjdFwiKSxcbiAgICAgICAgICBzdGF0dXM6IE51bWJlcihyZXMuaGVhZGVycy5nZXQoXCJYLVJlbWl4LVN0YXR1c1wiKSB8fCBcIjMwMlwiKSxcbiAgICAgICAgICByZXZhbGlkYXRlOiByZXMuaGVhZGVycy5nZXQoXCJYLVJlbWl4LVJldmFsaWRhdGVcIikgPT09IFwidHJ1ZVwiLFxuICAgICAgICAgIHJlbG9hZDogcmVzLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIikgPT09IFwidHJ1ZVwiLFxuICAgICAgICAgIHJlcGxhY2U6IHJlcy5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVwbGFjZVwiKSA9PT0gXCJ0cnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgaWYgKE5PX0JPRFlfU1RBVFVTX0NPREVTLmhhcyhyZXMuc3RhdHVzKSkge1xuICAgIGxldCByb3V0ZXMgPSB7fTtcbiAgICBpZiAodGFyZ2V0Um91dGVzICYmIHJlcXVlc3QubWV0aG9kICE9PSBcIkdFVFwiKSB7XG4gICAgICByb3V0ZXNbdGFyZ2V0Um91dGVzWzBdXSA9IHsgZGF0YTogdm9pZCAwIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICBkYXRhOiB7IHJvdXRlcyB9XG4gICAgfTtcbiAgfVxuICBpbnZhcmlhbnQyKHJlcy5ib2R5LCBcIk5vIHJlc3BvbnNlIGJvZHkgdG8gZGVjb2RlXCIpO1xuICB0cnkge1xuICAgIGxldCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlVmlhVHVyYm9TdHJlYW0ocmVzLmJvZHksIHdpbmRvdyk7XG4gICAgbGV0IGRhdGEyO1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgbGV0IHR5cGVkID0gZGVjb2RlZC52YWx1ZTtcbiAgICAgIGlmIChTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sIGluIHR5cGVkKSB7XG4gICAgICAgIGRhdGEyID0geyByZWRpcmVjdDogdHlwZWRbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF0gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEyID0geyByb3V0ZXM6IHR5cGVkIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0eXBlZCA9IGRlY29kZWQudmFsdWU7XG4gICAgICBsZXQgcm91dGVJZCA9IHRhcmdldFJvdXRlcz8uWzBdO1xuICAgICAgaW52YXJpYW50Mihyb3V0ZUlkLCBcIk5vIHJvdXRlSWQgZm91bmQgZm9yIHNpbmdsZSBmZXRjaCBjYWxsIGRlY29kaW5nXCIpO1xuICAgICAgaWYgKFwicmVkaXJlY3RcIiBpbiB0eXBlZCkge1xuICAgICAgICBkYXRhMiA9IHsgcmVkaXJlY3Q6IHR5cGVkIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhMiA9IHsgcm91dGVzOiB7IFtyb3V0ZUlkXTogdHlwZWQgfSB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHJlcy5zdGF0dXMsIGRhdGE6IGRhdGEyIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGVjb2RlIHR1cmJvLXN0cmVhbSByZXNwb25zZVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjb2RlVmlhVHVyYm9TdHJlYW0oYm9keSwgZ2xvYmFsMikge1xuICByZXR1cm4gZGVjb2RlKGJvZHksIHtcbiAgICBwbHVnaW5zOiBbXG4gICAgICAodHlwZSwgLi4ucmVzdCkgPT4ge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJTYW5pdGl6ZWRFcnJvclwiKSB7XG4gICAgICAgICAgbGV0IFtuYW1lLCBtZXNzYWdlLCBzdGFja10gPSByZXN0O1xuICAgICAgICAgIGxldCBDb25zdHJ1Y3RvciA9IEVycm9yO1xuICAgICAgICAgIGlmIChuYW1lICYmIG5hbWUgaW4gZ2xvYmFsMiAmJiB0eXBlb2YgZ2xvYmFsMltuYW1lXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IGdsb2JhbDJbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBlcnJvciA9IG5ldyBDb25zdHJ1Y3RvcihtZXNzYWdlKTtcbiAgICAgICAgICBlcnJvci5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBlcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcIkVycm9yUmVzcG9uc2VcIikge1xuICAgICAgICAgIGxldCBbZGF0YTIsIHN0YXR1cywgc3RhdHVzVGV4dF0gPSByZXN0O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IEVycm9yUmVzcG9uc2VJbXBsKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YTIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJTaW5nbGVGZXRjaFJlZGlyZWN0XCIpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogeyBbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF06IHJlc3RbMF0gfSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcIlNpbmdsZUZldGNoQ2xhc3NJbnN0YW5jZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJlc3RbMF0gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJTaW5nbGVGZXRjaEZhbGxiYWNrXCIpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdm9pZCAwIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH0pO1xufVxuZnVuY3Rpb24gdW53cmFwU2luZ2xlRmV0Y2hSZXN1bHQocmVzdWx0LCByb3V0ZUlkKSB7XG4gIGlmIChcInJlZGlyZWN0XCIgaW4gcmVzdWx0KSB7XG4gICAgbGV0IHtcbiAgICAgIHJlZGlyZWN0OiBsb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGUsXG4gICAgICByZWxvYWQsXG4gICAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICAgIHN0YXR1c1xuICAgIH0gPSByZXN1bHQucmVkaXJlY3Q7XG4gICAgdGhyb3cgcmVkaXJlY3QobG9jYXRpb24sIHtcbiAgICAgIHN0YXR1cyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLy8gVGhyZWUgUidzIG9mIHJlZGlyZWN0aW5nIChsb2wgVmVlcClcbiAgICAgICAgLi4ucmV2YWxpZGF0ZSA/IHsgXCJYLVJlbWl4LVJldmFsaWRhdGVcIjogXCJ5ZXNcIiB9IDogbnVsbCxcbiAgICAgICAgLi4ucmVsb2FkID8geyBcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCI6IFwieWVzXCIgfSA6IG51bGwsXG4gICAgICAgIC4uLnJlcGxhY2UyID8geyBcIlgtUmVtaXgtUmVwbGFjZVwiOiBcInllc1wiIH0gOiBudWxsXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbGV0IHJvdXRlUmVzdWx0ID0gcmVzdWx0LnJvdXRlc1tyb3V0ZUlkXTtcbiAgaWYgKHJvdXRlUmVzdWx0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgU2luZ2xlRmV0Y2hOb1Jlc3VsdEVycm9yKFxuICAgICAgYE5vIHJlc3VsdCBmb3VuZCBmb3Igcm91dGVJZCBcIiR7cm91dGVJZH1cImBcbiAgICApO1xuICB9IGVsc2UgaWYgKFwiZXJyb3JcIiBpbiByb3V0ZVJlc3VsdCkge1xuICAgIHRocm93IHJvdXRlUmVzdWx0LmVycm9yO1xuICB9IGVsc2UgaWYgKFwiZGF0YVwiIGluIHJvdXRlUmVzdWx0KSB7XG4gICAgcmV0dXJuIHJvdXRlUmVzdWx0LmRhdGE7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGZvdW5kIGZvciByb3V0ZUlkIFwiJHtyb3V0ZUlkfVwiYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkMigpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IGFzeW5jICh2YWwpID0+IHtcbiAgICAgIHJlcyh2YWwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlamVjdCA9IGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgcmVqKGVycm9yKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICAvL0B0cy1pZ25vcmVcbiAgICByZXNvbHZlLFxuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJlamVjdFxuICB9O1xufVxuXG4vLyBsaWIvZG9tL3Nzci9mb2ctb2Ytd2FyLnRzXG52YXIgUmVhY3Q4ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuXG4vLyBsaWIvZG9tL3Nzci9yb3V0ZXMudHN4XG52YXIgUmVhY3Q3ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuXG4vLyBsaWIvZG9tL3Nzci9lcnJvckJvdW5kYXJpZXMudHN4XG52YXIgUmVhY3Q1ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIFJlbWl4RXJyb3JCb3VuZGFyeSA9IGNsYXNzIGV4dGVuZHMgUmVhY3Q1LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7IGVycm9yOiBwcm9wcy5lcnJvciB8fCBudWxsLCBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24gfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24pIHtcbiAgICAgIHJldHVybiB7IGVycm9yOiBwcm9wcy5lcnJvciB8fCBudWxsLCBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyb3I6IHByb3BzLmVycm9yIHx8IHN0YXRlLmVycm9yLCBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24gfTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5LFxuICAgICAgICB7XG4gICAgICAgICAgZXJyb3I6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgICAgaXNPdXRzaWRlUmVtaXhBcHA6IHRydWVcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gUmVtaXhSb290RGVmYXVsdEVycm9yQm91bmRhcnkoe1xuICBlcnJvcixcbiAgaXNPdXRzaWRlUmVtaXhBcHBcbn0pIHtcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gIGxldCBoZXlEZXZlbG9wZXIgPSAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJzY3JpcHRcIixcbiAgICB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICBfX2h0bWw6IGBcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCJcXHV7MUY0QkZ9IEhleSBkZXZlbG9wZXIgXFx1ezFGNDRCfS4gWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgd2hlbiB5b3VyIGFwcCB0aHJvd3MgZXJyb3JzLiBDaGVjayBvdXQgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG93LXRvL2Vycm9yLWJvdW5kYXJ5IGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICk7XG4gICAgICBgXG4gICAgICB9XG4gICAgfVxuICApO1xuICBpZiAoaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChCb3VuZGFyeVNoZWxsLCB7IHRpdGxlOiBcIlVuaGFuZGxlZCBUaHJvd24gUmVzcG9uc2UhXCIgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBzdHlsZTogeyBmb250U2l6ZTogXCIyNHB4XCIgfSB9LCBlcnJvci5zdGF0dXMsIFwiIFwiLCBlcnJvci5zdGF0dXNUZXh0KSwgRU5BQkxFX0RFVl9XQVJOSU5HUyA/IGhleURldmVsb3BlciA6IG51bGwpO1xuICB9XG4gIGxldCBlcnJvckluc3RhbmNlO1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGVycm9ySW5zdGFuY2UgPSBlcnJvcjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZXJyb3JTdHJpbmcgPSBlcnJvciA9PSBudWxsID8gXCJVbmtub3duIEVycm9yXCIgOiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJ0b1N0cmluZ1wiIGluIGVycm9yID8gZXJyb3IudG9TdHJpbmcoKSA6IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgICBlcnJvckluc3RhbmNlID0gbmV3IEVycm9yKGVycm9yU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFxuICAgIEJvdW5kYXJ5U2hlbGwsXG4gICAge1xuICAgICAgdGl0bGU6IFwiQXBwbGljYXRpb24gRXJyb3IhXCIsXG4gICAgICBpc091dHNpZGVSZW1peEFwcFxuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBzdHlsZTogeyBmb250U2l6ZTogXCIyNHB4XCIgfSB9LCBcIkFwcGxpY2F0aW9uIEVycm9yXCIpLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICAgIFwicHJlXCIsXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcGFkZGluZzogXCIycmVtXCIsXG4gICAgICAgICAgYmFja2dyb3VuZDogXCJoc2xhKDEwLCA1MCUsIDUwJSwgMC4xKVwiLFxuICAgICAgICAgIGNvbG9yOiBcInJlZFwiLFxuICAgICAgICAgIG92ZXJmbG93OiBcImF1dG9cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJyb3JJbnN0YW5jZS5zdGFja1xuICAgICksXG4gICAgaGV5RGV2ZWxvcGVyXG4gICk7XG59XG5mdW5jdGlvbiBCb3VuZGFyeVNoZWxsKHtcbiAgdGl0bGUsXG4gIHJlbmRlclNjcmlwdHMsXG4gIGlzT3V0c2lkZVJlbWl4QXBwLFxuICBjaGlsZHJlblxufSkge1xuICBsZXQgeyByb3V0ZU1vZHVsZXMgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgaWYgKHJvdXRlTW9kdWxlcy5yb290Py5MYXlvdXQgJiYgIWlzT3V0c2lkZVJlbWl4QXBwKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIsIHsgbGFuZzogXCJlblwiIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImhlYWRcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7IGNoYXJTZXQ6IFwidXRmLThcIiB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFxuICAgIFwibWV0YVwiLFxuICAgIHtcbiAgICAgIG5hbWU6IFwidmlld3BvcnRcIixcbiAgICAgIGNvbnRlbnQ6IFwid2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MSx2aWV3cG9ydC1maXQ9Y292ZXJcIlxuICAgIH1cbiAgKSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgdGl0bGUpKSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwiYm9keVwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJtYWluXCIsIHsgc3R5bGU6IHsgZm9udEZhbWlseTogXCJzeXN0ZW0tdWksIHNhbnMtc2VyaWZcIiwgcGFkZGluZzogXCIycmVtXCIgfSB9LCBjaGlsZHJlbiwgcmVuZGVyU2NyaXB0cyA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChTY3JpcHRzLCBudWxsKSA6IG51bGwpKSk7XG59XG5cbi8vIGxpYi9kb20vc3NyL2ZhbGxiYWNrLnRzeFxudmFyIFJlYWN0NiA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIFJlbWl4Um9vdERlZmF1bHRIeWRyYXRlRmFsbGJhY2soKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoQm91bmRhcnlTaGVsbCwgeyB0aXRsZTogXCJMb2FkaW5nLi4uXCIsIHJlbmRlclNjcmlwdHM6IHRydWUgfSwgRU5BQkxFX0RFVl9XQVJOSU5HUyA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgIF9faHRtbDogYFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBcIlxcdXsxRjRCRn0gSGV5IGRldmVsb3BlciBcXHV7MUY0NEJ9LiBZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyBcIiArXG4gICAgICAgICAgICAgICAgXCJ3aGVuIHlvdXIgYXBwIGlzIGxvYWRpbmcgSlMgbW9kdWxlcyBhbmQvb3IgcnVubmluZyBcXGBjbGllbnRMb2FkZXJcXGAgXCIgK1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25zLiBDaGVjayBvdXQgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vc3RhcnQvZnJhbWV3b3JrL3JvdXRlLW1vZHVsZSNoeWRyYXRlZmFsbGJhY2sgXCIgK1xuICAgICAgICAgICAgICAgIFwiZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGBcbiAgICAgIH1cbiAgICB9XG4gICkgOiBudWxsKTtcbn1cblxuLy8gbGliL2RvbS9zc3Ivcm91dGVzLnRzeFxuZnVuY3Rpb24gZ3JvdXBSb3V0ZXNCeVBhcmVudElkKG1hbmlmZXN0KSB7XG4gIGxldCByb3V0ZXMgPSB7fTtcbiAgT2JqZWN0LnZhbHVlcyhtYW5pZmVzdCkuZm9yRWFjaCgocm91dGUpID0+IHtcbiAgICBpZiAocm91dGUpIHtcbiAgICAgIGxldCBwYXJlbnRJZCA9IHJvdXRlLnBhcmVudElkIHx8IFwiXCI7XG4gICAgICBpZiAoIXJvdXRlc1twYXJlbnRJZF0pIHtcbiAgICAgICAgcm91dGVzW3BhcmVudElkXSA9IFtdO1xuICAgICAgfVxuICAgICAgcm91dGVzW3BhcmVudElkXS5wdXNoKHJvdXRlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm91dGVzO1xufVxuZnVuY3Rpb24gZ2V0Um91dGVDb21wb25lbnRzKHJvdXRlLCByb3V0ZU1vZHVsZSwgaXNTcGFNb2RlKSB7XG4gIGxldCBDb21wb25lbnQ0ID0gZ2V0Um91dGVNb2R1bGVDb21wb25lbnQocm91dGVNb2R1bGUpO1xuICBsZXQgSHlkcmF0ZUZhbGxiYWNrID0gcm91dGVNb2R1bGUuSHlkcmF0ZUZhbGxiYWNrICYmICghaXNTcGFNb2RlIHx8IHJvdXRlLmlkID09PSBcInJvb3RcIikgPyByb3V0ZU1vZHVsZS5IeWRyYXRlRmFsbGJhY2sgOiByb3V0ZS5pZCA9PT0gXCJyb290XCIgPyBSZW1peFJvb3REZWZhdWx0SHlkcmF0ZUZhbGxiYWNrIDogdm9pZCAwO1xuICBsZXQgRXJyb3JCb3VuZGFyeSA9IHJvdXRlTW9kdWxlLkVycm9yQm91bmRhcnkgPyByb3V0ZU1vZHVsZS5FcnJvckJvdW5kYXJ5IDogcm91dGUuaWQgPT09IFwicm9vdFwiID8gKCkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5LCB7IGVycm9yOiB1c2VSb3V0ZUVycm9yKCkgfSkgOiB2b2lkIDA7XG4gIGlmIChyb3V0ZS5pZCA9PT0gXCJyb290XCIgJiYgcm91dGVNb2R1bGUuTGF5b3V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkNvbXBvbmVudDQgPyB7XG4gICAgICAgIGVsZW1lbnQ6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChyb3V0ZU1vZHVsZS5MYXlvdXQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChDb21wb25lbnQ0LCBudWxsKSlcbiAgICAgIH0gOiB7IENvbXBvbmVudDogQ29tcG9uZW50NCB9LFxuICAgICAgLi4uRXJyb3JCb3VuZGFyeSA/IHtcbiAgICAgICAgZXJyb3JFbGVtZW50OiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQocm91dGVNb2R1bGUuTGF5b3V0LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeSwgbnVsbCkpXG4gICAgICB9IDogeyBFcnJvckJvdW5kYXJ5IH0sXG4gICAgICAuLi5IeWRyYXRlRmFsbGJhY2sgPyB7XG4gICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChyb3V0ZU1vZHVsZS5MYXlvdXQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChIeWRyYXRlRmFsbGJhY2ssIG51bGwpKVxuICAgICAgfSA6IHsgSHlkcmF0ZUZhbGxiYWNrIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7IENvbXBvbmVudDogQ29tcG9uZW50NCwgRXJyb3JCb3VuZGFyeSwgSHlkcmF0ZUZhbGxiYWNrIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJSb3V0ZXMobWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgZnV0dXJlLCBpc1NwYU1vZGUsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCksIHNwYU1vZGVMYXp5UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh7IENvbXBvbmVudDogKCkgPT4gbnVsbCB9KSkge1xuICByZXR1cm4gKHJvdXRlc0J5UGFyZW50SWRbcGFyZW50SWRdIHx8IFtdKS5tYXAoKHJvdXRlKSA9PiB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gcm91dGVNb2R1bGVzW3JvdXRlLmlkXTtcbiAgICBpbnZhcmlhbnQyKFxuICAgICAgcm91dGVNb2R1bGUsXG4gICAgICBcIk5vIGByb3V0ZU1vZHVsZWAgYXZhaWxhYmxlIHRvIGNyZWF0ZSBzZXJ2ZXIgcm91dGVzXCJcbiAgICApO1xuICAgIGxldCBkYXRhUm91dGUgPSB7XG4gICAgICAuLi5nZXRSb3V0ZUNvbXBvbmVudHMocm91dGUsIHJvdXRlTW9kdWxlLCBpc1NwYU1vZGUpLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIGluZGV4OiByb3V0ZS5pbmRleCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGgsXG4gICAgICBoYW5kbGU6IHJvdXRlTW9kdWxlLmhhbmRsZSxcbiAgICAgIC8vIEZvciBTUEEgTW9kZSwgYWxsIHJvdXRlcyBhcmUgbGF6eSBleGNlcHQgcm9vdC4gIEhvd2V2ZXIgd2UgdGVsbCB0aGVcbiAgICAgIC8vIHJvdXRlciByb290IGlzIGFsc28gbGF6eSBoZXJlIHRvbyBzaW5jZSB3ZSBkb24ndCBuZWVkIGEgZnVsbFxuICAgICAgLy8gaW1wbGVtZW50YXRpb24gLSB3ZSBqdXN0IG5lZWQgYSBgbGF6eWAgcHJvcCB0byB0ZWxsIHRoZSBSUiByZW5kZXJpbmdcbiAgICAgIC8vIHdoZXJlIHRvIHN0b3Agd2hpY2ggaXMgYWx3YXlzIGF0IHRoZSByb290IHJvdXRlIGluIFNQQSBtb2RlXG4gICAgICBsYXp5OiBpc1NwYU1vZGUgPyAoKSA9PiBzcGFNb2RlTGF6eVByb21pc2UgOiB2b2lkIDAsXG4gICAgICAvLyBGb3IgcGFydGlhbCBoeWRyYXRpb24gcmVuZGVyaW5nLCB3ZSBuZWVkIHRvIGluZGljYXRlIHdoZW4gdGhlIHJvdXRlXG4gICAgICAvLyBoYXMgYSBsb2FkZXIvY2xpZW50TG9hZGVyLCBidXQgaXQgd29uJ3QgZXZlciBiZSBjYWxsZWQgZHVyaW5nIHRoZSBzdGF0aWNcbiAgICAgIC8vIHJlbmRlciwgc28ganVzdCBnaXZlIGl0IGEgbm8tb3AgZnVuY3Rpb24gc28gd2UgY2FuIHJlbmRlciBkb3duIHRvIHRoZVxuICAgICAgLy8gcHJvcGVyIGZhbGxiYWNrXG4gICAgICBsb2FkZXI6IHJvdXRlLmhhc0xvYWRlciB8fCByb3V0ZS5oYXNDbGllbnRMb2FkZXIgPyAoKSA9PiBudWxsIDogdm9pZCAwXG4gICAgICAvLyBXZSBkb24ndCBuZWVkIG1pZGRsZXdhcmUvYWN0aW9uL3Nob3VsZFJldmFsaWRhdGUgb24gdGhlc2Ugcm91dGVzIHNpbmNlXG4gICAgICAvLyB0aGV5J3JlIGZvciBhIHN0YXRpYyByZW5kZXJcbiAgICB9O1xuICAgIGxldCBjaGlsZHJlbiA9IGNyZWF0ZVNlcnZlclJvdXRlcyhcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgcm91dGVNb2R1bGVzLFxuICAgICAgZnV0dXJlLFxuICAgICAgaXNTcGFNb2RlLFxuICAgICAgcm91dGUuaWQsXG4gICAgICByb3V0ZXNCeVBhcmVudElkLFxuICAgICAgc3BhTW9kZUxhenlQcm9taXNlXG4gICAgKTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkgZGF0YVJvdXRlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIGRhdGFSb3V0ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnRSb3V0ZXNXaXRoSE1SUmV2YWxpZGF0aW9uT3B0T3V0KG5lZWRzUmV2YWxpZGF0aW9uLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzQ2FjaGUsIGluaXRpYWxTdGF0ZSwgc3NyLCBpc1NwYU1vZGUpIHtcbiAgcmV0dXJuIGNyZWF0ZUNsaWVudFJvdXRlcyhcbiAgICBtYW5pZmVzdCxcbiAgICByb3V0ZU1vZHVsZXNDYWNoZSxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgc3NyLFxuICAgIGlzU3BhTW9kZSxcbiAgICBcIlwiLFxuICAgIGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCksXG4gICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRJbnZhbGlkU2VydmVySGFuZGxlckNhbGwodHlwZSwgcm91dGUpIHtcbiAgaWYgKHR5cGUgPT09IFwibG9hZGVyXCIgJiYgIXJvdXRlLmhhc0xvYWRlciB8fCB0eXBlID09PSBcImFjdGlvblwiICYmICFyb3V0ZS5oYXNBY3Rpb24pIHtcbiAgICBsZXQgZm4gPSB0eXBlID09PSBcImFjdGlvblwiID8gXCJzZXJ2ZXJBY3Rpb24oKVwiIDogXCJzZXJ2ZXJMb2FkZXIoKVwiO1xuICAgIGxldCBtc2cgPSBgWW91IGFyZSB0cnlpbmcgdG8gY2FsbCAke2ZufSBvbiBhIHJvdXRlIHRoYXQgZG9lcyBub3QgaGF2ZSBhIHNlcnZlciAke3R5cGV9IChyb3V0ZUlkOiBcIiR7cm91dGUuaWR9XCIpYDtcbiAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2VJbXBsKDQwMCwgXCJCYWQgUmVxdWVzdFwiLCBuZXcgRXJyb3IobXNnKSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vQWN0aW9uRGVmaW5lZEVycm9yKHR5cGUsIHJvdXRlSWQpIHtcbiAgbGV0IGFydGljbGUgPSB0eXBlID09PSBcImNsaWVudEFjdGlvblwiID8gXCJhXCIgOiBcImFuXCI7XG4gIGxldCBtc2cgPSBgUm91dGUgXCIke3JvdXRlSWR9XCIgZG9lcyBub3QgaGF2ZSAke2FydGljbGV9ICR7dHlwZX0sIGJ1dCB5b3UgYXJlIHRyeWluZyB0byBzdWJtaXQgdG8gaXQuIFRvIGZpeCB0aGlzLCBwbGVhc2UgYWRkICR7YXJ0aWNsZX0gXFxgJHt0eXBlfVxcYCBmdW5jdGlvbiB0byB0aGUgcm91dGVgO1xuICBjb25zb2xlLmVycm9yKG1zZyk7XG4gIHRocm93IG5ldyBFcnJvclJlc3BvbnNlSW1wbCg0MDUsIFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsIG5ldyBFcnJvcihtc2cpLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFJvdXRlcyhtYW5pZmVzdCwgcm91dGVNb2R1bGVzQ2FjaGUsIGluaXRpYWxTdGF0ZSwgc3NyLCBpc1NwYU1vZGUsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCksIG5lZWRzUmV2YWxpZGF0aW9uKSB7XG4gIHJldHVybiAocm91dGVzQnlQYXJlbnRJZFtwYXJlbnRJZF0gfHwgW10pLm1hcCgocm91dGUpID0+IHtcbiAgICBsZXQgcm91dGVNb2R1bGUgPSByb3V0ZU1vZHVsZXNDYWNoZVtyb3V0ZS5pZF07XG4gICAgZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJIYW5kbGVyKHNpbmdsZUZldGNoKSB7XG4gICAgICBpbnZhcmlhbnQyKFxuICAgICAgICB0eXBlb2Ygc2luZ2xlRmV0Y2ggPT09IFwiZnVuY3Rpb25cIixcbiAgICAgICAgXCJObyBzaW5nbGUgZmV0Y2ggZnVuY3Rpb24gYXZhaWxhYmxlIGZvciByb3V0ZSBoYW5kbGVyXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gc2luZ2xlRmV0Y2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJMb2FkZXIoc2luZ2xlRmV0Y2gpIHtcbiAgICAgIGlmICghcm91dGUuaGFzTG9hZGVyKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgcmV0dXJuIGZldGNoU2VydmVySGFuZGxlcihzaW5nbGVGZXRjaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZldGNoU2VydmVyQWN0aW9uKHNpbmdsZUZldGNoKSB7XG4gICAgICBpZiAoIXJvdXRlLmhhc0FjdGlvbikge1xuICAgICAgICB0aHJvdyBub0FjdGlvbkRlZmluZWRFcnJvcihcImFjdGlvblwiLCByb3V0ZS5pZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJIYW5kbGVyKHNpbmdsZUZldGNoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlZmV0Y2hNb2R1bGUobW9kdWxlUGF0aCkge1xuICAgICAgaW1wb3J0KFxuICAgICAgICAvKiBAdml0ZS1pZ25vcmUgKi9cbiAgICAgICAgLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqL1xuICAgICAgICBtb2R1bGVQYXRoXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVmZXRjaFJvdXRlTW9kdWxlQ2h1bmtzKHJvdXRlMikge1xuICAgICAgaWYgKHJvdXRlMi5jbGllbnRBY3Rpb25Nb2R1bGUpIHtcbiAgICAgICAgcHJlZmV0Y2hNb2R1bGUocm91dGUyLmNsaWVudEFjdGlvbk1vZHVsZSk7XG4gICAgICB9XG4gICAgICBpZiAocm91dGUyLmNsaWVudExvYWRlck1vZHVsZSkge1xuICAgICAgICBwcmVmZXRjaE1vZHVsZShyb3V0ZTIuY2xpZW50TG9hZGVyTW9kdWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICBsZXQgY2FjaGVkTW9kdWxlID0gcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdO1xuICAgICAgbGV0IGxpbmtQcmVmZXRjaFByb21pc2UgPSBjYWNoZWRNb2R1bGUgPyBwcmVmZXRjaFN0eWxlTGlua3Mocm91dGUsIGNhY2hlZE1vZHVsZSkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhd2FpdCBsaW5rUHJlZmV0Y2hQcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGF0YVJvdXRlID0ge1xuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgaW5kZXg6IHJvdXRlLmluZGV4LFxuICAgICAgcGF0aDogcm91dGUucGF0aFxuICAgIH07XG4gICAgaWYgKHJvdXRlTW9kdWxlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGRhdGFSb3V0ZSwge1xuICAgICAgICAuLi5kYXRhUm91dGUsXG4gICAgICAgIC4uLmdldFJvdXRlQ29tcG9uZW50cyhyb3V0ZSwgcm91dGVNb2R1bGUsIGlzU3BhTW9kZSksXG4gICAgICAgIHVuc3RhYmxlX21pZGRsZXdhcmU6IHJvdXRlTW9kdWxlLnVuc3RhYmxlX2NsaWVudE1pZGRsZXdhcmUsXG4gICAgICAgIGhhbmRsZTogcm91dGVNb2R1bGUuaGFuZGxlLFxuICAgICAgICBzaG91bGRSZXZhbGlkYXRlOiBnZXRTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24oXG4gICAgICAgICAgZGF0YVJvdXRlLnBhdGgsXG4gICAgICAgICAgcm91dGVNb2R1bGUsXG4gICAgICAgICAgcm91dGUsXG4gICAgICAgICAgc3NyLFxuICAgICAgICAgIG5lZWRzUmV2YWxpZGF0aW9uXG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgbGV0IGhhc0luaXRpYWxEYXRhID0gaW5pdGlhbFN0YXRlICYmIGluaXRpYWxTdGF0ZS5sb2FkZXJEYXRhICYmIHJvdXRlLmlkIGluIGluaXRpYWxTdGF0ZS5sb2FkZXJEYXRhO1xuICAgICAgbGV0IGluaXRpYWxEYXRhID0gaGFzSW5pdGlhbERhdGEgPyBpbml0aWFsU3RhdGU/LmxvYWRlckRhdGE/Lltyb3V0ZS5pZF0gOiB2b2lkIDA7XG4gICAgICBsZXQgaGFzSW5pdGlhbEVycm9yID0gaW5pdGlhbFN0YXRlICYmIGluaXRpYWxTdGF0ZS5lcnJvcnMgJiYgcm91dGUuaWQgaW4gaW5pdGlhbFN0YXRlLmVycm9ycztcbiAgICAgIGxldCBpbml0aWFsRXJyb3IgPSBoYXNJbml0aWFsRXJyb3IgPyBpbml0aWFsU3RhdGU/LmVycm9ycz8uW3JvdXRlLmlkXSA6IHZvaWQgMDtcbiAgICAgIGxldCBpc0h5ZHJhdGlvblJlcXVlc3QgPSBuZWVkc1JldmFsaWRhdGlvbiA9PSBudWxsICYmIChyb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXI/Lmh5ZHJhdGUgPT09IHRydWUgfHwgIXJvdXRlLmhhc0xvYWRlcik7XG4gICAgICBkYXRhUm91dGUubG9hZGVyID0gYXN5bmMgKHsgcmVxdWVzdCwgcGFyYW1zLCBjb250ZXh0IH0sIHNpbmdsZUZldGNoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaW52YXJpYW50MihcbiAgICAgICAgICAgICAgcm91dGVNb2R1bGUsXG4gICAgICAgICAgICAgIFwiTm8gYHJvdXRlTW9kdWxlYCBhdmFpbGFibGUgZm9yIGNyaXRpY2FsLXJvdXRlIGxvYWRlclwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFyb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyTG9hZGVyKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIoe1xuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIGFzeW5jIHNlcnZlckxvYWRlcigpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwibG9hZGVyXCIsIHJvdXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIeWRyYXRpb25SZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaGFzSW5pdGlhbERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxEYXRhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGhhc0luaXRpYWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyb3I7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckxvYWRlcihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaXNIeWRyYXRpb25SZXF1ZXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBkYXRhUm91dGUubG9hZGVyLmh5ZHJhdGUgPSBzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIoXG4gICAgICAgIHJvdXRlLmlkLFxuICAgICAgICByb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIsXG4gICAgICAgIHJvdXRlLmhhc0xvYWRlcixcbiAgICAgICAgaXNTcGFNb2RlXG4gICAgICApO1xuICAgICAgZGF0YVJvdXRlLmFjdGlvbiA9ICh7IHJlcXVlc3QsIHBhcmFtcywgY29udGV4dCB9LCBzaW5nbGVGZXRjaCkgPT4ge1xuICAgICAgICByZXR1cm4gcHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaW52YXJpYW50MihcbiAgICAgICAgICAgIHJvdXRlTW9kdWxlLFxuICAgICAgICAgICAgXCJObyBgcm91dGVNb2R1bGVgIGF2YWlsYWJsZSBmb3IgY3JpdGljYWwtcm91dGUgYWN0aW9uXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghcm91dGVNb2R1bGUuY2xpZW50QWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoaXNTcGFNb2RlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5vQWN0aW9uRGVmaW5lZEVycm9yKFwiY2xpZW50QWN0aW9uXCIsIHJvdXRlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckFjdGlvbihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByb3V0ZU1vZHVsZS5jbGllbnRBY3Rpb24oe1xuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBhc3luYyBzZXJ2ZXJBY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHByZXZlbnRJbnZhbGlkU2VydmVySGFuZGxlckNhbGwoXCJhY3Rpb25cIiwgcm91dGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc2luZ2xlRmV0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcm91dGUuaGFzQ2xpZW50TG9hZGVyKSB7XG4gICAgICAgIGRhdGFSb3V0ZS5sb2FkZXIgPSAoXywgc2luZ2xlRmV0Y2gpID0+IHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckxvYWRlcihzaW5nbGVGZXRjaCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFyb3V0ZS5oYXNDbGllbnRBY3Rpb24pIHtcbiAgICAgICAgZGF0YVJvdXRlLmFjdGlvbiA9IChfLCBzaW5nbGVGZXRjaCkgPT4gcHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlcigoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzU3BhTW9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbm9BY3Rpb25EZWZpbmVkRXJyb3IoXCJjbGllbnRBY3Rpb25cIiwgcm91dGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc2luZ2xlRmV0Y2gpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxldCBsYXp5Um91dGVQcm9taXNlO1xuICAgICAgYXN5bmMgZnVuY3Rpb24gZ2V0TGF6eVJvdXRlKCkge1xuICAgICAgICBpZiAobGF6eVJvdXRlUHJvbWlzZSkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBsYXp5Um91dGVQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGxhenlSb3V0ZVByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmIChyb3V0ZS5jbGllbnRMb2FkZXJNb2R1bGUgfHwgcm91dGUuY2xpZW50QWN0aW9uTW9kdWxlKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByb3V0ZU1vZHVsZVByb21pc2UgPSBsb2FkUm91dGVNb2R1bGVXaXRoQmxvY2tpbmdMaW5rcyhcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgcm91dGVNb2R1bGVzQ2FjaGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHByZWZldGNoUm91dGVNb2R1bGVDaHVua3Mocm91dGUpO1xuICAgICAgICAgIHJldHVybiBhd2FpdCByb3V0ZU1vZHVsZVByb21pc2U7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBsYXp5Um91dGVQcm9taXNlO1xuICAgICAgfVxuICAgICAgZGF0YVJvdXRlLmxhenkgPSB7XG4gICAgICAgIGxvYWRlcjogcm91dGUuaGFzQ2xpZW50TG9hZGVyID8gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGxldCB7IGNsaWVudExvYWRlciB9ID0gcm91dGUuY2xpZW50TG9hZGVyTW9kdWxlID8gYXdhaXQgaW1wb3J0KFxuICAgICAgICAgICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgICAgICAgICAvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovXG4gICAgICAgICAgICByb3V0ZS5jbGllbnRMb2FkZXJNb2R1bGVcbiAgICAgICAgICApIDogYXdhaXQgZ2V0TGF6eVJvdXRlKCk7XG4gICAgICAgICAgaW52YXJpYW50MihjbGllbnRMb2FkZXIsIFwiTm8gYGNsaWVudExvYWRlcmAgZXhwb3J0IGZvdW5kXCIpO1xuICAgICAgICAgIHJldHVybiAoYXJncywgc2luZ2xlRmV0Y2gpID0+IGNsaWVudExvYWRlcih7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgYXN5bmMgc2VydmVyTG9hZGVyKCkge1xuICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwibG9hZGVyXCIsIHJvdXRlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyTG9hZGVyKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgYWN0aW9uOiByb3V0ZS5oYXNDbGllbnRBY3Rpb24gPyBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgbGV0IGNsaWVudEFjdGlvblByb21pc2UgPSByb3V0ZS5jbGllbnRBY3Rpb25Nb2R1bGUgPyBpbXBvcnQoXG4gICAgICAgICAgICAvKiBAdml0ZS1pZ25vcmUgKi9cbiAgICAgICAgICAgIC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi9cbiAgICAgICAgICAgIHJvdXRlLmNsaWVudEFjdGlvbk1vZHVsZVxuICAgICAgICAgICkgOiBnZXRMYXp5Um91dGUoKTtcbiAgICAgICAgICBwcmVmZXRjaFJvdXRlTW9kdWxlQ2h1bmtzKHJvdXRlKTtcbiAgICAgICAgICBsZXQgeyBjbGllbnRBY3Rpb24gfSA9IGF3YWl0IGNsaWVudEFjdGlvblByb21pc2U7XG4gICAgICAgICAgaW52YXJpYW50MihjbGllbnRBY3Rpb24sIFwiTm8gYGNsaWVudEFjdGlvbmAgZXhwb3J0IGZvdW5kXCIpO1xuICAgICAgICAgIHJldHVybiAoYXJncywgc2luZ2xlRmV0Y2gpID0+IGNsaWVudEFjdGlvbih7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgYXN5bmMgc2VydmVyQWN0aW9uKCkge1xuICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwiYWN0aW9uXCIsIHJvdXRlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyQWN0aW9uKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgdW5zdGFibGVfbWlkZGxld2FyZTogcm91dGUuaGFzQ2xpZW50TWlkZGxld2FyZSA/IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBsZXQgeyB1bnN0YWJsZV9jbGllbnRNaWRkbGV3YXJlIH0gPSByb3V0ZS5jbGllbnRNaWRkbGV3YXJlTW9kdWxlID8gYXdhaXQgaW1wb3J0KFxuICAgICAgICAgICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgICAgICAgICAvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovXG4gICAgICAgICAgICByb3V0ZS5jbGllbnRNaWRkbGV3YXJlTW9kdWxlXG4gICAgICAgICAgKSA6IGF3YWl0IGdldExhenlSb3V0ZSgpO1xuICAgICAgICAgIGludmFyaWFudDIoXG4gICAgICAgICAgICB1bnN0YWJsZV9jbGllbnRNaWRkbGV3YXJlLFxuICAgICAgICAgICAgXCJObyBgdW5zdGFibGVfY2xpZW50TWlkZGxld2FyZWAgZXhwb3J0IGZvdW5kXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB1bnN0YWJsZV9jbGllbnRNaWRkbGV3YXJlO1xuICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICBzaG91bGRSZXZhbGlkYXRlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgbGV0IGxhenlSb3V0ZSA9IGF3YWl0IGdldExhenlSb3V0ZSgpO1xuICAgICAgICAgIHJldHVybiBnZXRTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24oXG4gICAgICAgICAgICBkYXRhUm91dGUucGF0aCxcbiAgICAgICAgICAgIGxhenlSb3V0ZSxcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgc3NyLFxuICAgICAgICAgICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBoYW5kbGU6IGFzeW5jICgpID0+IChhd2FpdCBnZXRMYXp5Um91dGUoKSkuaGFuZGxlLFxuICAgICAgICAvLyBObyBuZWVkIHRvIHdyYXAgdGhlc2UgaW4gbGF5b3V0IHNpbmNlIHRoZSByb290IHJvdXRlIGlzIG5ldmVyXG4gICAgICAgIC8vIGxvYWRlZCB2aWEgcm91dGUubGF6eSgpXG4gICAgICAgIENvbXBvbmVudDogYXN5bmMgKCkgPT4gKGF3YWl0IGdldExhenlSb3V0ZSgpKS5Db21wb25lbnQsXG4gICAgICAgIEVycm9yQm91bmRhcnk6IHJvdXRlLmhhc0Vycm9yQm91bmRhcnkgPyBhc3luYyAoKSA9PiAoYXdhaXQgZ2V0TGF6eVJvdXRlKCkpLkVycm9yQm91bmRhcnkgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IGNyZWF0ZUNsaWVudFJvdXRlcyhcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgcm91dGVNb2R1bGVzQ2FjaGUsXG4gICAgICBpbml0aWFsU3RhdGUsXG4gICAgICBzc3IsXG4gICAgICBpc1NwYU1vZGUsXG4gICAgICByb3V0ZS5pZCxcbiAgICAgIHJvdXRlc0J5UGFyZW50SWQsXG4gICAgICBuZWVkc1JldmFsaWRhdGlvblxuICAgICk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIGRhdGFSb3V0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHJldHVybiBkYXRhUm91dGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uKHBhdGgsIHJvdXRlLCBtYW5pZmVzdFJvdXRlLCBzc3IsIG5lZWRzUmV2YWxpZGF0aW9uKSB7XG4gIGlmIChuZWVkc1JldmFsaWRhdGlvbikge1xuICAgIHJldHVybiB3cmFwU2hvdWxkUmV2YWxpZGF0ZUZvckhkcihcbiAgICAgIG1hbmlmZXN0Um91dGUuaWQsXG4gICAgICByb3V0ZS5zaG91bGRSZXZhbGlkYXRlLFxuICAgICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgICApO1xuICB9XG4gIGlmICghc3NyICYmIG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyICYmICFtYW5pZmVzdFJvdXRlLmhhc0NsaWVudExvYWRlcikge1xuICAgIGxldCBteVBhcmFtcyA9IHBhdGggPyBjb21waWxlUGF0aChwYXRoKVsxXS5tYXAoKHApID0+IHAucGFyYW1OYW1lKSA6IFtdO1xuICAgIGNvbnN0IGRpZFBhcmFtc0NoYW5nZSA9IChvcHRzKSA9PiBteVBhcmFtcy5zb21lKChwKSA9PiBvcHRzLmN1cnJlbnRQYXJhbXNbcF0gIT09IG9wdHMubmV4dFBhcmFtc1twXSk7XG4gICAgaWYgKHJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgIGxldCBmbiA9IHJvdXRlLnNob3VsZFJldmFsaWRhdGU7XG4gICAgICByZXR1cm4gKG9wdHMpID0+IGZuKHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IGRpZFBhcmFtc0NoYW5nZShvcHRzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAob3B0cykgPT4gZGlkUGFyYW1zQ2hhbmdlKG9wdHMpO1xuICAgIH1cbiAgfVxuICBpZiAoc3NyICYmIHJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICBsZXQgZm4gPSByb3V0ZS5zaG91bGRSZXZhbGlkYXRlO1xuICAgIHJldHVybiAob3B0cykgPT4gZm4oeyAuLi5vcHRzLCBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogdHJ1ZSB9KTtcbiAgfVxuICByZXR1cm4gcm91dGUuc2hvdWxkUmV2YWxpZGF0ZTtcbn1cbmZ1bmN0aW9uIHdyYXBTaG91bGRSZXZhbGlkYXRlRm9ySGRyKHJvdXRlSWQsIHJvdXRlU2hvdWxkUmV2YWxpZGF0ZSwgbmVlZHNSZXZhbGlkYXRpb24pIHtcbiAgbGV0IGhhbmRsZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcbiAgcmV0dXJuIChhcmcpID0+IHtcbiAgICBpZiAoIWhhbmRsZWRSZXZhbGlkYXRpb24pIHtcbiAgICAgIGhhbmRsZWRSZXZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgcmV0dXJuIG5lZWRzUmV2YWxpZGF0aW9uLmhhcyhyb3V0ZUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdXRlU2hvdWxkUmV2YWxpZGF0ZSA/IHJvdXRlU2hvdWxkUmV2YWxpZGF0ZShhcmcpIDogYXJnLmRlZmF1bHRTaG91bGRSZXZhbGlkYXRlO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZFJvdXRlTW9kdWxlV2l0aEJsb2NraW5nTGlua3Mocm91dGUsIHJvdXRlTW9kdWxlcykge1xuICBsZXQgcm91dGVNb2R1bGVQcm9taXNlID0gbG9hZFJvdXRlTW9kdWxlKHJvdXRlLCByb3V0ZU1vZHVsZXMpO1xuICBsZXQgcHJlZmV0Y2hSb3V0ZUNzc1Byb21pc2UgPSBwcmVmZXRjaFJvdXRlQ3NzKHJvdXRlKTtcbiAgbGV0IHJvdXRlTW9kdWxlID0gYXdhaXQgcm91dGVNb2R1bGVQcm9taXNlO1xuICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgcHJlZmV0Y2hSb3V0ZUNzc1Byb21pc2UsXG4gICAgcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZSlcbiAgXSk7XG4gIHJldHVybiB7XG4gICAgQ29tcG9uZW50OiBnZXRSb3V0ZU1vZHVsZUNvbXBvbmVudChyb3V0ZU1vZHVsZSksXG4gICAgRXJyb3JCb3VuZGFyeTogcm91dGVNb2R1bGUuRXJyb3JCb3VuZGFyeSxcbiAgICB1bnN0YWJsZV9jbGllbnRNaWRkbGV3YXJlOiByb3V0ZU1vZHVsZS51bnN0YWJsZV9jbGllbnRNaWRkbGV3YXJlLFxuICAgIGNsaWVudEFjdGlvbjogcm91dGVNb2R1bGUuY2xpZW50QWN0aW9uLFxuICAgIGNsaWVudExvYWRlcjogcm91dGVNb2R1bGUuY2xpZW50TG9hZGVyLFxuICAgIGhhbmRsZTogcm91dGVNb2R1bGUuaGFuZGxlLFxuICAgIGxpbmtzOiByb3V0ZU1vZHVsZS5saW5rcyxcbiAgICBtZXRhOiByb3V0ZU1vZHVsZS5tZXRhLFxuICAgIHNob3VsZFJldmFsaWRhdGU6IHJvdXRlTW9kdWxlLnNob3VsZFJldmFsaWRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJvdXRlTW9kdWxlQ29tcG9uZW50KHJvdXRlTW9kdWxlKSB7XG4gIGlmIChyb3V0ZU1vZHVsZS5kZWZhdWx0ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gIGxldCBpc0VtcHR5T2JqZWN0ID0gdHlwZW9mIHJvdXRlTW9kdWxlLmRlZmF1bHQgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMocm91dGVNb2R1bGUuZGVmYXVsdCkubGVuZ3RoID09PSAwO1xuICBpZiAoIWlzRW1wdHlPYmplY3QpIHtcbiAgICByZXR1cm4gcm91dGVNb2R1bGUuZGVmYXVsdDtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyKHJvdXRlSWQsIGNsaWVudExvYWRlciwgaGFzTG9hZGVyLCBpc1NwYU1vZGUpIHtcbiAgcmV0dXJuIGlzU3BhTW9kZSAmJiByb3V0ZUlkICE9PSBcInJvb3RcIiB8fCBjbGllbnRMb2FkZXIgIT0gbnVsbCAmJiAoY2xpZW50TG9hZGVyLmh5ZHJhdGUgPT09IHRydWUgfHwgaGFzTG9hZGVyICE9PSB0cnVlKTtcbn1cblxuLy8gbGliL2RvbS9zc3IvZm9nLW9mLXdhci50c1xudmFyIG5leHRQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG52YXIgZGlzY292ZXJlZFBhdGhzTWF4U2l6ZSA9IDFlMztcbnZhciBkaXNjb3ZlcmVkUGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xudmFyIFVSTF9MSU1JVCA9IDc2ODA7XG5mdW5jdGlvbiBpc0ZvZ09mV2FyRW5hYmxlZChyb3V0ZURpc2NvdmVyeSwgc3NyKSB7XG4gIHJldHVybiByb3V0ZURpc2NvdmVyeS5tb2RlID09PSBcImxhenlcIiAmJiBzc3IgPT09IHRydWU7XG59XG5mdW5jdGlvbiBnZXRQYXJ0aWFsTWFuaWZlc3QoeyBzcmksIC4uLm1hbmlmZXN0IH0sIHJvdXRlcikge1xuICBsZXQgcm91dGVJZHMgPSBuZXcgU2V0KHJvdXRlci5zdGF0ZS5tYXRjaGVzLm1hcCgobSkgPT4gbS5yb3V0ZS5pZCkpO1xuICBsZXQgc2VnbWVudHMgPSByb3V0ZXIuc3RhdGUubG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IHBhdGhzID0gW1wiL1wiXTtcbiAgc2VnbWVudHMucG9wKCk7XG4gIHdoaWxlIChzZWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgcGF0aHMucHVzaChgLyR7c2VnbWVudHMuam9pbihcIi9cIil9YCk7XG4gICAgc2VnbWVudHMucG9wKCk7XG4gIH1cbiAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVyLnJvdXRlcywgcGF0aCwgcm91dGVyLmJhc2VuYW1lKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgbWF0Y2hlcy5mb3JFYWNoKChtKSA9PiByb3V0ZUlkcy5hZGQobS5yb3V0ZS5pZCkpO1xuICAgIH1cbiAgfSk7XG4gIGxldCBpbml0aWFsUm91dGVzID0gWy4uLnJvdXRlSWRzXS5yZWR1Y2UoXG4gICAgKGFjYywgaWQpID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7IFtpZF06IG1hbmlmZXN0LnJvdXRlc1tpZF0gfSksXG4gICAge31cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tYW5pZmVzdCxcbiAgICByb3V0ZXM6IGluaXRpYWxSb3V0ZXMsXG4gICAgc3JpOiBzcmkgPyB0cnVlIDogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uKG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIHNzciwgcm91dGVEaXNjb3ZlcnksIGlzU3BhTW9kZSwgYmFzZW5hbWUpIHtcbiAgaWYgKCFpc0ZvZ09mV2FyRW5hYmxlZChyb3V0ZURpc2NvdmVyeSwgc3NyKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGFzeW5jICh7IHBhdGgsIHBhdGNoLCBzaWduYWwsIGZldGNoZXJLZXkgfSkgPT4ge1xuICAgIGlmIChkaXNjb3ZlcmVkUGF0aHMuaGFzKHBhdGgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IGZldGNoQW5kQXBwbHlNYW5pZmVzdFBhdGNoZXMoXG4gICAgICBbcGF0aF0sXG4gICAgICBmZXRjaGVyS2V5ID8gd2luZG93LmxvY2F0aW9uLmhyZWYgOiBwYXRoLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICBzc3IsXG4gICAgICBpc1NwYU1vZGUsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIHJvdXRlRGlzY292ZXJ5Lm1hbmlmZXN0UGF0aCxcbiAgICAgIHBhdGNoLFxuICAgICAgc2lnbmFsXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUZvZ09GV2FyRGlzY292ZXJ5KHJvdXRlciwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgc3NyLCByb3V0ZURpc2NvdmVyeSwgaXNTcGFNb2RlKSB7XG4gIFJlYWN0OC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNGb2dPZldhckVuYWJsZWQocm91dGVEaXNjb3ZlcnksIHNzcikgfHwgLy8gQHRzLWV4cGVjdC1lcnJvciAtIFRTIGRvZXNuJ3Qga25vdyBhYm91dCB0aGlzIHlldFxuICAgIHdpbmRvdy5uYXZpZ2F0b3I/LmNvbm5lY3Rpb24/LnNhdmVEYXRhID09PSB0cnVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRWxlbWVudChlbCkge1xuICAgICAgbGV0IHBhdGggPSBlbC50YWdOYW1lID09PSBcIkZPUk1cIiA/IGVsLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKSA6IGVsLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHBhdGhuYW1lID0gZWwudGFnTmFtZSA9PT0gXCJBXCIgPyBlbC5wYXRobmFtZSA6IG5ldyBVUkwocGF0aCwgd2luZG93LmxvY2F0aW9uLm9yaWdpbikucGF0aG5hbWU7XG4gICAgICBpZiAoIWRpc2NvdmVyZWRQYXRocy5oYXMocGF0aG5hbWUpKSB7XG4gICAgICAgIG5leHRQYXRocy5hZGQocGF0aG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBmZXRjaFBhdGNoZXMoKSB7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiYVtkYXRhLWRpc2NvdmVyXSwgZm9ybVtkYXRhLWRpc2NvdmVyXVwiKS5mb3JFYWNoKHJlZ2lzdGVyRWxlbWVudCk7XG4gICAgICBsZXQgbGF6eVBhdGhzID0gQXJyYXkuZnJvbShuZXh0UGF0aHMua2V5cygpKS5maWx0ZXIoKHBhdGgpID0+IHtcbiAgICAgICAgaWYgKGRpc2NvdmVyZWRQYXRocy5oYXMocGF0aCkpIHtcbiAgICAgICAgICBuZXh0UGF0aHMuZGVsZXRlKHBhdGgpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGxhenlQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZmV0Y2hBbmRBcHBseU1hbmlmZXN0UGF0Y2hlcyhcbiAgICAgICAgICBsYXp5UGF0aHMsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICAgICAgc3NyLFxuICAgICAgICAgIGlzU3BhTW9kZSxcbiAgICAgICAgICByb3V0ZXIuYmFzZW5hbWUsXG4gICAgICAgICAgcm91dGVEaXNjb3ZlcnkubWFuaWZlc3RQYXRoLFxuICAgICAgICAgIHJvdXRlci5wYXRjaFJvdXRlc1xuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1hbmlmZXN0IHBhdGNoZXNcIiwgZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkZWJvdW5jZWRGZXRjaFBhdGNoZXMgPSBkZWJvdW5jZShmZXRjaFBhdGNoZXMsIDEwMCk7XG4gICAgZmV0Y2hQYXRjaGVzKCk7XG4gICAgbGV0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gZGVib3VuY2VkRmV0Y2hQYXRjaGVzKCkpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wiZGF0YS1kaXNjb3ZlclwiLCBcImhyZWZcIiwgXCJhY3Rpb25cIl1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9LCBbc3NyLCBpc1NwYU1vZGUsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIHJvdXRlciwgcm91dGVEaXNjb3ZlcnldKTtcbn1cbmZ1bmN0aW9uIGdldE1hbmlmZXN0UGF0aChfbWFuaWZlc3RQYXRoLCBiYXNlbmFtZSkge1xuICBsZXQgbWFuaWZlc3RQYXRoID0gX21hbmlmZXN0UGF0aCB8fCBcIi9fX21hbmlmZXN0XCI7XG4gIGlmIChiYXNlbmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG1hbmlmZXN0UGF0aDtcbiAgfVxuICByZXR1cm4gYCR7YmFzZW5hbWV9JHttYW5pZmVzdFBhdGh9YC5yZXBsYWNlKC9cXC8rL2csIFwiL1wiKTtcbn1cbnZhciBNQU5JRkVTVF9WRVJTSU9OX1NUT1JBR0VfS0VZID0gXCJyZWFjdC1yb3V0ZXItbWFuaWZlc3QtdmVyc2lvblwiO1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmRBcHBseU1hbmlmZXN0UGF0Y2hlcyhwYXRocywgZXJyb3JSZWxvYWRQYXRoLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBzc3IsIGlzU3BhTW9kZSwgYmFzZW5hbWUsIG1hbmlmZXN0UGF0aCwgcGF0Y2hSb3V0ZXMsIHNpZ25hbCkge1xuICBsZXQgdXJsID0gbmV3IFVSTChcbiAgICBnZXRNYW5pZmVzdFBhdGgobWFuaWZlc3RQYXRoLCBiYXNlbmFtZSksXG4gICAgd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICApO1xuICBwYXRocy5zb3J0KCkuZm9yRWFjaCgocGF0aCkgPT4gdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJwXCIsIHBhdGgpKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsIG1hbmlmZXN0LnZlcnNpb24pO1xuICBpZiAodXJsLnRvU3RyaW5nKCkubGVuZ3RoID4gVVJMX0xJTUlUKSB7XG4gICAgbmV4dFBhdGhzLmNsZWFyKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzZXJ2ZXJQYXRjaGVzO1xuICB0cnkge1xuICAgIGxldCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHsgc2lnbmFsIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH1gKTtcbiAgICB9IGVsc2UgaWYgKHJlcy5zdGF0dXMgPT09IDIwNCAmJiByZXMuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiKSkge1xuICAgICAgaWYgKCFlcnJvclJlbG9hZFBhdGgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiRGV0ZWN0ZWQgYSBtYW5pZmVzdCB2ZXJzaW9uIG1pc21hdGNoIGR1cmluZyBlYWdlciByb3V0ZSBkaXNjb3ZlcnkuIFRoZSBuZXh0IG5hdmlnYXRpb24vZmV0Y2ggdG8gYW4gdW5kaXNjb3ZlcmVkIHJvdXRlIHdpbGwgcmVzdWx0IGluIGEgbmV3IGRvY3VtZW50IG5hdmlnYXRpb24gdG8gc3luYyB1cCB3aXRoIHRoZSBsYXRlc3QgbWFuaWZlc3QuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oTUFOSUZFU1RfVkVSU0lPTl9TVE9SQUdFX0tFWSkgPT09IG1hbmlmZXN0LnZlcnNpb24pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVuYWJsZSB0byBkaXNjb3ZlciByb3V0ZXMgZHVlIHRvIG1hbmlmZXN0IHZlcnNpb24gbWlzbWF0Y2guXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShNQU5JRkVTVF9WRVJTSU9OX1NUT1JBR0VfS0VZLCBtYW5pZmVzdC52ZXJzaW9uKTtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZXJyb3JSZWxvYWRQYXRoO1xuICAgICAgY29uc29sZS53YXJuKFwiRGV0ZWN0ZWQgbWFuaWZlc3QgdmVyc2lvbiBtaXNtYXRjaCwgcmVsb2FkaW5nLi4uXCIpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKCkgPT4ge1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChyZXMuc3RhdHVzID49IDQwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGF3YWl0IHJlcy50ZXh0KCkpO1xuICAgIH1cbiAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKE1BTklGRVNUX1ZFUlNJT05fU1RPUkFHRV9LRVkpO1xuICAgIHNlcnZlclBhdGNoZXMgPSBhd2FpdCByZXMuanNvbigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkgcmV0dXJuO1xuICAgIHRocm93IGU7XG4gIH1cbiAgbGV0IGtub3duUm91dGVzID0gbmV3IFNldChPYmplY3Qua2V5cyhtYW5pZmVzdC5yb3V0ZXMpKTtcbiAgbGV0IHBhdGNoZXMgPSBPYmplY3QudmFsdWVzKHNlcnZlclBhdGNoZXMpLnJlZHVjZSgoYWNjLCByb3V0ZSkgPT4ge1xuICAgIGlmIChyb3V0ZSAmJiAha25vd25Sb3V0ZXMuaGFzKHJvdXRlLmlkKSkge1xuICAgICAgYWNjW3JvdXRlLmlkXSA9IHJvdXRlO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIE9iamVjdC5hc3NpZ24obWFuaWZlc3Qucm91dGVzLCBwYXRjaGVzKTtcbiAgcGF0aHMuZm9yRWFjaCgocCkgPT4gYWRkVG9GaWZvUXVldWUocCwgZGlzY292ZXJlZFBhdGhzKSk7XG4gIGxldCBwYXJlbnRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBPYmplY3QudmFsdWVzKHBhdGNoZXMpLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgaWYgKHBhdGNoICYmICghcGF0Y2gucGFyZW50SWQgfHwgIXBhdGNoZXNbcGF0Y2gucGFyZW50SWRdKSkge1xuICAgICAgcGFyZW50SWRzLmFkZChwYXRjaC5wYXJlbnRJZCk7XG4gICAgfVxuICB9KTtcbiAgcGFyZW50SWRzLmZvckVhY2goXG4gICAgKHBhcmVudElkKSA9PiBwYXRjaFJvdXRlcyhcbiAgICAgIHBhcmVudElkIHx8IG51bGwsXG4gICAgICBjcmVhdGVDbGllbnRSb3V0ZXMocGF0Y2hlcywgcm91dGVNb2R1bGVzLCBudWxsLCBzc3IsIGlzU3BhTW9kZSwgcGFyZW50SWQpXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gYWRkVG9GaWZvUXVldWUocGF0aCwgcXVldWUpIHtcbiAgaWYgKHF1ZXVlLnNpemUgPj0gZGlzY292ZXJlZFBhdGhzTWF4U2l6ZSkge1xuICAgIGxldCBmaXJzdCA9IHF1ZXVlLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICBxdWV1ZS5kZWxldGUoZmlyc3QpO1xuICB9XG4gIHF1ZXVlLmFkZChwYXRoKTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCB3YWl0KSB7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjayguLi5hcmdzKSwgd2FpdCk7XG4gIH07XG59XG5cbi8vIGxpYi9kb20vc3NyL2NvbXBvbmVudHMudHN4XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dDIoKSB7XG4gIGxldCBjb250ZXh0ID0gUmVhY3Q5LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQyKFxuICAgIGNvbnRleHQsXG4gICAgXCJZb3UgbXVzdCByZW5kZXIgdGhpcyBlbGVtZW50IGluc2lkZSBhIDxEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlcj4gZWxlbWVudFwiXG4gICk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlQ29udGV4dCgpIHtcbiAgbGV0IGNvbnRleHQgPSBSZWFjdDkudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgaW52YXJpYW50MihcbiAgICBjb250ZXh0LFxuICAgIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbnNpZGUgYSA8RGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlcj4gZWxlbWVudFwiXG4gICk7XG4gIHJldHVybiBjb250ZXh0O1xufVxudmFyIEZyYW1ld29ya0NvbnRleHQgPSBSZWFjdDkuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuRnJhbWV3b3JrQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRnJhbWV3b3JrQ29udGV4dFwiO1xuZnVuY3Rpb24gdXNlRnJhbWV3b3JrQ29udGV4dCgpIHtcbiAgbGV0IGNvbnRleHQgPSBSZWFjdDkudXNlQ29udGV4dChGcmFtZXdvcmtDb250ZXh0KTtcbiAgaW52YXJpYW50MihcbiAgICBjb250ZXh0LFxuICAgIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbnNpZGUgYSA8SHlkcmF0ZWRSb3V0ZXI+IGVsZW1lbnRcIlxuICApO1xuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIHVzZVByZWZldGNoQmVoYXZpb3IocHJlZmV0Y2gsIHRoZWlyRWxlbWVudFByb3BzKSB7XG4gIGxldCBmcmFtZXdvcmtDb250ZXh0ID0gUmVhY3Q5LnVzZUNvbnRleHQoRnJhbWV3b3JrQ29udGV4dCk7XG4gIGxldCBbbWF5YmVQcmVmZXRjaCwgc2V0TWF5YmVQcmVmZXRjaF0gPSBSZWFjdDkudXNlU3RhdGUoZmFsc2UpO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBzZXRTaG91bGRQcmVmZXRjaF0gPSBSZWFjdDkudXNlU3RhdGUoZmFsc2UpO1xuICBsZXQgeyBvbkZvY3VzLCBvbkJsdXIsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlLCBvblRvdWNoU3RhcnQgfSA9IHRoZWlyRWxlbWVudFByb3BzO1xuICBsZXQgcmVmID0gUmVhY3Q5LnVzZVJlZihudWxsKTtcbiAgUmVhY3Q5LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHByZWZldGNoID09PSBcInJlbmRlclwiKSB7XG4gICAgICBzZXRTaG91bGRQcmVmZXRjaCh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHByZWZldGNoID09PSBcInZpZXdwb3J0XCIpIHtcbiAgICAgIGxldCBjYWxsYmFjayA9IChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICBzZXRTaG91bGRQcmVmZXRjaChlbnRyeS5pc0ludGVyc2VjdGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihjYWxsYmFjaywgeyB0aHJlc2hvbGQ6IDAuNSB9KTtcbiAgICAgIGlmIChyZWYuY3VycmVudCkgb2JzZXJ2ZXIub2JzZXJ2ZShyZWYuY3VycmVudCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3ByZWZldGNoXSk7XG4gIFJlYWN0OS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXliZVByZWZldGNoKSB7XG4gICAgICBsZXQgaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgICB9LCAxMDApO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbbWF5YmVQcmVmZXRjaF0pO1xuICBsZXQgc2V0SW50ZW50ID0gKCkgPT4ge1xuICAgIHNldE1heWJlUHJlZmV0Y2godHJ1ZSk7XG4gIH07XG4gIGxldCBjYW5jZWxJbnRlbnQgPSAoKSA9PiB7XG4gICAgc2V0TWF5YmVQcmVmZXRjaChmYWxzZSk7XG4gICAgc2V0U2hvdWxkUHJlZmV0Y2goZmFsc2UpO1xuICB9O1xuICBpZiAoIWZyYW1ld29ya0NvbnRleHQpIHtcbiAgICByZXR1cm4gW2ZhbHNlLCByZWYsIHt9XTtcbiAgfVxuICBpZiAocHJlZmV0Y2ggIT09IFwiaW50ZW50XCIpIHtcbiAgICByZXR1cm4gW3Nob3VsZFByZWZldGNoLCByZWYsIHt9XTtcbiAgfVxuICByZXR1cm4gW1xuICAgIHNob3VsZFByZWZldGNoLFxuICAgIHJlZixcbiAgICB7XG4gICAgICBvbkZvY3VzOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkZvY3VzLCBzZXRJbnRlbnQpLFxuICAgICAgb25CbHVyOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkJsdXIsIGNhbmNlbEludGVudCksXG4gICAgICBvbk1vdXNlRW50ZXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VFbnRlciwgc2V0SW50ZW50KSxcbiAgICAgIG9uTW91c2VMZWF2ZTogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Nb3VzZUxlYXZlLCBjYW5jZWxJbnRlbnQpLFxuICAgICAgb25Ub3VjaFN0YXJ0OiBjb21wb3NlRXZlbnRIYW5kbGVycyhvblRvdWNoU3RhcnQsIHNldEludGVudClcbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBjb21wb3NlRXZlbnRIYW5kbGVycyh0aGVpckhhbmRsZXIsIG91ckhhbmRsZXIpIHtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIHRoZWlySGFuZGxlciAmJiB0aGVpckhhbmRsZXIoZXZlbnQpO1xuICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgb3VySGFuZGxlcihldmVudCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlTWF0Y2hlcyhtYXRjaGVzLCBlcnJvcnMsIGlzU3BhTW9kZSkge1xuICBpZiAoaXNTcGFNb2RlICYmICFpc0h5ZHJhdGVkKSB7XG4gICAgcmV0dXJuIFttYXRjaGVzWzBdXTtcbiAgfVxuICBpZiAoZXJyb3JzKSB7XG4gICAgbGV0IGVycm9ySWR4ID0gbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IGVycm9yc1ttLnJvdXRlLmlkXSAhPT0gdm9pZCAwKTtcbiAgICByZXR1cm4gbWF0Y2hlcy5zbGljZSgwLCBlcnJvcklkeCArIDEpO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gTGlua3MoKSB7XG4gIGxldCB7IGlzU3BhTW9kZSwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgY3JpdGljYWxDc3MgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IHsgZXJyb3JzLCBtYXRjaGVzOiByb3V0ZXJNYXRjaGVzIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBtYXRjaGVzID0gZ2V0QWN0aXZlTWF0Y2hlcyhyb3V0ZXJNYXRjaGVzLCBlcnJvcnMsIGlzU3BhTW9kZSk7XG4gIGxldCBrZXllZExpbmtzID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0S2V5ZWRMaW5rc0Zvck1hdGNoZXMobWF0Y2hlcywgcm91dGVNb2R1bGVzLCBtYW5pZmVzdCksXG4gICAgW21hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3RdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUmVhY3Q5LkZyYWdtZW50LCBudWxsLCB0eXBlb2YgY3JpdGljYWxDc3MgPT09IFwic3RyaW5nXCIgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogY3JpdGljYWxDc3MgfSB9KSA6IG51bGwsIHR5cGVvZiBjcml0aWNhbENzcyA9PT0gXCJvYmplY3RcIiA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgeyByZWw6IFwic3R5bGVzaGVldFwiLCBocmVmOiBjcml0aWNhbENzcy5ocmVmIH0pIDogbnVsbCwga2V5ZWRMaW5rcy5tYXAoXG4gICAgKHsga2V5LCBsaW5rIH0pID0+IGlzUGFnZUxpbmtEZXNjcmlwdG9yKGxpbmspID8gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzLCB7IGtleSwgLi4ubGluayB9KSA6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgeyBrZXksIC4uLmxpbmsgfSlcbiAgKSk7XG59XG5mdW5jdGlvbiBQcmVmZXRjaFBhZ2VMaW5rcyh7XG4gIHBhZ2UsXG4gIC4uLmRhdGFMaW5rUHJvcHNcbn0pIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDIoKTtcbiAgbGV0IG1hdGNoZXMgPSBSZWFjdDkudXNlTWVtbyhcbiAgICAoKSA9PiBtYXRjaFJvdXRlcyhyb3V0ZXIucm91dGVzLCBwYWdlLCByb3V0ZXIuYmFzZW5hbWUpLFxuICAgIFtyb3V0ZXIucm91dGVzLCBwYWdlLCByb3V0ZXIuYmFzZW5hbWVdXG4gICk7XG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3NJbXBsLCB7IHBhZ2UsIG1hdGNoZXMsIC4uLmRhdGFMaW5rUHJvcHMgfSk7XG59XG5mdW5jdGlvbiB1c2VLZXllZFByZWZldGNoTGlua3MobWF0Y2hlcykge1xuICBsZXQgeyBtYW5pZmVzdCwgcm91dGVNb2R1bGVzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCBba2V5ZWRQcmVmZXRjaExpbmtzLCBzZXRLZXllZFByZWZldGNoTGlua3NdID0gUmVhY3Q5LnVzZVN0YXRlKFtdKTtcbiAgUmVhY3Q5LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGludGVycnVwdGVkID0gZmFsc2U7XG4gICAgdm9pZCBnZXRLZXllZFByZWZldGNoTGlua3MobWF0Y2hlcywgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcykudGhlbihcbiAgICAgIChsaW5rcykgPT4ge1xuICAgICAgICBpZiAoIWludGVycnVwdGVkKSB7XG4gICAgICAgICAgc2V0S2V5ZWRQcmVmZXRjaExpbmtzKGxpbmtzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGludGVycnVwdGVkID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbbWF0Y2hlcywgbWFuaWZlc3QsIHJvdXRlTW9kdWxlc10pO1xuICByZXR1cm4ga2V5ZWRQcmVmZXRjaExpbmtzO1xufVxuZnVuY3Rpb24gUHJlZmV0Y2hQYWdlTGlua3NJbXBsKHtcbiAgcGFnZSxcbiAgbWF0Y2hlczogbmV4dE1hdGNoZXMsXG4gIC4uLmxpbmtQcm9wc1xufSkge1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgeyBtYW5pZmVzdCwgcm91dGVNb2R1bGVzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDIoKTtcbiAgbGV0IHsgbG9hZGVyRGF0YSwgbWF0Y2hlcyB9ID0gdXNlRGF0YVJvdXRlclN0YXRlQ29udGV4dCgpO1xuICBsZXQgbmV3TWF0Y2hlc0ZvckRhdGEgPSBSZWFjdDkudXNlTWVtbyhcbiAgICAoKSA9PiBnZXROZXdNYXRjaGVzRm9yTGlua3MoXG4gICAgICBwYWdlLFxuICAgICAgbmV4dE1hdGNoZXMsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIFwiZGF0YVwiXG4gICAgKSxcbiAgICBbcGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIG1hbmlmZXN0LCBsb2NhdGlvbl1cbiAgKTtcbiAgbGV0IG5ld01hdGNoZXNGb3JBc3NldHMgPSBSZWFjdDkudXNlTWVtbyhcbiAgICAoKSA9PiBnZXROZXdNYXRjaGVzRm9yTGlua3MoXG4gICAgICBwYWdlLFxuICAgICAgbmV4dE1hdGNoZXMsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIFwiYXNzZXRzXCJcbiAgICApLFxuICAgIFtwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbWFuaWZlc3QsIGxvY2F0aW9uXVxuICApO1xuICBsZXQgZGF0YUhyZWZzID0gUmVhY3Q5LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChwYWdlID09PSBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IHJvdXRlc1BhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IGZvdW5kT3B0T3V0Um91dGUgPSBmYWxzZTtcbiAgICBuZXh0TWF0Y2hlcy5mb3JFYWNoKChtKSA9PiB7XG4gICAgICBsZXQgbWFuaWZlc3RSb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttLnJvdXRlLmlkXTtcbiAgICAgIGlmICghbWFuaWZlc3RSb3V0ZSB8fCAhbWFuaWZlc3RSb3V0ZS5oYXNMb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFuZXdNYXRjaGVzRm9yRGF0YS5zb21lKChtMikgPT4gbTIucm91dGUuaWQgPT09IG0ucm91dGUuaWQpICYmIG0ucm91dGUuaWQgaW4gbG9hZGVyRGF0YSAmJiByb3V0ZU1vZHVsZXNbbS5yb3V0ZS5pZF0/LnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgICAgZm91bmRPcHRPdXRSb3V0ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG1hbmlmZXN0Um91dGUuaGFzQ2xpZW50TG9hZGVyKSB7XG4gICAgICAgIGZvdW5kT3B0T3V0Um91dGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGVzUGFyYW1zLmFkZChtLnJvdXRlLmlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocm91dGVzUGFyYW1zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IHVybCA9IHNpbmdsZUZldGNoVXJsKHBhZ2UsIGJhc2VuYW1lKTtcbiAgICBpZiAoZm91bmRPcHRPdXRSb3V0ZSAmJiByb3V0ZXNQYXJhbXMuc2l6ZSA+IDApIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFxuICAgICAgICBcIl9yb3V0ZXNcIixcbiAgICAgICAgbmV4dE1hdGNoZXMuZmlsdGVyKChtKSA9PiByb3V0ZXNQYXJhbXMuaGFzKG0ucm91dGUuaWQpKS5tYXAoKG0pID0+IG0ucm91dGUuaWQpLmpvaW4oXCIsXCIpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW3VybC5wYXRobmFtZSArIHVybC5zZWFyY2hdO1xuICB9LCBbXG4gICAgYmFzZW5hbWUsXG4gICAgbG9hZGVyRGF0YSxcbiAgICBsb2NhdGlvbixcbiAgICBtYW5pZmVzdCxcbiAgICBuZXdNYXRjaGVzRm9yRGF0YSxcbiAgICBuZXh0TWF0Y2hlcyxcbiAgICBwYWdlLFxuICAgIHJvdXRlTW9kdWxlc1xuICBdKTtcbiAgbGV0IG1vZHVsZUhyZWZzID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0TW9kdWxlTGlua0hyZWZzKG5ld01hdGNoZXNGb3JBc3NldHMsIG1hbmlmZXN0KSxcbiAgICBbbmV3TWF0Y2hlc0ZvckFzc2V0cywgbWFuaWZlc3RdXG4gICk7XG4gIGxldCBrZXllZFByZWZldGNoTGlua3MgPSB1c2VLZXllZFByZWZldGNoTGlua3MobmV3TWF0Y2hlc0ZvckFzc2V0cyk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUmVhY3Q5LkZyYWdtZW50LCBudWxsLCBkYXRhSHJlZnMubWFwKChocmVmMikgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwibGlua1wiLCB7IGtleTogaHJlZjIsIHJlbDogXCJwcmVmZXRjaFwiLCBhczogXCJmZXRjaFwiLCBocmVmOiBocmVmMiwgLi4ubGlua1Byb3BzIH0pKSwgbW9kdWxlSHJlZnMubWFwKChocmVmMikgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwibGlua1wiLCB7IGtleTogaHJlZjIsIHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsIGhyZWY6IGhyZWYyLCAuLi5saW5rUHJvcHMgfSkpLCBrZXllZFByZWZldGNoTGlua3MubWFwKCh7IGtleSwgbGluayB9KSA9PiAoXG4gICAgLy8gdGhlc2UgZG9uJ3Qgc3ByZWFkIGBsaW5rUHJvcHNgIGJlY2F1c2UgdGhleSBhcmUgZnVsbCBsaW5rIGRlc2NyaXB0b3JzXG4gICAgLy8gYWxyZWFkeSB3aXRoIHRoZWlyIG93biBwcm9wc1xuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgeyBrZXksIC4uLmxpbmsgfSlcbiAgKSkpO1xufVxuZnVuY3Rpb24gTWV0YSgpIHtcbiAgbGV0IHsgaXNTcGFNb2RlLCByb3V0ZU1vZHVsZXMgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IHtcbiAgICBlcnJvcnMsXG4gICAgbWF0Y2hlczogcm91dGVyTWF0Y2hlcyxcbiAgICBsb2FkZXJEYXRhXG4gIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBfbWF0Y2hlcyA9IGdldEFjdGl2ZU1hdGNoZXMocm91dGVyTWF0Y2hlcywgZXJyb3JzLCBpc1NwYU1vZGUpO1xuICBsZXQgZXJyb3IgPSBudWxsO1xuICBpZiAoZXJyb3JzKSB7XG4gICAgZXJyb3IgPSBlcnJvcnNbX21hdGNoZXNbX21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaWRdO1xuICB9XG4gIGxldCBtZXRhID0gW107XG4gIGxldCBsZWFmTWV0YSA9IG51bGw7XG4gIGxldCBtYXRjaGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgX21hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgX21hdGNoID0gX21hdGNoZXNbaV07XG4gICAgbGV0IHJvdXRlSWQgPSBfbWF0Y2gucm91dGUuaWQ7XG4gICAgbGV0IGRhdGEyID0gbG9hZGVyRGF0YVtyb3V0ZUlkXTtcbiAgICBsZXQgcGFyYW1zID0gX21hdGNoLnBhcmFtcztcbiAgICBsZXQgcm91dGVNb2R1bGUgPSByb3V0ZU1vZHVsZXNbcm91dGVJZF07XG4gICAgbGV0IHJvdXRlTWV0YSA9IFtdO1xuICAgIGxldCBtYXRjaCA9IHtcbiAgICAgIGlkOiByb3V0ZUlkLFxuICAgICAgZGF0YTogZGF0YTIsXG4gICAgICBtZXRhOiBbXSxcbiAgICAgIHBhcmFtczogX21hdGNoLnBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBfbWF0Y2gucGF0aG5hbWUsXG4gICAgICBoYW5kbGU6IF9tYXRjaC5yb3V0ZS5oYW5kbGUsXG4gICAgICBlcnJvclxuICAgIH07XG4gICAgbWF0Y2hlc1tpXSA9IG1hdGNoO1xuICAgIGlmIChyb3V0ZU1vZHVsZT8ubWV0YSkge1xuICAgICAgcm91dGVNZXRhID0gdHlwZW9mIHJvdXRlTW9kdWxlLm1ldGEgPT09IFwiZnVuY3Rpb25cIiA/IHJvdXRlTW9kdWxlLm1ldGEoe1xuICAgICAgICBkYXRhOiBkYXRhMixcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pIDogQXJyYXkuaXNBcnJheShyb3V0ZU1vZHVsZS5tZXRhKSA/IFsuLi5yb3V0ZU1vZHVsZS5tZXRhXSA6IHJvdXRlTW9kdWxlLm1ldGE7XG4gICAgfSBlbHNlIGlmIChsZWFmTWV0YSkge1xuICAgICAgcm91dGVNZXRhID0gWy4uLmxlYWZNZXRhXTtcbiAgICB9XG4gICAgcm91dGVNZXRhID0gcm91dGVNZXRhIHx8IFtdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyb3V0ZU1ldGEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVGhlIHJvdXRlIGF0IFwiICsgX21hdGNoLnJvdXRlLnBhdGggKyBcIiByZXR1cm5zIGFuIGludmFsaWQgdmFsdWUuIEFsbCByb3V0ZSBtZXRhIGZ1bmN0aW9ucyBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBtZXRhIG9iamVjdHMuXFxuXFxuVG8gcmVmZXJlbmNlIHRoZSBtZXRhIGZ1bmN0aW9uIEFQSSwgc2VlIGh0dHBzOi8vcmVtaXgucnVuL3JvdXRlL21ldGFcIlxuICAgICAgKTtcbiAgICB9XG4gICAgbWF0Y2gubWV0YSA9IHJvdXRlTWV0YTtcbiAgICBtYXRjaGVzW2ldID0gbWF0Y2g7XG4gICAgbWV0YSA9IFsuLi5yb3V0ZU1ldGFdO1xuICAgIGxlYWZNZXRhID0gbWV0YTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFJlYWN0OS5GcmFnbWVudCwgbnVsbCwgbWV0YS5mbGF0KCkubWFwKChtZXRhUHJvcHMpID0+IHtcbiAgICBpZiAoIW1ldGFQcm9wcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChcInRhZ05hbWVcIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIGxldCB7IHRhZ05hbWUsIC4uLnJlc3QgfSA9IG1ldGFQcm9wcztcbiAgICAgIGlmICghaXNWYWxpZE1ldGFUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBBIG1ldGEgb2JqZWN0IHVzZXMgYW4gaW52YWxpZCB0YWdOYW1lOiAke3RhZ05hbWV9LiBFeHBlY3RlZCBlaXRoZXIgJ2xpbmsnIG9yICdtZXRhJ2BcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsZXQgQ29tcCA9IHRhZ05hbWU7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KENvbXAsIHsga2V5OiBKU09OLnN0cmluZ2lmeShyZXN0KSwgLi4ucmVzdCB9KTtcbiAgICB9XG4gICAgaWYgKFwidGl0bGVcIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCB7IGtleTogXCJ0aXRsZVwiIH0sIFN0cmluZyhtZXRhUHJvcHMudGl0bGUpKTtcbiAgICB9XG4gICAgaWYgKFwiY2hhcnNldFwiIGluIG1ldGFQcm9wcykge1xuICAgICAgbWV0YVByb3BzLmNoYXJTZXQgPz8gKG1ldGFQcm9wcy5jaGFyU2V0ID0gbWV0YVByb3BzLmNoYXJzZXQpO1xuICAgICAgZGVsZXRlIG1ldGFQcm9wcy5jaGFyc2V0O1xuICAgIH1cbiAgICBpZiAoXCJjaGFyU2V0XCIgaW4gbWV0YVByb3BzICYmIG1ldGFQcm9wcy5jaGFyU2V0ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbWV0YVByb3BzLmNoYXJTZXQgPT09IFwic3RyaW5nXCIgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHsga2V5OiBcImNoYXJTZXRcIiwgY2hhclNldDogbWV0YVByb3BzLmNoYXJTZXQgfSkgOiBudWxsO1xuICAgIH1cbiAgICBpZiAoXCJzY3JpcHQ6bGQranNvblwiIGluIG1ldGFQcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGpzb24gPSBKU09OLnN0cmluZ2lmeShtZXRhUHJvcHNbXCJzY3JpcHQ6bGQranNvblwiXSk7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgXCJzY3JpcHRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IGBzY3JpcHQ6bGQranNvbjoke2pzb259YCxcbiAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vbGQranNvblwiLFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBqc29uIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHsga2V5OiBKU09OLnN0cmluZ2lmeShtZXRhUHJvcHMpLCAuLi5tZXRhUHJvcHMgfSk7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRNZXRhVGFnKHRhZ05hbWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0YWdOYW1lID09PSBcInN0cmluZ1wiICYmIC9eKG1ldGF8bGluaykkLy50ZXN0KHRhZ05hbWUpO1xufVxudmFyIGlzSHlkcmF0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIFNjcmlwdHMocHJvcHMpIHtcbiAgbGV0IHtcbiAgICBtYW5pZmVzdCxcbiAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nLFxuICAgIGlzU3BhTW9kZSxcbiAgICByZW5kZXJNZXRhLFxuICAgIHJvdXRlRGlzY292ZXJ5LFxuICAgIHNzclxuICB9ID0gdXNlRnJhbWV3b3JrQ29udGV4dCgpO1xuICBsZXQgeyByb3V0ZXIsIHN0YXRpYzogaXNTdGF0aWMsIHN0YXRpY0NvbnRleHQgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0MigpO1xuICBsZXQgeyBtYXRjaGVzOiByb3V0ZXJNYXRjaGVzIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBlbmFibGVGb2dPZldhciA9IGlzRm9nT2ZXYXJFbmFibGVkKHJvdXRlRGlzY292ZXJ5LCBzc3IpO1xuICBpZiAocmVuZGVyTWV0YSkge1xuICAgIHJlbmRlck1ldGEuZGlkUmVuZGVyU2NyaXB0cyA9IHRydWU7XG4gIH1cbiAgbGV0IG1hdGNoZXMgPSBnZXRBY3RpdmVNYXRjaGVzKHJvdXRlck1hdGNoZXMsIG51bGwsIGlzU3BhTW9kZSk7XG4gIFJlYWN0OS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzSHlkcmF0ZWQgPSB0cnVlO1xuICB9LCBbXSk7XG4gIGxldCBpbml0aWFsU2NyaXB0cyA9IFJlYWN0OS51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgc3RyZWFtU2NyaXB0ID0gXCJ3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtzdGFydChjb250cm9sbGVyKXt3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7fX0pLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKTtcIjtcbiAgICBsZXQgY29udGV4dFNjcmlwdCA9IHN0YXRpY0NvbnRleHQgPyBgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0ID0gJHtzZXJ2ZXJIYW5kb2ZmU3RyaW5nfTske3N0cmVhbVNjcmlwdH1gIDogXCIgXCI7XG4gICAgbGV0IHJvdXRlTW9kdWxlc1NjcmlwdCA9ICFpc1N0YXRpYyA/IFwiIFwiIDogYCR7bWFuaWZlc3QuaG1yPy5ydW50aW1lID8gYGltcG9ydCAke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0Lmhtci5ydW50aW1lKX07YCA6IFwiXCJ9JHshZW5hYmxlRm9nT2ZXYXIgPyBgaW1wb3J0ICR7SlNPTi5zdHJpbmdpZnkobWFuaWZlc3QudXJsKX1gIDogXCJcIn07XG4ke21hdGNoZXMubWFwKChtYXRjaCwgcm91dGVJbmRleCkgPT4ge1xuICAgICAgbGV0IHJvdXRlVmFyTmFtZSA9IGByb3V0ZSR7cm91dGVJbmRleH1gO1xuICAgICAgbGV0IG1hbmlmZXN0RW50cnkgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaW52YXJpYW50MihtYW5pZmVzdEVudHJ5LCBgUm91dGUgJHttYXRjaC5yb3V0ZS5pZH0gbm90IGZvdW5kIGluIG1hbmlmZXN0YCk7XG4gICAgICBsZXQge1xuICAgICAgICBjbGllbnRBY3Rpb25Nb2R1bGUsXG4gICAgICAgIGNsaWVudExvYWRlck1vZHVsZSxcbiAgICAgICAgY2xpZW50TWlkZGxld2FyZU1vZHVsZSxcbiAgICAgICAgaHlkcmF0ZUZhbGxiYWNrTW9kdWxlLFxuICAgICAgICBtb2R1bGU6IG1vZHVsZTJcbiAgICAgIH0gPSBtYW5pZmVzdEVudHJ5O1xuICAgICAgbGV0IGNodW5rcyA9IFtcbiAgICAgICAgLi4uY2xpZW50QWN0aW9uTW9kdWxlID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZHVsZTogY2xpZW50QWN0aW9uTW9kdWxlLFxuICAgICAgICAgICAgdmFyTmFtZTogYCR7cm91dGVWYXJOYW1lfV9jbGllbnRBY3Rpb25gXG4gICAgICAgICAgfVxuICAgICAgICBdIDogW10sXG4gICAgICAgIC4uLmNsaWVudExvYWRlck1vZHVsZSA/IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtb2R1bGU6IGNsaWVudExvYWRlck1vZHVsZSxcbiAgICAgICAgICAgIHZhck5hbWU6IGAke3JvdXRlVmFyTmFtZX1fY2xpZW50TG9hZGVyYFxuICAgICAgICAgIH1cbiAgICAgICAgXSA6IFtdLFxuICAgICAgICAuLi5jbGllbnRNaWRkbGV3YXJlTW9kdWxlID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZHVsZTogY2xpZW50TWlkZGxld2FyZU1vZHVsZSxcbiAgICAgICAgICAgIHZhck5hbWU6IGAke3JvdXRlVmFyTmFtZX1fY2xpZW50TWlkZGxld2FyZWBcbiAgICAgICAgICB9XG4gICAgICAgIF0gOiBbXSxcbiAgICAgICAgLi4uaHlkcmF0ZUZhbGxiYWNrTW9kdWxlID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZHVsZTogaHlkcmF0ZUZhbGxiYWNrTW9kdWxlLFxuICAgICAgICAgICAgdmFyTmFtZTogYCR7cm91dGVWYXJOYW1lfV9IeWRyYXRlRmFsbGJhY2tgXG4gICAgICAgICAgfVxuICAgICAgICBdIDogW10sXG4gICAgICAgIHsgbW9kdWxlOiBtb2R1bGUyLCB2YXJOYW1lOiBgJHtyb3V0ZVZhck5hbWV9X21haW5gIH1cbiAgICAgIF07XG4gICAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYGltcG9ydCAqIGFzICR7cm91dGVWYXJOYW1lfSBmcm9tICR7SlNPTi5zdHJpbmdpZnkobW9kdWxlMil9O2A7XG4gICAgICB9XG4gICAgICBsZXQgY2h1bmtJbXBvcnRzU25pcHBldCA9IGNodW5rcy5tYXAoKGNodW5rKSA9PiBgaW1wb3J0ICogYXMgJHtjaHVuay52YXJOYW1lfSBmcm9tIFwiJHtjaHVuay5tb2R1bGV9XCI7YCkuam9pbihcIlxcblwiKTtcbiAgICAgIGxldCBtZXJnZWRDaHVua3NTbmlwcGV0ID0gYGNvbnN0ICR7cm91dGVWYXJOYW1lfSA9IHske2NodW5rcy5tYXAoKGNodW5rKSA9PiBgLi4uJHtjaHVuay52YXJOYW1lfWApLmpvaW4oXCIsXCIpfX07YDtcbiAgICAgIHJldHVybiBbY2h1bmtJbXBvcnRzU25pcHBldCwgbWVyZ2VkQ2h1bmtzU25pcHBldF0uam9pbihcIlxcblwiKTtcbiAgICB9KS5qb2luKFwiXFxuXCIpfVxuICAke2VuYWJsZUZvZ09mV2FyID8gKFxuICAgICAgLy8gSW5saW5lIGEgbWluaW1hbCBtYW5pZmVzdCB3aXRoIHRoZSBTU1IgbWF0Y2hlc1xuICAgICAgYHdpbmRvdy5fX3JlYWN0Um91dGVyTWFuaWZlc3QgPSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBnZXRQYXJ0aWFsTWFuaWZlc3QobWFuaWZlc3QsIHJvdXRlciksXG4gICAgICAgIG51bGwsXG4gICAgICAgIDJcbiAgICAgICl9O2BcbiAgICApIDogXCJcIn1cbiAgd2luZG93Ll9fcmVhY3RSb3V0ZXJSb3V0ZU1vZHVsZXMgPSB7JHttYXRjaGVzLm1hcCgobWF0Y2gsIGluZGV4KSA9PiBgJHtKU09OLnN0cmluZ2lmeShtYXRjaC5yb3V0ZS5pZCl9OnJvdXRlJHtpbmRleH1gKS5qb2luKFwiLFwiKX19O1xuXG5pbXBvcnQoJHtKU09OLnN0cmluZ2lmeShtYW5pZmVzdC5lbnRyeS5tb2R1bGUpfSk7YDtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFJlYWN0OS5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJzY3JpcHRcIixcbiAgICAgIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IGNyZWF0ZUh0bWwoY29udGV4dFNjcmlwdCksXG4gICAgICAgIHR5cGU6IHZvaWQgMFxuICAgICAgfVxuICAgICksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICAgIFwic2NyaXB0XCIsXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBjcmVhdGVIdG1sKHJvdXRlTW9kdWxlc1NjcmlwdCksXG4gICAgICAgIHR5cGU6IFwibW9kdWxlXCIsXG4gICAgICAgIGFzeW5jOiB0cnVlXG4gICAgICB9XG4gICAgKSk7XG4gIH0sIFtdKTtcbiAgbGV0IHByZWxvYWRzID0gaXNIeWRyYXRlZCA/IFtdIDogZGVkdXBlKFxuICAgIG1hbmlmZXN0LmVudHJ5LmltcG9ydHMuY29uY2F0KFxuICAgICAgZ2V0TW9kdWxlTGlua0hyZWZzKG1hdGNoZXMsIG1hbmlmZXN0LCB7XG4gICAgICAgIGluY2x1ZGVIeWRyYXRlRmFsbGJhY2s6IHRydWVcbiAgICAgIH0pXG4gICAgKVxuICApO1xuICBsZXQgc3JpID0gdHlwZW9mIG1hbmlmZXN0LnNyaSA9PT0gXCJvYmplY3RcIiA/IG1hbmlmZXN0LnNyaSA6IHt9O1xuICByZXR1cm4gaXNIeWRyYXRlZCA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUmVhY3Q5LkZyYWdtZW50LCBudWxsLCB0eXBlb2YgbWFuaWZlc3Quc3JpID09PSBcIm9iamVjdFwiID8gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFxuICAgIFwic2NyaXB0XCIsXG4gICAge1xuICAgICAgXCJyci1pbXBvcnRtYXBcIjogXCJcIixcbiAgICAgIHR5cGU6IFwiaW1wb3J0bWFwXCIsXG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICBfX2h0bWw6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpbnRlZ3JpdHk6IHNyaVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgKSA6IG51bGwsICFlbmFibGVGb2dPZldhciA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICBcImxpbmtcIixcbiAgICB7XG4gICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgaHJlZjogbWFuaWZlc3QudXJsLFxuICAgICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgaW50ZWdyaXR5OiBzcmlbbWFuaWZlc3QudXJsXSxcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZVxuICAgIH1cbiAgKSA6IG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICBcImxpbmtcIixcbiAgICB7XG4gICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgaHJlZjogbWFuaWZlc3QuZW50cnkubW9kdWxlLFxuICAgICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgaW50ZWdyaXR5OiBzcmlbbWFuaWZlc3QuZW50cnkubW9kdWxlXSxcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZVxuICAgIH1cbiAgKSwgcHJlbG9hZHMubWFwKChwYXRoKSA9PiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJsaW5rXCIsXG4gICAge1xuICAgICAga2V5OiBwYXRoLFxuICAgICAgcmVsOiBcIm1vZHVsZXByZWxvYWRcIixcbiAgICAgIGhyZWY6IHBhdGgsXG4gICAgICBjcm9zc09yaWdpbjogcHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgICBpbnRlZ3JpdHk6IHNyaVtwYXRoXSxcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZVxuICAgIH1cbiAgKSksIGluaXRpYWxTY3JpcHRzKTtcbn1cbmZ1bmN0aW9uIGRlZHVwZShhcnJheSkge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoYXJyYXkpXTtcbn1cbmZ1bmN0aW9uIG1lcmdlUmVmcyguLi5yZWZzKSB7XG4gIHJldHVybiAodmFsdWUpID0+IHtcbiAgICByZWZzLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZWYodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG4vLyBsaWIvZG9tL2xpYi50c3hcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xudHJ5IHtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIHdpbmRvdy5fX3JlYWN0Um91dGVyVmVyc2lvbiA9IFwiNy42LjFcIjtcbiAgfVxufSBjYXRjaCAoZSkge1xufVxuZnVuY3Rpb24gY3JlYXRlQnJvd3NlclJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIHVuc3RhYmxlX2dldENvbnRleHQ6IG9wdHM/LnVuc3RhYmxlX2dldENvbnRleHQsXG4gICAgZnV0dXJlOiBvcHRzPy5mdXR1cmUsXG4gICAgaGlzdG9yeTogY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzLFxuICAgIGRhdGFTdHJhdGVneTogb3B0cz8uZGF0YVN0cmF0ZWd5LFxuICAgIHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uOiBvcHRzPy5wYXRjaFJvdXRlc09uTmF2aWdhdGlvbixcbiAgICB3aW5kb3c6IG9wdHM/LndpbmRvd1xuICB9KS5pbml0aWFsaXplKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVIYXNoUm91dGVyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cz8uYmFzZW5hbWUsXG4gICAgdW5zdGFibGVfZ2V0Q29udGV4dDogb3B0cz8udW5zdGFibGVfZ2V0Q29udGV4dCxcbiAgICBmdXR1cmU6IG9wdHM/LmZ1dHVyZSxcbiAgICBoaXN0b3J5OiBjcmVhdGVIYXNoSGlzdG9yeSh7IHdpbmRvdzogb3B0cz8ud2luZG93IH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IG9wdHM/Lmh5ZHJhdGlvbkRhdGEgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMsXG4gICAgZGF0YVN0cmF0ZWd5OiBvcHRzPy5kYXRhU3RyYXRlZ3ksXG4gICAgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb246IG9wdHM/LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uLFxuICAgIHdpbmRvdzogb3B0cz8ud2luZG93XG4gIH0pLmluaXRpYWxpemUoKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSHlkcmF0aW9uRGF0YSgpIHtcbiAgbGV0IHN0YXRlID0gd2luZG93Py5fX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGE7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZXJyb3JzOiBkZXNlcmlhbGl6ZUVycm9ycyhzdGF0ZS5lcnJvcnMpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJSb3V0ZUVycm9yUmVzcG9uc2VcIikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICB2YWwuc3RhdHVzLFxuICAgICAgICB2YWwuc3RhdHVzVGV4dCxcbiAgICAgICAgdmFsLmRhdGEsXG4gICAgICAgIHZhbC5pbnRlcm5hbCA9PT0gdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIkVycm9yXCIpIHtcbiAgICAgIGlmICh2YWwuX19zdWJUeXBlKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gd2luZG93W3ZhbC5fX3N1YlR5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIEVycm9yQ29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JDb25zdHJ1Y3Rvcih2YWwubWVzc2FnZSk7XG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VyaWFsaXplZFtrZXldID09IG51bGwpIHtcbiAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBcIlwiO1xuICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cbmZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIHdpbmRvdzogd2luZG93MlxufSkge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0MTAudXNlUmVmKCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHsgd2luZG93OiB3aW5kb3cyLCB2NUNvbXBhdDogdHJ1ZSB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0MTAudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlKSA9PiB7XG4gICAgICBSZWFjdDEwLnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICB9LFxuICAgIFtzZXRTdGF0ZUltcGxdXG4gICk7XG4gIFJlYWN0MTAudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIEhhc2hSb3V0ZXIoeyBiYXNlbmFtZSwgY2hpbGRyZW4sIHdpbmRvdzogd2luZG93MiB9KSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QxMC51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3c6IHdpbmRvdzIsIHY1Q29tcGF0OiB0cnVlIH0pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QxMC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUpID0+IHtcbiAgICAgIFJlYWN0MTAuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbF1cbiAgKTtcbiAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gSGlzdG9yeVJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgaGlzdG9yeVxufSkge1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QxMC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUpID0+IHtcbiAgICAgIFJlYWN0MTAuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbF1cbiAgKTtcbiAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfVxuICApO1xufVxuSGlzdG9yeVJvdXRlci5kaXNwbGF5TmFtZSA9IFwidW5zdGFibGVfSGlzdG9yeVJvdXRlclwiO1xudmFyIEFCU09MVVRFX1VSTF9SRUdFWDIgPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG52YXIgTGluayA9IFJlYWN0MTAuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24gTGlua1dpdGhSZWYoe1xuICAgIG9uQ2xpY2ssXG4gICAgZGlzY292ZXIgPSBcInJlbmRlclwiLFxuICAgIHByZWZldGNoID0gXCJub25lXCIsXG4gICAgcmVsYXRpdmUsXG4gICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgc3RhdGUsXG4gICAgdGFyZ2V0LFxuICAgIHRvLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICB2aWV3VHJhbnNpdGlvbixcbiAgICAuLi5yZXN0XG4gIH0sIGZvcndhcmRlZFJlZikge1xuICAgIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIGxldCBpc0Fic29sdXRlID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiICYmIEFCU09MVVRFX1VSTF9SRUdFWDIudGVzdCh0byk7XG4gICAgbGV0IGFic29sdXRlSHJlZjtcbiAgICBsZXQgaXNFeHRlcm5hbCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgJiYgaXNBYnNvbHV0ZSkge1xuICAgICAgYWJzb2x1dGVIcmVmID0gdG87XG4gICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICBsZXQgdGFyZ2V0VXJsID0gdG8uc3RhcnRzV2l0aChcIi8vXCIpID8gbmV3IFVSTChjdXJyZW50VXJsLnByb3RvY29sICsgdG8pIDogbmV3IFVSTCh0byk7XG4gICAgICAgICAgbGV0IHBhdGggPSBzdHJpcEJhc2VuYW1lKHRhcmdldFVybC5wYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgICAgICAgIGlmICh0YXJnZXRVcmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBwYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRvID0gcGF0aCArIHRhcmdldFVybC5zZWFyY2ggKyB0YXJnZXRVcmwuaGFzaDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNFeHRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYDxMaW5rIHRvPVwiJHt0b31cIj4gY29udGFpbnMgYW4gaW52YWxpZCBVUkwgd2hpY2ggd2lsbCBwcm9iYWJseSBicmVhayB3aGVuIGNsaWNrZWQgLSBwbGVhc2UgdXBkYXRlIHRvIGEgdmFsaWQgVVJMIHBhdGguYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhyZWYyID0gdXNlSHJlZih0bywgeyByZWxhdGl2ZSB9KTtcbiAgICBsZXQgW3Nob3VsZFByZWZldGNoLCBwcmVmZXRjaFJlZiwgcHJlZmV0Y2hIYW5kbGVyc10gPSB1c2VQcmVmZXRjaEJlaGF2aW9yKFxuICAgICAgcHJlZmV0Y2gsXG4gICAgICByZXN0XG4gICAgKTtcbiAgICBsZXQgaW50ZXJuYWxPbkNsaWNrID0gdXNlTGlua0NsaWNrSGFuZGxlcih0bywge1xuICAgICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgdmlld1RyYW5zaXRpb25cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgICAgaWYgKG9uQ2xpY2spIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGludGVybmFsT25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBsaW5rID0gKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2FuY2hvci1oYXMtY29udGVudFxuICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICAgICAgXCJhXCIsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgIC4uLnByZWZldGNoSGFuZGxlcnMsXG4gICAgICAgICAgaHJlZjogYWJzb2x1dGVIcmVmIHx8IGhyZWYyLFxuICAgICAgICAgIG9uQ2xpY2s6IGlzRXh0ZXJuYWwgfHwgcmVsb2FkRG9jdW1lbnQgPyBvbkNsaWNrIDogaGFuZGxlQ2xpY2ssXG4gICAgICAgICAgcmVmOiBtZXJnZVJlZnMoZm9yd2FyZGVkUmVmLCBwcmVmZXRjaFJlZiksXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIFwiZGF0YS1kaXNjb3ZlclwiOiAhaXNBYnNvbHV0ZSAmJiBkaXNjb3ZlciA9PT0gXCJyZW5kZXJcIiA/IFwidHJ1ZVwiIDogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBzaG91bGRQcmVmZXRjaCAmJiAhaXNBYnNvbHV0ZSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMC5GcmFnbWVudCwgbnVsbCwgbGluaywgLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rcywgeyBwYWdlOiBocmVmMiB9KSkgOiBsaW5rO1xuICB9XG4pO1xuTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xudmFyIE5hdkxpbmsgPSBSZWFjdDEwLmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uIE5hdkxpbmtXaXRoUmVmKHtcbiAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudFByb3AgPSBcInBhZ2VcIixcbiAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVQcm9wID0gXCJcIixcbiAgICBlbmQgPSBmYWxzZSxcbiAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgIHRvLFxuICAgIHZpZXdUcmFuc2l0aW9uLFxuICAgIGNoaWxkcmVuLFxuICAgIC4uLnJlc3RcbiAgfSwgcmVmKSB7XG4gICAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmU6IHJlc3QucmVsYXRpdmUgfSk7XG4gICAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgICBsZXQgcm91dGVyU3RhdGUgPSBSZWFjdDEwLnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gICAgbGV0IHsgbmF2aWdhdG9yLCBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgICBsZXQgaXNUcmFuc2l0aW9uaW5nID0gcm91dGVyU3RhdGUgIT0gbnVsbCAmJiAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZShwYXRoKSAmJiB2aWV3VHJhbnNpdGlvbiA9PT0gdHJ1ZTtcbiAgICBsZXQgdG9QYXRobmFtZSA9IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihwYXRoKS5wYXRobmFtZSA6IHBhdGgucGF0aG5hbWU7XG4gICAgbGV0IGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICBsZXQgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSByb3V0ZXJTdGF0ZSAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gPyByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLnBhdGhuYW1lIDogbnVsbDtcbiAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IG5leHRMb2NhdGlvblBhdGhuYW1lID8gbmV4dExvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgICB0b1BhdGhuYW1lID0gdG9QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAobmV4dExvY2F0aW9uUGF0aG5hbWUgJiYgYmFzZW5hbWUpIHtcbiAgICAgIG5leHRMb2NhdGlvblBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShuZXh0TG9jYXRpb25QYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvblBhdGhuYW1lO1xuICAgIH1cbiAgICBjb25zdCBlbmRTbGFzaFBvc2l0aW9uID0gdG9QYXRobmFtZSAhPT0gXCIvXCIgJiYgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIikgPyB0b1BhdGhuYW1lLmxlbmd0aCAtIDEgOiB0b1BhdGhuYW1lLmxlbmd0aDtcbiAgICBsZXQgaXNBY3RpdmUgPSBsb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmIGxvY2F0aW9uUGF0aG5hbWUuY2hhckF0KGVuZFNsYXNoUG9zaXRpb24pID09PSBcIi9cIjtcbiAgICBsZXQgaXNQZW5kaW5nID0gbmV4dExvY2F0aW9uUGF0aG5hbWUgIT0gbnVsbCAmJiAobmV4dExvY2F0aW9uUGF0aG5hbWUgPT09IHRvUGF0aG5hbWUgfHwgIWVuZCAmJiBuZXh0TG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmIG5leHRMb2NhdGlvblBhdGhuYW1lLmNoYXJBdCh0b1BhdGhuYW1lLmxlbmd0aCkgPT09IFwiL1wiKTtcbiAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICBpc0FjdGl2ZSxcbiAgICAgIGlzUGVuZGluZyxcbiAgICAgIGlzVHJhbnNpdGlvbmluZ1xuICAgIH07XG4gICAgbGV0IGFyaWFDdXJyZW50ID0gaXNBY3RpdmUgPyBhcmlhQ3VycmVudFByb3AgOiB2b2lkIDA7XG4gICAgbGV0IGNsYXNzTmFtZTtcbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZVByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lUHJvcChyZW5kZXJQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsYXNzTmFtZSA9IFtcbiAgICAgICAgY2xhc3NOYW1lUHJvcCxcbiAgICAgICAgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbCxcbiAgICAgICAgaXNQZW5kaW5nID8gXCJwZW5kaW5nXCIgOiBudWxsLFxuICAgICAgICBpc1RyYW5zaXRpb25pbmcgPyBcInRyYW5zaXRpb25pbmdcIiA6IG51bGxcbiAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICBsZXQgc3R5bGUgPSB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZVByb3AocmVuZGVyUHJvcHMpIDogc3R5bGVQcm9wO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgICAgTGluayxcbiAgICAgIHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnQsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgcmVmLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgdG8sXG4gICAgICAgIHZpZXdUcmFuc2l0aW9uXG4gICAgICB9LFxuICAgICAgdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihyZW5kZXJQcm9wcykgOiBjaGlsZHJlblxuICAgICk7XG4gIH1cbik7XG5OYXZMaW5rLmRpc3BsYXlOYW1lID0gXCJOYXZMaW5rXCI7XG52YXIgRm9ybSA9IFJlYWN0MTAuZm9yd2FyZFJlZihcbiAgKHtcbiAgICBkaXNjb3ZlciA9IFwicmVuZGVyXCIsXG4gICAgZmV0Y2hlcktleSxcbiAgICBuYXZpZ2F0ZSxcbiAgICByZWxvYWREb2N1bWVudCxcbiAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICBzdGF0ZSxcbiAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kLFxuICAgIGFjdGlvbixcbiAgICBvblN1Ym1pdCxcbiAgICByZWxhdGl2ZSxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgdmlld1RyYW5zaXRpb24sXG4gICAgLi4ucHJvcHNcbiAgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdCgpO1xuICAgIGxldCBmb3JtQWN0aW9uID0gdXNlRm9ybUFjdGlvbihhY3Rpb24sIHsgcmVsYXRpdmUgfSk7XG4gICAgbGV0IGZvcm1NZXRob2QgPSBtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIiA/IFwiZ2V0XCIgOiBcInBvc3RcIjtcbiAgICBsZXQgaXNBYnNvbHV0ZSA9IHR5cGVvZiBhY3Rpb24gPT09IFwic3RyaW5nXCIgJiYgQUJTT0xVVEVfVVJMX1JFR0VYMi50ZXN0KGFjdGlvbik7XG4gICAgbGV0IHN1Ym1pdEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgIG9uU3VibWl0ICYmIG9uU3VibWl0KGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbGV0IHN1Ym1pdHRlciA9IGV2ZW50Lm5hdGl2ZUV2ZW50LnN1Ym1pdHRlcjtcbiAgICAgIGxldCBzdWJtaXRNZXRob2QgPSBzdWJtaXR0ZXI/LmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgfHwgbWV0aG9kO1xuICAgICAgc3VibWl0KHN1Ym1pdHRlciB8fCBldmVudC5jdXJyZW50VGFyZ2V0LCB7XG4gICAgICAgIGZldGNoZXJLZXksXG4gICAgICAgIG1ldGhvZDogc3VibWl0TWV0aG9kLFxuICAgICAgICBuYXZpZ2F0ZSxcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICB2aWV3VHJhbnNpdGlvblxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICAgIFwiZm9ybVwiLFxuICAgICAge1xuICAgICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgICAgbWV0aG9kOiBmb3JtTWV0aG9kLFxuICAgICAgICBhY3Rpb246IGZvcm1BY3Rpb24sXG4gICAgICAgIG9uU3VibWl0OiByZWxvYWREb2N1bWVudCA/IG9uU3VibWl0IDogc3VibWl0SGFuZGxlcixcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIFwiZGF0YS1kaXNjb3ZlclwiOiAhaXNBYnNvbHV0ZSAmJiBkaXNjb3ZlciA9PT0gXCJyZW5kZXJcIiA/IFwidHJ1ZVwiIDogdm9pZCAwXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcbkZvcm0uZGlzcGxheU5hbWUgPSBcIkZvcm1cIjtcbmZ1bmN0aW9uIFNjcm9sbFJlc3RvcmF0aW9uKHtcbiAgZ2V0S2V5LFxuICBzdG9yYWdlS2V5LFxuICAuLi5wcm9wc1xufSkge1xuICBsZXQgcmVtaXhDb250ZXh0ID0gUmVhY3QxMC51c2VDb250ZXh0KEZyYW1ld29ya0NvbnRleHQpO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uKHsgZ2V0S2V5LCBzdG9yYWdlS2V5IH0pO1xuICBsZXQgc3NyS2V5ID0gUmVhY3QxMC51c2VNZW1vKFxuICAgICgpID0+IHtcbiAgICAgIGlmICghcmVtaXhDb250ZXh0IHx8ICFnZXRLZXkpIHJldHVybiBudWxsO1xuICAgICAgbGV0IHVzZXJLZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBnZXRLZXlcbiAgICAgICk7XG4gICAgICByZXR1cm4gdXNlcktleSAhPT0gbG9jYXRpb24ua2V5ID8gdXNlcktleSA6IG51bGw7XG4gICAgfSxcbiAgICAvLyBOYWgsIHdlIG9ubHkgbmVlZCB0aGlzIHRoZSBmaXJzdCB0aW1lIGZvciB0aGUgU1NSIHJlbmRlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXVxuICApO1xuICBpZiAoIXJlbWl4Q29udGV4dCB8fCByZW1peENvbnRleHQuaXNTcGFNb2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IHJlc3RvcmVTY3JvbGwgPSAoKHN0b3JhZ2VLZXkyLCByZXN0b3JlS2V5KSA9PiB7XG4gICAgaWYgKCF3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCAhd2luZG93Lmhpc3Rvcnkuc3RhdGUua2V5KSB7XG4gICAgICBsZXQga2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzMikuc2xpY2UoMik7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXkgfSwgXCJcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgcG9zaXRpb25zID0gSlNPTi5wYXJzZShzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkyKSB8fCBcInt9XCIpO1xuICAgICAgbGV0IHN0b3JlZFkgPSBwb3NpdGlvbnNbcmVzdG9yZUtleSB8fCB3aW5kb3cuaGlzdG9yeS5zdGF0ZS5rZXldO1xuICAgICAgaWYgKHR5cGVvZiBzdG9yZWRZID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzdG9yZWRZKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkyKTtcbiAgICB9XG4gIH0pLnRvU3RyaW5nKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgIFwic2NyaXB0XCIsXG4gICAge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICBfX2h0bWw6IGAoJHtyZXN0b3JlU2Nyb2xsfSkoJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWVxuICAgICAgICApfSwgJHtKU09OLnN0cmluZ2lmeShzc3JLZXkpfSlgXG4gICAgICB9XG4gICAgfVxuICApO1xufVxuU2Nyb2xsUmVzdG9yYXRpb24uZGlzcGxheU5hbWUgPSBcIlNjcm9sbFJlc3RvcmF0aW9uXCI7XG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yMihob29rTmFtZSkge1xuICByZXR1cm4gYCR7aG9va05hbWV9IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9lbi9tYWluL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5gO1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQzKGhvb2tOYW1lKSB7XG4gIGxldCBjdHggPSBSZWFjdDEwLnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQoY3R4LCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yMihob29rTmFtZSkpO1xuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlMihob29rTmFtZSkge1xuICBsZXQgc3RhdGUgPSBSZWFjdDEwLnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGludmFyaWFudChzdGF0ZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcjIoaG9va05hbWUpKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlTGlua0NsaWNrSGFuZGxlcih0bywge1xuICB0YXJnZXQsXG4gIHJlcGxhY2U6IHJlcGxhY2VQcm9wLFxuICBzdGF0ZSxcbiAgcHJldmVudFNjcm9sbFJlc2V0LFxuICByZWxhdGl2ZSxcbiAgdmlld1RyYW5zaXRpb25cbn0gPSB7fSkge1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZSB9KTtcbiAgcmV0dXJuIFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgcmVwbGFjZTIgPSByZXBsYWNlUHJvcCAhPT0gdm9pZCAwID8gcmVwbGFjZVByb3AgOiBjcmVhdGVQYXRoKGxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChwYXRoKTtcbiAgICAgICAgbmF2aWdhdGUodG8sIHtcbiAgICAgICAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgICAgdmlld1RyYW5zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG5hdmlnYXRlLFxuICAgICAgcGF0aCxcbiAgICAgIHJlcGxhY2VQcm9wLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0byxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgdmlld1RyYW5zaXRpb25cbiAgICBdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpIHtcbiAgd2FybmluZyhcbiAgICB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSBcInVuZGVmaW5lZFwiLFxuICAgIGBZb3UgY2Fubm90IHVzZSB0aGUgXFxgdXNlU2VhcmNoUGFyYW1zXFxgIGhvb2sgaW4gYSBicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgVVJMU2VhcmNoUGFyYW1zIEFQSS4gSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBJbnRlcm5ldCBFeHBsb3JlciAxMSwgd2UgcmVjb21tZW5kIHlvdSBsb2FkIGEgcG9seWZpbGwgc3VjaCBhcyBodHRwczovL2dpdGh1Yi5jb20vdW5nYXAvdXJsLXNlYXJjaC1wYXJhbXMuYFxuICApO1xuICBsZXQgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0MTAudXNlUmVmKGNyZWF0ZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkpO1xuICBsZXQgaGFzU2V0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QxMC51c2VSZWYoZmFsc2UpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgc2VhcmNoUGFyYW1zID0gUmVhY3QxMC51c2VNZW1vKFxuICAgICgpID0+IChcbiAgICAgIC8vIE9ubHkgbWVyZ2UgaW4gdGhlIGRlZmF1bHRzIGlmIHdlIGhhdmVuJ3QgeWV0IGNhbGxlZCBzZXRTZWFyY2hQYXJhbXMuXG4gICAgICAvLyBPbmNlIHdlIGNhbGwgdGhhdCB3ZSB3YW50IHRob3NlIHRvIHRha2UgcHJlY2VkZW5jZSwgb3RoZXJ3aXNlIHlvdSBjYW4ndFxuICAgICAgLy8gcmVtb3ZlIGEgcGFyYW0gd2l0aCBzZXRTZWFyY2hQYXJhbXMoe30pIGlmIGl0IGhhcyBhbiBpbml0aWFsIHZhbHVlXG4gICAgICBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihcbiAgICAgICAgbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA/IG51bGwgOiBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnRcbiAgICAgIClcbiAgICApLFxuICAgIFtsb2NhdGlvbi5zZWFyY2hdXG4gICk7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBzZXRTZWFyY2hQYXJhbXMgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIChuZXh0SW5pdCwgbmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBuZXdTZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoXG4gICAgICAgIHR5cGVvZiBuZXh0SW5pdCA9PT0gXCJmdW5jdGlvblwiID8gbmV4dEluaXQoc2VhcmNoUGFyYW1zKSA6IG5leHRJbml0XG4gICAgICApO1xuICAgICAgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgbmF2aWdhdGUoXCI/XCIgKyBuZXdTZWFyY2hQYXJhbXMsIG5hdmlnYXRlT3B0aW9ucyk7XG4gICAgfSxcbiAgICBbbmF2aWdhdGUsIHNlYXJjaFBhcmFtc11cbiAgKTtcbiAgcmV0dXJuIFtzZWFyY2hQYXJhbXMsIHNldFNlYXJjaFBhcmFtc107XG59XG52YXIgZmV0Y2hlcklkID0gMDtcbnZhciBnZXRVbmlxdWVGZXRjaGVySWQgPSAoKSA9PiBgX18ke1N0cmluZygrK2ZldGNoZXJJZCl9X19gO1xuZnVuY3Rpb24gdXNlU3VibWl0KCkge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0MyhcInVzZVN1Ym1pdFwiIC8qIFVzZVN1Ym1pdCAqLyk7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgY3VycmVudFJvdXRlSWQgPSB1c2VSb3V0ZUlkKCk7XG4gIHJldHVybiBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh0YXJnZXQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgbGV0IHsgYWN0aW9uLCBtZXRob2QsIGVuY1R5cGUsIGZvcm1EYXRhLCBib2R5IH0gPSBnZXRGb3JtU3VibWlzc2lvbkluZm8oXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgYmFzZW5hbWVcbiAgICAgICk7XG4gICAgICBpZiAob3B0aW9ucy5uYXZpZ2F0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGtleSA9IG9wdGlvbnMuZmV0Y2hlcktleSB8fCBnZXRVbmlxdWVGZXRjaGVySWQoKTtcbiAgICAgICAgYXdhaXQgcm91dGVyLmZldGNoKGtleSwgY3VycmVudFJvdXRlSWQsIG9wdGlvbnMuYWN0aW9uIHx8IGFjdGlvbiwge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBmb3JtTWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBtZXRob2QsXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCBlbmNUeXBlLFxuICAgICAgICAgIGZsdXNoU3luYzogb3B0aW9ucy5mbHVzaFN5bmNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCByb3V0ZXIubmF2aWdhdGUob3B0aW9ucy5hY3Rpb24gfHwgYWN0aW9uLCB7XG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGZvcm1NZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IG1ldGhvZCxcbiAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0aW9ucy5lbmNUeXBlIHx8IGVuY1R5cGUsXG4gICAgICAgICAgcmVwbGFjZTogb3B0aW9ucy5yZXBsYWNlLFxuICAgICAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgICAgIGZyb21Sb3V0ZUlkOiBjdXJyZW50Um91dGVJZCxcbiAgICAgICAgICBmbHVzaFN5bmM6IG9wdGlvbnMuZmx1c2hTeW5jLFxuICAgICAgICAgIHZpZXdUcmFuc2l0aW9uOiBvcHRpb25zLnZpZXdUcmFuc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3JvdXRlciwgYmFzZW5hbWUsIGN1cnJlbnRSb3V0ZUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRm9ybUFjdGlvbihhY3Rpb24sIHsgcmVsYXRpdmUgfSA9IHt9KSB7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgcm91dGVDb250ZXh0ID0gUmVhY3QxMC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGludmFyaWFudChyb3V0ZUNvbnRleHQsIFwidXNlRm9ybUFjdGlvbiBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0XCIpO1xuICBsZXQgW21hdGNoXSA9IHJvdXRlQ29udGV4dC5tYXRjaGVzLnNsaWNlKC0xKTtcbiAgbGV0IHBhdGggPSB7IC4uLnVzZVJlc29sdmVkUGF0aChhY3Rpb24gPyBhY3Rpb24gOiBcIi5cIiwgeyByZWxhdGl2ZSB9KSB9O1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBpZiAoYWN0aW9uID09IG51bGwpIHtcbiAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoLnNlYXJjaCk7XG4gICAgbGV0IGluZGV4VmFsdWVzID0gcGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICAgIGxldCBoYXNOYWtlZEluZGV4UGFyYW0gPSBpbmRleFZhbHVlcy5zb21lKCh2KSA9PiB2ID09PSBcIlwiKTtcbiAgICBpZiAoaGFzTmFrZWRJbmRleFBhcmFtKSB7XG4gICAgICBwYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gICAgICBpbmRleFZhbHVlcy5maWx0ZXIoKHYpID0+IHYpLmZvckVhY2goKHYpID0+IHBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB2KSk7XG4gICAgICBsZXQgcXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgIHBhdGguc2VhcmNoID0gcXMgPyBgPyR7cXN9YCA6IFwiXCI7XG4gICAgfVxuICB9XG4gIGlmICgoIWFjdGlvbiB8fCBhY3Rpb24gPT09IFwiLlwiKSAmJiBtYXRjaC5yb3V0ZS5pbmRleCkge1xuICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgfVxuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVBhdGgocGF0aCk7XG59XG5mdW5jdGlvbiB1c2VGZXRjaGVyKHtcbiAga2V5XG59ID0ge30pIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDMoXCJ1c2VGZXRjaGVyXCIgLyogVXNlRmV0Y2hlciAqLyk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZTIoXCJ1c2VGZXRjaGVyXCIgLyogVXNlRmV0Y2hlciAqLyk7XG4gIGxldCBmZXRjaGVyRGF0YSA9IFJlYWN0MTAudXNlQ29udGV4dChGZXRjaGVyc0NvbnRleHQpO1xuICBsZXQgcm91dGUgPSBSZWFjdDEwLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlSWQgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0/LnJvdXRlLmlkO1xuICBpbnZhcmlhbnQoZmV0Y2hlckRhdGEsIGB1c2VGZXRjaGVyIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBGZXRjaGVyc0NvbnRleHRgKTtcbiAgaW52YXJpYW50KHJvdXRlLCBgdXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0YCk7XG4gIGludmFyaWFudChcbiAgICByb3V0ZUlkICE9IG51bGwsXG4gICAgYHVzZUZldGNoZXIgY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFwiaWRcImBcbiAgKTtcbiAgbGV0IGRlZmF1bHRLZXkgPSBSZWFjdDEwLnVzZUlkKCk7XG4gIGxldCBbZmV0Y2hlcktleSwgc2V0RmV0Y2hlcktleV0gPSBSZWFjdDEwLnVzZVN0YXRlKGtleSB8fCBkZWZhdWx0S2V5KTtcbiAgaWYgKGtleSAmJiBrZXkgIT09IGZldGNoZXJLZXkpIHtcbiAgICBzZXRGZXRjaGVyS2V5KGtleSk7XG4gIH1cbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJvdXRlci5nZXRGZXRjaGVyKGZldGNoZXJLZXkpO1xuICAgIHJldHVybiAoKSA9PiByb3V0ZXIuZGVsZXRlRmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgfSwgW3JvdXRlciwgZmV0Y2hlcktleV0pO1xuICBsZXQgbG9hZCA9IFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGhyZWYyLCBvcHRzKSA9PiB7XG4gICAgICBpbnZhcmlhbnQocm91dGVJZCwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5sb2FkKClcIik7XG4gICAgICBhd2FpdCByb3V0ZXIuZmV0Y2goZmV0Y2hlcktleSwgcm91dGVJZCwgaHJlZjIsIG9wdHMpO1xuICAgIH0sXG4gICAgW2ZldGNoZXJLZXksIHJvdXRlSWQsIHJvdXRlcl1cbiAgKTtcbiAgbGV0IHN1Ym1pdEltcGwgPSB1c2VTdWJtaXQoKTtcbiAgbGV0IHN1Ym1pdCA9IFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHRhcmdldCwgb3B0cykgPT4ge1xuICAgICAgYXdhaXQgc3VibWl0SW1wbCh0YXJnZXQsIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgbmF2aWdhdGU6IGZhbHNlLFxuICAgICAgICBmZXRjaGVyS2V5XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtmZXRjaGVyS2V5LCBzdWJtaXRJbXBsXVxuICApO1xuICBsZXQgRmV0Y2hlckZvcm0gPSBSZWFjdDEwLnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBGZXRjaGVyRm9ybTIgPSBSZWFjdDEwLmZvcndhcmRSZWYoXG4gICAgICAocHJvcHMsIHJlZikgPT4ge1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChGb3JtLCB7IC4uLnByb3BzLCBuYXZpZ2F0ZTogZmFsc2UsIGZldGNoZXJLZXksIHJlZiB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIEZldGNoZXJGb3JtMi5kaXNwbGF5TmFtZSA9IFwiZmV0Y2hlci5Gb3JtXCI7XG4gICAgcmV0dXJuIEZldGNoZXJGb3JtMjtcbiAgfSwgW2ZldGNoZXJLZXldKTtcbiAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoZmV0Y2hlcktleSkgfHwgSURMRV9GRVRDSEVSO1xuICBsZXQgZGF0YTIgPSBmZXRjaGVyRGF0YS5nZXQoZmV0Y2hlcktleSk7XG4gIGxldCBmZXRjaGVyV2l0aENvbXBvbmVudHMgPSBSZWFjdDEwLnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIEZvcm06IEZldGNoZXJGb3JtLFxuICAgICAgc3VibWl0LFxuICAgICAgbG9hZCxcbiAgICAgIC4uLmZldGNoZXIsXG4gICAgICBkYXRhOiBkYXRhMlxuICAgIH0pLFxuICAgIFtGZXRjaGVyRm9ybSwgc3VibWl0LCBsb2FkLCBmZXRjaGVyLCBkYXRhMl1cbiAgKTtcbiAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbn1cbmZ1bmN0aW9uIHVzZUZldGNoZXJzKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUyKFwidXNlRmV0Y2hlcnNcIiAvKiBVc2VGZXRjaGVycyAqLyk7XG4gIHJldHVybiBBcnJheS5mcm9tKHN0YXRlLmZldGNoZXJzLmVudHJpZXMoKSkubWFwKChba2V5LCBmZXRjaGVyXSkgPT4gKHtcbiAgICAuLi5mZXRjaGVyLFxuICAgIGtleVxuICB9KSk7XG59XG52YXIgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZID0gXCJyZWFjdC1yb3V0ZXItc2Nyb2xsLXBvc2l0aW9uc1wiO1xudmFyIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0ge307XG5mdW5jdGlvbiBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgbWF0Y2hlcywgYmFzZW5hbWUsIGdldEtleSkge1xuICBsZXQga2V5ID0gbnVsbDtcbiAgaWYgKGdldEtleSkge1xuICAgIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgIGtleSA9IGdldEtleShcbiAgICAgICAge1xuICAgICAgICAgIC4uLmxvY2F0aW9uLFxuICAgICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2hlc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gZ2V0S2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAga2V5ID0gbG9jYXRpb24ua2V5O1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiB1c2VTY3JvbGxSZXN0b3JhdGlvbih7XG4gIGdldEtleSxcbiAgc3RvcmFnZUtleVxufSA9IHt9KSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQzKFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIiAvKiBVc2VTY3JvbGxSZXN0b3JhdGlvbiAqLyk7XG4gIGxldCB7IHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0IH0gPSB1c2VEYXRhUm91dGVyU3RhdGUyKFxuICAgIFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIiAvKiBVc2VTY3JvbGxSZXN0b3JhdGlvbiAqL1xuICApO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIGxldCBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpO1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlUGFnZUhpZGUoXG4gICAgUmVhY3QxMC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBpZiAobmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KGxvY2F0aW9uLCBtYXRjaGVzLCBiYXNlbmFtZSwgZ2V0S2V5KTtcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICBzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSxcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShzYXZlZFNjcm9sbFBvc2l0aW9ucylcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgYEZhaWxlZCB0byBzYXZlIHNjcm9sbCBwb3NpdGlvbnMgaW4gc2Vzc2lvblN0b3JhZ2UsIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB3aWxsIG5vdCB3b3JrIHByb3Blcmx5ICgke2Vycm9yfSkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIjtcbiAgICB9LCBbbmF2aWdhdGlvbi5zdGF0ZSwgZ2V0S2V5LCBiYXNlbmFtZSwgbG9jYXRpb24sIG1hdGNoZXMsIHN0b3JhZ2VLZXldKVxuICApO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFxuICAgICAgICAgIHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfSwgW3N0b3JhZ2VLZXldKTtcbiAgICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBsZXQgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uID0gcm91dGVyPy5lbmFibGVTY3JvbGxSZXN0b3JhdGlvbihcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMsXG4gICAgICAgICgpID0+IHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICBnZXRLZXkgPyAobG9jYXRpb24yLCBtYXRjaGVzMikgPT4gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkobG9jYXRpb24yLCBtYXRjaGVzMiwgYmFzZW5hbWUsIGdldEtleSkgOiB2b2lkIDBcbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4gZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uICYmIGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbigpO1xuICAgIH0sIFtyb3V0ZXIsIGJhc2VuYW1lLCBnZXRLZXldKTtcbiAgICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAocmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgICAgZGVjb2RlVVJJQ29tcG9uZW50KGxvY2F0aW9uLmhhc2guc2xpY2UoMSkpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9LCBbbG9jYXRpb24sIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0XSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUJlZm9yZVVubG9hZChjYWxsYmFjaywgb3B0aW9ucykge1xuICBsZXQgeyBjYXB0dXJlIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7IGNhcHR1cmUgfSA6IHZvaWQgMDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbn1cbmZ1bmN0aW9uIHVzZVBhZ2VIaWRlKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGxldCB7IGNhcHR1cmUgfSA9IG9wdGlvbnMgfHwge307XG4gIFJlYWN0MTAudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb3B0cyA9IGNhcHR1cmUgIT0gbnVsbCA/IHsgY2FwdHVyZSB9IDogdm9pZCAwO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbn1cbmZ1bmN0aW9uIHVzZVByb21wdCh7XG4gIHdoZW4sXG4gIG1lc3NhZ2Vcbn0pIHtcbiAgbGV0IGJsb2NrZXIgPSB1c2VCbG9ja2VyKHdoZW4pO1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB7XG4gICAgICBsZXQgcHJvY2VlZCA9IHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpO1xuICAgICAgaWYgKHByb2NlZWQpIHtcbiAgICAgICAgc2V0VGltZW91dChibG9ja2VyLnByb2NlZWQsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIG1lc3NhZ2VdKTtcbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiAhd2hlbikge1xuICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIHdoZW5dKTtcbn1cbmZ1bmN0aW9uIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUodG8sIG9wdHMgPSB7fSkge1xuICBsZXQgdnRDb250ZXh0ID0gUmVhY3QxMC51c2VDb250ZXh0KFZpZXdUcmFuc2l0aW9uQ29udGV4dCk7XG4gIGludmFyaWFudChcbiAgICB2dENvbnRleHQgIT0gbnVsbCxcbiAgICBcImB1c2VWaWV3VHJhbnNpdGlvblN0YXRlYCBtdXN0IGJlIHVzZWQgd2l0aGluIGByZWFjdC1yb3V0ZXItZG9tYCdzIGBSb3V0ZXJQcm92aWRlcmAuICBEaWQgeW91IGFjY2lkZW50YWxseSBpbXBvcnQgYFJvdXRlclByb3ZpZGVyYCBmcm9tIGByZWFjdC1yb3V0ZXJgP1wiXG4gICk7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDMoXG4gICAgXCJ1c2VWaWV3VHJhbnNpdGlvblN0YXRlXCIgLyogdXNlVmlld1RyYW5zaXRpb25TdGF0ZSAqL1xuICApO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZTogb3B0cy5yZWxhdGl2ZSB9KTtcbiAgaWYgKCF2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBjdXJyZW50UGF0aCA9IHN0cmlwQmFzZW5hbWUodnRDb250ZXh0LmN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IHZ0Q29udGV4dC5jdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gIGxldCBuZXh0UGF0aCA9IHN0cmlwQmFzZW5hbWUodnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IHZ0Q29udGV4dC5uZXh0TG9jYXRpb24ucGF0aG5hbWU7XG4gIHJldHVybiBtYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgbmV4dFBhdGgpICE9IG51bGwgfHwgbWF0Y2hQYXRoKHBhdGgucGF0aG5hbWUsIGN1cnJlbnRQYXRoKSAhPSBudWxsO1xufVxuXG4vLyBsaWIvZG9tL3NlcnZlci50c3hcbnZhciBSZWFjdDExID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuZnVuY3Rpb24gU3RhdGljUm91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBsb2NhdGlvbjogbG9jYXRpb25Qcm9wID0gXCIvXCJcbn0pIHtcbiAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhdGlvblByb3AgPSBwYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgfVxuICBsZXQgYWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gIGxldCBsb2NhdGlvbiA9IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25Qcm9wLnBhdGhuYW1lIHx8IFwiL1wiLFxuICAgIHNlYXJjaDogbG9jYXRpb25Qcm9wLnNlYXJjaCB8fCBcIlwiLFxuICAgIGhhc2g6IGxvY2F0aW9uUHJvcC5oYXNoIHx8IFwiXCIsXG4gICAgc3RhdGU6IGxvY2F0aW9uUHJvcC5zdGF0ZSAhPSBudWxsID8gbG9jYXRpb25Qcm9wLnN0YXRlIDogbnVsbCxcbiAgICBrZXk6IGxvY2F0aW9uUHJvcC5rZXkgfHwgXCJkZWZhdWx0XCJcbiAgfTtcbiAgbGV0IHN0YXRpY05hdmlnYXRvciA9IGdldFN0YXRlbGVzc05hdmlnYXRvcigpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcbiAgICBSb3V0ZXIsXG4gICAge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IGFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogc3RhdGljTmF2aWdhdG9yLFxuICAgICAgc3RhdGljOiB0cnVlXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gU3RhdGljUm91dGVyUHJvdmlkZXIoe1xuICBjb250ZXh0LFxuICByb3V0ZXIsXG4gIGh5ZHJhdGU6IGh5ZHJhdGUyID0gdHJ1ZSxcbiAgbm9uY2Vcbn0pIHtcbiAgaW52YXJpYW50KFxuICAgIHJvdXRlciAmJiBjb250ZXh0LFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBgcm91dGVyYCBhbmQgYGNvbnRleHRgIHRvIDxTdGF0aWNSb3V0ZXJQcm92aWRlcj5cIlxuICApO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSB7XG4gICAgcm91dGVyLFxuICAgIG5hdmlnYXRvcjogZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCksXG4gICAgc3RhdGljOiB0cnVlLFxuICAgIHN0YXRpY0NvbnRleHQ6IGNvbnRleHQsXG4gICAgYmFzZW5hbWU6IGNvbnRleHQuYmFzZW5hbWUgfHwgXCIvXCJcbiAgfTtcbiAgbGV0IGZldGNoZXJzQ29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBoeWRyYXRlU2NyaXB0ID0gXCJcIjtcbiAgaWYgKGh5ZHJhdGUyICE9PSBmYWxzZSkge1xuICAgIGxldCBkYXRhMiA9IHtcbiAgICAgIGxvYWRlckRhdGE6IGNvbnRleHQubG9hZGVyRGF0YSxcbiAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgIGVycm9yczogc2VyaWFsaXplRXJyb3JzKGNvbnRleHQuZXJyb3JzKVxuICAgIH07XG4gICAgbGV0IGpzb24gPSBodG1sRXNjYXBlKEpTT04uc3RyaW5naWZ5KEpTT04uc3RyaW5naWZ5KGRhdGEyKSkpO1xuICAgIGh5ZHJhdGVTY3JpcHQgPSBgd2luZG93Ll9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YSA9IEpTT04ucGFyc2UoJHtqc29ufSk7YDtcbiAgfVxuICBsZXQgeyBzdGF0ZSB9ID0gZGF0YVJvdXRlckNvbnRleHQucm91dGVyO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChSZWFjdDExLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHN0YXRlIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoRmV0Y2hlcnNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBmZXRjaGVyc0NvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChWaWV3VHJhbnNpdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZSB9IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lOiBkYXRhUm91dGVyQ29udGV4dC5iYXNlbmFtZSxcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBkYXRhUm91dGVyQ29udGV4dC5uYXZpZ2F0b3IsXG4gICAgICBzdGF0aWM6IGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY1xuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcbiAgICAgIERhdGFSb3V0ZXMyLFxuICAgICAge1xuICAgICAgICByb3V0ZXM6IHJvdXRlci5yb3V0ZXMsXG4gICAgICAgIGZ1dHVyZTogcm91dGVyLmZ1dHVyZSxcbiAgICAgICAgc3RhdGVcbiAgICAgIH1cbiAgICApXG4gICkpKSkpLCBoeWRyYXRlU2NyaXB0ID8gLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgICAgIG5vbmNlLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBoeWRyYXRlU2NyaXB0IH1cbiAgICB9XG4gICkgOiBudWxsKTtcbn1cbmZ1bmN0aW9uIERhdGFSb3V0ZXMyKHtcbiAgcm91dGVzLFxuICBmdXR1cmUsXG4gIHN0YXRlXG59KSB7XG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgdm9pZCAwLCBzdGF0ZSwgZnV0dXJlKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmIChpc1JvdXRlRXJyb3JSZXNwb25zZSh2YWwpKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB7IC4uLnZhbCwgX190eXBlOiBcIlJvdXRlRXJyb3JSZXNwb25zZVwiIH07XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0ge1xuICAgICAgICBtZXNzYWdlOiB2YWwubWVzc2FnZSxcbiAgICAgICAgX190eXBlOiBcIkVycm9yXCIsXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdWJjbGFzcyAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpLCBzZW5kIHVwIHRoZSB0eXBlIHNvIHdlXG4gICAgICAgIC8vIGNhbiByZS1jcmVhdGUgdGhlIHNhbWUgdHlwZSBkdXJpbmcgaHlkcmF0aW9uLlxuICAgICAgICAuLi52YWwubmFtZSAhPT0gXCJFcnJvclwiID8ge1xuICAgICAgICAgIF9fc3ViVHlwZTogdmFsLm5hbWVcbiAgICAgICAgfSA6IHt9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuZnVuY3Rpb24gZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCkge1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZUhyZWYsXG4gICAgZW5jb2RlTG9jYXRpb24sXG4gICAgcHVzaCh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnB1c2goKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0pXFxgIHNvbWV3aGVyZSBpbiB5b3VyIGFwcC5gXG4gICAgICApO1xuICAgIH0sXG4gICAgcmVwbGFjZSh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnJlcGxhY2UoKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0sIHsgcmVwbGFjZTogdHJ1ZSB9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYFxuICAgICAgKTtcbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZ28oKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke2RlbHRhfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmBcbiAgICAgICk7XG4gICAgfSxcbiAgICBiYWNrKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmJhY2soKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuYFxuICAgICAgKTtcbiAgICB9LFxuICAgIGZvcndhcmQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZm9yd2FyZCgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBlbnZpcm9ubWVudC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXIyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlU3RhdGljSGFuZGxlcihyb3V0ZXMsIHtcbiAgICAuLi5vcHRzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1JvdXRlcihyb3V0ZXMsIGNvbnRleHQsIG9wdHMgPSB7fSkge1xuICBsZXQgbWFuaWZlc3QgPSB7fTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgdm9pZCAwLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGxldCBtYXRjaGVzID0gY29udGV4dC5tYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdFttYXRjaC5yb3V0ZS5pZF0gfHwgbWF0Y2gucm91dGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm1hdGNoLFxuICAgICAgcm91dGVcbiAgICB9O1xuICB9KTtcbiAgbGV0IG1zZyA9IChtZXRob2QpID0+IGBZb3UgY2Fubm90IHVzZSByb3V0ZXIuJHttZXRob2R9KCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGVudmlyb25tZW50YDtcbiAgcmV0dXJuIHtcbiAgICBnZXQgYmFzZW5hbWUoKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5iYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBmdXR1cmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1bnN0YWJsZV9taWRkbGV3YXJlOiBmYWxzZSxcbiAgICAgICAgLi4ub3B0cz8uZnV0dXJlXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGlzdG9yeUFjdGlvbjogXCJQT1BcIiAvKiBQb3AgKi8sXG4gICAgICAgIGxvY2F0aW9uOiBjb250ZXh0LmxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiBjb250ZXh0LmxvYWRlckRhdGEsXG4gICAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgICAgZXJyb3JzOiBjb250ZXh0LmVycm9ycyxcbiAgICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBudWxsLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgICAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgICAgICBmZXRjaGVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgYmxvY2tlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXQgcm91dGVzKCkge1xuICAgICAgcmV0dXJuIGRhdGFSb3V0ZXM7XG4gICAgfSxcbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9LFxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICB0aHJvdyBtc2coXCJpbml0aWFsaXplXCIpO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgdGhyb3cgbXNnKFwic3Vic2NyaWJlXCIpO1xuICAgIH0sXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gICAgICB0aHJvdyBtc2coXCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvblwiKTtcbiAgICB9LFxuICAgIG5hdmlnYXRlKCkge1xuICAgICAgdGhyb3cgbXNnKFwibmF2aWdhdGVcIik7XG4gICAgfSxcbiAgICBmZXRjaCgpIHtcbiAgICAgIHRocm93IG1zZyhcImZldGNoXCIpO1xuICAgIH0sXG4gICAgcmV2YWxpZGF0ZSgpIHtcbiAgICAgIHRocm93IG1zZyhcInJldmFsaWRhdGVcIik7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmLFxuICAgIGVuY29kZUxvY2F0aW9uLFxuICAgIGdldEZldGNoZXIoKSB7XG4gICAgICByZXR1cm4gSURMRV9GRVRDSEVSO1xuICAgIH0sXG4gICAgZGVsZXRlRmV0Y2hlcigpIHtcbiAgICAgIHRocm93IG1zZyhcImRlbGV0ZUZldGNoZXJcIik7XG4gICAgfSxcbiAgICBkaXNwb3NlKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZGlzcG9zZVwiKTtcbiAgICB9LFxuICAgIGdldEJsb2NrZXIoKSB7XG4gICAgICByZXR1cm4gSURMRV9CTE9DS0VSO1xuICAgIH0sXG4gICAgZGVsZXRlQmxvY2tlcigpIHtcbiAgICAgIHRocm93IG1zZyhcImRlbGV0ZUJsb2NrZXJcIik7XG4gICAgfSxcbiAgICBwYXRjaFJvdXRlcygpIHtcbiAgICAgIHRocm93IG1zZyhcInBhdGNoUm91dGVzXCIpO1xuICAgIH0sXG4gICAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBfaW50ZXJuYWxTZXRSb3V0ZXMoKSB7XG4gICAgICB0aHJvdyBtc2coXCJfaW50ZXJuYWxTZXRSb3V0ZXNcIik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xuICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUxvY2F0aW9uKHRvKSB7XG4gIGxldCBocmVmMiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIGhyZWYyID0gaHJlZjIucmVwbGFjZSgvICQvLCBcIiUyMFwiKTtcbiAgbGV0IGVuY29kZWQgPSBBQlNPTFVURV9VUkxfUkVHRVgzLnRlc3QoaHJlZjIpID8gbmV3IFVSTChocmVmMikgOiBuZXcgVVJMKGhyZWYyLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IGVuY29kZWQucGF0aG5hbWUsXG4gICAgc2VhcmNoOiBlbmNvZGVkLnNlYXJjaCxcbiAgICBoYXNoOiBlbmNvZGVkLmhhc2hcbiAgfTtcbn1cbnZhciBBQlNPTFVURV9VUkxfUkVHRVgzID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xudmFyIEVTQ0FQRV9MT09LVVAyID0ge1xuICBcIiZcIjogXCJcXFxcdTAwMjZcIixcbiAgXCI+XCI6IFwiXFxcXHUwMDNlXCIsXG4gIFwiPFwiOiBcIlxcXFx1MDAzY1wiLFxuICBcIlxcdTIwMjhcIjogXCJcXFxcdTIwMjhcIixcbiAgXCJcXHUyMDI5XCI6IFwiXFxcXHUyMDI5XCJcbn07XG52YXIgRVNDQVBFX1JFR0VYMiA9IC9bJj48XFx1MjAyOFxcdTIwMjldL2c7XG5mdW5jdGlvbiBodG1sRXNjYXBlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoRVNDQVBFX1JFR0VYMiwgKG1hdGNoKSA9PiBFU0NBUEVfTE9PS1VQMlttYXRjaF0pO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9zZXJ2ZXIudHN4XG52YXIgUmVhY3QxMiA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIFNlcnZlclJvdXRlcih7XG4gIGNvbnRleHQsXG4gIHVybCxcbiAgbm9uY2Vcbn0pIHtcbiAgaWYgKHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHVybCk7XG4gIH1cbiAgbGV0IHsgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgY3JpdGljYWxDc3MsIHNlcnZlckhhbmRvZmZTdHJpbmcgfSA9IGNvbnRleHQ7XG4gIGxldCByb3V0ZXMgPSBjcmVhdGVTZXJ2ZXJSb3V0ZXMoXG4gICAgbWFuaWZlc3Qucm91dGVzLFxuICAgIHJvdXRlTW9kdWxlcyxcbiAgICBjb250ZXh0LmZ1dHVyZSxcbiAgICBjb250ZXh0LmlzU3BhTW9kZVxuICApO1xuICBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0LmxvYWRlckRhdGEgPSB7XG4gICAgLi4uY29udGV4dC5zdGF0aWNIYW5kbGVyQ29udGV4dC5sb2FkZXJEYXRhXG4gIH07XG4gIGZvciAobGV0IG1hdGNoIG9mIGNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQubWF0Y2hlcykge1xuICAgIGxldCByb3V0ZUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgbGV0IHJvdXRlID0gcm91dGVNb2R1bGVzW3JvdXRlSWRdO1xuICAgIGxldCBtYW5pZmVzdFJvdXRlID0gY29udGV4dC5tYW5pZmVzdC5yb3V0ZXNbcm91dGVJZF07XG4gICAgaWYgKHJvdXRlICYmIG1hbmlmZXN0Um91dGUgJiYgc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyKFxuICAgICAgcm91dGVJZCxcbiAgICAgIHJvdXRlLmNsaWVudExvYWRlcixcbiAgICAgIG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyLFxuICAgICAgY29udGV4dC5pc1NwYU1vZGVcbiAgICApICYmIChyb3V0ZS5IeWRyYXRlRmFsbGJhY2sgfHwgIW1hbmlmZXN0Um91dGUuaGFzTG9hZGVyKSkge1xuICAgICAgZGVsZXRlIGNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbiAgICB9XG4gIH1cbiAgbGV0IHJvdXRlciA9IGNyZWF0ZVN0YXRpY1JvdXRlcihyb3V0ZXMsIGNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChSZWFjdDEyLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFxuICAgIEZyYW1ld29ya0NvbnRleHQuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIHJvdXRlTW9kdWxlcyxcbiAgICAgICAgY3JpdGljYWxDc3MsXG4gICAgICAgIHNlcnZlckhhbmRvZmZTdHJpbmcsXG4gICAgICAgIGZ1dHVyZTogY29udGV4dC5mdXR1cmUsXG4gICAgICAgIHNzcjogY29udGV4dC5zc3IsXG4gICAgICAgIGlzU3BhTW9kZTogY29udGV4dC5pc1NwYU1vZGUsXG4gICAgICAgIHJvdXRlRGlzY292ZXJ5OiBjb250ZXh0LnJvdXRlRGlzY292ZXJ5LFxuICAgICAgICBzZXJpYWxpemVFcnJvcjogY29udGV4dC5zZXJpYWxpemVFcnJvcixcbiAgICAgICAgcmVuZGVyTWV0YTogY29udGV4dC5yZW5kZXJNZXRhXG4gICAgICB9XG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFJlbWl4RXJyb3JCb3VuZGFyeSwgeyBsb2NhdGlvbjogcm91dGVyLnN0YXRlLmxvY2F0aW9uIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBTdGF0aWNSb3V0ZXJQcm92aWRlcixcbiAgICAgIHtcbiAgICAgICAgcm91dGVyLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0LFxuICAgICAgICBoeWRyYXRlOiBmYWxzZVxuICAgICAgfVxuICAgICkpXG4gICksIGNvbnRleHQuc2VydmVySGFuZG9mZlN0cmVhbSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMi5TdXNwZW5zZSwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcbiAgICBTdHJlYW1UcmFuc2ZlcixcbiAgICB7XG4gICAgICBjb250ZXh0LFxuICAgICAgaWRlbnRpZmllcjogMCxcbiAgICAgIHJlYWRlcjogY29udGV4dC5zZXJ2ZXJIYW5kb2ZmU3RyZWFtLmdldFJlYWRlcigpLFxuICAgICAgdGV4dERlY29kZXI6IG5ldyBUZXh0RGVjb2RlcigpLFxuICAgICAgbm9uY2VcbiAgICB9XG4gICkpIDogbnVsbCk7XG59XG5cbi8vIGxpYi9kb20vc3NyL3JvdXRlcy10ZXN0LXN0dWIudHN4XG52YXIgUmVhY3QxMyA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc1N0dWIocm91dGVzLCB1bnN0YWJsZV9nZXRDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBSb3V0ZXNUZXN0U3R1Yih7XG4gICAgaW5pdGlhbEVudHJpZXMsXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIGh5ZHJhdGlvbkRhdGEsXG4gICAgZnV0dXJlXG4gIH0pIHtcbiAgICBsZXQgcm91dGVyUmVmID0gUmVhY3QxMy51c2VSZWYoKTtcbiAgICBsZXQgcmVtaXhDb250ZXh0UmVmID0gUmVhY3QxMy51c2VSZWYoKTtcbiAgICBpZiAocm91dGVyUmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmVtaXhDb250ZXh0UmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIGZ1dHVyZToge1xuICAgICAgICAgIHVuc3RhYmxlX3N1YlJlc291cmNlSW50ZWdyaXR5OiBmdXR1cmU/LnVuc3RhYmxlX3N1YlJlc291cmNlSW50ZWdyaXR5ID09PSB0cnVlLFxuICAgICAgICAgIHVuc3RhYmxlX21pZGRsZXdhcmU6IGZ1dHVyZT8udW5zdGFibGVfbWlkZGxld2FyZSA9PT0gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtYW5pZmVzdDoge1xuICAgICAgICAgIHJvdXRlczoge30sXG4gICAgICAgICAgZW50cnk6IHsgaW1wb3J0czogW10sIG1vZHVsZTogXCJcIiB9LFxuICAgICAgICAgIHVybDogXCJcIixcbiAgICAgICAgICB2ZXJzaW9uOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIHJvdXRlTW9kdWxlczoge30sXG4gICAgICAgIHNzcjogZmFsc2UsXG4gICAgICAgIGlzU3BhTW9kZTogZmFsc2UsXG4gICAgICAgIHJvdXRlRGlzY292ZXJ5OiB7IG1vZGU6IFwibGF6eVwiLCBtYW5pZmVzdFBhdGg6IFwiL19fbWFuaWZlc3RcIiB9XG4gICAgICB9O1xuICAgICAgbGV0IHBhdGNoZWQgPSBwcm9jZXNzUm91dGVzKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBTdHViUm91dGVPYmplY3RgIGlzIHN0cmljdGVyIGFib3V0IGBsb2FkZXJgL2BhY3Rpb25gXG4gICAgICAgIC8vIHR5cGVzIGNvbXBhcmVkIHRvIGBBZ25vc3RpY1JvdXRlT2JqZWN0YFxuICAgICAgICBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgKHIpID0+IHIpLFxuICAgICAgICByZW1peENvbnRleHRSZWYuY3VycmVudC5tYW5pZmVzdCxcbiAgICAgICAgcmVtaXhDb250ZXh0UmVmLmN1cnJlbnQucm91dGVNb2R1bGVzXG4gICAgICApO1xuICAgICAgcm91dGVyUmVmLmN1cnJlbnQgPSBjcmVhdGVNZW1vcnlSb3V0ZXIocGF0Y2hlZCwge1xuICAgICAgICB1bnN0YWJsZV9nZXRDb250ZXh0LFxuICAgICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgICBoeWRyYXRpb25EYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoRnJhbWV3b3JrQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcmVtaXhDb250ZXh0UmVmLmN1cnJlbnQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTMuY3JlYXRlRWxlbWVudChSb3V0ZXJQcm92aWRlciwgeyByb3V0ZXI6IHJvdXRlclJlZi5jdXJyZW50IH0pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHdpdGhDb21wb25lbnRQcm9wcyhDb21wb25lbnQ0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXcmFwcGVkKCkge1xuICAgIHJldHVybiBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50NCwge1xuICAgICAgcGFyYW1zOiB1c2VQYXJhbXMoKSxcbiAgICAgIGxvYWRlckRhdGE6IHVzZUxvYWRlckRhdGEoKSxcbiAgICAgIGFjdGlvbkRhdGE6IHVzZUFjdGlvbkRhdGEoKSxcbiAgICAgIG1hdGNoZXM6IHVzZU1hdGNoZXMoKVxuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gd2l0aEh5ZHJhdGVGYWxsYmFja1Byb3BzKEh5ZHJhdGVGYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gV3JhcHBlZCgpIHtcbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIHBhcmFtczogdXNlUGFyYW1zKCksXG4gICAgICBsb2FkZXJEYXRhOiB1c2VMb2FkZXJEYXRhKCksXG4gICAgICBhY3Rpb25EYXRhOiB1c2VBY3Rpb25EYXRhKClcbiAgICB9O1xuICAgIHJldHVybiBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoSHlkcmF0ZUZhbGxiYWNrLCBwcm9wcyk7XG4gIH07XG59XG5mdW5jdGlvbiB3aXRoRXJyb3JCb3VuZGFyeVByb3BzKEVycm9yQm91bmRhcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdyYXBwZWQoKSB7XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICBwYXJhbXM6IHVzZVBhcmFtcygpLFxuICAgICAgbG9hZGVyRGF0YTogdXNlTG9hZGVyRGF0YSgpLFxuICAgICAgYWN0aW9uRGF0YTogdXNlQWN0aW9uRGF0YSgpLFxuICAgICAgZXJyb3I6IHVzZVJvdXRlRXJyb3IoKVxuICAgIH07XG4gICAgcmV0dXJuIFJlYWN0MTMuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5LCBwcm9wcyk7XG4gIH07XG59XG5mdW5jdGlvbiBwcm9jZXNzUm91dGVzKHJvdXRlcywgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgcGFyZW50SWQpIHtcbiAgcmV0dXJuIHJvdXRlcy5tYXAoKHJvdXRlKSA9PiB7XG4gICAgaWYgKCFyb3V0ZS5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgcm91dGUuaWQgaW4gQHJlbWl4LXJ1bi90ZXN0aW5nIHByb2Nlc3NSb3V0ZXMoKSBmdW5jdGlvblwiXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgbmV3Um91dGUgPSB7XG4gICAgICBpZDogcm91dGUuaWQsXG4gICAgICBwYXRoOiByb3V0ZS5wYXRoLFxuICAgICAgaW5kZXg6IHJvdXRlLmluZGV4LFxuICAgICAgQ29tcG9uZW50OiByb3V0ZS5Db21wb25lbnQgPyB3aXRoQ29tcG9uZW50UHJvcHMocm91dGUuQ29tcG9uZW50KSA6IHZvaWQgMCxcbiAgICAgIEh5ZHJhdGVGYWxsYmFjazogcm91dGUuSHlkcmF0ZUZhbGxiYWNrID8gd2l0aEh5ZHJhdGVGYWxsYmFja1Byb3BzKHJvdXRlLkh5ZHJhdGVGYWxsYmFjaykgOiB2b2lkIDAsXG4gICAgICBFcnJvckJvdW5kYXJ5OiByb3V0ZS5FcnJvckJvdW5kYXJ5ID8gd2l0aEVycm9yQm91bmRhcnlQcm9wcyhyb3V0ZS5FcnJvckJvdW5kYXJ5KSA6IHZvaWQgMCxcbiAgICAgIGFjdGlvbjogcm91dGUuYWN0aW9uLFxuICAgICAgbG9hZGVyOiByb3V0ZS5sb2FkZXIsXG4gICAgICBoYW5kbGU6IHJvdXRlLmhhbmRsZSxcbiAgICAgIHNob3VsZFJldmFsaWRhdGU6IHJvdXRlLnNob3VsZFJldmFsaWRhdGVcbiAgICB9O1xuICAgIGxldCBlbnRyeVJvdXRlID0ge1xuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgcGF0aDogcm91dGUucGF0aCxcbiAgICAgIGluZGV4OiByb3V0ZS5pbmRleCxcbiAgICAgIHBhcmVudElkLFxuICAgICAgaGFzQWN0aW9uOiByb3V0ZS5hY3Rpb24gIT0gbnVsbCxcbiAgICAgIGhhc0xvYWRlcjogcm91dGUubG9hZGVyICE9IG51bGwsXG4gICAgICAvLyBXaGVuIHRlc3Rpbmcgcm91dGVzLCB5b3Ugc2hvdWxkIGJlIHN0dWJiaW5nIGxvYWRlci9hY3Rpb24vbWlkZGxld2FyZSxcbiAgICAgIC8vIG5vdCB0cnlpbmcgdG8gcmUtaW1wbGVtZW50IHRoZSBmdWxsIGxvYWRlci9jbGllbnRMb2FkZXIvU1NSL2h5ZHJhdGlvblxuICAgICAgLy8gZmxvdy4gVGhhdCBpcyBiZXR0ZXIgdGVzdGVkIHZpYSBFMkUgdGVzdHMuXG4gICAgICBoYXNDbGllbnRBY3Rpb246IGZhbHNlLFxuICAgICAgaGFzQ2xpZW50TG9hZGVyOiBmYWxzZSxcbiAgICAgIGhhc0NsaWVudE1pZGRsZXdhcmU6IGZhbHNlLFxuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogcm91dGUuRXJyb3JCb3VuZGFyeSAhPSBudWxsLFxuICAgICAgLy8gYW55IG5lZWQgZm9yIHRoZXNlP1xuICAgICAgbW9kdWxlOiBcImJ1aWxkL3N0dWItcGF0aC10by1tb2R1bGUuanNcIixcbiAgICAgIGNsaWVudEFjdGlvbk1vZHVsZTogdm9pZCAwLFxuICAgICAgY2xpZW50TG9hZGVyTW9kdWxlOiB2b2lkIDAsXG4gICAgICBjbGllbnRNaWRkbGV3YXJlTW9kdWxlOiB2b2lkIDAsXG4gICAgICBoeWRyYXRlRmFsbGJhY2tNb2R1bGU6IHZvaWQgMFxuICAgIH07XG4gICAgbWFuaWZlc3Qucm91dGVzW25ld1JvdXRlLmlkXSA9IGVudHJ5Um91dGU7XG4gICAgcm91dGVNb2R1bGVzW3JvdXRlLmlkXSA9IHtcbiAgICAgIGRlZmF1bHQ6IG5ld1JvdXRlLkNvbXBvbmVudCB8fCBPdXRsZXQsXG4gICAgICBFcnJvckJvdW5kYXJ5OiBuZXdSb3V0ZS5FcnJvckJvdW5kYXJ5IHx8IHZvaWQgMCxcbiAgICAgIGhhbmRsZTogcm91dGUuaGFuZGxlLFxuICAgICAgbGlua3M6IHJvdXRlLmxpbmtzLFxuICAgICAgbWV0YTogcm91dGUubWV0YSxcbiAgICAgIHNob3VsZFJldmFsaWRhdGU6IHJvdXRlLnNob3VsZFJldmFsaWRhdGVcbiAgICB9O1xuICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgbmV3Um91dGUuY2hpbGRyZW4gPSBwcm9jZXNzUm91dGVzKFxuICAgICAgICByb3V0ZS5jaGlsZHJlbixcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIHJvdXRlTW9kdWxlcyxcbiAgICAgICAgbmV3Um91dGUuaWRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXdSb3V0ZTtcbiAgfSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9jb29raWVzLnRzXG52YXIgaW1wb3J0X2Nvb2tpZSA9IHJlcXVpcmUoXCJjb29raWVcIik7XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9jcnlwdG8udHNcbnZhciBlbmNvZGVyID0gLyogQF9fUFVSRV9fICovIG5ldyBUZXh0RW5jb2RlcigpO1xudmFyIHNpZ24gPSBhc3luYyAodmFsdWUsIHNlY3JldCkgPT4ge1xuICBsZXQgZGF0YTIgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gIGxldCBrZXkgPSBhd2FpdCBjcmVhdGVLZXkyKHNlY3JldCwgW1wic2lnblwiXSk7XG4gIGxldCBzaWduYXR1cmUgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnNpZ24oXCJITUFDXCIsIGtleSwgZGF0YTIpO1xuICBsZXQgaGFzaCA9IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShzaWduYXR1cmUpKSkucmVwbGFjZShcbiAgICAvPSskLyxcbiAgICBcIlwiXG4gICk7XG4gIHJldHVybiB2YWx1ZSArIFwiLlwiICsgaGFzaDtcbn07XG52YXIgdW5zaWduID0gYXN5bmMgKGNvb2tpZSwgc2VjcmV0KSA9PiB7XG4gIGxldCBpbmRleCA9IGNvb2tpZS5sYXN0SW5kZXhPZihcIi5cIik7XG4gIGxldCB2YWx1ZSA9IGNvb2tpZS5zbGljZSgwLCBpbmRleCk7XG4gIGxldCBoYXNoID0gY29va2llLnNsaWNlKGluZGV4ICsgMSk7XG4gIGxldCBkYXRhMiA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgbGV0IGtleSA9IGF3YWl0IGNyZWF0ZUtleTIoc2VjcmV0LCBbXCJ2ZXJpZnlcIl0pO1xuICBsZXQgc2lnbmF0dXJlID0gYnl0ZVN0cmluZ1RvVWludDhBcnJheShhdG9iKGhhc2gpKTtcbiAgbGV0IHZhbGlkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS52ZXJpZnkoXCJITUFDXCIsIGtleSwgc2lnbmF0dXJlLCBkYXRhMik7XG4gIHJldHVybiB2YWxpZCA/IHZhbHVlIDogZmFsc2U7XG59O1xudmFyIGNyZWF0ZUtleTIgPSBhc3luYyAoc2VjcmV0LCB1c2FnZXMpID0+IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICBcInJhd1wiLFxuICBlbmNvZGVyLmVuY29kZShzZWNyZXQpLFxuICB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiBcIlNIQS0yNTZcIiB9LFxuICBmYWxzZSxcbiAgdXNhZ2VzXG4pO1xuZnVuY3Rpb24gYnl0ZVN0cmluZ1RvVWludDhBcnJheShieXRlU3RyaW5nKSB7XG4gIGxldCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVTdHJpbmcubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvY29va2llcy50c1xudmFyIGNyZWF0ZUNvb2tpZSA9IChuYW1lLCBjb29raWVPcHRpb25zID0ge30pID0+IHtcbiAgbGV0IHsgc2VjcmV0cyA9IFtdLCAuLi5vcHRpb25zIH0gPSB7XG4gICAgcGF0aDogXCIvXCIsXG4gICAgc2FtZVNpdGU6IFwibGF4XCIsXG4gICAgLi4uY29va2llT3B0aW9uc1xuICB9O1xuICB3YXJuT25jZUFib3V0RXhwaXJlc0Nvb2tpZShuYW1lLCBvcHRpb25zLmV4cGlyZXMpO1xuICByZXR1cm4ge1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfSxcbiAgICBnZXQgaXNTaWduZWQoKSB7XG4gICAgICByZXR1cm4gc2VjcmV0cy5sZW5ndGggPiAwO1xuICAgIH0sXG4gICAgZ2V0IGV4cGlyZXMoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnMubWF4QWdlICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IERhdGUoRGF0ZS5ub3coKSArIG9wdGlvbnMubWF4QWdlICogMWUzKSA6IG9wdGlvbnMuZXhwaXJlcztcbiAgICB9LFxuICAgIGFzeW5jIHBhcnNlKGNvb2tpZUhlYWRlciwgcGFyc2VPcHRpb25zKSB7XG4gICAgICBpZiAoIWNvb2tpZUhlYWRlcikgcmV0dXJuIG51bGw7XG4gICAgICBsZXQgY29va2llcyA9ICgwLCBpbXBvcnRfY29va2llLnBhcnNlKShjb29raWVIZWFkZXIsIHsgLi4ub3B0aW9ucywgLi4ucGFyc2VPcHRpb25zIH0pO1xuICAgICAgaWYgKG5hbWUgaW4gY29va2llcykge1xuICAgICAgICBsZXQgdmFsdWUgPSBjb29raWVzW25hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgbGV0IGRlY29kZWQgPSBhd2FpdCBkZWNvZGVDb29raWVWYWx1ZSh2YWx1ZSwgc2VjcmV0cyk7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgc2VyaWFsaXplKHZhbHVlLCBzZXJpYWxpemVPcHRpb25zKSB7XG4gICAgICByZXR1cm4gKDAsIGltcG9ydF9jb29raWUuc2VyaWFsaXplKShcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWUgPT09IFwiXCIgPyBcIlwiIDogYXdhaXQgZW5jb2RlQ29va2llVmFsdWUodmFsdWUsIHNlY3JldHMpLFxuICAgICAgICB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAuLi5zZXJpYWxpemVPcHRpb25zXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9O1xufTtcbnZhciBpc0Nvb2tpZSA9IChvYmplY3QpID0+IHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QubmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqZWN0LmlzU2lnbmVkID09PSBcImJvb2xlYW5cIiAmJiB0eXBlb2Ygb2JqZWN0LnBhcnNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC5zZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIjtcbn07XG5hc3luYyBmdW5jdGlvbiBlbmNvZGVDb29raWVWYWx1ZSh2YWx1ZSwgc2VjcmV0cykge1xuICBsZXQgZW5jb2RlZCA9IGVuY29kZURhdGEodmFsdWUpO1xuICBpZiAoc2VjcmV0cy5sZW5ndGggPiAwKSB7XG4gICAgZW5jb2RlZCA9IGF3YWl0IHNpZ24oZW5jb2RlZCwgc2VjcmV0c1swXSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5hc3luYyBmdW5jdGlvbiBkZWNvZGVDb29raWVWYWx1ZSh2YWx1ZSwgc2VjcmV0cykge1xuICBpZiAoc2VjcmV0cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yIChsZXQgc2VjcmV0IG9mIHNlY3JldHMpIHtcbiAgICAgIGxldCB1bnNpZ25lZFZhbHVlID0gYXdhaXQgdW5zaWduKHZhbHVlLCBzZWNyZXQpO1xuICAgICAgaWYgKHVuc2lnbmVkVmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVEYXRhKHVuc2lnbmVkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZGVjb2RlRGF0YSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBlbmNvZGVEYXRhKHZhbHVlKSB7XG4gIHJldHVybiBidG9hKG15VW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHZhbHVlKSkpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZURhdGEodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQobXlFc2NhcGUoYXRvYih2YWx1ZSkpKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5mdW5jdGlvbiBteUVzY2FwZSh2YWx1ZSkge1xuICBsZXQgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBjaHIsIGNvZGU7XG4gIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBjaHIgPSBzdHIuY2hhckF0KGluZGV4KyspO1xuICAgIGlmICgvW1xcdyorXFwtLi9AXS8uZXhlYyhjaHIpKSB7XG4gICAgICByZXN1bHQgKz0gY2hyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICByZXN1bHQgKz0gXCIlXCIgKyBoZXgoY29kZSwgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gXCIldVwiICsgaGV4KGNvZGUsIDQpLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBoZXgoY29kZSwgbGVuZ3RoKSB7XG4gIGxldCByZXN1bHQgPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBsZW5ndGgpIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbXlVbmVzY2FwZSh2YWx1ZSkge1xuICBsZXQgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBjaHIsIHBhcnQ7XG4gIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBjaHIgPSBzdHIuY2hhckF0KGluZGV4KyspO1xuICAgIGlmIChjaHIgPT09IFwiJVwiKSB7XG4gICAgICBpZiAoc3RyLmNoYXJBdChpbmRleCkgPT09IFwidVwiKSB7XG4gICAgICAgIHBhcnQgPSBzdHIuc2xpY2UoaW5kZXggKyAxLCBpbmRleCArIDUpO1xuICAgICAgICBpZiAoL15bXFxkYS1mXXs0fSQvaS5leGVjKHBhcnQpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQocGFydCwgMTYpKTtcbiAgICAgICAgICBpbmRleCArPSA1O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0ID0gc3RyLnNsaWNlKGluZGV4LCBpbmRleCArIDIpO1xuICAgICAgICBpZiAoL15bXFxkYS1mXXsyfSQvaS5leGVjKHBhcnQpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQocGFydCwgMTYpKTtcbiAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCArPSBjaHI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdhcm5PbmNlQWJvdXRFeHBpcmVzQ29va2llKG5hbWUsIGV4cGlyZXMpIHtcbiAgd2Fybk9uY2UoXG4gICAgIWV4cGlyZXMsXG4gICAgYFRoZSBcIiR7bmFtZX1cIiBjb29raWUgaGFzIGFuIFwiZXhwaXJlc1wiIHByb3BlcnR5IHNldC4gVGhpcyB3aWxsIGNhdXNlIHRoZSBleHBpcmVzIHZhbHVlIHRvIG5vdCBiZSB1cGRhdGVkIHdoZW4gdGhlIHNlc3Npb24gaXMgY29tbWl0dGVkLiBJbnN0ZWFkLCB5b3Ugc2hvdWxkIHNldCB0aGUgZXhwaXJlcyB2YWx1ZSB3aGVuIHNlcmlhbGl6aW5nIHRoZSBjb29raWUuIFlvdSBjYW4gdXNlIFxcYGNvbW1pdFNlc3Npb24oc2Vzc2lvbiwgeyBleHBpcmVzIH0pXFxgIGlmIHVzaW5nIGEgc2Vzc2lvbiBzdG9yYWdlIG9iamVjdCwgb3IgXFxgY29va2llLnNlcmlhbGl6ZShcInZhbHVlXCIsIHsgZXhwaXJlcyB9KVxcYCBpZiB5b3UncmUgdXNpbmcgdGhlIGNvb2tpZSBkaXJlY3RseS5gXG4gICk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9lbnRyeS50c1xuZnVuY3Rpb24gY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMobWFuaWZlc3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1hbmlmZXN0KS5yZWR1Y2UoKG1lbW8yLCByb3V0ZUlkKSA9PiB7XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3Rbcm91dGVJZF07XG4gICAgaWYgKHJvdXRlKSB7XG4gICAgICBtZW1vMltyb3V0ZUlkXSA9IHJvdXRlLm1vZHVsZTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW8yO1xuICB9LCB7fSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9tb2RlLnRzXG52YXIgU2VydmVyTW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNlcnZlck1vZGUyKSA9PiB7XG4gIFNlcnZlck1vZGUyW1wiRGV2ZWxvcG1lbnRcIl0gPSBcImRldmVsb3BtZW50XCI7XG4gIFNlcnZlck1vZGUyW1wiUHJvZHVjdGlvblwiXSA9IFwicHJvZHVjdGlvblwiO1xuICBTZXJ2ZXJNb2RlMltcIlRlc3RcIl0gPSBcInRlc3RcIjtcbiAgcmV0dXJuIFNlcnZlck1vZGUyO1xufSkoU2VydmVyTW9kZSB8fCB7fSk7XG5mdW5jdGlvbiBpc1NlcnZlck1vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcImRldmVsb3BtZW50XCIgLyogRGV2ZWxvcG1lbnQgKi8gfHwgdmFsdWUgPT09IFwicHJvZHVjdGlvblwiIC8qIFByb2R1Y3Rpb24gKi8gfHwgdmFsdWUgPT09IFwidGVzdFwiIC8qIFRlc3QgKi87XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9lcnJvcnMudHNcbmZ1bmN0aW9uIHNhbml0aXplRXJyb3IoZXJyb3IsIHNlcnZlck1vZGUpIHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgc2VydmVyTW9kZSAhPT0gXCJkZXZlbG9wbWVudFwiIC8qIERldmVsb3BtZW50ICovKSB7XG4gICAgbGV0IHNhbml0aXplZCA9IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCIpO1xuICAgIHNhbml0aXplZC5zdGFjayA9IHZvaWQgMDtcbiAgICByZXR1cm4gc2FuaXRpemVkO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cbmZ1bmN0aW9uIHNhbml0aXplRXJyb3JzKGVycm9ycywgc2VydmVyTW9kZSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZXJyb3JzKS5yZWR1Y2UoKGFjYywgW3JvdXRlSWQsIGVycm9yXSkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywgeyBbcm91dGVJZF06IHNhbml0aXplRXJyb3IoZXJyb3IsIHNlcnZlck1vZGUpIH0pO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVFcnJvcihlcnJvciwgc2VydmVyTW9kZSkge1xuICBsZXQgc2FuaXRpemVkID0gc2FuaXRpemVFcnJvcihlcnJvciwgc2VydmVyTW9kZSk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogc2FuaXRpemVkLm1lc3NhZ2UsXG4gICAgc3RhY2s6IHNhbml0aXplZC5zdGFja1xuICB9O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRXJyb3JzMihlcnJvcnMsIHNlcnZlck1vZGUpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmIChpc1JvdXRlRXJyb3JSZXNwb25zZSh2YWwpKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB7IC4uLnZhbCwgX190eXBlOiBcIlJvdXRlRXJyb3JSZXNwb25zZVwiIH07XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgbGV0IHNhbml0aXplZCA9IHNhbml0aXplRXJyb3IodmFsLCBzZXJ2ZXJNb2RlKTtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHtcbiAgICAgICAgbWVzc2FnZTogc2FuaXRpemVkLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBzYW5pdGl6ZWQuc3RhY2ssXG4gICAgICAgIF9fdHlwZTogXCJFcnJvclwiLFxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc3ViY2xhc3MgKGkuZS4sIFJlZmVyZW5jZUVycm9yKSwgc2VuZCB1cCB0aGUgdHlwZSBzbyB3ZVxuICAgICAgICAvLyBjYW4gcmUtY3JlYXRlIHRoZSBzYW1lIHR5cGUgZHVyaW5nIGh5ZHJhdGlvbi4gIFRoaXMgd2lsbCBvbmx5IGFwcGx5XG4gICAgICAgIC8vIGluIGRldiBtb2RlIHNpbmNlIGFsbCBwcm9kdWN0aW9uIGVycm9ycyBhcmUgc2FuaXRpemVkIHRvIG5vcm1hbFxuICAgICAgICAvLyBFcnJvciBpbnN0YW5jZXNcbiAgICAgICAgLi4uc2FuaXRpemVkLm5hbWUgIT09IFwiRXJyb3JcIiA/IHtcbiAgICAgICAgICBfX3N1YlR5cGU6IHNhbml0aXplZC5uYW1lXG4gICAgICAgIH0gOiB7fVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3JvdXRlTWF0Y2hpbmcudHNcbmZ1bmN0aW9uIG1hdGNoU2VydmVyUm91dGVzKHJvdXRlcywgcGF0aG5hbWUsIGJhc2VuYW1lKSB7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoXG4gICAgcm91dGVzLFxuICAgIHBhdGhuYW1lLFxuICAgIGJhc2VuYW1lXG4gICk7XG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtYXRjaGVzLm1hcCgobWF0Y2gpID0+ICh7XG4gICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoLnBhdGhuYW1lLFxuICAgIHJvdXRlOiBtYXRjaC5yb3V0ZVxuICB9KSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9kYXRhLnRzXG5hc3luYyBmdW5jdGlvbiBjYWxsUm91dGVIYW5kbGVyKGhhbmRsZXIsIGFyZ3MpIHtcbiAgbGV0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZXIoe1xuICAgIHJlcXVlc3Q6IHN0cmlwUm91dGVzUGFyYW0oc3RyaXBJbmRleFBhcmFtMihhcmdzLnJlcXVlc3QpKSxcbiAgICBwYXJhbXM6IGFyZ3MucGFyYW1zLFxuICAgIGNvbnRleHQ6IGFyZ3MuY29udGV4dFxuICB9KTtcbiAgaWYgKGlzRGF0YVdpdGhSZXNwb25zZUluaXQocmVzdWx0KSAmJiByZXN1bHQuaW5pdCAmJiByZXN1bHQuaW5pdC5zdGF0dXMgJiYgaXNSZWRpcmVjdFN0YXR1c0NvZGUocmVzdWx0LmluaXQuc3RhdHVzKSkge1xuICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCByZXN1bHQuaW5pdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHN0cmlwSW5kZXhQYXJhbTIocmVxdWVzdCkge1xuICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gIGxldCBpbmRleFZhbHVlcyA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIik7XG4gIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gIGxldCBpbmRleFZhbHVlc1RvS2VlcCA9IFtdO1xuICBmb3IgKGxldCBpbmRleFZhbHVlIG9mIGluZGV4VmFsdWVzKSB7XG4gICAgaWYgKGluZGV4VmFsdWUpIHtcbiAgICAgIGluZGV4VmFsdWVzVG9LZWVwLnB1c2goaW5kZXhWYWx1ZSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IHRvS2VlcCBvZiBpbmRleFZhbHVlc1RvS2VlcCkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgdG9LZWVwKTtcbiAgfVxuICBsZXQgaW5pdCA9IHtcbiAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICB9O1xuICBpZiAoaW5pdC5ib2R5KSB7XG4gICAgaW5pdC5kdXBsZXggPSBcImhhbGZcIjtcbiAgfVxuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLmhyZWYsIGluaXQpO1xufVxuZnVuY3Rpb24gc3RyaXBSb3V0ZXNQYXJhbShyZXF1ZXN0KSB7XG4gIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJfcm91dGVzXCIpO1xuICBsZXQgaW5pdCA9IHtcbiAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICB9O1xuICBpZiAoaW5pdC5ib2R5KSB7XG4gICAgaW5pdC5kdXBsZXggPSBcImhhbGZcIjtcbiAgfVxuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLmhyZWYsIGluaXQpO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvaW52YXJpYW50LnRzXG5mdW5jdGlvbiBpbnZhcmlhbnQzKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiVGhlIGZvbGxvd2luZyBlcnJvciBpcyBhIGJ1ZyBpbiBSZWFjdCBSb3V0ZXI7IHBsZWFzZSBvcGVuIGFuIGlzc3VlISBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlYWN0LXJvdXRlci9pc3N1ZXMvbmV3L2Nob29zZVwiXG4gICAgKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2Rldi50c1xudmFyIGdsb2JhbERldlNlcnZlckhvb2tzS2V5ID0gXCJfX3JlYWN0Um91dGVyRGV2U2VydmVySG9va3NcIjtcbmZ1bmN0aW9uIHNldERldlNlcnZlckhvb2tzKGRldlNlcnZlckhvb2tzKSB7XG4gIGdsb2JhbFRoaXNbZ2xvYmFsRGV2U2VydmVySG9va3NLZXldID0gZGV2U2VydmVySG9va3M7XG59XG5mdW5jdGlvbiBnZXREZXZTZXJ2ZXJIb29rcygpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXNbZ2xvYmFsRGV2U2VydmVySG9va3NLZXldO1xufVxuZnVuY3Rpb24gZ2V0QnVpbGRUaW1lSGVhZGVyKHJlcXVlc3QsIGhlYWRlck5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChwcm9jZXNzLmVudj8uSVNfUlJfQlVJTERfUkVRVUVTVCA9PT0gXCJ5ZXNcIikge1xuICAgICAgICByZXR1cm4gcmVxdWVzdC5oZWFkZXJzLmdldChoZWFkZXJOYW1lKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvcm91dGVzLnRzXG5mdW5jdGlvbiBncm91cFJvdXRlc0J5UGFyZW50SWQyKG1hbmlmZXN0KSB7XG4gIGxldCByb3V0ZXMgPSB7fTtcbiAgT2JqZWN0LnZhbHVlcyhtYW5pZmVzdCkuZm9yRWFjaCgocm91dGUpID0+IHtcbiAgICBpZiAocm91dGUpIHtcbiAgICAgIGxldCBwYXJlbnRJZCA9IHJvdXRlLnBhcmVudElkIHx8IFwiXCI7XG4gICAgICBpZiAoIXJvdXRlc1twYXJlbnRJZF0pIHtcbiAgICAgICAgcm91dGVzW3BhcmVudElkXSA9IFtdO1xuICAgICAgfVxuICAgICAgcm91dGVzW3BhcmVudElkXS5wdXNoKHJvdXRlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm91dGVzO1xufVxuZnVuY3Rpb24gY3JlYXRlUm91dGVzKG1hbmlmZXN0LCBwYXJlbnRJZCA9IFwiXCIsIHJvdXRlc0J5UGFyZW50SWQgPSBncm91cFJvdXRlc0J5UGFyZW50SWQyKG1hbmlmZXN0KSkge1xuICByZXR1cm4gKHJvdXRlc0J5UGFyZW50SWRbcGFyZW50SWRdIHx8IFtdKS5tYXAoKHJvdXRlKSA9PiAoe1xuICAgIC4uLnJvdXRlLFxuICAgIGNoaWxkcmVuOiBjcmVhdGVSb3V0ZXMobWFuaWZlc3QsIHJvdXRlLmlkLCByb3V0ZXNCeVBhcmVudElkKVxuICB9KSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyRGF0YVJvdXRlcyhtYW5pZmVzdCwgZnV0dXJlLCBwYXJlbnRJZCA9IFwiXCIsIHJvdXRlc0J5UGFyZW50SWQgPSBncm91cFJvdXRlc0J5UGFyZW50SWQyKG1hbmlmZXN0KSkge1xuICByZXR1cm4gKHJvdXRlc0J5UGFyZW50SWRbcGFyZW50SWRdIHx8IFtdKS5tYXAoKHJvdXRlKSA9PiB7XG4gICAgbGV0IGNvbW1vblJvdXRlID0ge1xuICAgICAgLy8gQWx3YXlzIGluY2x1ZGUgcm9vdCBkdWUgdG8gZGVmYXVsdCBib3VuZGFyaWVzXG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiByb3V0ZS5pZCA9PT0gXCJyb290XCIgfHwgcm91dGUubW9kdWxlLkVycm9yQm91bmRhcnkgIT0gbnVsbCxcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGgsXG4gICAgICB1bnN0YWJsZV9taWRkbGV3YXJlOiByb3V0ZS5tb2R1bGUudW5zdGFibGVfbWlkZGxld2FyZSxcbiAgICAgIC8vIE5lZWQgdG8gdXNlIFJSJ3MgdmVyc2lvbiBpbiB0aGUgcGFyYW0gdHlwZWQgaGVyZSB0byBwZXJtaXQgdGhlIG9wdGlvbmFsXG4gICAgICAvLyBjb250ZXh0IGV2ZW4gdGhvdWdoIHdlIGtub3cgaXQnbGwgYWx3YXlzIGJlIHByb3ZpZGVkIGluIHJlbWl4XG4gICAgICBsb2FkZXI6IHJvdXRlLm1vZHVsZS5sb2FkZXIgPyBhc3luYyAoYXJncykgPT4ge1xuICAgICAgICBsZXQgcHJlUmVuZGVyZWREYXRhID0gZ2V0QnVpbGRUaW1lSGVhZGVyKFxuICAgICAgICAgIGFyZ3MucmVxdWVzdCxcbiAgICAgICAgICBcIlgtUmVhY3QtUm91dGVyLVByZXJlbmRlci1EYXRhXCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHByZVJlbmRlcmVkRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgbGV0IGVuY29kZWQgPSBwcmVSZW5kZXJlZERhdGEgPyBkZWNvZGVVUkkocHJlUmVuZGVyZWREYXRhKSA6IHByZVJlbmRlcmVkRGF0YTtcbiAgICAgICAgICBpbnZhcmlhbnQzKGVuY29kZWQsIFwiTWlzc2luZyBwcmVyZW5kZXJlZCBkYXRhIGZvciByb3V0ZVwiKTtcbiAgICAgICAgICBsZXQgdWludDhhcnJheSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShlbmNvZGVkKTtcbiAgICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHVpbnQ4YXJyYXkpO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGV0IGRlY29kZWQgPSBhd2FpdCBkZWNvZGVWaWFUdXJib1N0cmVhbShzdHJlYW0sIGdsb2JhbCk7XG4gICAgICAgICAgbGV0IGRhdGEyID0gZGVjb2RlZC52YWx1ZTtcbiAgICAgICAgICBpZiAoZGF0YTIgJiYgU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbCBpbiBkYXRhMikge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGRhdGEyW1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2xdO1xuICAgICAgICAgICAgbGV0IGluaXQgPSB7IHN0YXR1czogcmVzdWx0LnN0YXR1cyB9O1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWxvYWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVkaXJlY3REb2N1bWVudChyZXN1bHQucmVkaXJlY3QsIGluaXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQucmVwbGFjZSkge1xuICAgICAgICAgICAgICB0aHJvdyByZXBsYWNlKHJlc3VsdC5yZWRpcmVjdCwgaW5pdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyByZWRpcmVjdChyZXN1bHQucmVkaXJlY3QsIGluaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnZhcmlhbnQzKFxuICAgICAgICAgICAgICBkYXRhMiAmJiByb3V0ZS5pZCBpbiBkYXRhMixcbiAgICAgICAgICAgICAgXCJVbmFibGUgdG8gZGVjb2RlIHByZXJlbmRlcmVkIGRhdGFcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBkYXRhMltyb3V0ZS5pZF07XG4gICAgICAgICAgICBpbnZhcmlhbnQzKFxuICAgICAgICAgICAgICBcImRhdGFcIiBpbiByZXN1bHQsXG4gICAgICAgICAgICAgIFwiVW5hYmxlIHRvIHByb2Nlc3MgcHJlcmVuZGVyZWQgZGF0YVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsID0gYXdhaXQgY2FsbFJvdXRlSGFuZGxlcihyb3V0ZS5tb2R1bGUubG9hZGVyLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH0gOiB2b2lkIDAsXG4gICAgICBhY3Rpb246IHJvdXRlLm1vZHVsZS5hY3Rpb24gPyAoYXJncykgPT4gY2FsbFJvdXRlSGFuZGxlcihyb3V0ZS5tb2R1bGUuYWN0aW9uLCBhcmdzKSA6IHZvaWQgMCxcbiAgICAgIGhhbmRsZTogcm91dGUubW9kdWxlLmhhbmRsZVxuICAgIH07XG4gICAgcmV0dXJuIHJvdXRlLmluZGV4ID8ge1xuICAgICAgaW5kZXg6IHRydWUsXG4gICAgICAuLi5jb21tb25Sb3V0ZVxuICAgIH0gOiB7XG4gICAgICBjYXNlU2Vuc2l0aXZlOiByb3V0ZS5jYXNlU2Vuc2l0aXZlLFxuICAgICAgY2hpbGRyZW46IGNyZWF0ZVN0YXRpY0hhbmRsZXJEYXRhUm91dGVzKFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgZnV0dXJlLFxuICAgICAgICByb3V0ZS5pZCxcbiAgICAgICAgcm91dGVzQnlQYXJlbnRJZFxuICAgICAgKSxcbiAgICAgIC4uLmNvbW1vblJvdXRlXG4gICAgfTtcbiAgfSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9tYXJrdXAudHNcbnZhciBFU0NBUEVfTE9PS1VQMyA9IHtcbiAgXCImXCI6IFwiXFxcXHUwMDI2XCIsXG4gIFwiPlwiOiBcIlxcXFx1MDAzZVwiLFxuICBcIjxcIjogXCJcXFxcdTAwM2NcIixcbiAgXCJcXHUyMDI4XCI6IFwiXFxcXHUyMDI4XCIsXG4gIFwiXFx1MjAyOVwiOiBcIlxcXFx1MjAyOVwiXG59O1xudmFyIEVTQ0FQRV9SRUdFWDMgPSAvWyY+PFxcdTIwMjhcXHUyMDI5XS9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbDIoaHRtbCkge1xuICByZXR1cm4gaHRtbC5yZXBsYWNlKEVTQ0FQRV9SRUdFWDMsIChtYXRjaCkgPT4gRVNDQVBFX0xPT0tVUDNbbWF0Y2hdKTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3NlcnZlckhhbmRvZmYudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcoc2VydmVySGFuZG9mZikge1xuICByZXR1cm4gZXNjYXBlSHRtbDIoSlNPTi5zdHJpbmdpZnkoc2VydmVySGFuZG9mZikpO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvaGVhZGVycy50c1xudmFyIGltcG9ydF9zZXRfY29va2llX3BhcnNlciA9IHJlcXVpcmUoXCJzZXQtY29va2llLXBhcnNlclwiKTtcbmZ1bmN0aW9uIGdldERvY3VtZW50SGVhZGVycyhidWlsZCwgY29udGV4dCkge1xuICBsZXQgYm91bmRhcnlJZHggPSBjb250ZXh0LmVycm9ycyA/IGNvbnRleHQubWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IGNvbnRleHQuZXJyb3JzW20ucm91dGUuaWRdKSA6IC0xO1xuICBsZXQgbWF0Y2hlcyA9IGJvdW5kYXJ5SWR4ID49IDAgPyBjb250ZXh0Lm1hdGNoZXMuc2xpY2UoMCwgYm91bmRhcnlJZHggKyAxKSA6IGNvbnRleHQubWF0Y2hlcztcbiAgbGV0IGVycm9ySGVhZGVycztcbiAgaWYgKGJvdW5kYXJ5SWR4ID49IDApIHtcbiAgICBsZXQgeyBhY3Rpb25IZWFkZXJzLCBhY3Rpb25EYXRhLCBsb2FkZXJIZWFkZXJzLCBsb2FkZXJEYXRhIH0gPSBjb250ZXh0O1xuICAgIGNvbnRleHQubWF0Y2hlcy5zbGljZShib3VuZGFyeUlkeCkuc29tZSgobWF0Y2gpID0+IHtcbiAgICAgIGxldCBpZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgICAgaWYgKGFjdGlvbkhlYWRlcnNbaWRdICYmICghYWN0aW9uRGF0YSB8fCAhYWN0aW9uRGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpKSB7XG4gICAgICAgIGVycm9ySGVhZGVycyA9IGFjdGlvbkhlYWRlcnNbaWRdO1xuICAgICAgfSBlbHNlIGlmIChsb2FkZXJIZWFkZXJzW2lkXSAmJiAhbG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgZXJyb3JIZWFkZXJzID0gbG9hZGVySGVhZGVyc1tpZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3JIZWFkZXJzICE9IG51bGw7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXMucmVkdWNlKChwYXJlbnRIZWFkZXJzLCBtYXRjaCwgaWR4KSA9PiB7XG4gICAgbGV0IHsgaWQgfSA9IG1hdGNoLnJvdXRlO1xuICAgIGxldCByb3V0ZSA9IGJ1aWxkLnJvdXRlc1tpZF07XG4gICAgaW52YXJpYW50Myhyb3V0ZSwgYFJvdXRlIHdpdGggaWQgXCIke2lkfVwiIG5vdCBmb3VuZCBpbiBidWlsZGApO1xuICAgIGxldCByb3V0ZU1vZHVsZSA9IHJvdXRlLm1vZHVsZTtcbiAgICBsZXQgbG9hZGVySGVhZGVycyA9IGNvbnRleHQubG9hZGVySGVhZGVyc1tpZF0gfHwgbmV3IEhlYWRlcnMoKTtcbiAgICBsZXQgYWN0aW9uSGVhZGVycyA9IGNvbnRleHQuYWN0aW9uSGVhZGVyc1tpZF0gfHwgbmV3IEhlYWRlcnMoKTtcbiAgICBsZXQgaW5jbHVkZUVycm9ySGVhZGVycyA9IGVycm9ySGVhZGVycyAhPSBudWxsICYmIGlkeCA9PT0gbWF0Y2hlcy5sZW5ndGggLSAxO1xuICAgIGxldCBpbmNsdWRlRXJyb3JDb29raWVzID0gaW5jbHVkZUVycm9ySGVhZGVycyAmJiBlcnJvckhlYWRlcnMgIT09IGxvYWRlckhlYWRlcnMgJiYgZXJyb3JIZWFkZXJzICE9PSBhY3Rpb25IZWFkZXJzO1xuICAgIGlmIChyb3V0ZU1vZHVsZS5oZWFkZXJzID09IG51bGwpIHtcbiAgICAgIGxldCBoZWFkZXJzMiA9IG5ldyBIZWFkZXJzKHBhcmVudEhlYWRlcnMpO1xuICAgICAgaWYgKGluY2x1ZGVFcnJvckNvb2tpZXMpIHtcbiAgICAgICAgcHJlcGVuZENvb2tpZXMoZXJyb3JIZWFkZXJzLCBoZWFkZXJzMik7XG4gICAgICB9XG4gICAgICBwcmVwZW5kQ29va2llcyhhY3Rpb25IZWFkZXJzLCBoZWFkZXJzMik7XG4gICAgICBwcmVwZW5kQ29va2llcyhsb2FkZXJIZWFkZXJzLCBoZWFkZXJzMik7XG4gICAgICByZXR1cm4gaGVhZGVyczI7XG4gICAgfVxuICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoXG4gICAgICByb3V0ZU1vZHVsZS5oZWFkZXJzID8gdHlwZW9mIHJvdXRlTW9kdWxlLmhlYWRlcnMgPT09IFwiZnVuY3Rpb25cIiA/IHJvdXRlTW9kdWxlLmhlYWRlcnMoe1xuICAgICAgICBsb2FkZXJIZWFkZXJzLFxuICAgICAgICBwYXJlbnRIZWFkZXJzLFxuICAgICAgICBhY3Rpb25IZWFkZXJzLFxuICAgICAgICBlcnJvckhlYWRlcnM6IGluY2x1ZGVFcnJvckhlYWRlcnMgPyBlcnJvckhlYWRlcnMgOiB2b2lkIDBcbiAgICAgIH0pIDogcm91dGVNb2R1bGUuaGVhZGVycyA6IHZvaWQgMFxuICAgICk7XG4gICAgaWYgKGluY2x1ZGVFcnJvckNvb2tpZXMpIHtcbiAgICAgIHByZXBlbmRDb29raWVzKGVycm9ySGVhZGVycywgaGVhZGVycyk7XG4gICAgfVxuICAgIHByZXBlbmRDb29raWVzKGFjdGlvbkhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIHByZXBlbmRDb29raWVzKGxvYWRlckhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIHByZXBlbmRDb29raWVzKHBhcmVudEhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9LCBuZXcgSGVhZGVycygpKTtcbn1cbmZ1bmN0aW9uIHByZXBlbmRDb29raWVzKHBhcmVudEhlYWRlcnMsIGNoaWxkSGVhZGVycykge1xuICBsZXQgcGFyZW50U2V0Q29va2llU3RyaW5nID0gcGFyZW50SGVhZGVycy5nZXQoXCJTZXQtQ29va2llXCIpO1xuICBpZiAocGFyZW50U2V0Q29va2llU3RyaW5nKSB7XG4gICAgbGV0IGNvb2tpZXMgPSAoMCwgaW1wb3J0X3NldF9jb29raWVfcGFyc2VyLnNwbGl0Q29va2llc1N0cmluZykocGFyZW50U2V0Q29va2llU3RyaW5nKTtcbiAgICBsZXQgY2hpbGRDb29raWVzID0gbmV3IFNldChjaGlsZEhlYWRlcnMuZ2V0U2V0Q29va2llKCkpO1xuICAgIGNvb2tpZXMuZm9yRWFjaCgoY29va2llKSA9PiB7XG4gICAgICBpZiAoIWNoaWxkQ29va2llcy5oYXMoY29va2llKSkge1xuICAgICAgICBjaGlsZEhlYWRlcnMuYXBwZW5kKFwiU2V0LUNvb2tpZVwiLCBjb29raWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zaW5nbGUtZmV0Y2gudHNcbnZhciBTRVJWRVJfTk9fQk9EWV9TVEFUVVNfQ09ERVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIC4uLk5PX0JPRFlfU1RBVFVTX0NPREVTLFxuICAzMDRcbl0pO1xuYXN5bmMgZnVuY3Rpb24gc2luZ2xlRmV0Y2hBY3Rpb24oYnVpbGQsIHNlcnZlck1vZGUsIHN0YXRpY0hhbmRsZXIsIHJlcXVlc3QsIGhhbmRsZXJVcmwsIGxvYWRDb250ZXh0LCBoYW5kbGVFcnJvcikge1xuICB0cnkge1xuICAgIGxldCByZXNwb25kMiA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIGxldCBoZWFkZXJzID0gZ2V0RG9jdW1lbnRIZWFkZXJzKGJ1aWxkLCBjb250ZXh0KTtcbiAgICAgIGlmIChpc1JlZGlyZWN0U3RhdHVzQ29kZShjb250ZXh0LnN0YXR1c0NvZGUpICYmIGhlYWRlcnMuaGFzKFwiTG9jYXRpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlU2luZ2xlRmV0Y2hSZXNwb25zZShyZXF1ZXN0LCBidWlsZCwgc2VydmVyTW9kZSwge1xuICAgICAgICAgIHJlc3VsdDogZ2V0U2luZ2xlRmV0Y2hSZWRpcmVjdChcbiAgICAgICAgICAgIGNvbnRleHQuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBidWlsZC5iYXNlbmFtZVxuICAgICAgICAgICksXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBzdGF0dXM6IFNJTkdMRV9GRVRDSF9SRURJUkVDVF9TVEFUVVNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhjb250ZXh0LmVycm9ycykuZm9yRWFjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCFpc1JvdXRlRXJyb3JSZXNwb25zZShlcnIpIHx8IGVyci5lcnJvcikge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LmVycm9ycyA9IHNhbml0aXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKTtcbiAgICAgIH1cbiAgICAgIGxldCBzaW5nbGVGZXRjaFJlc3VsdDtcbiAgICAgIGlmIChjb250ZXh0LmVycm9ycykge1xuICAgICAgICBzaW5nbGVGZXRjaFJlc3VsdCA9IHsgZXJyb3I6IE9iamVjdC52YWx1ZXMoY29udGV4dC5lcnJvcnMpWzBdIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaW5nbGVGZXRjaFJlc3VsdCA9IHtcbiAgICAgICAgICBkYXRhOiBPYmplY3QudmFsdWVzKGNvbnRleHQuYWN0aW9uRGF0YSB8fCB7fSlbMF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgICAgcmVzdWx0OiBzaW5nbGVGZXRjaFJlc3VsdCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc3RhdHVzOiBjb250ZXh0LnN0YXR1c0NvZGVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIHJlc3BvbmQgPSByZXNwb25kMjtcbiAgICBsZXQgaGFuZGxlclJlcXVlc3QgPSBuZXcgUmVxdWVzdChoYW5kbGVyVXJsLCB7XG4gICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgYm9keTogcmVxdWVzdC5ib2R5LFxuICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbCxcbiAgICAgIC4uLnJlcXVlc3QuYm9keSA/IHsgZHVwbGV4OiBcImhhbGZcIiB9IDogdm9pZCAwXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHN0YXRpY0hhbmRsZXIucXVlcnkoaGFuZGxlclJlcXVlc3QsIHtcbiAgICAgIHJlcXVlc3RDb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nOiB0cnVlLFxuICAgICAgc2tpcFJldmFsaWRhdGlvbjogdHJ1ZSxcbiAgICAgIHVuc3RhYmxlX3Jlc3BvbmQ6IHJlc3BvbmQyXG4gICAgfSk7XG4gICAgaWYgKCFpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3BvbmQyKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIGdlbmVyYXRlU2luZ2xlRmV0Y2hSZXNwb25zZShyZXF1ZXN0LCBidWlsZCwgc2VydmVyTW9kZSwge1xuICAgICAgICByZXN1bHQ6IGdldFNpbmdsZUZldGNoUmVkaXJlY3QoXG4gICAgICAgICAgcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgICByZXN1bHQuaGVhZGVycyxcbiAgICAgICAgICBidWlsZC5iYXNlbmFtZVxuICAgICAgICApLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVycyxcbiAgICAgICAgc3RhdHVzOiBTSU5HTEVfRkVUQ0hfUkVESVJFQ1RfU1RBVFVTXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBoYW5kbGVFcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIGdlbmVyYXRlU2luZ2xlRmV0Y2hSZXNwb25zZShyZXF1ZXN0LCBidWlsZCwgc2VydmVyTW9kZSwge1xuICAgICAgcmVzdWx0OiB7IGVycm9yIH0sXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycygpLFxuICAgICAgc3RhdHVzOiA1MDBcbiAgICB9KTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc2luZ2xlRmV0Y2hMb2FkZXJzKGJ1aWxkLCBzZXJ2ZXJNb2RlLCBzdGF0aWNIYW5kbGVyLCByZXF1ZXN0LCBoYW5kbGVyVXJsLCBsb2FkQ29udGV4dCwgaGFuZGxlRXJyb3IpIHtcbiAgdHJ5IHtcbiAgICBsZXQgcmVzcG9uZDIgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICBsZXQgaGVhZGVycyA9IGdldERvY3VtZW50SGVhZGVycyhidWlsZCwgY29udGV4dCk7XG4gICAgICBpZiAoaXNSZWRpcmVjdFN0YXR1c0NvZGUoY29udGV4dC5zdGF0dXNDb2RlKSAmJiBoZWFkZXJzLmhhcyhcIkxvY2F0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgIFtTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sXTogZ2V0U2luZ2xlRmV0Y2hSZWRpcmVjdChcbiAgICAgICAgICAgICAgY29udGV4dC5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICBidWlsZC5iYXNlbmFtZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBzdGF0dXM6IFNJTkdMRV9GRVRDSF9SRURJUkVDVF9TVEFUVVNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhjb250ZXh0LmVycm9ycykuZm9yRWFjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCFpc1JvdXRlRXJyb3JSZXNwb25zZShlcnIpIHx8IGVyci5lcnJvcikge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LmVycm9ycyA9IHNhbml0aXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHRzID0ge307XG4gICAgICBsZXQgbG9hZGVkTWF0Y2hlcyA9IG5ldyBTZXQoXG4gICAgICAgIGNvbnRleHQubWF0Y2hlcy5maWx0ZXIoXG4gICAgICAgICAgKG0pID0+IGxvYWRSb3V0ZUlkcyA/IGxvYWRSb3V0ZUlkcy5oYXMobS5yb3V0ZS5pZCkgOiBtLnJvdXRlLmxvYWRlciAhPSBudWxsXG4gICAgICAgICkubWFwKChtKSA9PiBtLnJvdXRlLmlkKVxuICAgICAgKTtcbiAgICAgIGlmIChjb250ZXh0LmVycm9ycykge1xuICAgICAgICBmb3IgKGxldCBbaWQsIGVycm9yXSBvZiBPYmplY3QuZW50cmllcyhjb250ZXh0LmVycm9ycykpIHtcbiAgICAgICAgICByZXN1bHRzW2lkXSA9IHsgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgW2lkLCBkYXRhMl0gb2YgT2JqZWN0LmVudHJpZXMoY29udGV4dC5sb2FkZXJEYXRhKSkge1xuICAgICAgICBpZiAoIShpZCBpbiByZXN1bHRzKSAmJiBsb2FkZWRNYXRjaGVzLmhhcyhpZCkpIHtcbiAgICAgICAgICByZXN1bHRzW2lkXSA9IHsgZGF0YTogZGF0YTIgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdlbmVyYXRlU2luZ2xlRmV0Y2hSZXNwb25zZShyZXF1ZXN0LCBidWlsZCwgc2VydmVyTW9kZSwge1xuICAgICAgICByZXN1bHQ6IHJlc3VsdHMsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogY29udGV4dC5zdGF0dXNDb2RlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciByZXNwb25kID0gcmVzcG9uZDI7XG4gICAgbGV0IGhhbmRsZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaGFuZGxlclVybCwge1xuICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICAgIH0pO1xuICAgIGxldCByb3V0ZXNQYXJhbSA9IG5ldyBVUkwocmVxdWVzdC51cmwpLnNlYXJjaFBhcmFtcy5nZXQoXCJfcm91dGVzXCIpO1xuICAgIGxldCBsb2FkUm91dGVJZHMgPSByb3V0ZXNQYXJhbSA/IG5ldyBTZXQocm91dGVzUGFyYW0uc3BsaXQoXCIsXCIpKSA6IG51bGw7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHN0YXRpY0hhbmRsZXIucXVlcnkoaGFuZGxlclJlcXVlc3QsIHtcbiAgICAgIHJlcXVlc3RDb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgIGZpbHRlck1hdGNoZXNUb0xvYWQ6IChtKSA9PiAhbG9hZFJvdXRlSWRzIHx8IGxvYWRSb3V0ZUlkcy5oYXMobS5yb3V0ZS5pZCksXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZzogdHJ1ZSxcbiAgICAgIHVuc3RhYmxlX3Jlc3BvbmQ6IHJlc3BvbmQyXG4gICAgfSk7XG4gICAgaWYgKCFpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3BvbmQyKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIGdlbmVyYXRlU2luZ2xlRmV0Y2hSZXNwb25zZShyZXF1ZXN0LCBidWlsZCwgc2VydmVyTW9kZSwge1xuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICBbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF06IGdldFNpbmdsZUZldGNoUmVkaXJlY3QoXG4gICAgICAgICAgICByZXN1bHQuc3RhdHVzLFxuICAgICAgICAgICAgcmVzdWx0LmhlYWRlcnMsXG4gICAgICAgICAgICBidWlsZC5iYXNlbmFtZVxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVU1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgIHJlc3VsdDogeyByb290OiB7IGVycm9yIH0gfSxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKCksXG4gICAgICBzdGF0dXM6IDUwMFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgcmVzdWx0LFxuICBoZWFkZXJzLFxuICBzdGF0dXNcbn0pIHtcbiAgbGV0IHJlc3VsdEhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzKTtcbiAgcmVzdWx0SGVhZGVycy5zZXQoXCJYLVJlbWl4LVJlc3BvbnNlXCIsIFwieWVzXCIpO1xuICBpZiAoU0VSVkVSX05PX0JPRFlfU1RBVFVTX0NPREVTLmhhcyhzdGF0dXMpKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1cywgaGVhZGVyczogcmVzdWx0SGVhZGVycyB9KTtcbiAgfVxuICByZXN1bHRIZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQveC1zY3JpcHRcIik7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UoXG4gICAgZW5jb2RlVmlhVHVyYm9TdHJlYW0oXG4gICAgICByZXN1bHQsXG4gICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgIGJ1aWxkLmVudHJ5Lm1vZHVsZS5zdHJlYW1UaW1lb3V0LFxuICAgICAgc2VydmVyTW9kZVxuICAgICksXG4gICAge1xuICAgICAgc3RhdHVzOiBzdGF0dXMgfHwgMjAwLFxuICAgICAgaGVhZGVyczogcmVzdWx0SGVhZGVyc1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFNpbmdsZUZldGNoUmVkaXJlY3Qoc3RhdHVzLCBoZWFkZXJzLCBiYXNlbmFtZSkge1xuICBsZXQgcmVkaXJlY3QyID0gaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgaWYgKGJhc2VuYW1lKSB7XG4gICAgcmVkaXJlY3QyID0gc3RyaXBCYXNlbmFtZShyZWRpcmVjdDIsIGJhc2VuYW1lKSB8fCByZWRpcmVjdDI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZWRpcmVjdDogcmVkaXJlY3QyLFxuICAgIHN0YXR1cyxcbiAgICByZXZhbGlkYXRlOiAoXG4gICAgICAvLyBUZWNobmljYWxseSBYLVJlbWl4LVJldmFsaWRhdGUgaXNuJ3QgbmVlZGVkIGhlcmUgLSB0aGF0IHdhcyBhbiBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gZGV0YWlsIG9mID9fZGF0YSByZXF1ZXN0cyBhcyBvdXIgd2F5IHRvIHRlbGwgdGhlIGZyb250IGVuZCB0byByZXZhbGlkYXRlIHdoZW5cbiAgICAgIC8vIHdlIGRpZG4ndCBoYXZlIGEgcmVzcG9uc2UgYm9keSB0byBpbmNsdWRlIHRoYXQgaW5mb3JtYXRpb24gaW4uXG4gICAgICAvLyBXaXRoIHNpbmdsZSBmZXRjaCwgd2UgdGVsbCB0aGUgZnJvbnQgZW5kIHZpYSB0aGlzIHJldmFsaWRhdGUgYm9vbGVhbiBmaWVsZC5cbiAgICAgIC8vIEhvd2V2ZXIsIHdlJ3JlIHJlc3BlY3RpbmcgaXQgZm9yIG5vdyBiZWNhdXNlIGl0IG1heSBiZSBzb21ldGhpbmcgZm9sa3MgaGF2ZVxuICAgICAgLy8gdXNlZCBpbiB0aGVpciBvd24gcmVzcG9uc2VzXG4gICAgICAvLyBUT0RPKHYzKTogQ29uc2lkZXIgcmVtb3Zpbmcgb3IgbWFraW5nIHRoaXMgb2ZmaWNpYWwgcHVibGljIEFQSVxuICAgICAgaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJldmFsaWRhdGVcIikgfHwgaGVhZGVycy5oYXMoXCJTZXQtQ29va2llXCIpXG4gICAgKSxcbiAgICByZWxvYWQ6IGhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIiksXG4gICAgcmVwbGFjZTogaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlcGxhY2VcIilcbiAgfTtcbn1cbmZ1bmN0aW9uIGVuY29kZVZpYVR1cmJvU3RyZWFtKGRhdGEyLCByZXF1ZXN0U2lnbmFsLCBzdHJlYW1UaW1lb3V0LCBzZXJ2ZXJNb2RlKSB7XG4gIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICBsZXQgdGltZW91dElkID0gc2V0VGltZW91dChcbiAgICAoKSA9PiBjb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcihcIlNlcnZlciBUaW1lb3V0XCIpKSxcbiAgICB0eXBlb2Ygc3RyZWFtVGltZW91dCA9PT0gXCJudW1iZXJcIiA/IHN0cmVhbVRpbWVvdXQgOiA0OTUwXG4gICk7XG4gIHJlcXVlc3RTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpKTtcbiAgcmV0dXJuIGVuY29kZShkYXRhMiwge1xuICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgcGx1Z2luczogW1xuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgbGV0IHsgbmFtZSwgbWVzc2FnZSwgc3RhY2sgfSA9IHNlcnZlck1vZGUgPT09IFwicHJvZHVjdGlvblwiIC8qIFByb2R1Y3Rpb24gKi8gPyBzYW5pdGl6ZUVycm9yKHZhbHVlLCBzZXJ2ZXJNb2RlKSA6IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBbXCJTYW5pdGl6ZWRFcnJvclwiLCBuYW1lLCBtZXNzYWdlLCBzdGFja107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3JSZXNwb25zZUltcGwpIHtcbiAgICAgICAgICBsZXQgeyBkYXRhOiBkYXRhMywgc3RhdHVzLCBzdGF0dXNUZXh0IH0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gW1wiRXJyb3JSZXNwb25zZVwiLCBkYXRhMywgc3RhdHVzLCBzdGF0dXNUZXh0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFNpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wgaW4gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gW1wiU2luZ2xlRmV0Y2hSZWRpcmVjdFwiLCB2YWx1ZVtTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdLFxuICAgIHBvc3RQbHVnaW5zOiBbXG4gICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSByZXR1cm47XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJTaW5nbGVGZXRjaENsYXNzSW5zdGFuY2VcIixcbiAgICAgICAgICBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModmFsdWUpKVxuICAgICAgICBdO1xuICAgICAgfSxcbiAgICAgICgpID0+IFtcIlNpbmdsZUZldGNoRmFsbGJhY2tcIl1cbiAgICBdXG4gIH0pO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2VydmVyLnRzXG5mdW5jdGlvbiBkZXJpdmUoYnVpbGQsIG1vZGUpIHtcbiAgbGV0IHJvdXRlcyA9IGNyZWF0ZVJvdXRlcyhidWlsZC5yb3V0ZXMpO1xuICBsZXQgZGF0YVJvdXRlcyA9IGNyZWF0ZVN0YXRpY0hhbmRsZXJEYXRhUm91dGVzKGJ1aWxkLnJvdXRlcywgYnVpbGQuZnV0dXJlKTtcbiAgbGV0IHNlcnZlck1vZGUgPSBpc1NlcnZlck1vZGUobW9kZSkgPyBtb2RlIDogXCJwcm9kdWN0aW9uXCIgLyogUHJvZHVjdGlvbiAqLztcbiAgbGV0IHN0YXRpY0hhbmRsZXIgPSBjcmVhdGVTdGF0aWNIYW5kbGVyKGRhdGFSb3V0ZXMsIHtcbiAgICBiYXNlbmFtZTogYnVpbGQuYmFzZW5hbWVcbiAgfSk7XG4gIGxldCBlcnJvckhhbmRsZXIgPSBidWlsZC5lbnRyeS5tb2R1bGUuaGFuZGxlRXJyb3IgfHwgKChlcnJvciwgeyByZXF1ZXN0IH0pID0+IHtcbiAgICBpZiAoc2VydmVyTW9kZSAhPT0gXCJ0ZXN0XCIgLyogVGVzdCAqLyAmJiAhcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUaGlzIGlzIFwicHJpdmF0ZVwiIGZyb20gdXNlcnMgYnV0IGludGVuZGVkIGZvciBpbnRlcm5hbCB1c2VcbiAgICAgICAgaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpICYmIGVycm9yLmVycm9yID8gZXJyb3IuZXJyb3IgOiBlcnJvclxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHJvdXRlcyxcbiAgICBkYXRhUm91dGVzLFxuICAgIHNlcnZlck1vZGUsXG4gICAgc3RhdGljSGFuZGxlcixcbiAgICBlcnJvckhhbmRsZXJcbiAgfTtcbn1cbnZhciBjcmVhdGVSZXF1ZXN0SGFuZGxlciA9IChidWlsZCwgbW9kZSkgPT4ge1xuICBsZXQgX2J1aWxkO1xuICBsZXQgcm91dGVzO1xuICBsZXQgc2VydmVyTW9kZTtcbiAgbGV0IHN0YXRpY0hhbmRsZXI7XG4gIGxldCBlcnJvckhhbmRsZXI7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiByZXF1ZXN0SGFuZGxlcihyZXF1ZXN0LCBpbml0aWFsQ29udGV4dCkge1xuICAgIF9idWlsZCA9IHR5cGVvZiBidWlsZCA9PT0gXCJmdW5jdGlvblwiID8gYXdhaXQgYnVpbGQoKSA6IGJ1aWxkO1xuICAgIGlmICh0eXBlb2YgYnVpbGQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgbGV0IGRlcml2ZWQgPSBkZXJpdmUoX2J1aWxkLCBtb2RlKTtcbiAgICAgIHJvdXRlcyA9IGRlcml2ZWQucm91dGVzO1xuICAgICAgc2VydmVyTW9kZSA9IGRlcml2ZWQuc2VydmVyTW9kZTtcbiAgICAgIHN0YXRpY0hhbmRsZXIgPSBkZXJpdmVkLnN0YXRpY0hhbmRsZXI7XG4gICAgICBlcnJvckhhbmRsZXIgPSBkZXJpdmVkLmVycm9ySGFuZGxlcjtcbiAgICB9IGVsc2UgaWYgKCFyb3V0ZXMgfHwgIXNlcnZlck1vZGUgfHwgIXN0YXRpY0hhbmRsZXIgfHwgIWVycm9ySGFuZGxlcikge1xuICAgICAgbGV0IGRlcml2ZWQgPSBkZXJpdmUoX2J1aWxkLCBtb2RlKTtcbiAgICAgIHJvdXRlcyA9IGRlcml2ZWQucm91dGVzO1xuICAgICAgc2VydmVyTW9kZSA9IGRlcml2ZWQuc2VydmVyTW9kZTtcbiAgICAgIHN0YXRpY0hhbmRsZXIgPSBkZXJpdmVkLnN0YXRpY0hhbmRsZXI7XG4gICAgICBlcnJvckhhbmRsZXIgPSBkZXJpdmVkLmVycm9ySGFuZGxlcjtcbiAgICB9XG4gICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgIGxldCBsb2FkQ29udGV4dDtcbiAgICBsZXQgaGFuZGxlRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIGlmIChtb2RlID09PSBcImRldmVsb3BtZW50XCIgLyogRGV2ZWxvcG1lbnQgKi8pIHtcbiAgICAgICAgZ2V0RGV2U2VydmVySG9va3MoKT8ucHJvY2Vzc1JlcXVlc3RFcnJvcj8uKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGVycm9ySGFuZGxlcihlcnJvciwge1xuICAgICAgICBjb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChfYnVpbGQuZnV0dXJlLnVuc3RhYmxlX21pZGRsZXdhcmUpIHtcbiAgICAgIGlmIChpbml0aWFsQ29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgIGxvYWRDb250ZXh0ID0gbmV3IHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsb2FkQ29udGV4dCA9IG5ldyB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXIoXG4gICAgICAgICAgICBpbml0aWFsQ29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVW5hYmxlIHRvIGNyZWF0ZSBpbml0aWFsIFxcYHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlclxcYCBpbnN0YW5jZS4gUGxlYXNlIGNvbmZpcm0geW91IGFyZSByZXR1cm5pbmcgYW4gaW5zdGFuY2Ugb2YgXFxgTWFwPHVuc3RhYmxlX3JvdXRlckNvbnRleHQsIHVua25vd24+XFxgIGZyb20geW91ciBcXGBnZXRMb2FkQ29udGV4dFxcYCBmdW5jdGlvbi5cblxuRXJyb3I6ICR7ZSBpbnN0YW5jZW9mIEVycm9yID8gZS50b1N0cmluZygpIDogZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuIHJldHVybkxhc3RSZXNvcnRFcnJvclJlc3BvbnNlKGVycm9yLCBzZXJ2ZXJNb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkQ29udGV4dCA9IGluaXRpYWxDb250ZXh0IHx8IHt9O1xuICAgIH1cbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG5vcm1hbGl6ZWRCYXNlbmFtZSA9IF9idWlsZC5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgICBsZXQgbm9ybWFsaXplZFBhdGggPSB1cmwucGF0aG5hbWU7XG4gICAgaWYgKHN0cmlwQmFzZW5hbWUobm9ybWFsaXplZFBhdGgsIG5vcm1hbGl6ZWRCYXNlbmFtZSkgPT09IFwiL19yb290LmRhdGFcIikge1xuICAgICAgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVkQmFzZW5hbWU7XG4gICAgfSBlbHNlIGlmIChub3JtYWxpemVkUGF0aC5lbmRzV2l0aChcIi5kYXRhXCIpKSB7XG4gICAgICBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZWRQYXRoLnJlcGxhY2UoL1xcLmRhdGEkLywgXCJcIik7XG4gICAgfVxuICAgIGlmIChzdHJpcEJhc2VuYW1lKG5vcm1hbGl6ZWRQYXRoLCBub3JtYWxpemVkQmFzZW5hbWUpICE9PSBcIi9cIiAmJiBub3JtYWxpemVkUGF0aC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgIG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplZFBhdGguc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICBsZXQgaXNTcGFNb2RlID0gZ2V0QnVpbGRUaW1lSGVhZGVyKHJlcXVlc3QsIFwiWC1SZWFjdC1Sb3V0ZXItU1BBLU1vZGVcIikgPT09IFwieWVzXCI7XG4gICAgaWYgKCFfYnVpbGQuc3NyKSB7XG4gICAgICBpZiAoX2J1aWxkLnByZXJlbmRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaXNTcGFNb2RlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIV9idWlsZC5wcmVyZW5kZXIuaW5jbHVkZXMobm9ybWFsaXplZFBhdGgpICYmICFfYnVpbGQucHJlcmVuZGVyLmluY2x1ZGVzKG5vcm1hbGl6ZWRQYXRoICsgXCIvXCIpKSB7XG4gICAgICAgIGlmICh1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIuZGF0YVwiKSkge1xuICAgICAgICAgIGVycm9ySGFuZGxlcihcbiAgICAgICAgICAgIG5ldyBFcnJvclJlc3BvbnNlSW1wbChcbiAgICAgICAgICAgICAgNDA0LFxuICAgICAgICAgICAgICBcIk5vdCBGb3VuZFwiLFxuICAgICAgICAgICAgICBgUmVmdXNpbmcgdG8gU1NSIHRoZSBwYXRoIFxcYCR7bm9ybWFsaXplZFBhdGh9XFxgIGJlY2F1c2UgXFxgc3NyOmZhbHNlXFxgIGlzIHNldCBhbmQgdGhlIHBhdGggaXMgbm90IGluY2x1ZGVkIGluIHRoZSBcXGBwcmVyZW5kZXJcXGAgY29uZmlnLCBzbyBpbiBwcm9kdWN0aW9uIHRoZSBwYXRoIHdpbGwgYmUgYSA0MDQuYFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgcmVxdWVzdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShcIk5vdCBGb3VuZFwiLCB7XG4gICAgICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IFwiTm90IEZvdW5kXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1NwYU1vZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBtYW5pZmVzdFVybCA9IGdldE1hbmlmZXN0UGF0aChcbiAgICAgIF9idWlsZC5yb3V0ZURpc2NvdmVyeS5tYW5pZmVzdFBhdGgsXG4gICAgICBub3JtYWxpemVkQmFzZW5hbWVcbiAgICApO1xuICAgIGlmICh1cmwucGF0aG5hbWUgPT09IG1hbmlmZXN0VXJsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgcmVzID0gYXdhaXQgaGFuZGxlTWFuaWZlc3RSZXF1ZXN0KF9idWlsZCwgcm91dGVzLCB1cmwpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShcIlVua25vd24gU2VydmVyIEVycm9yXCIsIHsgc3RhdHVzOiA1MDAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hTZXJ2ZXJSb3V0ZXMocm91dGVzLCBub3JtYWxpemVkUGF0aCwgX2J1aWxkLmJhc2VuYW1lKTtcbiAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ocGFyYW1zLCBtYXRjaGVzWzBdLnBhcmFtcyk7XG4gICAgfVxuICAgIGxldCByZXNwb25zZTtcbiAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLmRhdGFcIikpIHtcbiAgICAgIGxldCBoYW5kbGVyVXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICBoYW5kbGVyVXJsLnBhdGhuYW1lID0gbm9ybWFsaXplZFBhdGg7XG4gICAgICBsZXQgc2luZ2xlRmV0Y2hNYXRjaGVzID0gbWF0Y2hTZXJ2ZXJSb3V0ZXMoXG4gICAgICAgIHJvdXRlcyxcbiAgICAgICAgaGFuZGxlclVybC5wYXRobmFtZSxcbiAgICAgICAgX2J1aWxkLmJhc2VuYW1lXG4gICAgICApO1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVTaW5nbGVGZXRjaFJlcXVlc3QoXG4gICAgICAgIHNlcnZlck1vZGUsXG4gICAgICAgIF9idWlsZCxcbiAgICAgICAgc3RhdGljSGFuZGxlcixcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgaGFuZGxlclVybCxcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIGhhbmRsZUVycm9yXG4gICAgICApO1xuICAgICAgaWYgKF9idWlsZC5lbnRyeS5tb2R1bGUuaGFuZGxlRGF0YVJlcXVlc3QpIHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBfYnVpbGQuZW50cnkubW9kdWxlLmhhbmRsZURhdGFSZXF1ZXN0KHJlc3BvbnNlLCB7XG4gICAgICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICAgICAgcGFyYW1zOiBzaW5nbGVGZXRjaE1hdGNoZXMgPyBzaW5nbGVGZXRjaE1hdGNoZXNbMF0ucGFyYW1zIDoge30sXG4gICAgICAgICAgcmVxdWVzdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZ2V0U2luZ2xlRmV0Y2hSZWRpcmVjdChcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICBfYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICBbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF06IHJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQveC1zY3JpcHRcIik7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgICAgICAgIGVuY29kZVZpYVR1cmJvU3RyZWFtKFxuICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICAgICAgICBfYnVpbGQuZW50cnkubW9kdWxlLnN0cmVhbVRpbWVvdXQsXG4gICAgICAgICAgICAgIHNlcnZlck1vZGVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVUyxcbiAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1NwYU1vZGUgJiYgbWF0Y2hlcyAmJiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUubW9kdWxlLmRlZmF1bHQgPT0gbnVsbCAmJiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUubW9kdWxlLkVycm9yQm91bmRhcnkgPT0gbnVsbCkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVSZXNvdXJjZVJlcXVlc3QoXG4gICAgICAgIHNlcnZlck1vZGUsXG4gICAgICAgIF9idWlsZCxcbiAgICAgICAgc3RhdGljSGFuZGxlcixcbiAgICAgICAgbWF0Y2hlcy5zbGljZSgtMSlbMF0ucm91dGUuaWQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBoYW5kbGVFcnJvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHsgcGF0aG5hbWUgfSA9IHVybDtcbiAgICAgIGxldCBjcml0aWNhbENzcyA9IHZvaWQgMDtcbiAgICAgIGlmIChfYnVpbGQudW5zdGFibGVfZ2V0Q3JpdGljYWxDc3MpIHtcbiAgICAgICAgY3JpdGljYWxDc3MgPSBhd2FpdCBfYnVpbGQudW5zdGFibGVfZ2V0Q3JpdGljYWxDc3MoeyBwYXRobmFtZSB9KTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJkZXZlbG9wbWVudFwiIC8qIERldmVsb3BtZW50ICovICYmIGdldERldlNlcnZlckhvb2tzKCk/LmdldENyaXRpY2FsQ3NzKSB7XG4gICAgICAgIGNyaXRpY2FsQ3NzID0gYXdhaXQgZ2V0RGV2U2VydmVySG9va3MoKT8uZ2V0Q3JpdGljYWxDc3M/LihwYXRobmFtZSk7XG4gICAgICB9XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZURvY3VtZW50UmVxdWVzdChcbiAgICAgICAgc2VydmVyTW9kZSxcbiAgICAgICAgX2J1aWxkLFxuICAgICAgICBzdGF0aWNIYW5kbGVyLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgaGFuZGxlRXJyb3IsXG4gICAgICAgIGlzU3BhTW9kZSxcbiAgICAgICAgY3JpdGljYWxDc3NcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gXCJIRUFEXCIpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfTtcbn07XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVNYW5pZmVzdFJlcXVlc3QoYnVpbGQsIHJvdXRlcywgdXJsKSB7XG4gIGlmIChidWlsZC5hc3NldHMudmVyc2lvbiAhPT0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ2ZXJzaW9uXCIpKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICBzdGF0dXM6IDIwNCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiOiBcInRydWVcIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxldCBwYXRjaGVzID0ge307XG4gIGlmICh1cmwuc2VhcmNoUGFyYW1zLmhhcyhcInBcIikpIHtcbiAgICBsZXQgcGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKFwicFwiKS5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICBpZiAoIXBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgcGF0aCA9IGAvJHtwYXRofWA7XG4gICAgICB9XG4gICAgICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKS5zbGljZSgxKTtcbiAgICAgIHNlZ21lbnRzLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgICAgbGV0IHBhcnRpYWxQYXRoID0gc2VnbWVudHMuc2xpY2UoMCwgaSArIDEpLmpvaW4oXCIvXCIpO1xuICAgICAgICBwYXRocy5hZGQoYC8ke3BhcnRpYWxQYXRofWApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZm9yIChsZXQgcGF0aCBvZiBwYXRocykge1xuICAgICAgbGV0IG1hdGNoZXMgPSBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHBhdGgsIGJ1aWxkLmJhc2VuYW1lKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICBsZXQgcm91dGVJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgICAgICAgIGxldCByb3V0ZSA9IGJ1aWxkLmFzc2V0cy5yb3V0ZXNbcm91dGVJZF07XG4gICAgICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgICAgICBwYXRjaGVzW3JvdXRlSWRdID0gcm91dGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZXNwb25zZS5qc29uKHBhdGNoZXMsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDYWNoZS1Db250cm9sXCI6IFwicHVibGljLCBtYXgtYWdlPTMxNTM2MDAwLCBpbW11dGFibGVcIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgUmVzcG9uc2UoXCJJbnZhbGlkIFJlcXVlc3RcIiwgeyBzdGF0dXM6IDQwMCB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVNpbmdsZUZldGNoUmVxdWVzdChzZXJ2ZXJNb2RlLCBidWlsZCwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgaGFuZGxlclVybCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIGxldCByZXNwb25zZSA9IHJlcXVlc3QubWV0aG9kICE9PSBcIkdFVFwiID8gYXdhaXQgc2luZ2xlRmV0Y2hBY3Rpb24oXG4gICAgYnVpbGQsXG4gICAgc2VydmVyTW9kZSxcbiAgICBzdGF0aWNIYW5kbGVyLFxuICAgIHJlcXVlc3QsXG4gICAgaGFuZGxlclVybCxcbiAgICBsb2FkQ29udGV4dCxcbiAgICBoYW5kbGVFcnJvclxuICApIDogYXdhaXQgc2luZ2xlRmV0Y2hMb2FkZXJzKFxuICAgIGJ1aWxkLFxuICAgIHNlcnZlck1vZGUsXG4gICAgc3RhdGljSGFuZGxlcixcbiAgICByZXF1ZXN0LFxuICAgIGhhbmRsZXJVcmwsXG4gICAgbG9hZENvbnRleHQsXG4gICAgaGFuZGxlRXJyb3JcbiAgKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlRG9jdW1lbnRSZXF1ZXN0KHNlcnZlck1vZGUsIGJ1aWxkLCBzdGF0aWNIYW5kbGVyLCByZXF1ZXN0LCBsb2FkQ29udGV4dCwgaGFuZGxlRXJyb3IsIGlzU3BhTW9kZSwgY3JpdGljYWxDc3MpIHtcbiAgdHJ5IHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBzdGF0aWNIYW5kbGVyLnF1ZXJ5KHJlcXVlc3QsIHtcbiAgICAgIHJlcXVlc3RDb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgIHVuc3RhYmxlX3Jlc3BvbmQ6IGJ1aWxkLmZ1dHVyZS51bnN0YWJsZV9taWRkbGV3YXJlID8gKGN0eCkgPT4gcmVuZGVySHRtbChjdHgsIGlzU3BhTW9kZSkgOiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gaXNSZXNwb25zZShyZXNwb25zZSkgPyByZXNwb25zZSA6IHJlbmRlckh0bWwocmVzcG9uc2UsIGlzU3BhTW9kZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZW5kZXJIdG1sKGNvbnRleHQsIGlzU3BhTW9kZTIpIHtcbiAgICBpZiAoaXNSZXNwb25zZShjb250ZXh0KSkge1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGxldCBoZWFkZXJzID0gZ2V0RG9jdW1lbnRIZWFkZXJzKGJ1aWxkLCBjb250ZXh0KTtcbiAgICBpZiAoU0VSVkVSX05PX0JPRFlfU1RBVFVTX0NPREVTLmhhcyhjb250ZXh0LnN0YXR1c0NvZGUpKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgc3RhdHVzOiBjb250ZXh0LnN0YXR1c0NvZGUsIGhlYWRlcnMgfSk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmVycm9ycykge1xuICAgICAgT2JqZWN0LnZhbHVlcyhjb250ZXh0LmVycm9ycykuZm9yRWFjaCgoZXJyKSA9PiB7XG4gICAgICAgIGlmICghaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyKSB8fCBlcnIuZXJyb3IpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnRleHQuZXJyb3JzID0gc2FuaXRpemVFcnJvcnMoY29udGV4dC5lcnJvcnMsIHNlcnZlck1vZGUpO1xuICAgIH1cbiAgICBsZXQgc3RhdGUgPSB7XG4gICAgICBsb2FkZXJEYXRhOiBjb250ZXh0LmxvYWRlckRhdGEsXG4gICAgICBhY3Rpb25EYXRhOiBjb250ZXh0LmFjdGlvbkRhdGEsXG4gICAgICBlcnJvcnM6IHNlcmlhbGl6ZUVycm9yczIoY29udGV4dC5lcnJvcnMsIHNlcnZlck1vZGUpXG4gICAgfTtcbiAgICBsZXQgYmFzZVNlcnZlckhhbmRvZmYgPSB7XG4gICAgICBiYXNlbmFtZTogYnVpbGQuYmFzZW5hbWUsXG4gICAgICBmdXR1cmU6IGJ1aWxkLmZ1dHVyZSxcbiAgICAgIHJvdXRlRGlzY292ZXJ5OiBidWlsZC5yb3V0ZURpc2NvdmVyeSxcbiAgICAgIHNzcjogYnVpbGQuc3NyLFxuICAgICAgaXNTcGFNb2RlOiBpc1NwYU1vZGUyXG4gICAgfTtcbiAgICBsZXQgZW50cnlDb250ZXh0ID0ge1xuICAgICAgbWFuaWZlc3Q6IGJ1aWxkLmFzc2V0cyxcbiAgICAgIHJvdXRlTW9kdWxlczogY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMoYnVpbGQucm91dGVzKSxcbiAgICAgIHN0YXRpY0hhbmRsZXJDb250ZXh0OiBjb250ZXh0LFxuICAgICAgY3JpdGljYWxDc3MsXG4gICAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nOiBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKHtcbiAgICAgICAgLi4uYmFzZVNlcnZlckhhbmRvZmYsXG4gICAgICAgIGNyaXRpY2FsQ3NzXG4gICAgICB9KSxcbiAgICAgIHNlcnZlckhhbmRvZmZTdHJlYW06IGVuY29kZVZpYVR1cmJvU3RyZWFtKFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICAgIGJ1aWxkLmVudHJ5Lm1vZHVsZS5zdHJlYW1UaW1lb3V0LFxuICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICApLFxuICAgICAgcmVuZGVyTWV0YToge30sXG4gICAgICBmdXR1cmU6IGJ1aWxkLmZ1dHVyZSxcbiAgICAgIHNzcjogYnVpbGQuc3NyLFxuICAgICAgcm91dGVEaXNjb3Zlcnk6IGJ1aWxkLnJvdXRlRGlzY292ZXJ5LFxuICAgICAgaXNTcGFNb2RlOiBpc1NwYU1vZGUyLFxuICAgICAgc2VyaWFsaXplRXJyb3I6IChlcnIpID0+IHNlcmlhbGl6ZUVycm9yKGVyciwgc2VydmVyTW9kZSlcbiAgICB9O1xuICAgIGxldCBoYW5kbGVEb2N1bWVudFJlcXVlc3RGdW5jdGlvbiA9IGJ1aWxkLmVudHJ5Lm1vZHVsZS5kZWZhdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNvbnRleHQuc3RhdHVzQ29kZSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgZW50cnlDb250ZXh0LFxuICAgICAgICBsb2FkQ29udGV4dFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgbGV0IGVycm9yRm9yU2Vjb25kUmVuZGVyID0gZXJyb3I7XG4gICAgICBpZiAoaXNSZXNwb25zZShlcnJvcikpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgZGF0YTIgPSBhd2FpdCB1bndyYXBSZXNwb25zZShlcnJvcik7XG4gICAgICAgICAgZXJyb3JGb3JTZWNvbmRSZW5kZXIgPSBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgICAgICBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgICBlcnJvci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgZGF0YTJcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnRleHQgPSBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yKFxuICAgICAgICBzdGF0aWNIYW5kbGVyLmRhdGFSb3V0ZXMsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGVycm9yRm9yU2Vjb25kUmVuZGVyXG4gICAgICApO1xuICAgICAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgICAgIGNvbnRleHQuZXJyb3JzID0gc2FuaXRpemVFcnJvcnMoY29udGV4dC5lcnJvcnMsIHNlcnZlck1vZGUpO1xuICAgICAgfVxuICAgICAgbGV0IHN0YXRlMiA9IHtcbiAgICAgICAgbG9hZGVyRGF0YTogY29udGV4dC5sb2FkZXJEYXRhLFxuICAgICAgICBhY3Rpb25EYXRhOiBjb250ZXh0LmFjdGlvbkRhdGEsXG4gICAgICAgIGVycm9yczogc2VyaWFsaXplRXJyb3JzMihjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSlcbiAgICAgIH07XG4gICAgICBlbnRyeUNvbnRleHQgPSB7XG4gICAgICAgIC4uLmVudHJ5Q29udGV4dCxcbiAgICAgICAgc3RhdGljSGFuZGxlckNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHNlcnZlckhhbmRvZmZTdHJpbmc6IGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcoYmFzZVNlcnZlckhhbmRvZmYpLFxuICAgICAgICBzZXJ2ZXJIYW5kb2ZmU3RyZWFtOiBlbmNvZGVWaWFUdXJib1N0cmVhbShcbiAgICAgICAgICBzdGF0ZTIsXG4gICAgICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICAgICAgYnVpbGQuZW50cnkubW9kdWxlLnN0cmVhbVRpbWVvdXQsXG4gICAgICAgICAgc2VydmVyTW9kZVxuICAgICAgICApLFxuICAgICAgICByZW5kZXJNZXRhOiB7fVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVEb2N1bWVudFJlcXVlc3RGdW5jdGlvbihcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGNvbnRleHQuc3RhdHVzQ29kZSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGVudHJ5Q29udGV4dCxcbiAgICAgICAgICBsb2FkQ29udGV4dFxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVycm9yMik7XG4gICAgICAgIHJldHVybiByZXR1cm5MYXN0UmVzb3J0RXJyb3JSZXNwb25zZShlcnJvcjIsIHNlcnZlck1vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVzb3VyY2VSZXF1ZXN0KHNlcnZlck1vZGUsIGJ1aWxkLCBzdGF0aWNIYW5kbGVyLCByb3V0ZUlkLCByZXF1ZXN0LCBsb2FkQ29udGV4dCwgaGFuZGxlRXJyb3IpIHtcbiAgdHJ5IHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBzdGF0aWNIYW5kbGVyLnF1ZXJ5Um91dGUocmVxdWVzdCwge1xuICAgICAgcm91dGVJZCxcbiAgICAgIHJlcXVlc3RDb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgIHVuc3RhYmxlX3Jlc3BvbmQ6IGJ1aWxkLmZ1dHVyZS51bnN0YWJsZV9taWRkbGV3YXJlID8gKGN0eCkgPT4gY3R4IDogdm9pZCAwXG4gICAgfSk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gUmVzcG9uc2UuanNvbihyZXNwb25zZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICBlcnJvci5oZWFkZXJzLnNldChcIlgtUmVtaXgtQ2F0Y2hcIiwgXCJ5ZXNcIik7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGlmIChpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3JSZXNwb25zZVRvSnNvbihlcnJvciwgc2VydmVyTW9kZSk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UgPT09IFwiRXhwZWN0ZWQgYSByZXNwb25zZSBmcm9tIHF1ZXJ5Um91dGVcIikge1xuICAgICAgbGV0IG5ld0Vycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgUmVzcG9uc2UgdG8gYmUgcmV0dXJuZWQgZnJvbSByZXNvdXJjZSByb3V0ZSBoYW5kbGVyXCJcbiAgICAgICk7XG4gICAgICBoYW5kbGVFcnJvcihuZXdFcnJvcik7XG4gICAgICByZXR1cm4gcmV0dXJuTGFzdFJlc29ydEVycm9yUmVzcG9uc2UobmV3RXJyb3IsIHNlcnZlck1vZGUpO1xuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIHJldHVybkxhc3RSZXNvcnRFcnJvclJlc3BvbnNlKGVycm9yLCBzZXJ2ZXJNb2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JSZXNwb25zZVRvSnNvbihlcnJvclJlc3BvbnNlLCBzZXJ2ZXJNb2RlKSB7XG4gIHJldHVybiBSZXNwb25zZS5qc29uKFxuICAgIHNlcmlhbGl6ZUVycm9yKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUaGlzIGlzIFwicHJpdmF0ZVwiIGZyb20gdXNlcnMgYnV0IGludGVuZGVkIGZvciBpbnRlcm5hbCB1c2VcbiAgICAgIGVycm9yUmVzcG9uc2UuZXJyb3IgfHwgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBTZXJ2ZXIgRXJyb3JcIiksXG4gICAgICBzZXJ2ZXJNb2RlXG4gICAgKSxcbiAgICB7XG4gICAgICBzdGF0dXM6IGVycm9yUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogZXJyb3JSZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIlgtUmVtaXgtRXJyb3JcIjogXCJ5ZXNcIlxuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHJldHVybkxhc3RSZXNvcnRFcnJvclJlc3BvbnNlKGVycm9yLCBzZXJ2ZXJNb2RlKSB7XG4gIGxldCBtZXNzYWdlID0gXCJVbmV4cGVjdGVkIFNlcnZlciBFcnJvclwiO1xuICBpZiAoc2VydmVyTW9kZSAhPT0gXCJwcm9kdWN0aW9uXCIgLyogUHJvZHVjdGlvbiAqLykge1xuICAgIG1lc3NhZ2UgKz0gYFxuXG4ke1N0cmluZyhlcnJvcil9YDtcbiAgfVxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG1lc3NhZ2UsIHtcbiAgICBzdGF0dXM6IDUwMCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW5cIlxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB1bndyYXBSZXNwb25zZShyZXNwb25zZSkge1xuICBsZXQgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgcmV0dXJuIGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpID8gcmVzcG9uc2UuYm9keSA9PSBudWxsID8gbnVsbCA6IHJlc3BvbnNlLmpzb24oKSA6IHJlc3BvbnNlLnRleHQoKTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3Nlc3Npb25zLnRzXG5mdW5jdGlvbiBmbGFzaChuYW1lKSB7XG4gIHJldHVybiBgX19mbGFzaF8ke25hbWV9X19gO1xufVxudmFyIGNyZWF0ZVNlc3Npb24gPSAoaW5pdGlhbERhdGEgPSB7fSwgaWQgPSBcIlwiKSA9PiB7XG4gIGxldCBtYXAgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGluaXRpYWxEYXRhKSk7XG4gIHJldHVybiB7XG4gICAgZ2V0IGlkKCkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKG1hcCk7XG4gICAgfSxcbiAgICBoYXMobmFtZSkge1xuICAgICAgcmV0dXJuIG1hcC5oYXMobmFtZSkgfHwgbWFwLmhhcyhmbGFzaChuYW1lKSk7XG4gICAgfSxcbiAgICBnZXQobmFtZSkge1xuICAgICAgaWYgKG1hcC5oYXMobmFtZSkpIHJldHVybiBtYXAuZ2V0KG5hbWUpO1xuICAgICAgbGV0IGZsYXNoTmFtZSA9IGZsYXNoKG5hbWUpO1xuICAgICAgaWYgKG1hcC5oYXMoZmxhc2hOYW1lKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBtYXAuZ2V0KGZsYXNoTmFtZSk7XG4gICAgICAgIG1hcC5kZWxldGUoZmxhc2hOYW1lKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9LFxuICAgIHNldChuYW1lLCB2YWx1ZSkge1xuICAgICAgbWFwLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBmbGFzaChuYW1lLCB2YWx1ZSkge1xuICAgICAgbWFwLnNldChmbGFzaChuYW1lKSwgdmFsdWUpO1xuICAgIH0sXG4gICAgdW5zZXQobmFtZSkge1xuICAgICAgbWFwLmRlbGV0ZShuYW1lKTtcbiAgICB9XG4gIH07XG59O1xudmFyIGlzU2Vzc2lvbiA9IChvYmplY3QpID0+IHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QuaWQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iamVjdC5kYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBvYmplY3QuaGFzID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC5nZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LnNldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmplY3QuZmxhc2ggPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LnVuc2V0ID09PSBcImZ1bmN0aW9uXCI7XG59O1xuZnVuY3Rpb24gY3JlYXRlU2Vzc2lvblN0b3JhZ2Uoe1xuICBjb29raWU6IGNvb2tpZUFyZyxcbiAgY3JlYXRlRGF0YSxcbiAgcmVhZERhdGEsXG4gIHVwZGF0ZURhdGEsXG4gIGRlbGV0ZURhdGFcbn0pIHtcbiAgbGV0IGNvb2tpZSA9IGlzQ29va2llKGNvb2tpZUFyZykgPyBjb29raWVBcmcgOiBjcmVhdGVDb29raWUoY29va2llQXJnPy5uYW1lIHx8IFwiX19zZXNzaW9uXCIsIGNvb2tpZUFyZyk7XG4gIHdhcm5PbmNlQWJvdXRTaWduaW5nU2Vzc2lvbkNvb2tpZShjb29raWUpO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIGdldFNlc3Npb24oY29va2llSGVhZGVyLCBvcHRpb25zKSB7XG4gICAgICBsZXQgaWQgPSBjb29raWVIZWFkZXIgJiYgYXdhaXQgY29va2llLnBhcnNlKGNvb2tpZUhlYWRlciwgb3B0aW9ucyk7XG4gICAgICBsZXQgZGF0YTIgPSBpZCAmJiBhd2FpdCByZWFkRGF0YShpZCk7XG4gICAgICByZXR1cm4gY3JlYXRlU2Vzc2lvbihkYXRhMiB8fCB7fSwgaWQgfHwgXCJcIik7XG4gICAgfSxcbiAgICBhc3luYyBjb21taXRTZXNzaW9uKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgIGxldCB7IGlkLCBkYXRhOiBkYXRhMiB9ID0gc2Vzc2lvbjtcbiAgICAgIGxldCBleHBpcmVzID0gb3B0aW9ucz8ubWF4QWdlICE9IG51bGwgPyBuZXcgRGF0ZShEYXRlLm5vdygpICsgb3B0aW9ucy5tYXhBZ2UgKiAxZTMpIDogb3B0aW9ucz8uZXhwaXJlcyAhPSBudWxsID8gb3B0aW9ucy5leHBpcmVzIDogY29va2llLmV4cGlyZXM7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgYXdhaXQgdXBkYXRlRGF0YShpZCwgZGF0YTIsIGV4cGlyZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWQgPSBhd2FpdCBjcmVhdGVEYXRhKGRhdGEyLCBleHBpcmVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb29raWUuc2VyaWFsaXplKGlkLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGFzeW5jIGRlc3Ryb3lTZXNzaW9uKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgIGF3YWl0IGRlbGV0ZURhdGEoc2Vzc2lvbi5pZCk7XG4gICAgICByZXR1cm4gY29va2llLnNlcmlhbGl6ZShcIlwiLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIG1heEFnZTogdm9pZCAwLFxuICAgICAgICBleHBpcmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMClcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHdhcm5PbmNlQWJvdXRTaWduaW5nU2Vzc2lvbkNvb2tpZShjb29raWUpIHtcbiAgd2Fybk9uY2UoXG4gICAgY29va2llLmlzU2lnbmVkLFxuICAgIGBUaGUgXCIke2Nvb2tpZS5uYW1lfVwiIGNvb2tpZSBpcyBub3Qgc2lnbmVkLCBidXQgc2Vzc2lvbiBjb29raWVzIHNob3VsZCBiZSBzaWduZWQgdG8gcHJldmVudCB0YW1wZXJpbmcgb24gdGhlIGNsaWVudCBiZWZvcmUgdGhleSBhcmUgc2VudCBiYWNrIHRvIHRoZSBzZXJ2ZXIuIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9leHBsYW5hdGlvbi9zZXNzaW9ucy1hbmQtY29va2llcyNzaWduaW5nLWNvb2tpZXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICApO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2Vzc2lvbnMvY29va2llU3RvcmFnZS50c1xuZnVuY3Rpb24gY3JlYXRlQ29va2llU2Vzc2lvblN0b3JhZ2UoeyBjb29raWU6IGNvb2tpZUFyZyB9ID0ge30pIHtcbiAgbGV0IGNvb2tpZSA9IGlzQ29va2llKGNvb2tpZUFyZykgPyBjb29raWVBcmcgOiBjcmVhdGVDb29raWUoY29va2llQXJnPy5uYW1lIHx8IFwiX19zZXNzaW9uXCIsIGNvb2tpZUFyZyk7XG4gIHdhcm5PbmNlQWJvdXRTaWduaW5nU2Vzc2lvbkNvb2tpZShjb29raWUpO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIGdldFNlc3Npb24oY29va2llSGVhZGVyLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU2Vzc2lvbihcbiAgICAgICAgY29va2llSGVhZGVyICYmIGF3YWl0IGNvb2tpZS5wYXJzZShjb29raWVIZWFkZXIsIG9wdGlvbnMpIHx8IHt9XG4gICAgICApO1xuICAgIH0sXG4gICAgYXN5bmMgY29tbWl0U2Vzc2lvbihzZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgICBsZXQgc2VyaWFsaXplZENvb2tpZSA9IGF3YWl0IGNvb2tpZS5zZXJpYWxpemUoc2Vzc2lvbi5kYXRhLCBvcHRpb25zKTtcbiAgICAgIGlmIChzZXJpYWxpemVkQ29va2llLmxlbmd0aCA+IDQwOTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ29va2llIGxlbmd0aCB3aWxsIGV4Y2VlZCBicm93c2VyIG1heGltdW0uIExlbmd0aDogXCIgKyBzZXJpYWxpemVkQ29va2llLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRDb29raWU7XG4gICAgfSxcbiAgICBhc3luYyBkZXN0cm95U2Vzc2lvbihfc2Vzc2lvbiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNvb2tpZS5zZXJpYWxpemUoXCJcIiwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBtYXhBZ2U6IHZvaWQgMCxcbiAgICAgICAgZXhwaXJlczogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zZXNzaW9ucy9tZW1vcnlTdG9yYWdlLnRzXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZSh7IGNvb2tpZSB9ID0ge30pIHtcbiAgbGV0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiBjcmVhdGVTZXNzaW9uU3RvcmFnZSh7XG4gICAgY29va2llLFxuICAgIGFzeW5jIGNyZWF0ZURhdGEoZGF0YTIsIGV4cGlyZXMpIHtcbiAgICAgIGxldCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCk7XG4gICAgICBtYXAuc2V0KGlkLCB7IGRhdGE6IGRhdGEyLCBleHBpcmVzIH0pO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gICAgYXN5bmMgcmVhZERhdGEoaWQpIHtcbiAgICAgIGlmIChtYXAuaGFzKGlkKSkge1xuICAgICAgICBsZXQgeyBkYXRhOiBkYXRhMiwgZXhwaXJlcyB9ID0gbWFwLmdldChpZCk7XG4gICAgICAgIGlmICghZXhwaXJlcyB8fCBleHBpcmVzID4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGlyZXMpIG1hcC5kZWxldGUoaWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBhc3luYyB1cGRhdGVEYXRhKGlkLCBkYXRhMiwgZXhwaXJlcykge1xuICAgICAgbWFwLnNldChpZCwgeyBkYXRhOiBkYXRhMiwgZXhwaXJlcyB9KTtcbiAgICB9LFxuICAgIGFzeW5jIGRlbGV0ZURhdGEoaWQpIHtcbiAgICAgIG1hcC5kZWxldGUoaWQpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGxpYi9ocmVmLnRzXG5mdW5jdGlvbiBocmVmKHBhdGgsIC4uLmFyZ3MpIHtcbiAgbGV0IHBhcmFtcyA9IGFyZ3NbMF07XG4gIHJldHVybiBwYXRoLnNwbGl0KFwiL1wiKS5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICBpZiAoc2VnbWVudCA9PT0gXCIqXCIpIHtcbiAgICAgIHJldHVybiBwYXJhbXMgPyBwYXJhbXNbXCIqXCJdIDogdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IHNlZ21lbnQubWF0Y2goL146KFtcXHctXSspKFxcPyk/Lyk7XG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIHNlZ21lbnQ7XG4gICAgY29uc3QgcGFyYW0gPSBtYXRjaFsxXTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcmFtcyA/IHBhcmFtc1twYXJhbV0gOiB2b2lkIDA7XG4gICAgY29uc3QgaXNSZXF1aXJlZCA9IG1hdGNoWzJdID09PSB2b2lkIDA7XG4gICAgaWYgKGlzUmVxdWlyZWQgJiYgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBQYXRoICcke3BhdGh9JyByZXF1aXJlcyBwYXJhbSAnJHtwYXJhbX0nIGJ1dCBpdCB3YXMgbm90IHByb3ZpZGVkYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KS5maWx0ZXIoKHNlZ21lbnQpID0+IHNlZ21lbnQgIT09IHZvaWQgMCkuam9pbihcIi9cIik7XG59XG5cbi8vIGxpYi9kb20vc3NyL2Vycm9ycy50c1xuZnVuY3Rpb24gZGVzZXJpYWxpemVFcnJvcnMyKGVycm9ycykge1xuICBpZiAoIWVycm9ycykgcmV0dXJuIG51bGw7XG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzKTtcbiAgbGV0IHNlcmlhbGl6ZWQgPSB7fTtcbiAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIlJvdXRlRXJyb3JSZXNwb25zZVwiKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgIHZhbC5zdGF0dXMsXG4gICAgICAgIHZhbC5zdGF0dXNUZXh0LFxuICAgICAgICB2YWwuZGF0YSxcbiAgICAgICAgdmFsLmludGVybmFsID09PSB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiRXJyb3JcIikge1xuICAgICAgaWYgKHZhbC5fX3N1YlR5cGUpIHtcbiAgICAgICAgbGV0IEVycm9yQ29uc3RydWN0b3IgPSB3aW5kb3dbdmFsLl9fc3ViVHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3JDb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvckNvbnN0cnVjdG9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgICAgIGVycm9yLnN0YWNrID0gdmFsLnN0YWNrO1xuICAgICAgICAgICAgc2VyaWFsaXplZFtrZXldID0gZXJyb3I7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlcmlhbGl6ZWRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcih2YWwubWVzc2FnZSk7XG4gICAgICAgIGVycm9yLnN0YWNrID0gdmFsLnN0YWNrO1xuICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cblxuLy8gbGliL2RvbS9zc3IvaHlkcmF0aW9uLnRzeFxuZnVuY3Rpb24gZ2V0SHlkcmF0aW9uRGF0YShzdGF0ZSwgcm91dGVzLCBnZXRSb3V0ZUluZm8sIGxvY2F0aW9uLCBiYXNlbmFtZSwgaXNTcGFNb2RlKSB7XG4gIGxldCBoeWRyYXRpb25EYXRhID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxvYWRlckRhdGE6IHsgLi4uc3RhdGUubG9hZGVyRGF0YSB9XG4gIH07XG4gIGxldCBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb24sIGJhc2VuYW1lKTtcbiAgaWYgKGluaXRpYWxNYXRjaGVzKSB7XG4gICAgZm9yIChsZXQgbWF0Y2ggb2YgaW5pdGlhbE1hdGNoZXMpIHtcbiAgICAgIGxldCByb3V0ZUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgICBsZXQgcm91dGVJbmZvID0gZ2V0Um91dGVJbmZvKHJvdXRlSWQpO1xuICAgICAgaWYgKHNob3VsZEh5ZHJhdGVSb3V0ZUxvYWRlcihcbiAgICAgICAgcm91dGVJZCxcbiAgICAgICAgcm91dGVJbmZvLmNsaWVudExvYWRlcixcbiAgICAgICAgcm91dGVJbmZvLmhhc0xvYWRlcixcbiAgICAgICAgaXNTcGFNb2RlXG4gICAgICApICYmIChyb3V0ZUluZm8uaGFzSHlkcmF0ZUZhbGxiYWNrIHx8ICFyb3V0ZUluZm8uaGFzTG9hZGVyKSkge1xuICAgICAgICBkZWxldGUgaHlkcmF0aW9uRGF0YS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xuICAgICAgfSBlbHNlIGlmICghcm91dGVJbmZvLmhhc0xvYWRlcikge1xuICAgICAgICBoeWRyYXRpb25EYXRhLmxvYWRlckRhdGFbcm91dGVJZF0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaHlkcmF0aW9uRGF0YTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBBd2FpdCxcbiAgQnJvd3NlclJvdXRlcixcbiAgRm9ybSxcbiAgSGFzaFJvdXRlcixcbiAgSURMRV9CTE9DS0VSLFxuICBJRExFX0ZFVENIRVIsXG4gIElETEVfTkFWSUdBVElPTixcbiAgTGluayxcbiAgTGlua3MsXG4gIE1lbW9yeVJvdXRlcixcbiAgTWV0YSxcbiAgTmF2TGluayxcbiAgTmF2aWdhdGUsXG4gIE5hdmlnYXRpb25UeXBlLFxuICBPdXRsZXQsXG4gIFByZWZldGNoUGFnZUxpbmtzLFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXJQcm92aWRlcixcbiAgUm91dGVzLFxuICBTY3JpcHRzLFxuICBTY3JvbGxSZXN0b3JhdGlvbixcbiAgU2VydmVyUm91dGVyLFxuICBTdGF0aWNSb3V0ZXIsXG4gIFN0YXRpY1JvdXRlclByb3ZpZGVyLFxuICBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsXG4gIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwsXG4gIFVOU0FGRV9GZXRjaGVyc0NvbnRleHQsXG4gIFVOU0FGRV9GcmFtZXdvcmtDb250ZXh0LFxuICBVTlNBRkVfTG9jYXRpb25Db250ZXh0LFxuICBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9SZW1peEVycm9yQm91bmRhcnksXG4gIFVOU0FGRV9Sb3V0ZUNvbnRleHQsXG4gIFVOU0FGRV9TZXJ2ZXJNb2RlLFxuICBVTlNBRkVfU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbCxcbiAgVU5TQUZFX1ZpZXdUcmFuc2l0aW9uQ29udGV4dCxcbiAgVU5TQUZFX2NyZWF0ZUJyb3dzZXJIaXN0b3J5LFxuICBVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzLFxuICBVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dCxcbiAgVU5TQUZFX2NyZWF0ZVJvdXRlcixcbiAgVU5TQUZFX2RlY29kZVZpYVR1cmJvU3RyZWFtLFxuICBVTlNBRkVfZGVzZXJpYWxpemVFcnJvcnMsXG4gIFVOU0FGRV9nZXRIeWRyYXRpb25EYXRhLFxuICBVTlNBRkVfZ2V0UGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25GdW5jdGlvbixcbiAgVU5TQUZFX2dldFR1cmJvU3RyZWFtU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3ksXG4gIFVOU0FGRV9oeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMsXG4gIFVOU0FGRV9pbnZhcmlhbnQsXG4gIFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMsXG4gIFVOU0FGRV9zaG91bGRIeWRyYXRlUm91dGVMb2FkZXIsXG4gIFVOU0FGRV91c2VGb2dPRldhckRpc2NvdmVyeSxcbiAgVU5TQUZFX3VzZVNjcm9sbFJlc3RvcmF0aW9uLFxuICBjcmVhdGVCcm93c2VyUm91dGVyLFxuICBjcmVhdGVDb29raWUsXG4gIGNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlLFxuICBjcmVhdGVIYXNoUm91dGVyLFxuICBjcmVhdGVNZW1vcnlSb3V0ZXIsXG4gIGNyZWF0ZU1lbW9yeVNlc3Npb25TdG9yYWdlLFxuICBjcmVhdGVQYXRoLFxuICBjcmVhdGVSZXF1ZXN0SGFuZGxlcixcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLFxuICBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMsXG4gIGNyZWF0ZVJvdXRlc1N0dWIsXG4gIGNyZWF0ZVNlYXJjaFBhcmFtcyxcbiAgY3JlYXRlU2Vzc2lvbixcbiAgY3JlYXRlU2Vzc2lvblN0b3JhZ2UsXG4gIGNyZWF0ZVN0YXRpY0hhbmRsZXIsXG4gIGNyZWF0ZVN0YXRpY1JvdXRlcixcbiAgZGF0YSxcbiAgZ2VuZXJhdGVQYXRoLFxuICBocmVmLFxuICBpc0Nvb2tpZSxcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIGlzU2Vzc2lvbixcbiAgbWF0Y2hQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgcGFyc2VQYXRoLFxuICByZWRpcmVjdCxcbiAgcmVkaXJlY3REb2N1bWVudCxcbiAgcmVuZGVyTWF0Y2hlcyxcbiAgcmVwbGFjZSxcbiAgcmVzb2x2ZVBhdGgsXG4gIHVuc3RhYmxlX0hpc3RvcnlSb3V0ZXIsXG4gIHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlcixcbiAgdW5zdGFibGVfY3JlYXRlQ29udGV4dCxcbiAgdW5zdGFibGVfc2V0RGV2U2VydmVySG9va3MsXG4gIHVuc3RhYmxlX3VzZVByb21wdCxcbiAgdXNlQWN0aW9uRGF0YSxcbiAgdXNlQXN5bmNFcnJvcixcbiAgdXNlQXN5bmNWYWx1ZSxcbiAgdXNlQmVmb3JlVW5sb2FkLFxuICB1c2VCbG9ja2VyLFxuICB1c2VGZXRjaGVyLFxuICB1c2VGZXRjaGVycyxcbiAgdXNlRm9ybUFjdGlvbixcbiAgdXNlSHJlZixcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMaW5rQ2xpY2tIYW5kbGVyLFxuICB1c2VMb2FkZXJEYXRhLFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2gsXG4gIHVzZU1hdGNoZXMsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VOYXZpZ2F0aW9uLFxuICB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlT3V0bGV0LFxuICB1c2VPdXRsZXRDb250ZXh0LFxuICB1c2VQYXJhbXMsXG4gIHVzZVJlc29sdmVkUGF0aCxcbiAgdXNlUmV2YWxpZGF0b3IsXG4gIHVzZVJvdXRlRXJyb3IsXG4gIHVzZVJvdXRlTG9hZGVyRGF0YSxcbiAgdXNlUm91dGVzLFxuICB1c2VTZWFyY2hQYXJhbXMsXG4gIHVzZVN1Ym1pdCxcbiAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZVxufSk7XG4iXSwibmFtZXMiOlsiX19jcmVhdGUiLCJPYmplY3QiLCJjcmVhdGUiLCJfX2RlZlByb3AiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcERlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2dldE93blByb3BOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJfX2dldFByb3RvT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9faGFzT3duUHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiX190eXBlRXJyb3IiLCJtc2ciLCJUeXBlRXJyb3IiLCJfX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJnZXQiLCJlbnVtZXJhYmxlIiwiX19jb3B5UHJvcHMiLCJ0byIsImZyb20iLCJleGNlcHQiLCJkZXNjIiwia2V5IiwiY2FsbCIsIl9fdG9FU00iLCJtb2QiLCJpc05vZGVNb2RlIiwiX19lc01vZHVsZSIsInZhbHVlIiwiX190b0NvbW1vbkpTIiwiX19hY2Nlc3NDaGVjayIsIm9iaiIsIm1lbWJlciIsImhhcyIsIl9fcHJpdmF0ZUdldCIsImdldHRlciIsIl9fcHJpdmF0ZUFkZCIsIldlYWtTZXQiLCJhZGQiLCJzZXQiLCJyZWFjdF9yb3V0ZXJfZXhwb3J0cyIsIkF3YWl0IiwiQnJvd3NlclJvdXRlciIsIkZvcm0iLCJIYXNoUm91dGVyIiwiSURMRV9CTE9DS0VSIiwiSURMRV9GRVRDSEVSIiwiSURMRV9OQVZJR0FUSU9OIiwiTGluayIsIkxpbmtzIiwiTWVtb3J5Um91dGVyIiwiTWV0YSIsIk5hdkxpbmsiLCJOYXZpZ2F0ZSIsIk5hdmlnYXRpb25UeXBlIiwiQWN0aW9uIiwiT3V0bGV0IiwiUHJlZmV0Y2hQYWdlTGlua3MiLCJSb3V0ZSIsIlJvdXRlciIsIlJvdXRlclByb3ZpZGVyIiwiUm91dGVzIiwiU2NyaXB0cyIsIlNjcm9sbFJlc3RvcmF0aW9uIiwiU2VydmVyUm91dGVyIiwiU3RhdGljUm91dGVyIiwiU3RhdGljUm91dGVyUHJvdmlkZXIiLCJVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQiLCJEYXRhUm91dGVyQ29udGV4dCIsIlVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0IiwiRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsIlVOU0FGRV9FcnJvclJlc3BvbnNlSW1wbCIsIkVycm9yUmVzcG9uc2VJbXBsIiwiVU5TQUZFX0ZldGNoZXJzQ29udGV4dCIsIkZldGNoZXJzQ29udGV4dCIsIlVOU0FGRV9GcmFtZXdvcmtDb250ZXh0IiwiRnJhbWV3b3JrQ29udGV4dCIsIlVOU0FGRV9Mb2NhdGlvbkNvbnRleHQiLCJMb2NhdGlvbkNvbnRleHQiLCJVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQiLCJOYXZpZ2F0aW9uQ29udGV4dCIsIlVOU0FGRV9SZW1peEVycm9yQm91bmRhcnkiLCJSZW1peEVycm9yQm91bmRhcnkiLCJVTlNBRkVfUm91dGVDb250ZXh0IiwiUm91dGVDb250ZXh0IiwiVU5TQUZFX1NlcnZlck1vZGUiLCJTZXJ2ZXJNb2RlIiwiVU5TQUZFX1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wiLCJTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sIiwiVU5TQUZFX1ZpZXdUcmFuc2l0aW9uQ29udGV4dCIsIlZpZXdUcmFuc2l0aW9uQ29udGV4dCIsIlVOU0FGRV9jcmVhdGVCcm93c2VySGlzdG9yeSIsImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiVU5TQUZFX2NyZWF0ZUNsaWVudFJvdXRlcyIsImNyZWF0ZUNsaWVudFJvdXRlcyIsIlVOU0FGRV9jcmVhdGVDbGllbnRSb3V0ZXNXaXRoSE1SUmV2YWxpZGF0aW9uT3B0T3V0IiwiY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dCIsIlVOU0FGRV9jcmVhdGVSb3V0ZXIiLCJjcmVhdGVSb3V0ZXIiLCJVTlNBRkVfZGVjb2RlVmlhVHVyYm9TdHJlYW0iLCJkZWNvZGVWaWFUdXJib1N0cmVhbSIsIlVOU0FGRV9kZXNlcmlhbGl6ZUVycm9ycyIsImRlc2VyaWFsaXplRXJyb3JzMiIsIlVOU0FGRV9nZXRIeWRyYXRpb25EYXRhIiwiZ2V0SHlkcmF0aW9uRGF0YSIsIlVOU0FGRV9nZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uIiwiZ2V0UGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25GdW5jdGlvbiIsIlVOU0FGRV9nZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5IiwiZ2V0VHVyYm9TdHJlYW1TaW5nbGVGZXRjaERhdGFTdHJhdGVneSIsIlVOU0FGRV9oeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMiLCJoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMiLCJVTlNBRkVfaW52YXJpYW50IiwiaW52YXJpYW50IiwiVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyIsIm1hcFJvdXRlUHJvcGVydGllcyIsIlVOU0FGRV9zaG91bGRIeWRyYXRlUm91dGVMb2FkZXIiLCJzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIiLCJVTlNBRkVfdXNlRm9nT0ZXYXJEaXNjb3ZlcnkiLCJ1c2VGb2dPRldhckRpc2NvdmVyeSIsIlVOU0FGRV91c2VTY3JvbGxSZXN0b3JhdGlvbiIsInVzZVNjcm9sbFJlc3RvcmF0aW9uIiwiY3JlYXRlQnJvd3NlclJvdXRlciIsImNyZWF0ZUNvb2tpZSIsImNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlIiwiY3JlYXRlSGFzaFJvdXRlciIsImNyZWF0ZU1lbW9yeVJvdXRlciIsImNyZWF0ZU1lbW9yeVNlc3Npb25TdG9yYWdlIiwiY3JlYXRlUGF0aCIsImNyZWF0ZVJlcXVlc3RIYW5kbGVyIiwiY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIiwiY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzIiwiY3JlYXRlUm91dGVzU3R1YiIsImNyZWF0ZVNlYXJjaFBhcmFtcyIsImNyZWF0ZVNlc3Npb24iLCJjcmVhdGVTZXNzaW9uU3RvcmFnZSIsImNyZWF0ZVN0YXRpY0hhbmRsZXIiLCJjcmVhdGVTdGF0aWNIYW5kbGVyMiIsImNyZWF0ZVN0YXRpY1JvdXRlciIsImRhdGEiLCJnZW5lcmF0ZVBhdGgiLCJocmVmIiwiaXNDb29raWUiLCJpc1JvdXRlRXJyb3JSZXNwb25zZSIsImlzU2Vzc2lvbiIsIm1hdGNoUGF0aCIsIm1hdGNoUm91dGVzIiwicGFyc2VQYXRoIiwicmVkaXJlY3QiLCJyZWRpcmVjdERvY3VtZW50IiwicmVuZGVyTWF0Y2hlcyIsInJlcGxhY2UiLCJyZXNvbHZlUGF0aCIsInVuc3RhYmxlX0hpc3RvcnlSb3V0ZXIiLCJIaXN0b3J5Um91dGVyIiwidW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyIiwidW5zdGFibGVfY3JlYXRlQ29udGV4dCIsInVuc3RhYmxlX3NldERldlNlcnZlckhvb2tzIiwic2V0RGV2U2VydmVySG9va3MiLCJ1bnN0YWJsZV91c2VQcm9tcHQiLCJ1c2VQcm9tcHQiLCJ1c2VBY3Rpb25EYXRhIiwidXNlQXN5bmNFcnJvciIsInVzZUFzeW5jVmFsdWUiLCJ1c2VCZWZvcmVVbmxvYWQiLCJ1c2VCbG9ja2VyIiwidXNlRmV0Y2hlciIsInVzZUZldGNoZXJzIiwidXNlRm9ybUFjdGlvbiIsInVzZUhyZWYiLCJ1c2VJblJvdXRlckNvbnRleHQiLCJ1c2VMaW5rQ2xpY2tIYW5kbGVyIiwidXNlTG9hZGVyRGF0YSIsInVzZUxvY2F0aW9uIiwidXNlTWF0Y2giLCJ1c2VNYXRjaGVzIiwidXNlTmF2aWdhdGUiLCJ1c2VOYXZpZ2F0aW9uIiwidXNlTmF2aWdhdGlvblR5cGUiLCJ1c2VPdXRsZXQiLCJ1c2VPdXRsZXRDb250ZXh0IiwidXNlUGFyYW1zIiwidXNlUmVzb2x2ZWRQYXRoIiwidXNlUmV2YWxpZGF0b3IiLCJ1c2VSb3V0ZUVycm9yIiwidXNlUm91dGVMb2FkZXJEYXRhIiwidXNlUm91dGVzIiwidXNlU2VhcmNoUGFyYW1zIiwidXNlU3VibWl0IiwidXNlVmlld1RyYW5zaXRpb25TdGF0ZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJBY3Rpb24yIiwiUG9wU3RhdGVFdmVudFR5cGUiLCJjcmVhdGVNZW1vcnlIaXN0b3J5Iiwib3B0aW9ucyIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwidjVDb21wYXQiLCJlbnRyaWVzIiwibWFwIiwiZW50cnkiLCJpbmRleDIiLCJjcmVhdGVNZW1vcnlMb2NhdGlvbiIsInN0YXRlIiwiaW5kZXgiLCJjbGFtcEluZGV4IiwibGVuZ3RoIiwiYWN0aW9uIiwibGlzdGVuZXIiLCJuIiwiTWF0aCIsIm1pbiIsIm1heCIsImdldEN1cnJlbnRMb2NhdGlvbiIsImxvY2F0aW9uIiwiY3JlYXRlTG9jYXRpb24iLCJwYXRobmFtZSIsIndhcm5pbmciLCJjaGFyQXQiLCJKU09OIiwic3RyaW5naWZ5IiwiY3JlYXRlSHJlZjIiLCJoaXN0b3J5IiwiY3JlYXRlSHJlZiIsImNyZWF0ZVVSTCIsIlVSTCIsImVuY29kZUxvY2F0aW9uIiwicGF0aCIsInNlYXJjaCIsImhhc2giLCJwdXNoIiwibmV4dExvY2F0aW9uIiwic3BsaWNlIiwiZGVsdGEiLCJnbyIsIm5leHRJbmRleCIsImxpc3RlbiIsImZuIiwiY3JlYXRlQnJvd3NlckxvY2F0aW9uIiwid2luZG93MiIsImdsb2JhbEhpc3RvcnkiLCJ1c3IiLCJjcmVhdGVCcm93c2VySHJlZiIsImdldFVybEJhc2VkSGlzdG9yeSIsImNyZWF0ZUhhc2hIaXN0b3J5IiwiY3JlYXRlSGFzaExvY2F0aW9uIiwic3Vic3RyaW5nIiwic3RhcnRzV2l0aCIsImNyZWF0ZUhhc2hIcmVmIiwiYmFzZSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImhyZWYyIiwiZ2V0QXR0cmlidXRlIiwidXJsIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwidmFsaWRhdGVIYXNoTG9jYXRpb24iLCJtZXNzYWdlIiwiRXJyb3IiLCJjb25kIiwiY29uc29sZSIsIndhcm4iLCJlIiwiY3JlYXRlS2V5IiwicmFuZG9tIiwidG9TdHJpbmciLCJnZXRIaXN0b3J5U3RhdGUiLCJpZHgiLCJjdXJyZW50IiwicGFyc2VkUGF0aCIsInNlYXJjaEluZGV4IiwiZ2V0TG9jYXRpb24iLCJ2YWxpZGF0ZUxvY2F0aW9uIiwid2luZG93IiwiZGVmYXVsdFZpZXciLCJnZXRJbmRleCIsInJlcGxhY2VTdGF0ZSIsImhhbmRsZVBvcCIsImhpc3RvcnlTdGF0ZSIsInB1c2hTdGF0ZSIsImVycm9yIiwiRE9NRXhjZXB0aW9uIiwiYXNzaWduIiwicmVwbGFjZTIiLCJjcmVhdGVCcm93c2VyVVJMSW1wbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaXNBYnNvbHV0ZSIsIm9yaWdpbiIsImRlZmF1bHRWYWx1ZSIsIl9tYXAiLCJjb25zdHJ1Y3RvciIsImluaXQiLCJNYXAiLCJjb250ZXh0IiwiV2Vha01hcCIsInVuc3VwcG9ydGVkTGF6eVJvdXRlT2JqZWN0S2V5cyIsIlNldCIsImlzVW5zdXBwb3J0ZWRMYXp5Um91dGVPYmplY3RLZXkiLCJ1bnN1cHBvcnRlZExhenlSb3V0ZUZ1bmN0aW9uS2V5cyIsImlzVW5zdXBwb3J0ZWRMYXp5Um91dGVGdW5jdGlvbktleSIsImlzSW5kZXhSb3V0ZSIsInJvdXRlIiwiY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyIsInJvdXRlcyIsIm1hcFJvdXRlUHJvcGVydGllczIiLCJwYXJlbnRQYXRoIiwibWFuaWZlc3QiLCJ0cmVlUGF0aCIsIlN0cmluZyIsImlkIiwiam9pbiIsImNoaWxkcmVuIiwiaW5kZXhSb3V0ZSIsInBhdGhPckxheW91dFJvdXRlIiwibG9jYXRpb25BcmciLCJiYXNlbmFtZSIsIm1hdGNoUm91dGVzSW1wbCIsImFsbG93UGFydGlhbCIsInN0cmlwQmFzZW5hbWUiLCJicmFuY2hlcyIsImZsYXR0ZW5Sb3V0ZXMiLCJyYW5rUm91dGVCcmFuY2hlcyIsIm1hdGNoZXMiLCJpIiwiZGVjb2RlZCIsImRlY29kZVBhdGgiLCJtYXRjaFJvdXRlQnJhbmNoIiwiY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2giLCJtYXRjaCIsImxvYWRlckRhdGEiLCJwYXJhbXMiLCJoYW5kbGUiLCJwYXJlbnRzTWV0YSIsImZsYXR0ZW5Sb3V0ZSIsInJlbGF0aXZlUGF0aCIsIm1ldGEiLCJjYXNlU2Vuc2l0aXZlIiwiY2hpbGRyZW5JbmRleCIsImpvaW5QYXRocyIsInJvdXRlc01ldGEiLCJjb25jYXQiLCJzY29yZSIsImNvbXB1dGVTY29yZSIsImZvckVhY2giLCJpbmNsdWRlcyIsImV4cGxvZGVkIiwiZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMiLCJzZWdtZW50cyIsInNwbGl0IiwiZmlyc3QiLCJyZXN0IiwiaXNPcHRpb25hbCIsImVuZHNXaXRoIiwicmVxdWlyZWQiLCJyZXN0RXhwbG9kZWQiLCJyZXN1bHQiLCJzdWJwYXRoIiwic29ydCIsImEiLCJiIiwiY29tcGFyZUluZGV4ZXMiLCJwYXJhbVJlIiwiZHluYW1pY1NlZ21lbnRWYWx1ZSIsImluZGV4Um91dGVWYWx1ZSIsImVtcHR5U2VnbWVudFZhbHVlIiwic3RhdGljU2VnbWVudFZhbHVlIiwic3BsYXRQZW5hbHR5IiwiaXNTcGxhdCIsInMiLCJpbml0aWFsU2NvcmUiLCJzb21lIiwiZmlsdGVyIiwicmVkdWNlIiwic2VnbWVudCIsInRlc3QiLCJzaWJsaW5ncyIsImV2ZXJ5IiwiYnJhbmNoIiwibWF0Y2hlZFBhcmFtcyIsIm1hdGNoZWRQYXRobmFtZSIsImVuZCIsInJlbWFpbmluZ1BhdGhuYW1lIiwicGF0aG5hbWVCYXNlIiwibm9ybWFsaXplUGF0aG5hbWUiLCJvcmlnaW5hbFBhdGgiLCJwcmVmaXgiLCJzdHJpbmdpZnkyIiwicCIsImFycmF5IiwiaXNMYXN0U2VnbWVudCIsInN0YXIiLCJrZXlNYXRjaCIsIm9wdGlvbmFsIiwicGFyYW0iLCJwYXR0ZXJuIiwibWF0Y2hlciIsImNvbXBpbGVkUGFyYW1zIiwiY29tcGlsZVBhdGgiLCJjYXB0dXJlR3JvdXBzIiwibWVtbzIiLCJwYXJhbU5hbWUiLCJzcGxhdFZhbHVlIiwicmVnZXhwU291cmNlIiwiXyIsIlJlZ0V4cCIsInYiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0SW5kZXgiLCJuZXh0Q2hhciIsImZyb21QYXRobmFtZSIsInRvUGF0aG5hbWUiLCJyZXNvbHZlUGF0aG5hbWUiLCJub3JtYWxpemVTZWFyY2giLCJub3JtYWxpemVIYXNoIiwicmVsYXRpdmVTZWdtZW50cyIsInBvcCIsImdldEludmFsaWRQYXRoRXJyb3IiLCJjaGFyIiwiZmllbGQiLCJkZXN0IiwiZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMiLCJnZXRSZXNvbHZlVG9NYXRjaGVzIiwicGF0aE1hdGNoZXMiLCJyZXNvbHZlVG8iLCJ0b0FyZyIsInJvdXRlUGF0aG5hbWVzIiwibG9jYXRpb25QYXRobmFtZSIsImlzUGF0aFJlbGF0aXZlIiwiaXNFbXB0eVBhdGgiLCJyb3V0ZVBhdGhuYW1lSW5kZXgiLCJ0b1NlZ21lbnRzIiwic2hpZnQiLCJoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2giLCJoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCIsInBhdGhzIiwiRGF0YVdpdGhSZXNwb25zZUluaXQiLCJkYXRhMiIsInR5cGUiLCJzdGF0dXMiLCJyZXNwb25zZUluaXQiLCJoZWFkZXJzIiwiSGVhZGVycyIsIlJlc3BvbnNlIiwicmVzcG9uc2UiLCJzdGF0dXNUZXh0IiwiaW50ZXJuYWwiLCJ2YWxpZE11dGF0aW9uTWV0aG9kc0FyciIsInZhbGlkTXV0YXRpb25NZXRob2RzIiwidmFsaWRSZXF1ZXN0TWV0aG9kc0FyciIsInZhbGlkUmVxdWVzdE1ldGhvZHMiLCJyZWRpcmVjdFN0YXR1c0NvZGVzIiwicmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzIiwiZm9ybU1ldGhvZCIsImZvcm1BY3Rpb24iLCJmb3JtRW5jVHlwZSIsImZvcm1EYXRhIiwianNvbiIsInRleHQiLCJwcm9jZWVkIiwicmVzZXQiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzIiwiaGFzRXJyb3JCb3VuZGFyeSIsIkJvb2xlYW4iLCJUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSIsIlJlc2V0TG9hZGVyRGF0YVN5bWJvbCIsIlN5bWJvbCIsInJvdXRlcldpbmRvdyIsImlzQnJvd3NlcjIiLCJjcmVhdGVFbGVtZW50IiwiaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzMiIsImRhdGFSb3V0ZXMiLCJpbkZsaWdodERhdGFSb3V0ZXMiLCJkYXRhU3RyYXRlZ3lJbXBsIiwiZGF0YVN0cmF0ZWd5IiwiZGVmYXVsdERhdGFTdHJhdGVneVdpdGhNaWRkbGV3YXJlIiwiZnV0dXJlIiwidW5zdGFibGVfbWlkZGxld2FyZSIsInVubGlzdGVuSGlzdG9yeSIsInN1YnNjcmliZXJzIiwic2F2ZWRTY3JvbGxQb3NpdGlvbnMyIiwiZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkyIiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJpbml0aWFsU2Nyb2xsUmVzdG9yZWQiLCJoeWRyYXRpb25EYXRhIiwiaW5pdGlhbE1hdGNoZXMiLCJpbml0aWFsTWF0Y2hlc0lzRk9XIiwiaW5pdGlhbEVycm9ycyIsImluaXRpYWxpemVkIiwicGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24iLCJnZXRJbnRlcm5hbFJvdXRlckVycm9yIiwiZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyIsImZvZ09mV2FyIiwiY2hlY2tGb2dPZldhciIsImFjdGl2ZSIsIm0iLCJsYXp5IiwibG9hZGVyIiwiZXJyb3JzIiwiZmluZEluZGV4Iiwic2hvdWxkTG9hZFJvdXRlT25IeWRyYXRpb24iLCJyb3V0ZXIiLCJoaXN0b3J5QWN0aW9uIiwibmF2aWdhdGlvbiIsInJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsInByZXZlbnRTY3JvbGxSZXNldCIsInJldmFsaWRhdGlvbiIsImFjdGlvbkRhdGEiLCJmZXRjaGVycyIsImJsb2NrZXJzIiwicGVuZGluZ0FjdGlvbiIsInBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQiLCJwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIiLCJwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkIiwiYXBwbGllZFZpZXdUcmFuc2l0aW9ucyIsInJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lciIsImlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsImlzUmV2YWxpZGF0aW9uUmVxdWlyZWQiLCJjYW5jZWxsZWRGZXRjaGVyTG9hZHMiLCJmZXRjaENvbnRyb2xsZXJzIiwiaW5jcmVtZW50aW5nTG9hZElkIiwicGVuZGluZ05hdmlnYXRpb25Mb2FkSWQiLCJmZXRjaFJlbG9hZElkcyIsImZldGNoUmVkaXJlY3RJZHMiLCJmZXRjaExvYWRNYXRjaGVzIiwiYWN0aXZlRmV0Y2hlcnMiLCJmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uIiwiYmxvY2tlckZ1bmN0aW9ucyIsInVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSIsInBlbmRpbmdSZXZhbGlkYXRpb25EZmQiLCJpbml0aWFsaXplIiwic2l6ZSIsImJsb2NrZXJLZXkiLCJzaG91bGRCbG9ja05hdmlnYXRpb24iLCJjdXJyZW50TG9jYXRpb24iLCJuZXh0SGlzdG9yeVVwZGF0ZVByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInVwZGF0ZUJsb2NrZXIiLCJ0aGVuIiwidXBkYXRlU3RhdGUiLCJzdGFydE5hdmlnYXRpb24iLCJyZXN0b3JlQXBwbGllZFRyYW5zaXRpb25zIiwiX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMiLCJwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zIiwiaW5pdGlhbEh5ZHJhdGlvbiIsImRpc3Bvc2UiLCJjbGVhciIsImFib3J0IiwiZGVsZXRlRmV0Y2hlciIsImRlbGV0ZUJsb2NrZXIiLCJzdWJzY3JpYmUiLCJkZWxldGUiLCJuZXdTdGF0ZSIsIm9wdHMiLCJ1bm1vdW50ZWRGZXRjaGVycyIsIm1vdW50ZWRGZXRjaGVycyIsImZldGNoZXIiLCJzdWJzY3JpYmVyIiwiZGVsZXRlZEZldGNoZXJzIiwidmlld1RyYW5zaXRpb25PcHRzIiwiZmx1c2hTeW5jIiwiY29tcGxldGVOYXZpZ2F0aW9uIiwiaXNBY3Rpb25SZWxvYWQiLCJpc011dGF0aW9uTWV0aG9kIiwiX2lzUmVkaXJlY3QiLCJrZXlzIiwibWVyZ2VMb2FkZXJEYXRhIiwiayIsInByaW9yUGF0aHMiLCJ0b1BhdGhzIiwiZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbiIsIm5hdmlnYXRlIiwibm9ybWFsaXplZFBhdGgiLCJub3JtYWxpemVUbyIsImZyb21Sb3V0ZUlkIiwicmVsYXRpdmUiLCJzdWJtaXNzaW9uIiwibm9ybWFsaXplTmF2aWdhdGVPcHRpb25zIiwidXNlclJlcGxhY2UiLCJwZW5kaW5nRXJyb3IiLCJlbmFibGVWaWV3VHJhbnNpdGlvbiIsInZpZXdUcmFuc2l0aW9uIiwicmV2YWxpZGF0ZSIsImNyZWF0ZURlZmVycmVkIiwiaW50ZXJydXB0QWN0aXZlTG9hZHMiLCJwcm9taXNlIiwic3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uIiwib3ZlcnJpZGVOYXZpZ2F0aW9uIiwic2F2ZVNjcm9sbFBvc2l0aW9uIiwicm91dGVzVG9Vc2UiLCJsb2FkaW5nTmF2aWdhdGlvbiIsImlzSGFzaENoYW5nZU9ubHkiLCJub3RGb3VuZE1hdGNoZXMiLCJoYW5kbGVOYXZpZ2F0aW9uYWw0MDQiLCJBYm9ydENvbnRyb2xsZXIiLCJyZXF1ZXN0IiwiY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QiLCJzaWduYWwiLCJzY29wZWRDb250ZXh0IiwidW5zdGFibGVfZ2V0Q29udGV4dCIsInBlbmRpbmdBY3Rpb25SZXN1bHQiLCJmaW5kTmVhcmVzdEJvdW5kYXJ5IiwiYWN0aW9uUmVzdWx0IiwiaGFuZGxlQWN0aW9uIiwic2hvcnRDaXJjdWl0ZWQiLCJyb3V0ZUlkIiwiaXNFcnJvclJlc3VsdCIsImdldExvYWRpbmdOYXZpZ2F0aW9uIiwidXBkYXRlZE1hdGNoZXMiLCJoYW5kbGVMb2FkZXJzIiwiZmV0Y2hlclN1Ym1pc3Npb24iLCJnZXRBY3Rpb25EYXRhRm9yQ29tbWl0IiwiaXNGb2dPZldhciIsImdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uIiwiZGlzY292ZXJSZXN1bHQiLCJkaXNjb3ZlclJvdXRlcyIsImJvdW5kYXJ5SWQiLCJwYXJ0aWFsTWF0Y2hlcyIsImFjdGlvbk1hdGNoIiwiZ2V0VGFyZ2V0TWF0Y2giLCJtZXRob2QiLCJkc01hdGNoZXMiLCJnZXRUYXJnZXRlZERhdGFTdHJhdGVneU1hdGNoZXMiLCJyZXN1bHRzIiwiY2FsbERhdGFTdHJhdGVneSIsImFib3J0ZWQiLCJpc1JlZGlyZWN0UmVzdWx0IiwibG9jYXRpb24yIiwibm9ybWFsaXplUmVkaXJlY3RMb2NhdGlvbiIsInN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uIiwiYm91bmRhcnlNYXRjaCIsImFjdGl2ZVN1Ym1pc3Npb24iLCJnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24iLCJzaG91bGRVcGRhdGVOYXZpZ2F0aW9uU3RhdGUiLCJnZXRVcGRhdGVkQWN0aW9uRGF0YSIsInJldmFsaWRhdGluZ0ZldGNoZXJzIiwiZ2V0TWF0Y2hlc1RvTG9hZCIsInNob3VsZExvYWQiLCJ1cGRhdGVkRmV0Y2hlcnMyIiwibWFya0ZldGNoUmVkaXJlY3RzRG9uZSIsInVwZGF0ZXMiLCJnZXRVcGRhdGVkUmV2YWxpZGF0aW5nRmV0Y2hlcnMiLCJyZiIsImFib3J0RmV0Y2hlciIsImNvbnRyb2xsZXIiLCJhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMiLCJmIiwibG9hZGVyUmVzdWx0cyIsImZldGNoZXJSZXN1bHRzIiwiY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhIiwicmVkaXJlY3QyIiwiZmluZFJlZGlyZWN0IiwicHJvY2Vzc0xvYWRlckRhdGEiLCJ1cGRhdGVkRmV0Y2hlcnMiLCJkaWRBYm9ydEZldGNoTG9hZHMiLCJhYm9ydFN0YWxlRmV0Y2hMb2FkcyIsInNob3VsZFVwZGF0ZUZldGNoZXJzIiwicmV2YWxpZGF0aW5nRmV0Y2hlciIsImdldExvYWRpbmdGZXRjaGVyIiwiZmV0Y2gyIiwic2V0RmV0Y2hlckVycm9yIiwiaGFuZGxlRmV0Y2hlckFjdGlvbiIsImhhbmRsZUZldGNoZXJMb2FkZXIiLCJyZXF1ZXN0TWF0Y2hlcyIsImRldGVjdEFuZEhhbmRsZTQwNUVycm9yIiwiZXhpc3RpbmdGZXRjaGVyIiwidXBkYXRlRmV0Y2hlclN0YXRlIiwiZ2V0U3VibWl0dGluZ0ZldGNoZXIiLCJhYm9ydENvbnRyb2xsZXIiLCJmZXRjaFJlcXVlc3QiLCJvcmlnaW5hdGluZ0xvYWRJZCIsImZldGNoTWF0Y2hlcyIsImFjdGlvblJlc3VsdHMiLCJnZXREb25lRmV0Y2hlciIsInJldmFsaWRhdGlvblJlcXVlc3QiLCJsb2FkSWQiLCJsb2FkRmV0Y2hlciIsInN0YWxlS2V5IiwiZXhpc3RpbmdGZXRjaGVyMiIsInIiLCJkb25lRmV0Y2hlciIsImlzTmF2aWdhdGlvbiIsInJlZGlyZWN0TG9jYXRpb24iLCJpc0RvY3VtZW50UmVsb2FkIiwicmVkaXJlY3ROYXZpZ2F0aW9uVHlwZSIsImZldGNoZXJLZXkiLCJkYXRhUmVzdWx0cyIsImNhbGxEYXRhU3RyYXRlZ3lJbXBsIiwiaXNSZWRpcmVjdERhdGFTdHJhdGVneVJlc3VsdCIsIm5vcm1hbGl6ZVJlbGF0aXZlUm91dGluZ1JlZGlyZWN0UmVzcG9uc2UiLCJjb252ZXJ0RGF0YVN0cmF0ZWd5UmVzdWx0VG9EYXRhUmVzdWx0IiwiZmV0Y2hlcnNUb0xvYWQiLCJsb2FkZXJSZXN1bHRzUHJvbWlzZSIsImZldGNoZXJSZXN1bHRzUHJvbWlzZSIsImFjYyIsImdldEZldGNoZXIiLCJxdWV1ZUZldGNoZXJGb3JEZWxldGlvbiIsImNvdW50IiwibWFya0ZldGNoZXJzRG9uZSIsImRvbmVLZXlzIiwibGFuZGVkSWQiLCJ5ZWV0ZWRLZXlzIiwiZ2V0QmxvY2tlciIsImJsb2NrZXIiLCJuZXdCbG9ja2VyIiwiQXJyYXkiLCJibG9ja2VyRnVuY3Rpb24iLCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvbiIsInBvc2l0aW9ucyIsImdldFBvc2l0aW9uIiwiZ2V0S2V5IiwieSIsImdldFNjcm9sbEtleSIsImZvZ01hdGNoZXMiLCJpc05vbkhNUiIsImxvY2FsTWFuaWZlc3QiLCJwYXRjaCIsInBhdGNoUm91dGVzSW1wbCIsIm5ld01hdGNoZXMiLCJuZXdQYXJ0aWFsTWF0Y2hlcyIsIl9pbnRlcm5hbFNldFJvdXRlcyIsIm5ld1JvdXRlcyIsInBhdGNoUm91dGVzIiwiZmV0Y2giLCJfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzIiwicXVlcnkiLCJyZXF1ZXN0Q29udGV4dCIsImZpbHRlck1hdGNoZXNUb0xvYWQiLCJza2lwTG9hZGVyRXJyb3JCdWJibGluZyIsInNraXBSZXZhbGlkYXRpb24iLCJ1bnN0YWJsZV9yZXNwb25kIiwicmVzcG9uZCIsImlzVmFsaWRNZXRob2QiLCJtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcyIsInN0YXRpY0NvbnRleHQiLCJzdGF0dXNDb2RlIiwibG9hZGVySGVhZGVycyIsImFjdGlvbkhlYWRlcnMiLCJsb2FkTGF6eU1pZGRsZXdhcmVGb3JNYXRjaGVzIiwicmVuZGVyZWRTdGF0aWNDb250ZXh0IiwicnVuTWlkZGxld2FyZVBpcGVsaW5lIiwicmVzdWx0MiIsInF1ZXJ5SW1wbCIsImlzUmVzcG9uc2UiLCJyZXMiLCJnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yIiwiYm91bmRhcnlSb3V0ZUlkIiwiZmluZCIsInF1ZXJ5Um91dGUiLCJlcnJvcjIiLCJ2YWx1ZXMiLCJyb3V0ZU1hdGNoIiwic3VibWl0IiwibG9hZFJvdXRlRGF0YSIsImlzRGF0YVN0cmF0ZWd5UmVzdWx0IiwiaXNSZWRpcmVjdFJlc3BvbnNlIiwiaXNSb3V0ZVJlcXVlc3QiLCJ0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IiLCJMb2NhdGlvbiIsImxvYWRlclJlcXVlc3QiLCJSZXF1ZXN0IiwiaGFuZGxlckNvbnRleHQyIiwiaGFuZGxlckNvbnRleHQiLCJtYXhJZHgiLCJnZXREYXRhU3RyYXRlZ3lNYXRjaCIsInByb2Nlc3NSb3V0ZUxvYWRlckRhdGEiLCJkZWZhdWx0RGF0YVN0cmF0ZWd5IiwiZXJyb3JCb3VuZGFyeUlkIiwiX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQiLCJyZWFzb24iLCJpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uIiwiYm9keSIsImNvbnRleHR1YWxNYXRjaGVzIiwiYWN0aXZlUm91dGVNYXRjaCIsIm5ha2VkSW5kZXgiLCJoYXNOYWtlZEluZGV4UXVlcnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJpbmRleFZhbHVlcyIsImdldEFsbCIsImFwcGVuZCIsInFzIiwiaXNGZXRjaGVyIiwiZ2V0SW52YWxpZEJvZHlFcnJvciIsInJhd0Zvcm1NZXRob2QiLCJ0b1VwcGVyQ2FzZSIsInN0cmlwSGFzaEZyb21QYXRoIiwiRm9ybURhdGEiLCJwYXJzZSIsInNlYXJjaFBhcmFtcyIsImNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zIiwiY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEiLCJsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwIiwiaGFzUGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24iLCJjdXJyZW50VXJsIiwibmV4dFVybCIsImFjdGlvblN0YXR1cyIsInNob3VsZFNraXBSZXZhbGlkYXRpb24iLCJiYXNlU2hvdWxkUmV2YWxpZGF0ZUFyZ3MiLCJjdXJyZW50UGFyYW1zIiwibmV4dFBhcmFtcyIsImZvcmNlU2hvdWxkTG9hZCIsImlzTmV3TG9hZGVyIiwiZGVmYXVsdFNob3VsZFJldmFsaWRhdGUiLCJpc05ld1JvdXRlSW5zdGFuY2UiLCJzaG91bGRSZXZhbGlkYXRlQXJncyIsInNob3VsZFJldmFsaWRhdGVMb2FkZXIiLCJpc01pZEluaXRpYWxMb2FkIiwiZmV0Y2hlck1hdGNoZXMiLCJmZXRjaGVyTWF0Y2giLCJmZXRjaENvbnRyb2xsZXIiLCJmZXRjaGVyRHNNYXRjaGVzIiwiaGFzRGF0YSIsImhhc0Vycm9yIiwiaHlkcmF0ZSIsImN1cnJlbnRMb2FkZXJEYXRhIiwiY3VycmVudE1hdGNoIiwiaXNOZXciLCJpc01pc3NpbmdEYXRhIiwiY3VycmVudFBhdGgiLCJsb2FkZXJNYXRjaCIsImFyZyIsInNob3VsZFJldmFsaWRhdGUiLCJyb3V0ZUNob2ljZSIsImNoaWxkcmVuVG9QYXRjaCIsInVuaXF1ZUNoaWxkcmVuIiwibmV3Um91dGUiLCJleGlzdGluZ1JvdXRlIiwiaXNTYW1lUm91dGUiLCJhQ2hpbGQiLCJiQ2hpbGQiLCJsYXp5Um91dGVQcm9wZXJ0eUNhY2hlIiwibG9hZExhenlSb3V0ZVByb3BlcnR5Iiwicm91dGVUb1VwZGF0ZSIsImxhenlGbiIsImNhY2hlIiwiY2FjaGVkUHJvbWlzZSIsInByb3BlcnR5UHJvbWlzZSIsImlzVW5zdXBwb3J0ZWQiLCJzdGF0aWNSb3V0ZVZhbHVlIiwiaXNTdGF0aWNhbGx5RGVmaW5lZCIsImxhenlSb3V0ZUZ1bmN0aW9uQ2FjaGUiLCJsb2FkTGF6eVJvdXRlIiwibGF6eVJvdXRlUHJvbWlzZSIsImxhenlIYW5kbGVyUHJvbWlzZSIsImxhenlSb3V0ZVByb21pc2UyIiwibGF6eVJvdXRlIiwicm91dGVVcGRhdGVzIiwibGF6eVJvdXRlUHJvcGVydHkiLCJsYXp5VmFsdWUiLCJjYXRjaCIsImxhenlLZXlzIiwibGF6eVByb3BlcnR5UHJvbWlzZXMiLCJpc05vbk51bGxhYmxlIiwicHJvbWlzZXMiLCJhcmdzIiwibWF0Y2hlc1RvTG9hZCIsImtleWVkUmVzdWx0cyIsInByb3BhZ2F0ZVJlc3VsdCIsImhhbmRsZXIiLCJlcnJvckhhbmRsZXIiLCJtaWRkbGV3YXJlU3RhdGUiLCJoYW5kbGVyUmVzdWx0IiwidHVwbGVzIiwiZmxhdE1hcCIsImNhbGxSb3V0ZU1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlRXJyb3IiLCJtaWRkbGV3YXJlcyIsInR1cGxlIiwibWlkZGxld2FyZSIsIm5leHRDYWxsZWQiLCJuZXh0UmVzdWx0IiwibmV4dCIsImdldERhdGFTdHJhdGVneU1hdGNoTGF6eVByb21pc2VzIiwibGF6eU1pZGRsZXdhcmVQcm9taXNlIiwibGF6eVJvdXRlUHJvbWlzZXMiLCJ1bnN0YWJsZV9zaG91bGRSZXZhbGlkYXRlQXJncyIsImlzVXNpbmdOZXdBcGkiLCJfbGF6eVByb21pc2VzIiwidW5zdGFibGVfc2hvdWxkQ2FsbEhhbmRsZXIiLCJoYW5kbGVyT3ZlcnJpZGUiLCJjYWxsTG9hZGVyT3JBY3Rpb24iLCJ0YXJnZXRNYXRjaCIsImlzU3RhdGljSGFuZGxlciIsImRhdGFTdHJhdGVneUFyZ3MiLCJ1bnN0YWJsZV9ydW5DbGllbnRNaWRkbGV3YXJlIiwiY2IiLCJ0eXBlZERhdGFTdHJhdGVneUFyZ3MiLCJvblJlamVjdCIsImlzQWN0aW9uIiwicnVuSGFuZGxlciIsInJlamVjdCIsImFib3J0UHJvbWlzZSIsImFjdHVhbEhhbmRsZXIiLCJjdHgiLCJoYW5kbGVyUHJvbWlzZSIsInZhbCIsInJhY2UiLCJoYW5kbGVyRXJyb3IiLCJoYW5kbGVyMiIsImRhdGFTdHJhdGVneVJlc3VsdCIsImNvbnRlbnRUeXBlIiwiaXNEYXRhV2l0aFJlc3BvbnNlSW5pdCIsInRyaW1tZWRNYXRjaGVzIiwibm9ybWFsaXplZExvY2F0aW9uIiwicHJvdG9jb2wiLCJpc1NhbWVCYXNlbmFtZSIsImZvdW5kRXJyb3IiLCJuZXdMb2FkZXJEYXRhIiwibWVyZ2VkTG9hZGVyRGF0YSIsIm1lcmdlZCIsImVsaWdpYmxlTWF0Y2hlcyIsInJldmVyc2UiLCJlcnJvck1lc3NhZ2UiLCJpc1JlZGlyZWN0U3RhdHVzQ29kZSIsIl93aW5kb3ciLCJ0cmFuc2l0aW9ucyIsInNlc3Npb25Qb3NpdGlvbnMiLCJzZXNzaW9uU3RvcmFnZSIsImdldEl0ZW0iLCJpc0FycmF5Iiwic2V0SXRlbSIsInJlaiIsIlJlYWN0MyIsInJlcXVpcmUiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsImlzVHJhbnNpdGlvbmluZyIsIkF3YWl0Q29udGV4dCIsIm91dGxldCIsImlzRGF0YVJvdXRlIiwiUm91dGVFcnJvckNvbnRleHQiLCJFTkFCTEVfREVWX1dBUk5JTkdTIiwiUmVhY3QyIiwibmF2aWdhdG9yIiwidXNlQ29udGV4dCIsImpvaW5lZFBhdGhuYW1lIiwibmF2aWdhdGlvblR5cGUiLCJ1c2VNZW1vIiwibmF2aWdhdGVFZmZlY3RXYXJuaW5nIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImlzU3RhdGljIiwic3RhdGljIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlTmF2aWdhdGVTdGFibGUiLCJ1c2VOYXZpZ2F0ZVVuc3RhYmxlIiwiZGF0YVJvdXRlckNvbnRleHQiLCJyb3V0ZVBhdGhuYW1lc0pzb24iLCJhY3RpdmVSZWYiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsIk91dGxldENvbnRleHQiLCJQcm92aWRlciIsInVzZVJvdXRlc0ltcGwiLCJkYXRhUm91dGVyU3RhdGUiLCJwYXJlbnRNYXRjaGVzIiwicGFyZW50UGFyYW1zIiwicGFyZW50UGF0aG5hbWUiLCJwYXJlbnRQYXRobmFtZUJhc2UiLCJwYXJlbnRSb3V0ZSIsIndhcm5pbmdPbmNlIiwibG9jYXRpb25Gcm9tQ29udGV4dCIsInBhcnNlZExvY2F0aW9uQXJnIiwicGFyZW50U2VnbWVudHMiLCJlbGVtZW50IiwiQ29tcG9uZW50IiwicmVuZGVyZWRNYXRjaGVzIiwiX3JlbmRlck1hdGNoZXMiLCJEZWZhdWx0RXJyb3JDb21wb25lbnQiLCJzdGFjayIsImxpZ2h0Z3JleSIsInByZVN0eWxlcyIsInBhZGRpbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2RlU3R5bGVzIiwiZGV2SW5mbyIsIkZyYWdtZW50Iiwic3R5bGUiLCJmb250U3R5bGUiLCJkZWZhdWx0RXJyb3JFbGVtZW50IiwiUmVuZGVyRXJyb3JCb3VuZGFyeSIsInByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJlcnJvckluZm8iLCJyZW5kZXIiLCJyb3V0ZUNvbnRleHQiLCJjb21wb25lbnQiLCJSZW5kZXJlZFJvdXRlIiwiZXJyb3JFbGVtZW50IiwiRXJyb3JCb3VuZGFyeSIsImVycm9ySW5kZXgiLCJyZW5kZXJGYWxsYmFjayIsImZhbGxiYWNrSW5kZXgiLCJIeWRyYXRlRmFsbGJhY2siLCJoeWRyYXRlRmFsbGJhY2tFbGVtZW50IiwiZXJyb3JzMiIsIm5lZWRzVG9SdW5Mb2FkZXIiLCJyZWR1Y2VSaWdodCIsInNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayIsIm1hdGNoZXMyIiwiZ2V0Q2hpbGRyZW4iLCJnZXREYXRhUm91dGVyQ29uc29sZUVycm9yIiwiaG9va05hbWUiLCJ1c2VEYXRhUm91dGVyQ29udGV4dCIsInVzZURhdGFSb3V0ZXJTdGF0ZSIsInVzZVJvdXRlQ29udGV4dCIsInVzZUN1cnJlbnRSb3V0ZUlkIiwidGhpc1JvdXRlIiwidXNlUm91dGVJZCIsIl9kYXRhIiwiX2Vycm9yIiwiYmxvY2tlcklkIiwic2hvdWxkQmxvY2siLCJzZXRCbG9ja2VyS2V5IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJhbHJlYWR5V2FybmVkIiwiYWxyZWFkeVdhcm5lZDIiLCJ3YXJuT25jZSIsImNvbmRpdGlvbiIsIkRlZmVycmVkIiwicmVhY3REb21GbHVzaFN5bmNJbXBsIiwic2V0U3RhdGVJbXBsIiwicGVuZGluZ1N0YXRlIiwic2V0UGVuZGluZ1N0YXRlIiwidnRDb250ZXh0Iiwic2V0VnRDb250ZXh0IiwicmVuZGVyRGZkIiwic2V0UmVuZGVyRGZkIiwidHJhbnNpdGlvbiIsInNldFRyYW5zaXRpb24iLCJpbnRlcnJ1cHRpb24iLCJzZXRJbnRlcnJ1cHRpb24iLCJmZXRjaGVyRGF0YSIsInNldFN0YXRlIiwiaXNWaWV3VHJhbnNpdGlvbkF2YWlsYWJsZSIsInN0YXJ0Vmlld1RyYW5zaXRpb24iLCJzdGFydFRyYW5zaXRpb24iLCJza2lwVHJhbnNpdGlvbiIsInQiLCJmaW5pc2hlZCIsImZpbmFsbHkiLCJyZW5kZXJQcm9taXNlIiwidHJhbnNpdGlvbjIiLCJzdGF0ZTIiLCJNZW1vaXplZERhdGFSb3V0ZXMiLCJtZW1vIiwiRGF0YVJvdXRlcyIsImhpc3RvcnlSZWYiLCJqc29uUGF0aCIsIl9wcm9wcyIsImJhc2VuYW1lUHJvcCIsImxvY2F0aW9uUHJvcCIsInN0YXRpY1Byb3AiLCJuYXZpZ2F0aW9uQ29udGV4dCIsImxvY2F0aW9uQ29udGV4dCIsInRyYWlsaW5nUGF0aG5hbWUiLCJBd2FpdEVycm9yQm91bmRhcnkiLCJSZXNvbHZlQXdhaXQiLCJyZW5kZXJFcnJvciIsIl90cmFja2VkIiwidG9SZW5kZXIiLCJDaGlsZHJlbiIsImlzVmFsaWRFbGVtZW50IiwiYXBwbHkiLCJSZWFjdDEwIiwiZGVmYXVsdE1ldGhvZCIsImRlZmF1bHRFbmNUeXBlIiwiaXNIdG1sRWxlbWVudCIsIm9iamVjdCIsInRhZ05hbWUiLCJpc0J1dHRvbkVsZW1lbnQiLCJpc0Zvcm1FbGVtZW50IiwiaXNJbnB1dEVsZW1lbnQiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsIm1ldGFLZXkiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJzaG91bGRQcm9jZXNzTGlua0NsaWNrIiwiYnV0dG9uIiwiZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24iLCJsb2NhdGlvblNlYXJjaCIsImRlZmF1bHRTZWFyY2hQYXJhbXMiLCJfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciIsImlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQiLCJzdXBwb3J0ZWRGb3JtRW5jVHlwZXMiLCJnZXRGb3JtRW5jVHlwZSIsImVuY1R5cGUiLCJnZXRGb3JtU3VibWlzc2lvbkluZm8iLCJhdHRyIiwiZm9ybSIsIlJlYWN0OSIsImludmFyaWFudDIiLCJsb2FkUm91dGVNb2R1bGUiLCJyb3V0ZU1vZHVsZXNDYWNoZSIsInJvdXRlTW9kdWxlIiwiX19yZWFjdFJvdXRlckNvbnRleHQiLCJpc1NwYU1vZGUiLCJyZWxvYWQiLCJnZXRLZXllZExpbmtzRm9yTWF0Y2hlcyIsInJvdXRlTW9kdWxlcyIsImRlc2NyaXB0b3JzIiwibW9kdWxlMiIsImNzcyIsInJlbCIsImxpbmtzIiwiZmxhdCIsInByZWxvYWRzIiwiZ2V0TW9kdWxlTGlua0hyZWZzIiwiZGVkdXBlTGlua0Rlc2NyaXB0b3JzIiwiZ2V0Um91dGVDc3NEZXNjcmlwdG9ycyIsInByZWZldGNoUm91dGVDc3MiLCJwcmVmZXRjaFN0eWxlTGluayIsInByZWZldGNoU3R5bGVMaW5rcyIsImlzUHJlbG9hZFN1cHBvcnRlZCIsInN0eWxlTGlua3MiLCJkZXNjcmlwdG9yIiwiaXNQYWdlTGlua0Rlc2NyaXB0b3IiLCJhcyIsIm1lZGlhIiwibWF0Y2hNZWRpYSIsImxpbmsiLCJyZW1vdmVMaW5rIiwiaGVhZCIsImNvbnRhaW5zIiwicmVtb3ZlQ2hpbGQiLCJvbmxvYWQiLCJvbmVycm9yIiwiYXBwZW5kQ2hpbGQiLCJwYWdlIiwiaXNIdG1sTGlua0Rlc2NyaXB0b3IiLCJpbWFnZVNyY1NldCIsImltYWdlU2l6ZXMiLCJnZXRLZXllZFByZWZldGNoTGlua3MiLCJnZXROZXdNYXRjaGVzRm9yTGlua3MiLCJuZXh0TWF0Y2hlcyIsImN1cnJlbnRNYXRjaGVzIiwibW9kZSIsIm1hdGNoUGF0aENoYW5nZWQiLCJtYW5pZmVzdFJvdXRlIiwiaGFzTG9hZGVyIiwiaW5jbHVkZUh5ZHJhdGVGYWxsYmFjayIsImRlZHVwZUhyZWZzIiwiaHJlZnMiLCJjbGllbnRBY3Rpb25Nb2R1bGUiLCJjbGllbnRMb2FkZXJNb2R1bGUiLCJoeWRyYXRlRmFsbGJhY2tNb2R1bGUiLCJpbXBvcnRzIiwic29ydEtleXMiLCJzb3J0ZWQiLCJwcmVsb2Fkc1NldCIsImRlZHVwZWQiLCJhbHJlYWR5TW9kdWxlUHJlbG9hZCIsIl9pc1ByZWxvYWRTdXBwb3J0ZWQiLCJlbCIsInJlbExpc3QiLCJzdXBwb3J0cyIsIkVTQ0FQRV9MT09LVVAiLCJFU0NBUEVfUkVHRVgiLCJlc2NhcGVIdG1sIiwiaHRtbCIsImNyZWF0ZUh0bWwiLCJfX2h0bWwiLCJSZWFjdDQiLCJIT0xFIiwiTkFOIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJORUdBVElWRV9aRVJPIiwiTlVMTCIsIlBPU0lUSVZFX0lORklOSVRZIiwiVU5ERUZJTkVEIiwiVFlQRV9CSUdJTlQiLCJUWVBFX0RBVEUiLCJUWVBFX0VSUk9SIiwiVFlQRV9NQVAiLCJUWVBFX05VTExfT0JKRUNUIiwiVFlQRV9QUk9NSVNFIiwiVFlQRV9SRUdFWFAiLCJUWVBFX1NFVCIsIlRZUEVfU1lNQk9MIiwiVFlQRV9VUkwiLCJUWVBFX1BSRVZJT1VTX1JFU09MVkVEIiwiRGVmZXJyZWQyIiwiY3JlYXRlTGluZVNwbGl0dGluZ1RyYW5zZm9ybSIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImxlZnRvdmVyIiwiVHJhbnNmb3JtU3RyZWFtIiwidHJhbnNmb3JtIiwiY2h1bmsiLCJzdHIiLCJkZWNvZGUiLCJzdHJlYW0iLCJwYXJ0cyIsInBhcnQiLCJlbnF1ZXVlIiwiZmx1c2giLCJmbGF0dGVuIiwiaW5wdXQiLCJpbmRpY2VzIiwiZXhpc3RpbmciLCJOdW1iZXIiLCJpc05hTiIsImRlZmVycmVkIiwicGx1Z2lucyIsInBvc3RQbHVnaW5zIiwic3RyaW5naWZpZWQiLCJpbnB1dDIiLCJwYXJ0c0Zvck9iaiIsImtleUZvciIsInBsdWdpbkhhbmRsZWQiLCJwbHVnaW4iLCJwbHVnaW5SZXN1bHQiLCJwbHVnaW5JZGVudGlmaWVyIiwiRGF0ZSIsImdldFRpbWUiLCJzb3VyY2UiLCJmbGFncyIsImlzUGxhaW5PYmplY3QiLCJvYmplY3RQcm90b05hbWVzIiwidGhpbmciLCJwcm90byIsImdsb2JhbE9iaiIsImdsb2JhbFRoaXMiLCJ1bmZsYXR0ZW4iLCJwYXJzZWQiLCJoeWRyYXRlZCIsIlN5bnRheEVycm9yIiwicG9zdFJ1biIsIk5hTiIsIkluZmluaXR5IiwiYyIsIkJpZ0ludCIsImZvciIsIm5ld1NldCIsImQiLCJlcnJvclR5cGUiLCJ2YWxzIiwidjIiLCJyZWFkYWJsZSIsImRvbmUiLCJyZWFkZXIiLCJwaXBlVGhyb3VnaCIsImdldFJlYWRlciIsImRlY29kZUluaXRpYWwiLCJkb25lUHJvbWlzZSIsImRlY29kZURlZmVycmVkIiwiY2xvc2VkIiwicmVhZCIsImxpbmUiLCJjb2xvbkluZGV4IiwiZGVmZXJyZWRJZCIsImxpbmVEYXRhIiwianNvbkxpbmUiLCJlbmNvZGUiLCJlbmNvZGVyMiIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJsYXN0U2VudEluZGV4IiwiUmVhZGFibGVTdHJlYW0iLCJzdGFydCIsInNlZW5Qcm9taXNlcyIsInJhY2VEb25lIiwicmFjZVByb21pc2UiLCJyZWplY3RQcm9taXNlIiwicmVzb2x2ZWQiLCJpZDIiLCJjbG9zZSIsImNyZWF0ZVJlcXVlc3RJbml0IiwiU2luZ2xlRmV0Y2hOb1Jlc3VsdEVycm9yIiwiU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVUyIsIk5PX0JPRFlfU1RBVFVTX0NPREVTIiwiU3RyZWFtVHJhbnNmZXIiLCJpZGVudGlmaWVyIiwidGV4dERlY29kZXIiLCJub25jZSIsInJlbmRlck1ldGEiLCJkaWRSZW5kZXJTY3JpcHRzIiwic3RyZWFtQ2FjaGUiLCJzY3JpcHRUYWciLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIlN1c3BlbnNlIiwiZ2V0Um91dGVyIiwic3NyIiwiZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3lJbXBsIiwiaGFzQ2xpZW50TG9hZGVyIiwiaGFzU2hvdWxkUmV2YWxpZGF0ZSIsImZldGNoQW5kRGVjb2RlVmlhVHVyYm9TdHJlYW0iLCJnZXRSb3V0ZUluZm8iLCJmZXRjaEFuZERlY29kZSIsInNpbmdsZUZldGNoQWN0aW9uU3RyYXRlZ3kiLCJmb3VuZFJldmFsaWRhdGluZ1NlcnZlckxvYWRlciIsIm5vblNzclN0cmF0ZWd5Iiwic2luZ2xlRmV0Y2hMb2FkZXJGZXRjaGVyU3RyYXRlZ3kiLCJzaW5nbGVGZXRjaExvYWRlck5hdmlnYXRpb25TdHJhdGVneSIsInVud3JhcFNpbmdsZUZldGNoUmVzdWx0Iiwicm91dGVzUGFyYW1zIiwiZm91bmRPcHRPdXRSb3V0ZSIsInJvdXRlRGZkcyIsImNyZWF0ZURlZmVycmVkMiIsInNpbmdsZUZldGNoRGZkIiwicmVzb2x2ZVByb21pc2UiLCJzaG91bGRDYWxsIiwiaXNJbml0aWFsTG9hZCIsIl9fcmVhY3RSb3V0ZXJIZHJBY3RpdmUiLCJ0YXJnZXRSb3V0ZXMiLCJidWJibGVNaWRkbGV3YXJlRXJyb3JzIiwic2luZ2xlRmV0Y2hQcm9taXNlIiwiZmV0Y2hlZERhdGEiLCJyb3V0ZVJlc3VsdCIsInN0cmlwSW5kZXhQYXJhbSIsImluZGV4VmFsdWVzVG9LZWVwIiwiaW5kZXhWYWx1ZSIsInRvS2VlcCIsInNpbmdsZUZldGNoVXJsIiwicmVxVXJsIiwidHlwZWQiLCJnbG9iYWwyIiwiQ29uc3RydWN0b3IiLCJSZWFjdDgiLCJSZWFjdDciLCJSZWFjdDUiLCJSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSIsImlzT3V0c2lkZVJlbWl4QXBwIiwiaGV5RGV2ZWxvcGVyIiwiQm91bmRhcnlTaGVsbCIsInRpdGxlIiwiZm9udFNpemUiLCJlcnJvckluc3RhbmNlIiwiZXJyb3JTdHJpbmciLCJiYWNrZ3JvdW5kIiwiY29sb3IiLCJvdmVyZmxvdyIsInJlbmRlclNjcmlwdHMiLCJ1c2VGcmFtZXdvcmtDb250ZXh0Iiwicm9vdCIsIkxheW91dCIsImxhbmciLCJjaGFyU2V0IiwiY29udGVudCIsImZvbnRGYW1pbHkiLCJSZWFjdDYiLCJSZW1peFJvb3REZWZhdWx0SHlkcmF0ZUZhbGxiYWNrIiwiZ3JvdXBSb3V0ZXNCeVBhcmVudElkIiwicGFyZW50SWQiLCJnZXRSb3V0ZUNvbXBvbmVudHMiLCJDb21wb25lbnQ0IiwiZ2V0Um91dGVNb2R1bGVDb21wb25lbnQiLCJjcmVhdGVTZXJ2ZXJSb3V0ZXMiLCJyb3V0ZXNCeVBhcmVudElkIiwic3BhTW9kZUxhenlQcm9taXNlIiwiZGF0YVJvdXRlIiwibmVlZHNSZXZhbGlkYXRpb24iLCJpbml0aWFsU3RhdGUiLCJwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsIiwiaGFzQWN0aW9uIiwibm9BY3Rpb25EZWZpbmVkRXJyb3IiLCJhcnRpY2xlIiwiZmV0Y2hTZXJ2ZXJIYW5kbGVyIiwic2luZ2xlRmV0Y2giLCJmZXRjaFNlcnZlckxvYWRlciIsImZldGNoU2VydmVyQWN0aW9uIiwicHJlZmV0Y2hNb2R1bGUiLCJtb2R1bGVQYXRoIiwicHJlZmV0Y2hSb3V0ZU1vZHVsZUNodW5rcyIsInJvdXRlMiIsInByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIiLCJjYWNoZWRNb2R1bGUiLCJsaW5rUHJlZmV0Y2hQcm9taXNlIiwidW5zdGFibGVfY2xpZW50TWlkZGxld2FyZSIsImdldFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbiIsImhhc0luaXRpYWxEYXRhIiwiaW5pdGlhbERhdGEiLCJoYXNJbml0aWFsRXJyb3IiLCJpbml0aWFsRXJyb3IiLCJpc0h5ZHJhdGlvblJlcXVlc3QiLCJjbGllbnRMb2FkZXIiLCJzZXJ2ZXJMb2FkZXIiLCJjbGllbnRBY3Rpb24iLCJzZXJ2ZXJBY3Rpb24iLCJoYXNDbGllbnRBY3Rpb24iLCJnZXRMYXp5Um91dGUiLCJzZXRUaW1lb3V0Iiwicm91dGVNb2R1bGVQcm9taXNlIiwibG9hZFJvdXRlTW9kdWxlV2l0aEJsb2NraW5nTGlua3MiLCJjbGllbnRBY3Rpb25Qcm9taXNlIiwiaGFzQ2xpZW50TWlkZGxld2FyZSIsImNsaWVudE1pZGRsZXdhcmVNb2R1bGUiLCJ3cmFwU2hvdWxkUmV2YWxpZGF0ZUZvckhkciIsIm15UGFyYW1zIiwiZGlkUGFyYW1zQ2hhbmdlIiwicm91dGVTaG91bGRSZXZhbGlkYXRlIiwiaGFuZGxlZFJldmFsaWRhdGlvbiIsInByZWZldGNoUm91dGVDc3NQcm9taXNlIiwiZGVmYXVsdCIsImlzRW1wdHlPYmplY3QiLCJuZXh0UGF0aHMiLCJkaXNjb3ZlcmVkUGF0aHNNYXhTaXplIiwiZGlzY292ZXJlZFBhdGhzIiwiVVJMX0xJTUlUIiwiaXNGb2dPZldhckVuYWJsZWQiLCJyb3V0ZURpc2NvdmVyeSIsImdldFBhcnRpYWxNYW5pZmVzdCIsInNyaSIsInJvdXRlSWRzIiwiaW5pdGlhbFJvdXRlcyIsImZldGNoQW5kQXBwbHlNYW5pZmVzdFBhdGNoZXMiLCJtYW5pZmVzdFBhdGgiLCJjb25uZWN0aW9uIiwic2F2ZURhdGEiLCJyZWdpc3RlckVsZW1lbnQiLCJmZXRjaFBhdGNoZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwibGF6eVBhdGhzIiwiZGVib3VuY2VkRmV0Y2hQYXRjaGVzIiwiZGVib3VuY2UiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiZG9jdW1lbnRFbGVtZW50Iiwic3VidHJlZSIsImNoaWxkTGlzdCIsImF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVGaWx0ZXIiLCJkaXNjb25uZWN0IiwiZ2V0TWFuaWZlc3RQYXRoIiwiX21hbmlmZXN0UGF0aCIsIk1BTklGRVNUX1ZFUlNJT05fU1RPUkFHRV9LRVkiLCJlcnJvclJlbG9hZFBhdGgiLCJ2ZXJzaW9uIiwic2VydmVyUGF0Y2hlcyIsIm9rIiwicmVtb3ZlSXRlbSIsImtub3duUm91dGVzIiwicGF0Y2hlcyIsImFkZFRvRmlmb1F1ZXVlIiwicGFyZW50SWRzIiwicXVldWUiLCJjYWxsYmFjayIsIndhaXQiLCJ0aW1lb3V0SWQiLCJjbGVhclRpbWVvdXQiLCJ1c2VEYXRhUm91dGVyQ29udGV4dDIiLCJ1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0IiwidXNlUHJlZmV0Y2hCZWhhdmlvciIsInByZWZldGNoIiwidGhlaXJFbGVtZW50UHJvcHMiLCJmcmFtZXdvcmtDb250ZXh0IiwibWF5YmVQcmVmZXRjaCIsInNldE1heWJlUHJlZmV0Y2giLCJzaG91bGRQcmVmZXRjaCIsInNldFNob3VsZFByZWZldGNoIiwib25Gb2N1cyIsIm9uQmx1ciIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VMZWF2ZSIsIm9uVG91Y2hTdGFydCIsInJlZiIsImlzSW50ZXJzZWN0aW5nIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJ0aHJlc2hvbGQiLCJzZXRJbnRlbnQiLCJjYW5jZWxJbnRlbnQiLCJjb21wb3NlRXZlbnRIYW5kbGVycyIsInRoZWlySGFuZGxlciIsIm91ckhhbmRsZXIiLCJkZWZhdWx0UHJldmVudGVkIiwiZ2V0QWN0aXZlTWF0Y2hlcyIsImlzSHlkcmF0ZWQiLCJlcnJvcklkeCIsImNyaXRpY2FsQ3NzIiwicm91dGVyTWF0Y2hlcyIsImtleWVkTGlua3MiLCJkYXRhTGlua1Byb3BzIiwiUHJlZmV0Y2hQYWdlTGlua3NJbXBsIiwidXNlS2V5ZWRQcmVmZXRjaExpbmtzIiwia2V5ZWRQcmVmZXRjaExpbmtzIiwic2V0S2V5ZWRQcmVmZXRjaExpbmtzIiwiaW50ZXJydXB0ZWQiLCJsaW5rUHJvcHMiLCJuZXdNYXRjaGVzRm9yRGF0YSIsIm5ld01hdGNoZXNGb3JBc3NldHMiLCJkYXRhSHJlZnMiLCJtMiIsIm1vZHVsZUhyZWZzIiwiX21hdGNoZXMiLCJsZWFmTWV0YSIsIl9tYXRjaCIsInJvdXRlTWV0YSIsIm1ldGFQcm9wcyIsImlzVmFsaWRNZXRhVGFnIiwiQ29tcCIsImNoYXJzZXQiLCJlcnIiLCJzZXJ2ZXJIYW5kb2ZmU3RyaW5nIiwiZW5hYmxlRm9nT2ZXYXIiLCJpbml0aWFsU2NyaXB0cyIsInN0cmVhbVNjcmlwdCIsImNvbnRleHRTY3JpcHQiLCJyb3V0ZU1vZHVsZXNTY3JpcHQiLCJobXIiLCJydW50aW1lIiwicm91dGVJbmRleCIsInJvdXRlVmFyTmFtZSIsIm1hbmlmZXN0RW50cnkiLCJjaHVua3MiLCJ2YXJOYW1lIiwiY2h1bmtJbXBvcnRzU25pcHBldCIsIm1lcmdlZENodW5rc1NuaXBwZXQiLCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmciLCJhc3luYyIsImRlZHVwZSIsImludGVncml0eSIsImNyb3NzT3JpZ2luIiwibWVyZ2VSZWZzIiwicmVmcyIsImlzQnJvd3NlciIsIl9fcmVhY3RSb3V0ZXJWZXJzaW9uIiwicGFyc2VIeWRyYXRpb25EYXRhIiwiX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhIiwiZGVzZXJpYWxpemVFcnJvcnMiLCJzZXJpYWxpemVkIiwiX190eXBlIiwiX19zdWJUeXBlIiwiRXJyb3JDb25zdHJ1Y3RvciIsIkFCU09MVVRFX1VSTF9SRUdFWDIiLCJmb3J3YXJkUmVmIiwiTGlua1dpdGhSZWYiLCJvbkNsaWNrIiwiZGlzY292ZXIiLCJyZWxvYWREb2N1bWVudCIsImZvcndhcmRlZFJlZiIsImFic29sdXRlSHJlZiIsImlzRXh0ZXJuYWwiLCJ0YXJnZXRVcmwiLCJwcmVmZXRjaFJlZiIsInByZWZldGNoSGFuZGxlcnMiLCJpbnRlcm5hbE9uQ2xpY2siLCJoYW5kbGVDbGljayIsIk5hdkxpbmtXaXRoUmVmIiwiYXJpYUN1cnJlbnRQcm9wIiwiY2xhc3NOYW1lIiwiY2xhc3NOYW1lUHJvcCIsInN0eWxlUHJvcCIsInJvdXRlclN0YXRlIiwibmV4dExvY2F0aW9uUGF0aG5hbWUiLCJlbmRTbGFzaFBvc2l0aW9uIiwiaXNBY3RpdmUiLCJpc1BlbmRpbmciLCJyZW5kZXJQcm9wcyIsImFyaWFDdXJyZW50Iiwib25TdWJtaXQiLCJzdWJtaXRIYW5kbGVyIiwicHJldmVudERlZmF1bHQiLCJzdWJtaXR0ZXIiLCJuYXRpdmVFdmVudCIsInN1Ym1pdE1ldGhvZCIsImN1cnJlbnRUYXJnZXQiLCJzdG9yYWdlS2V5IiwicmVtaXhDb250ZXh0Iiwic3NyS2V5IiwidXNlcktleSIsImdldFNjcm9sbFJlc3RvcmF0aW9uS2V5IiwicmVzdG9yZVNjcm9sbCIsInN0b3JhZ2VLZXkyIiwicmVzdG9yZUtleSIsInN0b3JlZFkiLCJzY3JvbGxUbyIsIlNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSIsImdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IyIiwidXNlRGF0YVJvdXRlckNvbnRleHQzIiwidXNlRGF0YVJvdXRlclN0YXRlMiIsInJlcGxhY2VQcm9wIiwiZGVmYXVsdEluaXQiLCJkZWZhdWx0U2VhcmNoUGFyYW1zUmVmIiwiaGFzU2V0U2VhcmNoUGFyYW1zUmVmIiwic2V0U2VhcmNoUGFyYW1zIiwibmV4dEluaXQiLCJuYXZpZ2F0ZU9wdGlvbnMiLCJuZXdTZWFyY2hQYXJhbXMiLCJmZXRjaGVySWQiLCJnZXRVbmlxdWVGZXRjaGVySWQiLCJjdXJyZW50Um91dGVJZCIsImhhc05ha2VkSW5kZXhQYXJhbSIsImRlZmF1bHRLZXkiLCJ1c2VJZCIsInNldEZldGNoZXJLZXkiLCJsb2FkIiwic3VibWl0SW1wbCIsIkZldGNoZXJGb3JtIiwiRmV0Y2hlckZvcm0yIiwiZmV0Y2hlcldpdGhDb21wb25lbnRzIiwic2F2ZWRTY3JvbGxQb3NpdGlvbnMiLCJzY3JvbGxSZXN0b3JhdGlvbiIsInVzZVBhZ2VIaWRlIiwic2Nyb2xsWSIsImRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiIsImdldEVsZW1lbnRCeUlkIiwic2Nyb2xsSW50b1ZpZXciLCJjYXB0dXJlIiwid2hlbiIsImNvbmZpcm0iLCJuZXh0UGF0aCIsIlJlYWN0MTEiLCJzdGF0aWNOYXZpZ2F0b3IiLCJnZXRTdGF0ZWxlc3NOYXZpZ2F0b3IiLCJoeWRyYXRlMiIsImZldGNoZXJzQ29udGV4dCIsImh5ZHJhdGVTY3JpcHQiLCJzZXJpYWxpemVFcnJvcnMiLCJodG1sRXNjYXBlIiwiRGF0YVJvdXRlczIiLCJiYWNrIiwiZm9yd2FyZCIsImVuY29kZWQiLCJBQlNPTFVURV9VUkxfUkVHRVgzIiwiRVNDQVBFX0xPT0tVUDIiLCJFU0NBUEVfUkVHRVgyIiwiUmVhY3QxMiIsInN0YXRpY0hhbmRsZXJDb250ZXh0Iiwic2VyaWFsaXplRXJyb3IiLCJzZXJ2ZXJIYW5kb2ZmU3RyZWFtIiwiUmVhY3QxMyIsIlJvdXRlc1Rlc3RTdHViIiwicm91dGVyUmVmIiwicmVtaXhDb250ZXh0UmVmIiwidW5zdGFibGVfc3ViUmVzb3VyY2VJbnRlZ3JpdHkiLCJwYXRjaGVkIiwicHJvY2Vzc1JvdXRlcyIsIndpdGhDb21wb25lbnRQcm9wcyIsIldyYXBwZWQiLCJ3aXRoSHlkcmF0ZUZhbGxiYWNrUHJvcHMiLCJ3aXRoRXJyb3JCb3VuZGFyeVByb3BzIiwiZW50cnlSb3V0ZSIsImltcG9ydF9jb29raWUiLCJlbmNvZGVyIiwic2lnbiIsInNlY3JldCIsImNyZWF0ZUtleTIiLCJzaWduYXR1cmUiLCJjcnlwdG8iLCJzdWJ0bGUiLCJidG9hIiwiZnJvbUNoYXJDb2RlIiwiVWludDhBcnJheSIsInVuc2lnbiIsImNvb2tpZSIsImxhc3RJbmRleE9mIiwiYnl0ZVN0cmluZ1RvVWludDhBcnJheSIsImF0b2IiLCJ2YWxpZCIsInZlcmlmeSIsInVzYWdlcyIsImltcG9ydEtleSIsImJ5dGVTdHJpbmciLCJjaGFyQ29kZUF0IiwiY29va2llT3B0aW9ucyIsInNlY3JldHMiLCJzYW1lU2l0ZSIsIndhcm5PbmNlQWJvdXRFeHBpcmVzQ29va2llIiwiZXhwaXJlcyIsImlzU2lnbmVkIiwibWF4QWdlIiwibm93IiwiY29va2llSGVhZGVyIiwicGFyc2VPcHRpb25zIiwiY29va2llcyIsImRlY29kZUNvb2tpZVZhbHVlIiwic2VyaWFsaXplIiwic2VyaWFsaXplT3B0aW9ucyIsImVuY29kZUNvb2tpZVZhbHVlIiwiZW5jb2RlRGF0YSIsInVuc2lnbmVkVmFsdWUiLCJkZWNvZGVEYXRhIiwibXlVbmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIm15RXNjYXBlIiwiY2hyIiwiY29kZSIsImV4ZWMiLCJoZXgiLCJwYXJzZUludCIsImNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzIiwiU2VydmVyTW9kZTIiLCJpc1NlcnZlck1vZGUiLCJzYW5pdGl6ZUVycm9yIiwic2VydmVyTW9kZSIsInNhbml0aXplZCIsInNhbml0aXplRXJyb3JzIiwic2VyaWFsaXplRXJyb3JzMiIsIm1hdGNoU2VydmVyUm91dGVzIiwiY2FsbFJvdXRlSGFuZGxlciIsInN0cmlwUm91dGVzUGFyYW0iLCJzdHJpcEluZGV4UGFyYW0yIiwiZHVwbGV4IiwiaW52YXJpYW50MyIsImdsb2JhbERldlNlcnZlckhvb2tzS2V5IiwiZGV2U2VydmVySG9va3MiLCJnZXREZXZTZXJ2ZXJIb29rcyIsImdldEJ1aWxkVGltZUhlYWRlciIsImhlYWRlck5hbWUiLCJwcm9jZXNzIiwiZW52IiwiSVNfUlJfQlVJTERfUkVRVUVTVCIsImdyb3VwUm91dGVzQnlQYXJlbnRJZDIiLCJjcmVhdGVSb3V0ZXMiLCJjcmVhdGVTdGF0aWNIYW5kbGVyRGF0YVJvdXRlcyIsImNvbW1vblJvdXRlIiwicHJlUmVuZGVyZWREYXRhIiwiZGVjb2RlVVJJIiwidWludDhhcnJheSIsImdsb2JhbCIsIkVTQ0FQRV9MT09LVVAzIiwiRVNDQVBFX1JFR0VYMyIsImVzY2FwZUh0bWwyIiwiY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyIsInNlcnZlckhhbmRvZmYiLCJpbXBvcnRfc2V0X2Nvb2tpZV9wYXJzZXIiLCJnZXREb2N1bWVudEhlYWRlcnMiLCJidWlsZCIsImJvdW5kYXJ5SWR4IiwiZXJyb3JIZWFkZXJzIiwicGFyZW50SGVhZGVycyIsImluY2x1ZGVFcnJvckhlYWRlcnMiLCJpbmNsdWRlRXJyb3JDb29raWVzIiwiaGVhZGVyczIiLCJwcmVwZW5kQ29va2llcyIsImNoaWxkSGVhZGVycyIsInBhcmVudFNldENvb2tpZVN0cmluZyIsInNwbGl0Q29va2llc1N0cmluZyIsImNoaWxkQ29va2llcyIsImdldFNldENvb2tpZSIsIlNFUlZFUl9OT19CT0RZX1NUQVRVU19DT0RFUyIsInNpbmdsZUZldGNoQWN0aW9uIiwic3RhdGljSGFuZGxlciIsImhhbmRsZXJVcmwiLCJsb2FkQ29udGV4dCIsImhhbmRsZUVycm9yIiwicmVzcG9uZDIiLCJnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UiLCJnZXRTaW5nbGVGZXRjaFJlZGlyZWN0Iiwic2luZ2xlRmV0Y2hSZXN1bHQiLCJoYW5kbGVyUmVxdWVzdCIsInNpbmdsZUZldGNoTG9hZGVycyIsImxvYWRlZE1hdGNoZXMiLCJsb2FkUm91dGVJZHMiLCJyb3V0ZXNQYXJhbSIsInJlc3VsdEhlYWRlcnMiLCJlbmNvZGVWaWFUdXJib1N0cmVhbSIsInN0cmVhbVRpbWVvdXQiLCJyZXF1ZXN0U2lnbmFsIiwiZGF0YTMiLCJmcm9tRW50cmllcyIsImRlcml2ZSIsIl9idWlsZCIsInJlcXVlc3RIYW5kbGVyIiwiaW5pdGlhbENvbnRleHQiLCJkZXJpdmVkIiwicHJvY2Vzc1JlcXVlc3RFcnJvciIsInJldHVybkxhc3RSZXNvcnRFcnJvclJlc3BvbnNlIiwibm9ybWFsaXplZEJhc2VuYW1lIiwicHJlcmVuZGVyIiwibWFuaWZlc3RVcmwiLCJoYW5kbGVNYW5pZmVzdFJlcXVlc3QiLCJzaW5nbGVGZXRjaE1hdGNoZXMiLCJoYW5kbGVTaW5nbGVGZXRjaFJlcXVlc3QiLCJoYW5kbGVEYXRhUmVxdWVzdCIsImhhbmRsZVJlc291cmNlUmVxdWVzdCIsInVuc3RhYmxlX2dldENyaXRpY2FsQ3NzIiwiZ2V0Q3JpdGljYWxDc3MiLCJoYW5kbGVEb2N1bWVudFJlcXVlc3QiLCJhc3NldHMiLCJwYXJ0aWFsUGF0aCIsInJlbmRlckh0bWwiLCJpc1NwYU1vZGUyIiwiYmFzZVNlcnZlckhhbmRvZmYiLCJlbnRyeUNvbnRleHQiLCJoYW5kbGVEb2N1bWVudFJlcXVlc3RGdW5jdGlvbiIsImVycm9yRm9yU2Vjb25kUmVuZGVyIiwidW53cmFwUmVzcG9uc2UiLCJlcnJvclJlc3BvbnNlVG9Kc29uIiwibmV3RXJyb3IiLCJlcnJvclJlc3BvbnNlIiwiZmxhc2giLCJmbGFzaE5hbWUiLCJ1bnNldCIsImNvb2tpZUFyZyIsImNyZWF0ZURhdGEiLCJyZWFkRGF0YSIsInVwZGF0ZURhdGEiLCJkZWxldGVEYXRhIiwid2Fybk9uY2VBYm91dFNpZ25pbmdTZXNzaW9uQ29va2llIiwiZ2V0U2Vzc2lvbiIsImNvbW1pdFNlc3Npb24iLCJzZXNzaW9uIiwiZGVzdHJveVNlc3Npb24iLCJzZXJpYWxpemVkQ29va2llIiwiX3Nlc3Npb24iLCJpc1JlcXVpcmVkIiwicm91dGVJbmZvIiwiaGFzSHlkcmF0ZUZhbGxiYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/development/index.js\n");

/***/ })

};
;